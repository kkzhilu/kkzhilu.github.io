<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="一切都是有可能的，甚至那些不可能的也是.">
  <meta name="author" content="Kerwin">
  <meta name="keywords" content="Java;Python;Vue;前端;后端;多线程;设计模式;并发编程;数据库;">
  <title>Kerwin&#39;s Library - Kerwin&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/xcode.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Kerwin</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/article.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2023-02-06 23:36">
      2023年2月6日 晚上
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      4.1k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      53
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h1 id="Kerwin’s-Library"><a href="#Kerwin’s-Library" class="headerlink" title="Kerwin’s Library"></a>Kerwin’s Library</h1><blockquote>
<p>这里是Kerwin的编程图书馆，通过ABC—Z#构建快速检索话语工具，专业名词等等</p>
</blockquote>
<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><h3 id="1-AbstractRoutingDataSource"><a href="#1-AbstractRoutingDataSource" class="headerlink" title="1.  AbstractRoutingDataSource"></a>1.  AbstractRoutingDataSource</h3><p>Spring + Mybtias实现数据源切换的核心类，需要重写<code>determineCurrentLookupKey</code>方法，动态的更换当前线程中数据源指向</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DynamicRoutingDataSource</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractRoutingDataSource</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">determineCurrentLookupKey</span><span class="hljs-params">()</span> </span>&#123;
        logger.info(<span class="hljs-string">"切换数据源: "</span> + DataSourceContextHolder.getDbType());
        <span class="hljs-keyword">return</span> DataSourceContextHolder.getDbType();
    &#125;
&#125;</code></pre>



<h3 id="2-Adapter-Pattern"><a href="#2-Adapter-Pattern" class="headerlink" title="2. Adapter Pattern"></a>2. Adapter Pattern</h3><p>文章详情链接：<a href="https://juejin.im/post/5ed688c051882543413c1168" target="_blank" rel="noopener">https://juejin.im/post/5ed688c051882543413c1168</a></p>
<p>适配器模式</p>
<p>1）将一个类的接口转换成客户希望的另外一个接口，adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作</p>
<p>2）核心代码如下：</p>
<p>简单来说，当我们需要对两个本不相关的接口混合一起用时，需要用一个适配器实现A接口，持有B对象，再用B对象的方法去填充A接口的方法，同时还可以增加一些其他的逻辑</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 火鸡适配器</span>
<span class="hljs-comment"> * 实现鸭子接口同时持有火鸡对象，在实现的接口处用火鸡对象的方法填充一下（同时还可以做额外的事情）</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TurkeyAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Duck</span></span>&#123;

    Turkey turkey;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quack</span><span class="hljs-params">()</span> </span>&#123;
        turkey.gobble();
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123;
        turkey.fly();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TurkeyAdapter</span><span class="hljs-params">(Turkey turkey)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.turkey = turkey;
    &#125;
&#125;</code></pre>





<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><h3 id="1-Command-Pattern"><a href="#1-Command-Pattern" class="headerlink" title="1. Command Pattern"></a>1. Command Pattern</h3><p>文章详情链接：<a href="https://juejin.im/post/5ed5265851882543477c7abf" target="_blank" rel="noopener">https://juejin.im/post/5ed5265851882543477c7abf</a></p>
<p>命令模式</p>
<p>1）将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；</p>
<p>2）对请求排队或记录请求日志，以及支持可撤销的操作</p>
<p>3）核心代码如下：</p>
<p>代码的核心即：把请求抽象为一个命令，把执行命令的接收者和命令本身分离，交由第三方类（Invoker）去管理，达到解耦的目的</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LightOnCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Command</span> </span>&#123;

    Light light;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LightOnCommand</span><span class="hljs-params">(Light light)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.light = light;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;
        light.on();
    &#125;
&#125;</code></pre>



<h3 id="2-Composite-Pattern"><a href="#2-Composite-Pattern" class="headerlink" title="2. Composite Pattern"></a>2. Composite Pattern</h3><p>文章详情链接：<a href="https://juejin.im/post/5ee64aade51d45789671b974" target="_blank" rel="noopener">https://juejin.im/post/5ee64aade51d45789671b974</a></p>
<p>组合模式</p>
<p>意图：将对象组合成树形结构以表示 “部分-整体” 的层次结构，Composite使得用户对单个对象和组合对象的使用具有一致性</p>
<p>核心代码：让表示部分的实体和表示整体的实体实现同一个接口（或抽象类）</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Menu</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MenuComponent</span></span>&#123;

    List&lt;MenuComponent&gt; menuComponents = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Menu</span><span class="hljs-params">(String name)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.name = name;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(MenuComponent component)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.menuComponents.add(component);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(MenuComponent component)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.menuComponents.remove(component);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> MenuComponent <span class="hljs-title">getChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;
        <span class="hljs-keyword">return</span> menuComponents.get(i);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"当前菜单项: "</span> + getName());
        <span class="hljs-keyword">for</span> (MenuComponent component : menuComponents) &#123;
            component.print();
        &#125;
    &#125;
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MentItem</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MenuComponent</span></span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MentItem</span><span class="hljs-params">(String name)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.name = name;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(MenuComponent component)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"无法添加"</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(MenuComponent component)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"无法移除"</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> MenuComponent <span class="hljs-title">getChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"无子节点"</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"    食物名: "</span> + getName());
    &#125;
&#125;</code></pre>



<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><h3 id="1-determineCurrentLookupKey"><a href="#1-determineCurrentLookupKey" class="headerlink" title="1. determineCurrentLookupKey"></a>1. determineCurrentLookupKey</h3><p>determineCurrentLookupKey方法是Mybatis数据源切换时需要重写的方法，如下图所示：</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DynamicRoutingDataSource</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractRoutingDataSource</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">determineCurrentLookupKey</span><span class="hljs-params">()</span> </span>&#123;
        logger.info(<span class="hljs-string">"切换数据源: "</span> + DataSourceContextHolder.getDbType());
        <span class="hljs-keyword">return</span> DataSourceContextHolder.getDbType();
    &#125;
&#125;</code></pre>



<h3 id="2-Decorator-Pattern"><a href="#2-Decorator-Pattern" class="headerlink" title="2. Decorator Pattern"></a>2. Decorator Pattern</h3><p>文章详情链接：<a href="https://juejin.im/user/5c729b0b5188255cf64b2da6/posts" target="_blank" rel="noopener">https://juejin.im/user/5c729b0b5188255cf64b2da6/posts</a></p>
<p>装饰器模式</p>
<p>1）动态地给一个对象添加一些额外的职责，就增加功能来说，Decorator模式相比生成子类更为灵活</p>
<p>2）设计原则：</p>
<ul>
<li><strong>「对扩展开放，对修改关闭」</strong>：完美实现了不修改其代码达到增强方法的目的</li>
<li><strong>「针对接口编程」</strong>：装饰器与其本身都有同样的父级</li>
</ul>
<p>3）核心代码如下：（装饰类和原类实现同一个接口，装饰类持有原类对象，在实现自身方法时囊括原类对象的方法，达到增强的目的）</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 装饰器类 注意它利用了组合的方式，同时注意函数实现的部分</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MilkDecorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Component</span> </span>&#123;

    Component coffe;

    MilkDecorator(Component coffe) &#123;
        <span class="hljs-keyword">this</span>.coffe = coffe;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;
       <span class="hljs-keyword">return</span> coffe.getName() + <span class="hljs-string">", 牛奶"</span>;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getSpend</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> coffe.getSpend() + <span class="hljs-number">2</span>D;
    &#125;
&#125;</code></pre>





<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><h3 id="1-Explain"><a href="#1-Explain" class="headerlink" title="1. Explain"></a>1. Explain</h3><p>Mysql中的用以解释数据库查询的关键字，如：EXPLAIN SELECT * FROM user_coll;</p>
<pre><code class="hljs asciidoc">mysql&gt; EXPLAIN SELECT * FROM <span class="hljs-code">`user_coll`</span> where pid = 1;
<span class="hljs-code">+----+</span>-<span class="hljs-code">+-----+</span>-<span class="hljs-code">+---+</span><span class="hljs-code">+---+</span><span class="hljs-code">++---+</span>
| id | select<span class="hljs-emphasis">_type | table     | type  | possible_</span>keys | key  | key<span class="hljs-emphasis">_len | ref  | rows | Extra                 |</span>
<span class="hljs-emphasis">+----+-+-----+-+---++---+++---+</span>
<span class="hljs-emphasis">|  1 | SIMPLE      | user_</span>coll | index | pid           | demo | 45      | NULL |    3 | Using where |
<span class="hljs-code">+----+</span>-<span class="hljs-code">+-----+</span>-<span class="hljs-code">+---+</span><span class="hljs-code">+---+</span><span class="hljs-code">++---+</span>
1 row in set (0.05 sec)</code></pre>





<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><h3 id="1-final"><a href="#1-final" class="headerlink" title="1. final"></a>1. final</h3><p>1）修饰类则不可被继承，修饰方法则不可被重写，修饰变量则不可被复制</p>
<blockquote>
<p>在进行框架设计或者组件化代码，开源代码时，通过给方法或者变量附加final关键字可以增强语意</p>
</blockquote>
<h3 id="2-Factory-Pattern"><a href="#2-Factory-Pattern" class="headerlink" title="2. Factory Pattern"></a>2. Factory Pattern</h3><p>文章详情链接：<a href="https://juejin.im/post/5ecbcf19e51d4578a475ea5e" target="_blank" rel="noopener">https://juejin.im/post/5ecbcf19e51d4578a475ea5e</a></p>
<p>工厂模式：简单工厂，工厂方法以及抽象工厂模式</p>
<p>意图：工厂模式属于对象创建型模式，无论是上述三种的哪一种都是为了同一个设计原则即<font color="red">依赖抽象，不要依赖具体</font></p>
<p>简单来说就是把<font color="blue">复杂对象创建（初始化）的细节</font>或者<font color="blue">依赖关系经常可能发生变化的细节</font>交给一个第三方类（工厂类），避免在业务逻辑中书写不必要的内容</p>
<p><strong><em>简单工厂核心代码：</em></strong></p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Factory</span> </span>&#123;

    <span class="hljs-comment">/***</span>
<span class="hljs-comment">     * 产品订购方案</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractCPU <span class="hljs-title">orderCpu</span> <span class="hljs-params">()</span> </span>&#123;
        AbstractCPU cpu = generateCpu();
        cpu.show();
        cpu.prepare();
        cpu.box();

        <span class="hljs-comment">// 假设有相同的业务处理逻辑...</span>
        <span class="hljs-keyword">return</span> cpu;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> AbstractCPU <span class="hljs-title">generateCpu</span><span class="hljs-params">()</span></span>;
&#125;</code></pre>



<p><strong><em>抽象工厂核心代码：</em></strong></p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractFactory</span> </span>&#123;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 创建CPU对象</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> CPU对象</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> AbstractCPU <span class="hljs-title">createCpu</span><span class="hljs-params">()</span></span>;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 创建主板对象</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 主板对象</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> AbstractMotherboard <span class="hljs-title">createMainboard</span><span class="hljs-params">()</span></span>;
&#125;</code></pre>



<p><strong>相同点：</strong></p>
<ul>
<li>所有的工厂都是用来封装对象的创建</li>
<li>简单工厂，虽然不是真正的设计模式，但仍不失为一个简单的方法，可以进行解耦</li>
<li>所有工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合</li>
<li>依赖倒置原则，指导我们避免依赖具体类型，而要尽量依赖抽象</li>
<li>工厂是很有威力的技巧，帮助我们针对抽象编程，而不是具体类编程</li>
</ul>
<p><strong>工厂方法：</strong></p>
<ul>
<li>工厂方法利用继承：把对象的创建委托给子类，子类实现工厂方法来创建对象</li>
<li>工厂方法允许类将实例化延迟到子类实现</li>
</ul>
<p><strong>抽象工厂：</strong></p>
<ul>
<li>抽象工厂使用对象组合：对象的创建被实现在工厂接口所暴露出来的方法中</li>
<li>抽象工厂创建相关的<font color="red">对象家族</font>，而不需要依赖它们的具体类</li>
</ul>
<h3 id="3-Facade-Pattern"><a href="#3-Facade-Pattern" class="headerlink" title="3. Facade Pattern"></a>3. Facade Pattern</h3><p>文章详情链接：<a href="https://juejin.im/post/5ed688c051882543413c1168" target="_blank" rel="noopener">https://juejin.im/post/5ed688c051882543413c1168</a></p>
<p>外观模式</p>
<p>意图：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用</p>
<p>核心代码如下：</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FacadeComputer</span> </span>&#123;

    <span class="hljs-keyword">private</span> Cpu cpu;
    <span class="hljs-keyword">private</span> Ram ram;
    <span class="hljs-keyword">private</span> Ssd ssd;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FacadeComputer</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">this</span>.cpu = <span class="hljs-keyword">new</span> Cpu();
        <span class="hljs-keyword">this</span>.ram = <span class="hljs-keyword">new</span> Ram();
        <span class="hljs-keyword">this</span>.ssd = <span class="hljs-keyword">new</span> Ssd();
    &#125;

    <span class="hljs-comment">/** Cpu On **/</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCpu</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">this</span>.cpu.open();
    &#125;

    <span class="hljs-comment">/** Ram On **/</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onRam</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">this</span>.ram.open();
    &#125;

    <span class="hljs-comment">/** Ssd On **/</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSsd</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">this</span>.ssd.open();
    &#125;

    <span class="hljs-comment">/** All On **/</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">allOn</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">this</span>.cpu.open();
        <span class="hljs-keyword">this</span>.ram.open();
        <span class="hljs-keyword">this</span>.ssd.open();
    &#125;
&#125;</code></pre>





<h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><h2 id="H"><a href="#H" class="headerlink" title="H"></a>H</h2><h2 id="I"><a href="#I" class="headerlink" title="I"></a>I</h2><h3 id="1-InitializingBean"><a href="#1-InitializingBean" class="headerlink" title="1. InitializingBean"></a>1. InitializingBean</h3><p>1） InitializingBean接口为bean提供了初始化方法的方式，它只包括afterPropertiesSet方法，凡是继承该接口的类，在初始化bean的时候会执行该方法 </p>
<p>2） 两种初始化bean的方式之一，另一种是通过在配置文件中指定init-method</p>
<p>3）可以利用其初始化Bean的特征，进行通用Bean的注入和处理，如下代码所示</p>
<pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomStrategyFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InitializingBean</span> </span>&#123;

    <span class="hljs-comment">// 可获取到所有实现CustomStrategyInterface的实现类</span>
    <span class="hljs-meta">@Autowired</span>
    List&lt;CustomStrategyInterface&gt; interfaces;

    <span class="hljs-comment">// MAP存储对象</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, CustomStrategyInterface&gt; INTERFACES = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">1024</span>);

    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, CustomStrategyInterface&gt; <span class="hljs-title">getInterfaces</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> INTERFACES;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-keyword">for</span> (CustomStrategyInterface demo : interfaces) &#123;
            demo.handle();
            INTERFACES.put(demo.getClass().getSimpleName(), demo);
        &#125;
    &#125;
&#125;</code></pre>



<h3 id="2-Iterator-Pattern"><a href="#2-Iterator-Pattern" class="headerlink" title="2. Iterator Pattern"></a>2. Iterator Pattern</h3><p>文章详情链接：<a href="https://juejin.im/post/5ee64aade51d45789671b974" target="_blank" rel="noopener">https://juejin.im/post/5ee64aade51d45789671b974</a></p>
<p>迭代器模式</p>
<p>意图：提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴漏该对象的内部表示</p>
<p>核心代码如下：</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyContainer</span> </span>&#123;

    <span class="hljs-function">MyIterator <span class="hljs-title">getIterator</span><span class="hljs-params">()</span></span>;
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyIterator</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>;

    <span class="hljs-function">Object <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FoodRepository</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MyContainer</span> </span>&#123;

    String[] names = &#123;<span class="hljs-string">"宫保鸡丁"</span>, <span class="hljs-string">"麻辣香锅"</span>, <span class="hljs-string">"油闷大虾"</span>&#125;;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> MyIterator <span class="hljs-title">getIterator</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NameIterator();
    &#125;

    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NameIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MyIterator</span> </span>&#123;

        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> index;

        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;
            <span class="hljs-keyword">return</span> index &lt; names.length;
        &#125;

        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;
           <span class="hljs-keyword">return</span> hasNext() ? names[index++] : <span class="hljs-keyword">null</span>;
        &#125;

        NameIterator() &#123;
            index = <span class="hljs-number">0</span>;
        &#125;
    &#125;
&#125;</code></pre>





<h2 id="J"><a href="#J" class="headerlink" title="J"></a>J</h2><h3 id="1-Jstack"><a href="#1-Jstack" class="headerlink" title="1. Jstack"></a>1. Jstack</h3><p> jstack能得到运行java程序的java stack和native stack的信息 </p>
<h2 id="K"><a href="#K" class="headerlink" title="K"></a>K</h2><h2 id="L"><a href="#L" class="headerlink" title="L"></a>L</h2><h2 id="M"><a href="#M" class="headerlink" title="M"></a>M</h2><h2 id="N"><a href="#N" class="headerlink" title="N"></a>N</h2><h2 id="O"><a href="#O" class="headerlink" title="O"></a>O</h2><h3 id="1-Observer-Pattern"><a href="#1-Observer-Pattern" class="headerlink" title="1. Observer Pattern"></a>1. <strong>Observer Pattern</strong></h3><p>文章详情链接：<a href="https://juejin.im/post/5ec2a1dde51d454ddf23697d" target="_blank" rel="noopener">https://juejin.im/post/5ec2a1dde51d454ddf23697d</a></p>
<p>观察者模式</p>
<p>1）具备极强的解耦能力，可以很好的优化代码设计</p>
<p>2）JDK已默认实现，具备推拉模式</p>
<p>3）设计原则：</p>
<p><strong>「封装变化」</strong></p>
<ul>
<li>在观察者模式中会经常改变的是主题的状态，以及观察者的数目和类型</li>
<li>我们可以改变依赖于主题状态的对象，但是不必改变主题本身，这便是提前规划</li>
</ul>
<p><strong>「针对接口编程」</strong></p>
<ul>
<li>主题和观察者都使用了接口</li>
<li>观察者利用主题的接口向主题注册</li>
<li>主题利用观察者接口通知观察者，可以使两者之间正常交互，同时又具有松耦合的特性</li>
</ul>
<p><strong>「多使用组合」</strong></p>
<ul>
<li>观察者模式利用组合将许多观察者组合进主题中</li>
<li>它们之间的关系并不是通过继承得到，而是在运行时动态改变</li>
</ul>
<p>4）核心代码如下：（某一个目标持有观察者容器，可以增加和移除观察者，观察者实现同一个接口，当触发时调用容器内所有对象的更新方法即可）</p>
<pre><code class="hljs java"><span class="hljs-comment">// 核心代码</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Weather</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observable</span> </span>&#123;
    <span class="hljs-keyword">private</span> List&lt;Observer&gt; observers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addObserver</span><span class="hljs-params">(Observer observer)</span> </span>&#123;
        observers.add(observer);
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeObserver</span><span class="hljs-params">(Observer observer)</span> </span>&#123;
        observers.remove(observer);
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObservers</span><span class="hljs-params">(WeatherData data)</span> </span>&#123;
        <span class="hljs-keyword">for</span> (Observer observer : observers)
            observer.update(data);
    &#125;
&#125;</code></pre>





<h2 id="P"><a href="#P" class="headerlink" title="P"></a>P</h2><h3 id="1-Proxy-Pattern"><a href="#1-Proxy-Pattern" class="headerlink" title="1. Proxy Pattern"></a>1. <strong>Proxy Pattern</strong></h3><p>文章详情链接：<a href="https://juejin.im/post/5ef2b053f265da02e3401e5c" target="_blank" rel="noopener">https://juejin.im/post/5ef2b053f265da02e3401e5c</a></p>
<p>代理模式</p>
<p><strong>「意图」</strong>：为其他对象提供一种代理以控制对这个对象的访问</p>
<p><strong>「设计原则」</strong></p>
<ul>
<li>封装变化：在父级接口中提供 default 方法，子类实现其对应的状态方法即可</li>
<li>多用组合，少用继承：代理模式经常和策略模式做对比，它们都是利用组合而非继承增强其变化和能力</li>
</ul>
<p><strong>「核心代码」</strong></p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PhoneInterface</span> </span>&#123;

    <span class="hljs-comment">/***</span>
<span class="hljs-comment">     * 更新电话号码</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> phoneNum    电话号码</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception  可能抛出Exception 异常</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updatePhone</span><span class="hljs-params">(Long phoneNum)</span></span>;
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-comment">// 核心代理类</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhoneServiceProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PhoneInterface</span> </span>&#123;

    <span class="hljs-comment">/** 代理模式一般自行New对象, 反观装饰器模式则是传入对象 **/</span>
    <span class="hljs-keyword">private</span> PhoneInterface phoneInterface;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PhoneServiceProxy</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">this</span>.phoneInterface = <span class="hljs-keyword">new</span> PhoneServiceImpl();
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updatePhone</span><span class="hljs-params">(Long phoneNum)</span> </span>&#123;
        before(phoneNum);
        phoneInterface.updatePhone(phoneNum);
        after();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">(Long phoneNum)</span> </span>&#123;
        System.out.println(MessageFormat.format(<span class="hljs-string">"log start time:&#123;0&#125; , phoneNum is: &#123;1&#125;"</span>, <span class="hljs-keyword">new</span> Date(), phoneNum));
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == phoneNum || String.valueOf(phoneNum).length() != <span class="hljs-number">11</span>) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Update phoneNum fail, phoneNum is wrong."</span>);
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(MessageFormat.format(<span class="hljs-string">"log end time:&#123;0&#125;"</span>, <span class="hljs-keyword">new</span> Date()));
    &#125;
&#125;</code></pre>



<h2 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h2><h2 id="R"><a href="#R" class="headerlink" title="R"></a>R</h2><h3 id="1-redirect"><a href="#1-redirect" class="headerlink" title="1. redirect"></a>1. redirect</h3><p>重定向关键字，使用方式如：</p>
<pre><code class="hljs java"><span class="hljs-keyword">return</span> <span class="hljs-string">"redirect:"</span> + redirectUri;</code></pre>



<h3 id="2-Rancher"><a href="#2-Rancher" class="headerlink" title="2. Rancher"></a>2. Rancher</h3><p>Rancher是一个开源的企业级容器管理平台。通过Rancher，企业再也不必自己使用一系列的开源软件去从头搭建容器服务平台。Rancher提供了在生产环境中使用的管理Docker和Kubernetes的全栈化容器部署与管理平台（Testin云测使用中）</p>
<h2 id="S"><a href="#S" class="headerlink" title="S"></a>S</h2><h3 id="1-synchronize"><a href="#1-synchronize" class="headerlink" title="1. synchronize"></a>1. <strong>synchronize</strong></h3><p>1）基于字节码底层实现的Java对象锁</p>
<p>2）具有锁升级的特性，偏向锁，轻量级锁，重量级锁，但是无法降级</p>
<h3 id="2-Singleton-Pattern"><a href="#2-Singleton-Pattern" class="headerlink" title="2. Singleton Pattern"></a>2. Singleton Pattern</h3><p>文章详情链接：<a href="https://juejin.im/post/5ecbcabc6fb9a047d070c779" target="_blank" rel="noopener">https://juejin.im/post/5ecbcabc6fb9a047d070c779</a></p>
<p>意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p>推荐的实现方式：</p>
<p><strong><em>懒汉型之双重锁校验：</em></strong></p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyTypeSingleton</span> </span>&#123;

    <span class="hljs-comment">// volatile关键字修饰，防止指令重排</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> App app = <span class="hljs-keyword">null</span>;

    <span class="hljs-comment">/***</span>
<span class="hljs-comment">     * Double Check Lock（DCL） 双重锁校验</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> App <span class="hljs-title">getInstanceByDCL</span> <span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == app) &#123;
            <span class="hljs-keyword">synchronized</span> (LazyTypeSingleton<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == app) &#123;
                    System.out.println(<span class="hljs-string">"APP - 饿汉模式DCL 双重锁校验"</span>);
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> App();
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> app;
    &#125;
&#125;</code></pre>



<p><strong><em>静态内部类方式</em></strong></p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnterTypeSingleton</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">InnterTypeSingleton</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException();
    &#125;

    <span class="hljs-comment">// 静态内部类方式，类似饿汉保证天然的线程安全</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span></span>&#123;
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> App app = <span class="hljs-keyword">new</span> App();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">static</span> App <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;
        System.out.println(<span class="hljs-string">"APP - 静态内部类方式(Holder)"</span>);
        <span class="hljs-keyword">return</span> SingletonHolder.app;
    &#125;
&#125;</code></pre>



<p><strong><em>枚举方式</em></strong></p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span>  EnumSingleton &#123;
    <span class="hljs-comment">/***</span>
<span class="hljs-comment">     * APP对象</span>
<span class="hljs-comment">     */</span>
    APP;

    <span class="hljs-keyword">private</span> App app;

    EnumSingleton() &#123;
        app = <span class="hljs-keyword">new</span> App();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> App <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"**************************"</span>);
        System.out.println(<span class="hljs-string">"APP - 枚举方式"</span>);
        <span class="hljs-keyword">return</span> app;
    &#125;
&#125;</code></pre>



<h3 id="3-Strategy-Pattern"><a href="#3-Strategy-Pattern" class="headerlink" title="3. Strategy Pattern"></a>3. Strategy Pattern</h3><p>文章详情链接：<a href="https://juejin.im/post/5eb67fc46fb9a043830f597a" target="_blank" rel="noopener">https://juejin.im/post/5eb67fc46fb9a043830f597a</a></p>
<p>意图：定义个一个算法族， 各个算法的实现可以相互替换， 算法的实现和具体的算法使用场景隔离</p>
<p>核心代码：</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Duck</span> </span>&#123;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 飞行行为是动态的，可能会变的，因此抽成多个接口的组合，而不是让Duck类继承</span>
<span class="hljs-comment">     */</span>
    FlyBehavior flyBehavior;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 每个鸭子的叫声不同，抽象成接口</span>
<span class="hljs-comment">     */</span>
    QuackBehavior quackBehavior;
&#125;</code></pre>

<p>遵循的设计原则：</p>
<ul>
<li>封装变化</li>
<li>多用组合，少用继承</li>
<li>针对接口编程，而不是针对实现编程</li>
</ul>
<h3 id="4-State-Pattern"><a href="#4-State-Pattern" class="headerlink" title="4. State Pattern"></a>4. State Pattern</h3><p>文章详情链接：<a href="https://juejin.im/post/5ee8f64be51d452f9c27e66a" target="_blank" rel="noopener">https://juejin.im/post/5ee8f64be51d452f9c27e66a</a></p>
<p>意图：允许一个对象在其内部状态改变时改变它的行为</p>
<p>核心代码：</p>
<p><strong><em>状态接口</em></strong></p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">State</span> </span>&#123;

    <span class="hljs-comment">/** 投币 **/</span>
    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">giveMoney</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"无法投币"</span>);
    &#125;

    <span class="hljs-comment">/** 移动滑杆 **/</span>
    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">move</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"无法移动滑杆"</span>);
    &#125;

    <span class="hljs-comment">/** 抓取 **/</span>
    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">grab</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"无法抓取"</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">changeState</span><span class="hljs-params">()</span></span>;
&#125;</code></pre>



<p><strong><em>实际状态类</em></strong></p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MoneyState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">State</span></span>&#123;

    Context context;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MoneyState</span><span class="hljs-params">(Context context)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.context = context;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">giveMoney</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"已投币!"</span>);
        changeState();
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeState</span><span class="hljs-params">()</span> </span>&#123;
        context.setExecute(<span class="hljs-keyword">new</span> MoveState(context));
    &#125;
&#125;</code></pre>



<p><strong><em>遵循的设计原则</em></strong></p>
<ul>
<li>封装变化：在父级接口中提供 default 方法，子类实现其对应的状态方法即可</li>
<li>多用组合，少用继承：状态模式经常和策略模式做对比，它们都是利用组合而非继承增强其变化和能力</li>
</ul>
<blockquote>
<p><font color="red">状态模式拓展：</font> 当N种状态方法名不一样时，我们在接口中实现 default 关键字，保证其默认方法，子类重写自身对应的核心方法即可，当所有状态的方法名一致时，通过 while(true) 循环执行，也可以达到一种奇妙的效果</p>
<p>非常适合后台多流程的情况</p>
</blockquote>
<h2 id="T"><a href="#T" class="headerlink" title="T"></a>T</h2><h3 id="1-Template-Method-Pattern"><a href="#1-Template-Method-Pattern" class="headerlink" title="1. Template Method Pattern"></a>1. <strong>Template Method Pattern</strong></h3><p>文章详情链接：<a href="https://juejin.im/post/5ede6ce151882543485772ea" target="_blank" rel="noopener">https://juejin.im/post/5ede6ce151882543485772ea</a></p>
<p>模板方法模式意图：</p>
<p>定义一个操作中的算法的骨架，将一些步骤延迟到子类中。 Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤</p>
<p>核心代码：</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TemplateClass</span> </span>&#123;

 <span class="hljs-comment">/***</span>
<span class="hljs-comment">  * 模板方法，用来控制炒菜的流程 （炒菜的流程是一样的-复用）</span>
<span class="hljs-comment">  * 可根据需求申明为final，防止子类覆盖这个方法，导致流程的执行顺序</span>
<span class="hljs-comment">  */</span>
 <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cookProcess</span><span class="hljs-params">()</span> </span>&#123;

  <span class="hljs-comment">// 第一步：倒油</span>
  <span class="hljs-keyword">this</span>.pourOil();

  <span class="hljs-comment">// 第二步：热油</span>
  <span class="hljs-keyword">this</span>.heatOil();

  <span class="hljs-comment">// 第三步：倒蔬菜</span>
  <span class="hljs-keyword">this</span>.pourVegetable();

  <span class="hljs-comment">// 配合钩子函数, 确定是否需要倒调味料</span>
  <span class="hljs-keyword">if</span> (needSauce()) &#123;
   <span class="hljs-keyword">this</span>.pourSauce();
  &#125;

  <span class="hljs-comment">// 第五步：翻炒</span>
  <span class="hljs-keyword">this</span>.fry();
 &#125;

 <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pourOil</span><span class="hljs-params">()</span> </span>&#123;
  System.out.println(<span class="hljs-string">"倒油"</span>);
 &#125;

 <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heatOil</span><span class="hljs-params">()</span> </span>&#123;
  System.out.println(<span class="hljs-string">"热油"</span>);
 &#125;

 <span class="hljs-comment">/***</span>
<span class="hljs-comment">  * 需要变化的部分就定义为抽象</span>
<span class="hljs-comment">  */</span>
 <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pourVegetable</span><span class="hljs-params">()</span></span>;
 <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pourSauce</span><span class="hljs-params">()</span></span>;

 <span class="hljs-comment">/***</span>
<span class="hljs-comment">  * 钩子函数, 影响方法调用逻辑</span>
<span class="hljs-comment">  */</span>
 <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">needSauce</span><span class="hljs-params">()</span> </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
 &#125;

 <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fry</span><span class="hljs-params">()</span> </span>&#123;
  System.out.println(<span class="hljs-string">"炒啊炒啊炒到熟啊"</span>);
 &#125;
&#125;</code></pre>



<p><strong><em>遵循的设计原则</em></strong></p>
<p><strong>「封装变化」</strong></p>
<ul>
<li>在抽象基类中，我们可以有已经实现的方法供子类调用</li>
<li>在抽象基类中，对于必然不同的方法逻辑，定义为抽象的，供子类自行实现</li>
</ul>
<p><strong>「好莱坞原则」</strong></p>
<ul>
<li>别找我，我会找你   指的是底层代码（具体的实现类）不依赖于高层代码，我们在本次的SSO实战中也体现了，直接依赖接口，实现类只是作为真正的执行者而已</li>
</ul>
<h2 id="U"><a href="#U" class="headerlink" title="U"></a>U</h2><h2 id="V"><a href="#V" class="headerlink" title="V"></a>V</h2><h3 id="1-volatile"><a href="#1-volatile" class="headerlink" title="1. volatile"></a>1. volatile</h3><p>1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的 </p>
<p>2）禁止进行指令重排序 </p>
<blockquote>
<p>经典应用：一写多读多读场景可以保证线程安全，另外如单理模式中禁止指令重排等</p>
</blockquote>
<h2 id="W"><a href="#W" class="headerlink" title="W"></a>W</h2><h2 id="X"><a href="#X" class="headerlink" title="X"></a>X</h2><h2 id="Y"><a href="#Y" class="headerlink" title="Y"></a>Y</h2><h2 id="Z"><a href="#Z" class="headerlink" title="Z"></a>Z</h2><h2 id><a href="#" class="headerlink" title="#"></a>#</h2>
            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F%E7%AF%87/">程序人生篇</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Kerwin-s-Library/">Kerwin's Library</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2023/02/06/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">迭代器和组合模式</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2023/02/06/Kerwin&#39;s%20Open%20Source/">
                        <span class="hidden-mobile">Kerwin's Open Source</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
              <!-- Comments -->
              <div class="comments" id="comments">
                
                
  <div id="vcomments"></div>
  <script type="text/javascript">
    function loadValine() {
      addScript('https://cdn.staticfile.org/valine/1.4.14/Valine.min.js', function () {
        new Valine({
          el: "#vcomments",
          app_id: "6uM0Qq25J6ydLXiYqdyxxiMC-gzGzoHsz",
          app_key: "oc2dzMKP9uJXsnOOhIxAr94f",
          placeholder: "说点什么吧~",
          path: window.location.pathname,
          avatar: "retro",
          meta: ["nick","mail","link"],
          pageSize: "10",
          lang: "zh-CN",
          highlight: true,
          recordIP: false,
          serverURLs: "",
        });
      });
    }
    createObserver(loadValine, 'vcomments');
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://valine.js.org" target="_blank" rel="nofollow noopener noopener">comments
      powered by Valine.</a></noscript>


              </div>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
	  <i class="iconfont icon-love"></i>
	  <a href="https://cloud.tencent.com/product/wh?from=12331" target="_blank" rel="nofollow noopener">
        <span>Hosted BY 云开发 Cloudbase</span></a>
    </div>
    

    
  <!-- 备案信息 -->
  <div class="beian">
    <a href="http://beian.miit.gov.cn/" target="_blank"
       rel="nofollow noopener">鄂ICP备18012070号</a>
    
  </div>


    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 6,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Kerwin's Library&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>














  <script  src="https://cdn.staticfile.org/mermaid/8.5.0/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>







</body>
</html>
