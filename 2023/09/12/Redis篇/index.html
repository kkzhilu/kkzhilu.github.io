<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="一切都是有可能的，甚至那些不可能的也是.">
  <meta name="author" content="Kerwin">
  <meta name="keywords" content="Java;Python;Vue;前端;后端;多线程;设计模式;并发编程;数据库;">
  <title>Redis篇 - Kerwin&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/xcode.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Kerwin</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/article.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2023-09-12 00:31">
      2023年9月12日 凌晨
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      11k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      138
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h1 id="Redis篇"><a href="#Redis篇" class="headerlink" title="Redis篇"></a>Redis篇</h1><h2 id="Windows-Redis"><a href="#Windows-Redis" class="headerlink" title="Windows Redis"></a>Windows Redis</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>链接: <a href="https://pan.baidu.com/s/1MJnzX_qRuNXJI09euzkPGA" target="_blank" rel="noopener">https://pan.baidu.com/s/1MJnzX_qRuNXJI09euzkPGA</a> 提取码: 2c6w 复制这段内容后打开百度网盘手机App，操作更方便哦</p>
<p>无脑下一步即可</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>出现错误：</p>
<p>creating server tcp listening socket 127.0.0.1:6379: bind No error</p>
<p>解决方案：</p>
<ol>
<li>redis-cli.exe</li>
<li>shutdown</li>
<li>exit</li>
<li>redis-server.exe redis.windows.conf</li>
</ol>
<p>启动：redis-server.exe redis.windows.conf</p>
<p>客户端启动：redis-cli.exe  (不修改配置的话默认即可)</p>
<p>​                        redis-cli.exe -h 127.0.0.1 -p 6379 -a password</p>
<h2 id="基本文件说明"><a href="#基本文件说明" class="headerlink" title="基本文件说明"></a>基本文件说明</h2><table>
<thead>
<tr>
<th>可执行文件</th>
<th>作用说明</th>
</tr>
</thead>
<tbody><tr>
<td>redis-server</td>
<td>redis服务</td>
</tr>
<tr>
<td>redis-cli</td>
<td>redis命令行工具</td>
</tr>
<tr>
<td>redis-benchmark</td>
<td>基准性能测试工具</td>
</tr>
<tr>
<td>redis-check-aof</td>
<td>AOF持久化文件检测和修复工具</td>
</tr>
<tr>
<td>redis-check-dump</td>
<td>RDB持久化文件检测和修复工具</td>
</tr>
<tr>
<td>redis-sentinel</td>
<td>启动哨兵</td>
</tr>
<tr>
<td>redis-trib</td>
<td>cluster集群构建工具</td>
</tr>
</tbody></table>
<h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td>keys  *</td>
<td align="left">redis允许模糊查询key　　有3个通配符  *、?、[]</td>
</tr>
<tr>
<td>del      key</td>
<td align="left">删除key</td>
</tr>
<tr>
<td>exists kxm</td>
<td align="left">判断是否存在</td>
</tr>
<tr>
<td>expire key 20</td>
<td align="left">设置过期时间 - 秒</td>
</tr>
<tr>
<td>pexpire key 20000</td>
<td align="left">设置过期时间 - 毫秒</td>
</tr>
<tr>
<td>move kxm 2</td>
<td align="left">移动key到指定位置库中  2号库</td>
</tr>
<tr>
<td>persist key</td>
<td align="left">移除过期时间，key将会永久存在   成功设置返回1  否则返回0</td>
</tr>
<tr>
<td>pttl key</td>
<td align="left">以毫秒为单位返回 key 的剩余的过期时间</td>
</tr>
<tr>
<td>ttl key</td>
<td align="left">以秒为单位，返回给定 key 的剩余生存时间</td>
</tr>
<tr>
<td>randomkey</td>
<td align="left">从当前数据库中随机返回一个 key</td>
</tr>
<tr>
<td>rename key newkxy</td>
<td align="left">更改key的名字，如果重复了会覆盖</td>
</tr>
<tr>
<td>renamenx kxm key</td>
<td align="left">仅当 newkey 不存在时，将 key 改名为 newkey</td>
</tr>
<tr>
<td>type key</td>
<td align="left">返回 key 所储存的值的类型</td>
</tr>
<tr>
<td>select 0</td>
<td align="left">选择第一个库</td>
</tr>
<tr>
<td>ping</td>
<td align="left">返回PONG 表示连接正常</td>
</tr>
<tr>
<td>quit</td>
<td align="left">关闭当前连接</td>
</tr>
</tbody></table>
<h2 id="字符串命令"><a href="#字符串命令" class="headerlink" title="字符串命令"></a>字符串命令</h2><p>| 命令                           | 说明                                                         |<br>|  |  |<br>| set key aaa                    | 设置指定 key 的值                                            |<br>| get key                        | 获取指定 key 的值                                            |<br>| getrange key 0 1               | 返回 key 中字符串值的子字符  包含 0 和 1 包含关系            |<br>| getset key aaaaaaaa            | 将给定 key 的值设为 value ，并返回 key 的旧值(old value)     |<br>| mget key kxm                   | 获取所有(一个或多个)给定 key 的值                            |<br>| setex test 5 “this is my test” | 将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位) |<br>| setnx test test                | 只有在 key 不存在时设置 key 的值 （用于分布式锁）            |<br>| strlen test                    | 返回 key 所储存的字符串值的长度                              |<br>| mset key1 “1” key2 “2”         | 同时设置一个或多个 key-value 对                              |<br>| msetnx key3 “a” key2 “b”       | 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在   其中一个失败则全部失败 |<br>| incr key                       | 将 key 中储存的数字值增一 -&gt;  key的值 比如为 数字类型字符串  返回增加后的结果 |<br>| incrby num 1000                | 将 key 中储存的数字值增指定的值 -&gt;  key的值 比如为 数字类型字符串  返回增加后的结果 |<br>| decr key                       | 同 -&gt; 减一                                                   |<br>| decrby num 500                 | 同 -&gt; 减指定值                                               |<br>| append key 1123123             | 如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾  返回字符串长度 |</p>
<h2 id="哈希-Hash-命令"><a href="#哈希-Hash-命令" class="headerlink" title="哈希(Hash)命令"></a>哈希(Hash)命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>hdel key field1 [field2]</td>
<td>删除一个或多个哈希表字段</td>
</tr>
<tr>
<td>hexistskey field</td>
<td>查看哈希表 key 中，指定的字段是否存在</td>
</tr>
<tr>
<td>hget key field</td>
<td>获取存储在哈希表中指定字段的值</td>
</tr>
<tr>
<td>hgetall key</td>
<td>获取在哈希表中指定 key 的所有字段和值</td>
</tr>
<tr>
<td>hincrby hash yeary 1</td>
<td>为哈希表 key 中的指定字段的整数值加上增量 increment</td>
</tr>
<tr>
<td>hkeys hash</td>
<td>获取所有哈希表中的字段</td>
</tr>
<tr>
<td>hlen hash</td>
<td>获取哈希表中字段的数量</td>
</tr>
<tr>
<td>hmget hash name year</td>
<td>获取所有给定字段的值</td>
</tr>
<tr>
<td>hmset hash name “i am kxm” year 24</td>
<td>同时将多个 field-value (域-值)对设置到哈希表 key 中</td>
</tr>
<tr>
<td>hset hash name kxm</td>
<td>将哈希表 key 中的字段 field 的值设为 value</td>
</tr>
<tr>
<td>hsetnx key field value</td>
<td>只有在字段 field 不存在时，设置哈希表字段的值</td>
</tr>
<tr>
<td>hvals hash</td>
<td>获取哈希表中所有值</td>
</tr>
<tr>
<td>hexists hash name</td>
<td>是否存在</td>
</tr>
</tbody></table>
<blockquote>
<p>编码:  field value 值由 ziplist 及 hashtable 两种编码格式</p>
<p>字段较少的时候采用ziplist，字段较多的时候会变成hashtable编码</p>
</blockquote>
<h2 id="列表-List-命令"><a href="#列表-List-命令" class="headerlink" title="列表(List)命令"></a>列表(List)命令</h2><p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）</p>
<p>一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)</p>
<p>容量 -&gt; 集合,有序集合也是如此</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>lpush list php</td>
<td>将一个值插入到列表头部  返回列表长度</td>
</tr>
<tr>
<td>lindex list 0</td>
<td>通过索引获取列表中的元素</td>
</tr>
<tr>
<td>blpop  key1 [key2 ] timeout</td>
<td>移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</td>
</tr>
<tr>
<td>brpop  key1 [key2 ] timeout</td>
<td>移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</td>
</tr>
<tr>
<td>linsert list before 3 4</td>
<td>在值 3 前插入 4   前即为顶</td>
</tr>
<tr>
<td>linsert list after 4 5</td>
<td>在值4 后插入5</td>
</tr>
<tr>
<td>llen list</td>
<td>获取列表长度</td>
</tr>
<tr>
<td>lpop list</td>
<td>移出并获取列表的第一个元素</td>
</tr>
<tr>
<td>lpush list c++ c</td>
<td>将一个或多个值插入到列表头部</td>
</tr>
<tr>
<td>lrange list 0 1</td>
<td>获取列表指定范围内的元素  包含0和1   -1 代表所有 （lrange list 0 -1）</td>
</tr>
<tr>
<td>lrem list 1 c</td>
<td>移除list 集合中 值为 c 的  一个元素，  1 代表count 即移除几个</td>
</tr>
<tr>
<td>lset list 0 “this is update”</td>
<td>通过索引设置列表元素的值</td>
</tr>
<tr>
<td>ltrim list 1 5</td>
<td>对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除</td>
</tr>
<tr>
<td>rpop list</td>
<td>移除列表的最后一个元素，返回值为移除的元素</td>
</tr>
<tr>
<td>rpush list newvalue3</td>
<td>从底部添加新值</td>
</tr>
<tr>
<td>rpoplpush list list2</td>
<td>转移列表的数据</td>
</tr>
</tbody></table>
<h2 id="集合-Set-命令"><a href="#集合-Set-命令" class="headerlink" title="集合(Set)命令"></a>集合(Set)命令</h2><p>Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据</p>
<p>| 命令                                                         | 说明                                                |<br>|  | — |<br>| sadd set java php c c++ python                               | 向集合添加一个或多个成员                            |<br>| scard set                                                    | 获取集合的成员数                                    |<br>| sdiff key1 [key2]                                            | 返回给定所有集合的差集  数学含义差集                |<br>| sdiffstore curr set newset  （sdiffstore destination key1 [key2]） | 把set和 newset的差值存储到curr中                    |<br>| sinter set newset                                            | 返回给定所有集合的交集                              |<br>| sinterstore curr set newset  （sinterstoredestination key1 [key2]） | 同                                                  |<br>| sismember set c#                                             | 判断 member 元素是否是集合 key 的成员               |<br>| smembers set                                                 | 返回集合中的所有成员                                |<br>| srandmember set 2                                            | 随机抽取两个key (抽奖实现美滋滋)                    |<br>| smove set newtest java （smove source destination member）   | 将 member 元素从 source 集合移动到 destination 集合 |<br>| sunion set newset                                            | 返回所有给定集合的并集                              |<br>| srem set java                                                | 删除                                                |<br>| spop set                                                     | 从集合中弹出一个元素                                |<br>| sdiff | sinter | sunion                                    | 操作：集合间运算：差集                              |</p>
<h2 id="有序集合-sorted-set-命令"><a href="#有序集合-sorted-set-命令" class="headerlink" title="有序集合(sorted set)命令"></a>有序集合(sorted set)命令</h2><p>Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。</p>
<p>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p>
<p>有序集合的成员是唯一的,但分数(score)却可以重复。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>zadd sort 1 java 2 python</td>
<td>向有序集合添加一个或多个成员，或者更新已存在成员的分数</td>
</tr>
<tr>
<td>zcard sort</td>
<td>获取有序集合的成员数</td>
</tr>
<tr>
<td>zcount sort 0 1</td>
<td>计算在有序集合中指定区间分数的成员数</td>
</tr>
<tr>
<td>zincrby sort 500 java</td>
<td>有序集合中对指定成员的分数加上增量 increment</td>
</tr>
<tr>
<td>zscore sort java</td>
<td>返回有序集中，成员的分数值</td>
</tr>
<tr>
<td>zrange sort 0 -1</td>
<td>获取指定序号的值，-1代表全部</td>
</tr>
<tr>
<td>zrangebyscore sort 0 5</td>
<td>分数符合范围的值</td>
</tr>
<tr>
<td>zrangebyscore sort 0 5 limit 0 1</td>
<td>分页 limit  0代表页码，1代表每页显示数量</td>
</tr>
<tr>
<td>zrem sort java</td>
<td>移除元素</td>
</tr>
<tr>
<td>zremrangebyrank sort 0 1</td>
<td>按照排名范围删除元素</td>
</tr>
<tr>
<td>zremrangebyscore sort 0 1</td>
<td>按照分数范围删除元素</td>
</tr>
<tr>
<td>zrevrank sort c#</td>
<td>返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</td>
</tr>
</tbody></table>
<h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><p>开启两个客户端</p>
<p>A客户端订阅频道： subscribe redisChat                                      （频道名字为 redisChat）</p>
<p>B客户端发布内容： publish redisChat “Hello, this is my wor”   （内容是 hello….）</p>
<p>A客户端即为自动收到内容， 原理图如下:</p>
<p><img src="/2023/09/12/Redis%E7%AF%87/Redis%E7%AF%87%5Cpubsub1.png" srcset="/img/loading.gif" alt="img"></p>
<p><img src="/2023/09/12/Redis%E7%AF%87/Redis%E7%AF%87%5Cpubsub2.png" srcset="/img/loading.gif" alt="img"></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>pubsub channels</td>
<td>查看当前redis  有多少个频道</td>
</tr>
<tr>
<td>pubsub numsub chat1</td>
<td>查看某个频道的订阅者数量</td>
</tr>
<tr>
<td>unsubscrible chat1</td>
<td>退订指定频道</td>
</tr>
<tr>
<td>psubscribe java.*</td>
<td>订阅一组频道</td>
</tr>
</tbody></table>
<h2 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h2><p>Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：</p>
<ul>
<li>批量操作在发送 EXEC 命令前被放入队列缓存</li>
<li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行</li>
<li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中</li>
</ul>
<p>一个事务从开始到执行会经历以下三个阶段：</p>
<ul>
<li>开始事务</li>
<li>命令入队</li>
<li>执行事务</li>
</ul>
<pre><code class="hljs 注意：redis事务和数据库事务不同，redis事务出错后最大的特点是，一剩下的命令会继续执行，二出错的数据不会回滚```">
| 命令      | 说明                                                         |
| --- |  |
| multi     | 标记一个事务开始                                             |
| exec      | 执行事务                                                     |
| discard   | 事务开始后输入命令入队过程中，中止事务                       |
| watch key | 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断 |
| unwatch   | 取消 WATCH 命令对所有 key 的监视                             |



## Redis 服务器命令

| 命令     | 说明                    |
| -- | ----- |
| flushall | 删除所有数据库的所有key |
| flushdb  | 删除当前数据库的所有key |
| save     | 同步保存数据到硬盘      |



## Redis 数据备份与恢复

Redis **SAVE** 命令用于创建当前数据库的备份

如果需要恢复数据，只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可。获取 redis 目录可以使用 **CONFIG** 命令



## Redis 性能测试

redis 性能测试的基本命令如下：</code></pre>
<p>redis目录执行：redis-benchmark [option] [option value]</p>
<p>// 会返回各种操作的性能报告（100连接，10000请求）<br>redis-benchmark -h 127.0.0.1 -p 6379 -c 100 -n 10000</p>
<p>// 100个字节作为value值进行压测<br>redis-benchmark -h 127.0.0.1 -p 6379 -q -d 100</p>
<pre><code class="hljs">


## Java Redis

### Jedis 

```xml
&lt;!-- jedis --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;redis.clients&lt;/groupId&gt;
    &lt;artifactId&gt;jedis&lt;/artifactId&gt;
    &lt;version&gt;2.8.2&lt;/version&gt;
&lt;/dependency&gt;</code></pre>



<p><strong>Jedis配置</strong></p>
<pre><code class="hljs properties"><span class="hljs-comment">############# redis Config #############</span>
<span class="hljs-comment"># Redis数据库索引（默认为0）</span>
<span class="hljs-meta">spring.redis.database</span>=<span class="hljs-string">0</span>
<span class="hljs-comment"># Redis服务器地址</span>
<span class="hljs-meta">spring.redis.host</span>=<span class="hljs-string">120.79.88.17</span>
<span class="hljs-comment"># Redis服务器连接端口</span>
<span class="hljs-meta">spring.redis.port</span>=<span class="hljs-string">6379</span>
<span class="hljs-comment"># Redis服务器连接密码（默认为空）</span>
<span class="hljs-meta">spring.redis.password</span>=<span class="hljs-string">123456</span>
<span class="hljs-comment"># 连接池中的最大空闲连接</span>
<span class="hljs-meta">spring.redis.jedis.pool.max-idle</span>=<span class="hljs-string">8</span>
<span class="hljs-comment"># 连接池中的最小空闲连接</span>
<span class="hljs-meta">spring.redis.jedis.pool.min-idle</span>=<span class="hljs-string">0</span></code></pre>



<p><strong>JedisConfig</strong></p>
<pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JedisConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CachingConfigurerSupport</span> </span>&#123;

    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;spring.redis.host&#125;"</span>)
    <span class="hljs-keyword">private</span> String host;

    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;spring.redis.port&#125;"</span>)
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> port;

    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;spring.redis.password&#125;"</span>)
    <span class="hljs-keyword">private</span> String password;

    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;spring.redis.max-idle&#125;"</span>)
    <span class="hljs-keyword">private</span> Integer maxIdle;

    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;spring.redis.min-idle&#125;"</span>)
    <span class="hljs-keyword">private</span> Integer minIdle;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> JedisPool <span class="hljs-title">redisPoolFactory</span><span class="hljs-params">()</span></span>&#123;
        JedisPoolConfig jedisPoolConfig = <span class="hljs-keyword">new</span> JedisPoolConfig();
        jedisPoolConfig.setMaxIdle(maxIdle);
        jedisPoolConfig.setMinIdle(minIdle);
        jedisPoolConfig.setMaxWaitMillis(<span class="hljs-number">3000L</span>);
        <span class="hljs-keyword">int</span> timeOut = <span class="hljs-number">3</span>;
        <span class="hljs-keyword">return</span>  <span class="hljs-keyword">new</span> JedisPool(jedisPoolConfig, host, port, timeOut, password);
    &#125;
&#125;</code></pre>



<p><strong>基础使用</strong></p>
<pre><code class="hljs java"><span class="hljs-meta">@RunWith</span>(SpringRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>
<span class="hljs-class">@<span class="hljs-title">SpringBootTest</span>(<span class="hljs-title">classes</span> </span>= KerwinBootsApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>
<span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">ApplicationTests</span> </span>&#123;

    <span class="hljs-meta">@Resource</span>
    JedisPool jedisPool;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testJedis</span> <span class="hljs-params">()</span> </span>&#123;
        Jedis jedis = jedisPool.getResource();
        jedis.set(<span class="hljs-string">"year"</span>, String.valueOf(<span class="hljs-number">24</span>));
    &#125;
&#125;</code></pre>



<h3 id="SpringBoot-redis-staeter-RedisTemplate"><a href="#SpringBoot-redis-staeter-RedisTemplate" class="headerlink" title="SpringBoot redis staeter RedisTemplate"></a>SpringBoot redis staeter RedisTemplate</h3><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- redis --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-comment">&lt;!-- redis 2.X 更换为commons-pool2 连接池 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>

<pre><code class="hljs properties"><span class="hljs-comment">############# redis Config #############</span>
<span class="hljs-comment"># Redis数据库索引（默认为0）</span>
<span class="hljs-meta">spring.redis.database</span>=<span class="hljs-string">0</span>
<span class="hljs-comment"># Redis服务器地址</span>
<span class="hljs-meta">spring.redis.host</span>=<span class="hljs-string">120.79.88.17</span>
<span class="hljs-comment"># Redis服务器连接端口</span>
<span class="hljs-meta">spring.redis.port</span>=<span class="hljs-string">6379</span>
<span class="hljs-comment"># Redis服务器连接密码（默认为空）</span>
<span class="hljs-meta">spring.redis.password</span>=<span class="hljs-string">123456</span>
<span class="hljs-comment"># 连接池最大连接数（使用负值表示没有限制）</span>
<span class="hljs-meta">spring.redis.jedis.pool.max-active</span>=<span class="hljs-string">200</span>
<span class="hljs-comment"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span>
<span class="hljs-meta">spring.redis.jedis.pool.max-wait</span>=<span class="hljs-string">1000ms</span>
<span class="hljs-comment"># 连接池中的最大空闲连接</span>
<span class="hljs-meta">spring.redis.jedis.pool.max-idle</span>=<span class="hljs-string">8</span>
<span class="hljs-comment"># 连接池中的最小空闲连接</span>
<span class="hljs-meta">spring.redis.jedis.pool.min-idle</span>=<span class="hljs-string">0</span>
<span class="hljs-comment"># 连接超时时间（毫秒）</span>
<span class="hljs-meta">spring.redis.timeout</span>=<span class="hljs-string">1000ms</span></code></pre>

<pre><code class="hljs java"><span class="hljs-comment">//  Cache注解配置类</span>
<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisCacheConfig</span> </span>&#123;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> KeyGenerator <span class="hljs-title">simpleKeyGenerator</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> (o, method, objects) -&gt; &#123;
            StringBuilder stringBuilder = <span class="hljs-keyword">new</span> StringBuilder();
            stringBuilder.append(o.getClass().getSimpleName());
            stringBuilder.append(<span class="hljs-string">"."</span>);
            stringBuilder.append(method.getName());
            stringBuilder.append(<span class="hljs-string">"["</span>);
            <span class="hljs-keyword">for</span> (Object obj : objects) &#123;
                stringBuilder.append(obj.toString());
            &#125;
            stringBuilder.append(<span class="hljs-string">"]"</span>);
            <span class="hljs-keyword">return</span> stringBuilder.toString();
        &#125;;
    &#125;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> CacheManager <span class="hljs-title">cacheManager</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RedisCacheManager(
                RedisCacheWriter.nonLockingRedisCacheWriter(redisConnectionFactory),

                <span class="hljs-comment">// 默认策略，未配置的 key 会使用这个</span>
                <span class="hljs-keyword">this</span>.getRedisCacheConfigurationWithTtl(<span class="hljs-number">15</span>),

                <span class="hljs-comment">// 指定 key 策略</span>
                <span class="hljs-keyword">this</span>.getRedisCacheConfigurationMap()
        );
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> Map&lt;String, RedisCacheConfiguration&gt; <span class="hljs-title">getRedisCacheConfigurationMap</span><span class="hljs-params">()</span> </span>&#123;
        Map&lt;String, RedisCacheConfiguration&gt; redisCacheConfigurationMap  = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">16</span>);
        redisCacheConfigurationMap.put(<span class="hljs-string">"redisTest"</span>, <span class="hljs-keyword">this</span>.getRedisCacheConfigurationWithTtl(<span class="hljs-number">15</span>));
        <span class="hljs-keyword">return</span> redisCacheConfigurationMap;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> RedisCacheConfiguration <span class="hljs-title">getRedisCacheConfigurationWithTtl</span><span class="hljs-params">(Integer seconds)</span> </span>&#123;
        Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = <span class="hljs-keyword">new</span> Jackson2JsonRedisSerializer&lt;&gt;(Object<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
        ObjectMapper om = <span class="hljs-keyword">new</span> ObjectMapper();
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(om);

        RedisCacheConfiguration redisCacheConfiguration = RedisCacheConfiguration.defaultCacheConfig();
        redisCacheConfiguration = redisCacheConfiguration.serializeValuesWith(
                RedisSerializationContext
                        .SerializationPair
                        .fromSerializer(jackson2JsonRedisSerializer)
        ).entryTtl(Duration.ofSeconds(seconds));
        <span class="hljs-keyword">return</span> redisCacheConfiguration;
    &#125;
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-comment">// RedisAutoConfiguration</span>
<span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableCaching</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisConfig</span> </span>&#123;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"all"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory factory)</span> </span>&#123;

        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> RedisTemplate&lt;String, Object&gt;();
        template.setConnectionFactory(factory);

        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="hljs-keyword">new</span> Jackson2JsonRedisSerializer(Object<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

        ObjectMapper om = <span class="hljs-keyword">new</span> ObjectMapper();
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(om);

        StringRedisSerializer stringRedisSerializer = <span class="hljs-keyword">new</span> StringRedisSerializer();

        <span class="hljs-comment">// key采用String的序列化方式</span>
        template.setKeySerializer(stringRedisSerializer);

        <span class="hljs-comment">// hash的key也采用String的序列化方式</span>
        template.setHashKeySerializer(stringRedisSerializer);

        <span class="hljs-comment">// value序列化方式采用jackson</span>
        template.setValueSerializer(jackson2JsonRedisSerializer);

        <span class="hljs-comment">// hash的value序列化方式采用jackson</span>
        template.setHashValueSerializer(jackson2JsonRedisSerializer);
        template.afterPropertiesSet();
        <span class="hljs-keyword">return</span> template;
    &#125;
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-comment">// 基础使用</span>
<span class="hljs-meta">@Resource</span>
RedisTemplate&lt;String,Object&gt; redisTemplate;
redisTemplate.opsForList().rightPush(<span class="hljs-string">"user:1:order"</span>, dataList.get(<span class="hljs-number">3</span>).get(<span class="hljs-string">"key"</span>).toString());

<span class="hljs-comment">// 注解使用</span>
<span class="hljs-meta">@Cacheable</span>(value = <span class="hljs-string">"redisTest"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> TestBean <span class="hljs-title">testBeanAnnotation</span> <span class="hljs-params">()</span> </span>&#123;&#125;</code></pre>



<h2 id="Redis使用场景"><a href="#Redis使用场景" class="headerlink" title="Redis使用场景"></a>Redis使用场景</h2><p>| 类型   | 适用场景                                    |<br>|  | - |<br>| String | 缓存，限流，计数器，分布式锁，分布式session |<br>| Hash   | 存储用户信息，用户主页访问量，组合查询      |<br>| List   | 微博关注人时间轴列表，简单队列              |<br>| Set    | 赞，踩，标签，好友关系                      |<br>| Zset   | 排行榜                                      |</p>
<p>或者简单消息队列，发布订阅实施消息系统等等</p>
<h3 id="String-缓存"><a href="#String-缓存" class="headerlink" title="String - 缓存"></a>String - 缓存</h3><pre><code class="hljs java"><span class="hljs-comment">// 1.Cacheable 注解</span>
<span class="hljs-comment">// controller 调用 service 时自动判断有没有缓存，如果有就走redis缓存直接返回，如果没有则数据库然后自动放入redis中</span>
<span class="hljs-comment">// 可以设置过期时间，KEY生成规则 （KEY生成规则基于 参数的toString方法）</span>
<span class="hljs-meta">@Cacheable</span>(value = <span class="hljs-string">"yearScore"</span>, key = <span class="hljs-string">"#yearScore"</span>)
<span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;YearScore&gt; <span class="hljs-title">findBy</span> <span class="hljs-params">(YearScore yearScore)</span> </span>&#123;&#125;

<span class="hljs-comment">// 2.手动用缓存</span>
<span class="hljs-keyword">if</span> (redis.hasKey(???) &#123;
    <span class="hljs-keyword">return</span> ....
&#125; 

redis.set(find from DB)...</code></pre>



<h3 id="String-限流-计数器"><a href="#String-限流-计数器" class="headerlink" title="String - 限流 | 计数器"></a>String - 限流 | 计数器</h3><pre><code class="hljs java"><span class="hljs-comment">// 注：这只是一个最简单的Demo 效率低，耗时旧，但核心就是这个意思</span>
<span class="hljs-comment">// 计数器也是利用单线程incr...等等</span>
<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/redisLimit"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testRedisLimit</span><span class="hljs-params">(String uuid)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (jedis.get(uuid) != <span class="hljs-keyword">null</span>) &#123;
        Long incr = jedis.incr(uuid);
        <span class="hljs-keyword">if</span> (incr &gt; MAX_LIMITTIME) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-string">"Failure Request"</span>;
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-string">"Success Request"</span>;
        &#125;
    &#125;

    <span class="hljs-comment">// 设置Key 起始请求为1，10秒过期  -&gt;  实际写法肯定封装过,这里就是随便一写</span>
    jedis.set(uuid, <span class="hljs-string">"1"</span>);
    jedis.expire(uuid, <span class="hljs-number">10</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Success Request"</span>;
&#125;</code></pre>



<h3 id="String-分布式锁-重点"><a href="#String-分布式锁-重点" class="headerlink" title="String - 分布式锁 (重点)"></a>String - 分布式锁 (重点)</h3><pre><code class="hljs java"><span class="hljs-comment">/***</span>
<span class="hljs-comment"> * 核心思路：</span>
<span class="hljs-comment"> *     分布式服务调用时setnx,返回1证明拿到，用完了删除，返回0就证明被锁，等...</span>
<span class="hljs-comment"> *     SET KEY value [EX seconds] [PX milliseconds] [NX|XX]</span>
<span class="hljs-comment"> *     EX second:设置键的过期时间为second秒</span>
<span class="hljs-comment"> *     PX millisecond:设置键的过期时间为millisecond毫秒</span>
<span class="hljs-comment"> *     NX：只在键不存在时，才对键进行设置操作</span>
<span class="hljs-comment"> *     XX:只在键已经存在时，才对键进行设置操作</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * 1.设置锁</span>
<span class="hljs-comment"> *     A. 分布式业务统一Key</span>
<span class="hljs-comment"> *     B. 设置Key过期时间</span>
<span class="hljs-comment"> *     C. 设置随机value,利用ThreadLocal 线程私有存储随机value</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * 2.业务处理</span>
<span class="hljs-comment"> *     ...</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * 3.解锁</span>
<span class="hljs-comment"> *     A. 无论如何必须解锁 - finally (超时时间和finally 双保证)</span>
<span class="hljs-comment"> *     B. 要对比是否是本线程上的锁，所以要对比线程私有value和存储的value是否一致(避免把别人加锁的东西删除了)</span>
<span class="hljs-comment"> */</span>
<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/redisLock"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testRedisLock</span> <span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-keyword">for</span>(;;)&#123;
            RedisContextHolder.clear();
            String uuid = UUID.randomUUID().toString();

            String set = jedis.set(KEY, uuid, <span class="hljs-string">"NX"</span>, <span class="hljs-string">"EX"</span>, <span class="hljs-number">1000</span>);
            RedisContextHolder.setValue(uuid);

            <span class="hljs-keyword">if</span> (!<span class="hljs-string">"OK"</span>.equals(set)) &#123;
                <span class="hljs-comment">// 进入循环-可以短时间休眠</span>
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-comment">// 获取锁成功 Do Somethings....</span>
                <span class="hljs-keyword">break</span>;
            &#125;
        &#125;
    &#125; <span class="hljs-keyword">finally</span> &#123;
        <span class="hljs-comment">// 解锁 -&gt; 保证获取数据，判断一致以及删除数据三个操作是原子的， 因此如下写法是不符合的</span>
        <span class="hljs-comment">/*if (RedisContextHolder.getValue() != null &amp;&amp; jedis.get(KEY) != null &amp;&amp; RedisContextHolder.getValue().equals(jedis.get(KEY))) &#123;</span>
<span class="hljs-comment">                jedis.del(KEY);</span>
<span class="hljs-comment">            &#125;*/</span>

        <span class="hljs-comment">// 正确姿势 -&gt; 使用Lua脚本,保证原子性</span>
        String luaScript = <span class="hljs-string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del',KEYS[1]) else return 0 end"</span>;
        Object eval = jedis.eval(luaScript, Collections.singletonList(KEY), Collections.singletonList(RedisContextHolder.getValue()));
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-string">"锁创建成功-业务处理成功"</span>;
&#125;</code></pre>



<h3 id="String-分布式Session（重点）"><a href="#String-分布式Session（重点）" class="headerlink" title="String - 分布式Session（重点）"></a>String - 分布式Session（重点）</h3><pre><code class="hljs armasm">// <span class="hljs-number">1</span>.首先明白为什么需要分布式session -&gt; nginx负载均衡 分发到不同的Tomcat，即使利用<span class="hljs-built_in">IP</span>分发，可以利用request获取session，但是其中一个挂了，怎么办？？ 所以需要分布式session

注意理解其中的区别  A服务-用户校验服务  <span class="hljs-keyword">B服务-业务层</span>
<span class="hljs-keyword"></span>
<span class="hljs-keyword">情况A：</span>
<span class="hljs-keyword">A,B </span>服务单机部署：
<span class="hljs-symbol">cookie</span>：登录成功后，存储信息到cookie，A服务自身通过request设置session，获取session，<span class="hljs-keyword">B服务通过唯一key或者userid </span>查询数据库获取用户信息

<span class="hljs-symbol">cookie</span>+redis：登录成功后，存储信息到cookie，A服务自身通过request设置session，获取session，<span class="hljs-keyword">B服务通过唯一key或者userid </span>查询redis获取用户信息


情况<span class="hljs-keyword">B：</span>
<span class="hljs-keyword">A服务多节点部署，B服务多节点部署</span>
<span class="hljs-keyword">B服务获取用户信息的方式其实是不重要的，必然要查，要么从数据库，要么从cookie</span>
<span class="hljs-keyword"></span>
<span class="hljs-keyword">A服务：登录成功后，存储唯一key到cookie， </span>与此同时，A服务需要把session（KEY-UserInfo）同步到redis中，不能存在单纯的request（否则nginx分发到另一个服务器就完犊子了）

官方实现：
<span class="hljs-symbol">spring</span>-session-<span class="hljs-meta">data</span>-redis
有一个内置拦截器，拦截request，session通过redis交互，普通使用代码依然是request.getSession....  但是实际上这个session的值已经被该组件拦截，通过redis进行同步了</code></pre>



<h3 id="List-简单队列-栈"><a href="#List-简单队列-栈" class="headerlink" title="List 简单队列-栈"></a>List 简单队列-栈</h3><pre><code class="hljs java"><span class="hljs-comment">// 说白了利用redis - list数据结构 支持从左从右push，从左从右pop</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisStack</span> </span>&#123;

    <span class="hljs-meta">@Resource</span>
    Jedis jedis;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String KEY = <span class="hljs-string">"Stack"</span>;

    <span class="hljs-comment">/** push **/</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span> <span class="hljs-params">(String value)</span> </span>&#123;
        jedis.lpush(KEY, value);
    &#125;

    <span class="hljs-comment">/** pop **/</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">pop</span> <span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> jedis.lpop(KEY);
    &#125;
&#125;</code></pre>

<pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisQueue</span> </span>&#123;

    <span class="hljs-meta">@Resource</span>
    JedisPool jedisPool;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String KEY = <span class="hljs-string">"Queue"</span>;

    <span class="hljs-comment">/** push **/</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span> <span class="hljs-params">(String value)</span> </span>&#123;
        Jedis jedis = jedisPool.getResource();
        jedis.lpush(KEY, value);
    &#125;

    <span class="hljs-comment">/** pop **/</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">pop</span> <span class="hljs-params">()</span> </span>&#123;
        Jedis jedis = jedisPool.getResource();
        <span class="hljs-keyword">return</span> jedis.rpop(KEY);
    &#125;
&#125;</code></pre>



<h3 id="List-社交类APP-好友列表"><a href="#List-社交类APP-好友列表" class="headerlink" title="List 社交类APP - 好友列表"></a>List 社交类APP - 好友列表</h3><pre><code class="hljs jboss-cli">根据时间显示好友，多个好友列表，求交集，并集  显示共同好友等等<span class="hljs-string">...</span>
疑问：难道大厂真的用redis存这些数据吗？？？多大的量啊<span class="hljs-string">...</span> 我个人认为实际是数据库存用户id，然后用算法去处理，更省空间</code></pre>



<h3 id="Set-抽奖-好友关系（合，并，交集）"><a href="#Set-抽奖-好友关系（合，并，交集）" class="headerlink" title="Set 抽奖 | 好友关系（合，并，交集）"></a>Set 抽奖 | 好友关系（合，并，交集）</h3><pre><code class="hljs angelscript"><span class="hljs-comment">// 插入key 及用户id</span>
sadd cat:<span class="hljs-number">1</span> <span class="hljs-number">001</span> <span class="hljs-number">002</span> <span class="hljs-number">003</span> <span class="hljs-number">004</span> <span class="hljs-number">005</span> <span class="hljs-number">006</span>

<span class="hljs-comment">// 返回抽奖参与人数</span>
scard cat:<span class="hljs-number">1</span>

<span class="hljs-comment">// 随机抽取一个</span>
srandmember cat:<span class="hljs-number">1</span>

<span class="hljs-comment">// 随机抽取一人，并移除</span>
spop cat:<span class="hljs-number">1</span></code></pre>



<h3 id="Zset-排行榜"><a href="#Zset-排行榜" class="headerlink" title="Zset 排行榜"></a>Zset 排行榜</h3><pre><code class="hljs crmsh">根据分数实现有序列表
微博热搜：每点击一次 分数+<span class="hljs-number">1</span> 即可

--- 不用数据库目的是因为避免<span class="hljs-keyword">order</span> <span class="hljs-title">by</span> 进行全表扫描</code></pre>



<h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><h3 id="Q1-为什么Redis能这么快"><a href="#Q1-为什么Redis能这么快" class="headerlink" title="Q1:为什么Redis能这么快"></a>Q1:为什么Redis能这么快</h3><pre><code class="hljs tex">1.Redis完全基于内存，绝大部分请求是纯粹的内存操作，执行效率高。
2.Redis使用单进程单线程模型的(K,V)数据库，将数据存储在内存中，存取均不会受到硬盘IO的限制，因此其执行速度极快，另外单线程也能处理高并发请求，还可以避免频繁上下文切换和锁的竞争，同时由于单线程操作，也可以避免各种锁的使用，进一步提高效率
3.数据结构简单，对数据操作也简单，Redis不使用表，不会强制用户对各个关系进行关联，不会有复杂的关系限制，其存储结构就是键值对，类似于HashMap，HashMap最大的优点就是存取的时间复杂度为O(1)
5.C语言编写，效率更高
6.Redis使用多路I/O复用模型，为非阻塞IO
7.有专门设计的RESP协议</code></pre>

<blockquote>
<p>针对第四点进行说明 -&gt; </p>
<p>常见的IO模型有四种：</p>
<ul>
<li><p>同步阻塞IO（Blocking IO）：即传统的IO模型。</p>
</li>
<li><p>同步非阻塞IO（Non-blocking IO）：默认创建的socket都是阻塞的，非阻塞IO要求socket被设置为NONBLOCK。注意这里所说的NIO并非Java的NIO（New IO）库。</p>
</li>
<li><p>IO多路复用（IO Multiplexing）：即经典的Reactor设计模式，有时也称为异步阻塞IO，Java中的Selector和Linux中的epoll都是这种模型。</p>
</li>
<li><p>异步IO（Asynchronous IO）：即经典的Proactor设计模式，也称为异步非阻塞IO</p>
</li>
</ul>
<p>同步异步，阻塞非阻塞的概念：</p>
<p><img src="/2023/09/12/Redis%E7%AF%87/Redis%E7%AF%87%5Cu=3153840595,3774439005&fm=173&app=49&f=JPEG.jpg" srcset="/img/loading.gif" alt="img"></p>
<p><img src="/2023/09/12/Redis%E7%AF%87/Redis%E7%AF%87%5Cu=3983759926,858503315&fm=173&app=49&f=JPEG.jpg" srcset="/img/loading.gif" alt="img"></p>
<p>假设Redis采用同步阻塞IO：</p>
<p>Redis主程序（服务端 单线程）-&gt; 多个客户端连接（真实情况是如开发人员连接redis，程序 redispool连接redis），这每一个都对应着一个客户端，假设为100个客户端，其中一个进行交互时候，如果采用同步阻塞式，那么剩下的99个都需要原地等待，这势必是不科学的。</p>
<p>IO多路复用</p>
<p>Redis 采用  I/O 多路复用模型</p>
<p>I/O 多路复用模型中，最重要的函数调用就是 <code>select</code>，该方法的能够同时监控多个文件描述符的可读可写情况，当其中的某些文件描述符可读或者可写时，<code>select</code> 方法就会返回可读以及可写的文件描述符个数</p>
<pre><code class="hljs 注：redis默认使用的是更加优化的算法：epoll```">
|            | select                                   | poll                                     | epoll                                                        |
| ---- | ---- | ---- |  |
| 操作方式   | 遍历                                     | 遍历                                     | 回调                                                         |
| 底层实现   | 数组                                     | 链表                                     | 哈希表                                                       |
| IO效率     | 每次调用都进行线性遍历，时间复杂度为O(n) | 每次调用都进行线性遍历，时间复杂度为O(n) | 事件通知方式，每当fd就绪，系统注册的回调函数就会被调用，将就绪fd放到readyList里面，时间复杂度O(1) |
| 最大连接数 | 1024（x86）或2048（x64）                 | 无上限                                   | 无上限                                                       |

所以我们可以说Redis是这样的：服务端单线程毫无疑问，多客户端连接时候，如果客户端没有发起任何动作，则服务端会把其视为不活跃的IO流，将其挂起，当有真正的动作时，会通过回调的方式执行相应的事件




### Q2:从海量Key里查询出某一个固定前缀的Key

A. 笨办法：KEYS [pattern]  注意key很多的话，这样做肯定会出问题，造成redis崩溃

B. SCAN cursor [MATCH pattern] [COUNT count] 游标方式查找



### Q3:如何通过Redis实现分布式锁 </code></pre>
<p>见上文</p>
</blockquote>
<pre><code class="hljs">


### Q4:如何实现异步队列</code></pre>
<p>上文说到利用 redis-list 实现队列<br>假设场景:A服务生产数据 - B服务消费数据，即可利用此种模型构造-生产消费者模型</p>
<ol>
<li>使用Redis中的List作为队列</li>
<li>使用BLPOP key [key…] timeout  -&gt; LPOP key [key …] timeout:阻塞直到队列有消息或者超时<br>（方案二：解决方案一中，拿数据的时，生产者尚未生产的情况）</li>
</ol>
<p>3.pub/sub：主题订阅者模式<br>基于reds的终极方案，上文有介绍，基于发布/订阅模式<br>缺点:消息的发布是无状态的，无法保证可达。对于发布者来说，消息是“即发即失”的，此时如果某个消费者在生产者发布消息时下线，重新上线之后，是无法接收该消息的，要解决该问题需要使用专业的消息队列</p>
<pre><code class="hljs">


### Q5:Redis支持的数据类型？</code></pre>
<p>见上文</p>
<pre><code class="hljs">


### Q6:什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？

&gt; 持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。
&gt;
&gt; Redis 提供了两种持久化方式:RDB（默认） 和AOF 
&gt;
&gt; **RDB：**
&gt;
&gt; rdb是Redis DataBase缩写
&gt;
&gt; 功能核心函数rdbSave(生成RDB文件)和rdbLoad（从文件加载内存）两个函数
&gt;
&gt; ![img](Redis篇/1481291-20180925141429889-1694430603.png)
&gt;
&gt; 
&gt;
&gt; RDB:  把当前进程数据生成快照文件保存到硬盘的过程。分为手动触发和自动触发
&gt;
&gt; 手动触发 -&gt;  save (不推荐，阻塞严重)  bgsave -&gt; （save的优化版，微秒级阻塞）
&gt;
&gt; ```shutdowm 关闭服务时，如果没有配置AOF，则会使用bgsave持久化数据</code></pre>
<blockquote>
<p><strong>bgsave - 工作原理</strong></p>
<p>会从当前父进程fork一个子进程，然后生成rdb文件</p>
<p>缺点：频率低，无法做到实时持久化</p>
<p><strong>AOF:</strong></p>
<p>Aof是Append-only file缩写，AOF文件存储的也是RESP协议</p>
<p><img src="/2023/09/12/Redis%E7%AF%87/1481291-20180925141527592-2105439510.png" srcset="/img/loading.gif" alt="img"></p>
<p>每当执行服务器(定时)任务或者函数时flushAppendOnlyFile 函数都会被调用， 这个函数执行以下两个工作</p>
<p>aof写入保存：</p>
<p>WRITE：根据条件，将 aof_buf 中的缓存写入到 AOF 文件</p>
<p>SAVE：根据条件，调用 fsync 或 fdatasync 函数，将 AOF 文件保存到磁盘中。</p>
<p><strong>存储结构:</strong></p>
<p>内容是redis通讯协议(RESP )格式的命令文本存储</p>
<p><strong>原理：</strong></p>
<p>相当于存储了redis的执行命令(类似mysql的sql语句日志)，数据的完整性和一致性更高</p>
<p><strong>比较</strong>：</p>
<p>1、aof文件比rdb更新频率高</p>
<p>2、aof比rdb更安全</p>
<p>3、rdb性能更好</p>
<p>PS：正确停止redis服务 应该基于连接命令 加再上 shutdown -&gt; 否则数据持久化会出现问题</p>
</blockquote>
<h3 id="Q7-redis通讯协议-RESP"><a href="#Q7-redis通讯协议-RESP" class="headerlink" title="Q7:redis通讯协议(RESP)"></a>Q7:redis通讯协议(RESP)</h3><blockquote>
<p>Redis 即 REmote Dictionary Server (远程字典服务)；</p>
<p>而Redis的协议规范是 Redis Serialization Protocol (Redis序列化协议)</p>
<p>RESP 是redis客户端和服务端之前使用的一种通讯协议；</p>
<p>RESP 的特点：实现简单、快速解析、可读性好</p>
<p>协议如下：</p>
<p>客户端以规定格式的形式发送命令给服务器</p>
<pre><code class="hljs lsl">set <span class="hljs-type">key</span> value 协议翻译如下：

* <span class="hljs-number">3</span>    -&gt;  表示以下有几组命令

$ <span class="hljs-number">3</span>    -&gt;  表示命令长度是<span class="hljs-number">3</span>
SET

$<span class="hljs-number">6</span>     -&gt;  表示长度是<span class="hljs-number">6</span>
keykey

$<span class="hljs-number">5</span>     -&gt;  表示长度是<span class="hljs-number">5</span>
value

完整即：
* <span class="hljs-number">3</span>
$ <span class="hljs-number">3</span>
SET
$<span class="hljs-number">6</span>
keykey
$<span class="hljs-number">5</span> 
value</code></pre>



<p>​       </p>
<p>服务器在执行最后一条命令后，返回结果，返回格式如下：</p>
<p>For Simple Strings the first byte of the reply is “+” 回复</p>
<p>For Errors the first byte of the reply is “-“ 错误</p>
<p>For Integers the first byte of the reply is “:” 整数</p>
<p>For Bulk Strings the first byte of the reply is “$” 字符串</p>
<p>For Arrays the first byte of the reply is “*” 数组</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-comment">// 伪造6379 redis-服务端，监听  jedis发送的协议内容</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SocketApp</span> </span>&#123;
    
    <span class="hljs-comment">/***</span>
<span class="hljs-comment">     * 监听 6379 传输的数据</span>
<span class="hljs-comment">     * JVM端口需要进行设置</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>  </span>&#123;
        <span class="hljs-keyword">try</span> &#123;
            ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6379</span>);
            Socket redis = serverSocket.accept();
            <span class="hljs-keyword">byte</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">2048</span>];
            redis.getInputStream().read(result);
            System.out.println(<span class="hljs-keyword">new</span> String(result));
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;

<span class="hljs-comment">// jedis连接-发送命令</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;
        Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">"127.0.0.1"</span>);
        jedis.set(<span class="hljs-string">"key"</span>, <span class="hljs-string">"This is value."</span>);
        jedis.close();
    &#125;
&#125;

<span class="hljs-comment">// 监听命令内容如下：</span>
*<span class="hljs-number">3</span>
$<span class="hljs-number">3</span>
SET
$<span class="hljs-number">3</span>
key
$<span class="hljs-number">14</span></code></pre>



<h3 id="Q8-redis架构有哪些"><a href="#Q8-redis架构有哪些" class="headerlink" title="Q8:redis架构有哪些"></a>Q8:redis架构有哪些</h3><h4 id="单节点"><a href="#单节点" class="headerlink" title="单节点"></a>单节点</h4><h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><pre><code class="hljs crmsh"><span class="hljs-literal">Master</span>-<span class="hljs-literal">slave</span>  主从赋值，此种结构可以考虑关闭<span class="hljs-literal">master</span>的持久化，只让从数据库进行持久化，另外可以通过读写分离，缓解主服务器压力</code></pre>

<h4 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h4><pre><code class="hljs angelscript">Redis sentinel 是一个分布式系统中监控 redis 主从服务器，并在主服务器下线时自动进行故障转移。其中三个特性：

监控（Monitoring）：    Sentinel  会不断地检查你的主服务器和从服务器是否运作正常。

提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。

自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作。

特点：
<span class="hljs-number">1</span>、保证高可用
<span class="hljs-number">2</span>、监控各个节点
<span class="hljs-number">3</span>、自动故障迁移

缺点：主从模式，切换需要时间丢数据
没有解决 master 写的压力</code></pre>

<h4 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h4><blockquote>
<p><img src="/2023/09/12/Redis%E7%AF%87/1481291-20180925142304757-1498788186.png" srcset="/img/loading.gif" alt="img"></p>
<p>从redis 3.0之后版本支持redis-cluster集群，Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。</p>
<p>特点：</p>
<p>1、无中心架构（不存在哪个节点影响性能瓶颈），少了 proxy 层。</p>
<p>2、数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布。</p>
<p>3、可扩展性，可线性扩展到 1000 个节点，节点可动态添加或删除。</p>
<p>4、高可用性，部分节点不可用时，集群仍可用。通过增加 Slave 做备份数据副本</p>
<p>5、实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave到 Master 的角色提升。</p>
<p>缺点：</p>
<p>1、资源隔离性较差，容易出现相互影响的情况。</p>
<p>2、数据通过异步复制,不保证数据的强一致性</p>
</blockquote>
<h3 id="Q9-Redis集群-如何从海量数据里快速找到所需？"><a href="#Q9-Redis集群-如何从海量数据里快速找到所需？" class="headerlink" title="Q9:Redis集群-如何从海量数据里快速找到所需？"></a>Q9:Redis集群-如何从海量数据里快速找到所需？</h3><ul>
<li><h4 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h4><p>按照某种规则去划分数据，分散存储在多个节点上。通过将数据分到多个Redis服务器上，来减轻单个Redis服务器的压力。</p>
</li>
<li><h4 id="一致性Hash算法"><a href="#一致性Hash算法" class="headerlink" title="一致性Hash算法"></a>一致性Hash算法</h4><p>既然要将数据进行分片，那么通常的做法就是获取节点的Hash值，然后根据节点数求模，但这样的方法有明显的弊端，当Redis节点数需要动态增加或减少的时候，会造成大量的Key无法被命中。所以Redis中引入了<strong>一致性Hash算法</strong>。该算法<strong>对2^32 取模，将Hash值空间组成虚拟的圆环</strong>，整个圆环按<strong>顺时针</strong>方向组织，每个节点依次为0、1、2…2^32-1，之后将每个服务器进行Hash运算，确定服务器在这个Hash环上的地址，确定了服务器地址后，对数据使用同样的Hash算法，将数据定位到特定的Redis服务器上。如果定位到的地方没有Redis服务器实例，则继续顺时针寻找，找到的第一台服务器即该数据最终的服务器位置。 </p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/17/16d3e62113addc43?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" srcset="/img/loading.gif" alt="一致性Hash算法"></p>
</li>
</ul>
<h4 id="Hash环的数据倾斜问题"><a href="#Hash环的数据倾斜问题" class="headerlink" title="Hash环的数据倾斜问题"></a>Hash环的数据倾斜问题</h4><p>Hash环在服务器节点很少的时候，容易遇到服务器节点不均匀的问题，这会造成<strong>数据倾斜</strong>，数据倾斜指的是被缓存的对象大部分集中在Redis集群的其中一台或几台服务器上。 </p>
<p><img src="/2023/09/12/Redis%E7%AF%87/16d3e6243490f5e0" srcset="/img/loading.gif" alt="数据倾斜"></p>
<p> 如上图，一致性Hash算法运算后的数据大部分被存放在A节点上，而B节点只存放了少量的数据，久而久之A节点将被撑爆。<br><strong>引入虚拟节点</strong></p>
<p><img src="/2023/09/12/Redis%E7%AF%87/16d3e627518a678e" srcset="/img/loading.gif" alt="虚拟节点"></p>
<p> 例如上图：将NodeA和NodeB两个节点分为Node A#1-A#3 NodeB#1-B#3。</p>
<h3 id="Q10-什么是缓存穿透？如何避免？什么是缓存雪崩？如何避免？什么是缓存击穿？如何避免？"><a href="#Q10-什么是缓存穿透？如何避免？什么是缓存雪崩？如何避免？什么是缓存击穿？如何避免？" class="headerlink" title="Q10:什么是缓存穿透？如何避免？什么是缓存雪崩？如何避免？什么是缓存击穿？如何避免？"></a>Q10:什么是缓存穿透？如何避免？什么是缓存雪崩？如何避免？什么是缓存击穿？如何避免？</h3><blockquote>
<p>缓存穿透</p>
<p>一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。一些恶意的请求会故意查询不存在的key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。</p>
<p>如何避免？</p>
<p>1：对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。</p>
<p>2：对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤。</p>
<p>3：由于请求参数是不合法的（每次都请求不存在的参数），于是我们可以使用布隆过滤器（Bloomfilter）或压缩filter提前进行拦截，不合法就不让这个请求进入到数据库层</p>
<p>缓存雪崩</p>
<p>当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。</p>
<p>如何避免？</p>
<p>1：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p>
<p>2：做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期</p>
<p>3：不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>
<p>4：启用限流策略，尽量避免数据库被干掉</p>
<p>缓存击穿</p>
<p>概念<br>一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。</p>
<p>解决方案<br>A. 在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key</p>
<p>B. 服务层处理 - 方法加锁 + 双重校验：</p>
<pre><code class="hljs java"><span class="hljs-comment">// 锁-实例</span>
<span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();

<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getProductImgUrlById</span><span class="hljs-params">(String id)</span></span>&#123;
    <span class="hljs-comment">// 获取缓存</span>
    String product = jedisClient.get(PRODUCT_KEY + id);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == product) &#123;
        <span class="hljs-comment">// 如果没有获取锁等待3秒，SECONDS代表：秒</span>
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">if</span> (lock.tryLock(<span class="hljs-number">3</span>, TimeUnit.SECONDS)) &#123;
                <span class="hljs-keyword">try</span> &#123;
                    <span class="hljs-comment">// 获取锁后再查一次，查到了直接返回结果</span>
                    product = jedisClient.get(PRODUCT_KEY + id);
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == product) &#123;
                        <span class="hljs-comment">// ....</span>
                    &#125;
                    <span class="hljs-keyword">return</span> product;
                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                    product = jedisClient.get(PRODUCT_KEY + id);
                &#125; <span class="hljs-keyword">finally</span> &#123;
                    <span class="hljs-comment">// 释放锁（成功、失败都必须释放，如果是lock.tryLock()方法会一直阻塞在这）</span>
                    lock.unlock();
                &#125;
            &#125; <span class="hljs-keyword">else</span> &#123;
                product = jedisClient.get(PRODUCT_KEY + id);
            &#125;
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            product = jedisClient.get(PRODUCT_KEY + id);
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> product;
&#125;
</code></pre>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>解释</th>
<th>基础解决方案</th>
</tr>
</thead>
<tbody><tr>
<td>缓存穿透</td>
<td>访问一个不存在的key，缓存不起作用，请求会穿透到DB，流量大时DB会挂掉</td>
<td>1.采用布隆过滤器，使用一个足够大的bitmap，用于存储可能访问的key，不存在的key直接被过滤； 2.访问key未在DB查询到值，也将空值写进缓存，但可以设置较短过期时间</td>
</tr>
<tr>
<td>缓存雪崩</td>
<td>大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩</td>
<td>可以给缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效</td>
</tr>
<tr>
<td>缓存击穿</td>
<td>一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增</td>
<td>在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key</td>
</tr>
</tbody></table>
<h3 id="Q11-缓存与数据库双写一致"><a href="#Q11-缓存与数据库双写一致" class="headerlink" title="Q11:缓存与数据库双写一致"></a>Q11:缓存与数据库双写一致</h3><blockquote>
<p>如果仅仅是读数据，没有此类问题</p>
<p>如果是新增数据，也没有此类问题</p>
<p>当数据需要更新时，如何保证缓存与数据库的双写一致性？</p>
<p>三种更新策略：</p>
<ol>
<li>先更新数据库，再更新缓存  -&gt;  </li>
<li>先删除缓存，再更新数据库</li>
<li>先更新数据库，再删除缓存</li>
</ol>
<p>方案一：并发的时候，执行顺序无法保证，可能A先更新数据库，但B后更新数据库但先更新缓存</p>
<p>​                加锁的话，确实可以避免，但这样吞吐量会下降，可以根据业务场景考虑</p>
<p>方案二：该方案会导致不一致的原因是。同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:<br>（1）请求A进行写操作，删除缓存<br>（2）请求B查询发现缓存不存在<br>（3）请求B去数据库查询得到旧值<br>（4）请求B将旧值写入缓存<br>（5）请求A将新值写入数据库</p>
<p>因此采用：<strong>采用延时双删策略</strong>   即进入逻辑就删除Key，执行完操作，延时再删除key</p>
<p>方案三：更新数据库 - 删除缓存  可能出现问题的场景：</p>
<p>（1）缓存刚好失效<br>（2）请求A查询数据库，得一个旧值<br>（3）请求B将新值写入数据库<br>（4）请求B删除缓存<br>（5）请求A将查到的旧值写入缓存</p>
<p>先天条件要求：请求第二步的读取操作耗时要大于更新操作，条件较为苛刻</p>
<p>但如果真的发生怎么处理？</p>
<p>A. 给键设置合理的过期时间</p>
<p>B. 异步延时删除key</p>
</blockquote>
<h3 id="Q12-何保证Redis中的数据都是热点数据"><a href="#Q12-何保证Redis中的数据都是热点数据" class="headerlink" title="Q12:何保证Redis中的数据都是热点数据"></a>Q12:何保证Redis中的数据都是热点数据</h3><blockquote>
<p>A. 可以通过手工或者主动方式，去加载热点数据</p>
<p>B. Redis有其自己的数据淘汰策略：</p>
<p>redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略（回收策略）。redis 提供 6种数据淘汰策略：</p>
<ol>
<li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li>
<li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li>
<li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li>
<li>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</li>
<li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li>
<li>no-enviction（驱逐）：禁止驱逐数据</li>
</ol>
</blockquote>
<h3 id="Q13-Redis的并发竞争问题如何解决"><a href="#Q13-Redis的并发竞争问题如何解决" class="headerlink" title="Q13:Redis的并发竞争问题如何解决?"></a>Q13:Redis的并发竞争问题如何解决?</h3><pre><code class="hljs routeros">即多线程同时操作统一Key的解决办法：

Redis为单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，但是在Jedis客户端对Redis进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成

对此有多种解决方法：
A：条件允许的情况下，请使用redis自带的incr命令,decr命令
B：乐观锁方式
watch price
<span class="hljs-builtin-name">get</span> price <span class="hljs-variable">$price</span>
<span class="hljs-variable">$price</span> = <span class="hljs-variable">$price</span> + 10
multi
<span class="hljs-builtin-name">set</span> price <span class="hljs-variable">$price</span>
exec

C：针对客户端，操作同一个key的时候，进行加锁处理
D：场景允许的话，使用setnx 实现</code></pre>



<h3 id="Q14-Redis回收进程如何工作的-Redis回收使用的是什么算法"><a href="#Q14-Redis回收进程如何工作的-Redis回收使用的是什么算法" class="headerlink" title="Q14:Redis回收进程如何工作的? Redis回收使用的是什么算法?"></a>Q14:Redis回收进程如何工作的? Redis回收使用的是什么算法?</h3><blockquote>
<p>Q12 中提到过，当所需内存超过配置的最大内存时，redis会启用数据淘汰规则</p>
<p>默认规则是：# maxmemory-policy noeviction</p>
<p>即只允许读，无法继续添加key</p>
<p>因此常需要配置淘汰策略，比如LRU算法</p>
<p><img src="/2023/09/12/Redis%E7%AF%87/251954349742220-1569134965865.png" srcset="/img/loading.gif" alt="img"></p>
<pre><code class="hljs LRU算法最为精典的实现，就是HashMap+Double">


### Q15:Redis大批量增加数据

参考文章：https:&#x2F;&#x2F;www.cnblogs.com&#x2F;PatrickLiu&#x2F;p&#x2F;8548580.html

使用管道模式，运行的命令如下所示：
</code></pre>
<p>cat data.txt | redis-cli –pipe</p>
<pre><code class="hljs routeros">
data.txt文本：

```java
<span class="hljs-builtin-name">SET</span> Key0 Value0
<span class="hljs-builtin-name">SET</span> Key1 Value1
<span class="hljs-built_in">..</span>.
<span class="hljs-builtin-name">SET</span> KeyN ValueN

<span class="hljs-comment"># 或者是 RESP协议内容 - 注意文件编码！！！</span>

<span class="hljs-number">*8</span>
<span class="hljs-variable">$5</span>
HMSET
<span class="hljs-variable">$8</span>
person:1
<span class="hljs-variable">$2</span>
id
<span class="hljs-variable">$1</span>
1</code></pre>

<p>这将产生类似于这样的输出：</p>
<pre><code class="hljs yaml"><span class="hljs-string">All</span> <span class="hljs-string">data</span> <span class="hljs-string">transferred.</span> <span class="hljs-string">Waiting</span> <span class="hljs-string">for</span> <span class="hljs-string">the</span> <span class="hljs-string">last</span> <span class="hljs-string">reply...</span>
<span class="hljs-string">Last</span> <span class="hljs-string">reply</span> <span class="hljs-string">received</span> <span class="hljs-string">from</span> <span class="hljs-string">server.</span>
<span class="hljs-attr">errors:</span> <span class="hljs-number">0</span><span class="hljs-string">,</span> <span class="hljs-attr">replies:</span> <span class="hljs-number">1000000</span></code></pre>

<p>redis-cli实用程序还将确保只将从Redis实例收到的错误重定向到标准输出</p>
<p>演示：</p>
<pre><code class="hljs angelscript">cat redis_commands.txt | redis-cli -h <span class="hljs-number">192.168</span><span class="hljs-number">.127</span><span class="hljs-number">.130</span> -p <span class="hljs-number">6379</span> [-a <span class="hljs-string">"password"</span>] -n <span class="hljs-number">0</span> --pipe

All data transferred.Waiting <span class="hljs-keyword">for</span> the last reply...
Last reply received <span class="hljs-keyword">from</span> server.
errors:<span class="hljs-number">0</span>，replies：<span class="hljs-number">10000000</span></code></pre>



<pre><code class="hljs mysql数据快速导入到redis">
博文：https:&#x2F;&#x2F;www.cnblogs.com&#x2F;tommy-huang&#x2F;p&#x2F;4703514.html

&#96;&#96;&#96;sql
# 1.准备一个table
create database  if not exists &#96;test&#96;;
use &#96;test&#96;;
CREATE TABLE &#96;person&#96; (
  &#96;id&#96; int(10) unsigned NOT NULL AUTO_INCREMENT,
  &#96;name&#96; varchar(200) NOT NULL,
  &#96;age&#96; varchar(200) NOT NULL,
  PRIMARY KEY (&#96;id&#96;)
) ENGINE&#x3D;MyISAM AUTO_INCREMENT&#x3D;1 DEFAULT CHARSET&#x3D;utf8;

# 2.插入七八万条数据

# 3.SQL查询，将其转化为 RESP协议命令   Linux 版本： -&gt; 不要在windows环境试，没啥意义
SELECT CONCAT(
   &quot;*8\r\n&quot;,
   &#39;$&#39;,LENGTH(redis_cmd),&#39;\r\n&#39;,redis_cmd,&#39;\r\n&#39;,
   &#39;$&#39;,LENGTH(redis_key),&#39;\r\n&#39;,redis_key,&#39;\r\n&#39;,
   &#39;$&#39;,LENGTH(hkey1),&#39;\r\n&#39;,hkey1,&#39;\r\n&#39;,&#39;$&#39;,LENGTH(hval1),&#39;\r\n&#39;,hval1,&#39;\r\n&#39;,
   &#39;$&#39;,LENGTH(hkey2),&#39;\r\n&#39;,hkey2,&#39;\r\n&#39;,&#39;$&#39;,LENGTH(hval2),&#39;\r\n&#39;,hval2,&#39;\r\n&#39;,
   &#39;$&#39;,LENGTH(hkey3),&#39;\r\n&#39;,hkey3,&#39;\r\n&#39;,&#39;$&#39;,LENGTH(hval3),&#39;\r\n&#39;,hval3,&#39;\r&#39;
)FROM(
   SELECT &#39;HMSET&#39; AS redis_cmd,
   concat_ws(&#39;:&#39;,&#39;person&#39;, id) AS redis_key,
   &#39;id&#39; AS hkey1, id AS hval1,
   &#39;name&#39; AS hkey2, name AS hval2,
   &#39;age&#39; AS hkey3, age AS hval3
   From person
)AS t

# 4.如果用的就是线上数据库+线上Linux -&gt; 把sql存到 order.sql，进行执行
mysql -uroot -p123456 test --default-character-set&#x3D;utf8 --skip-column-names --raw &lt; order.sql  
|
redis-cli -h 127.0.0.1 -p 6379 -a 123456 --pipe

# 5.本地数据库+线上redis
利用Navicat导出数据 -&gt; data.txt，清理格式（导出来的数据里面各种 &quot; 符号），全局替换即可
cat data.txt | redis-cli -h 127.0.0.1 -p 6379 -a 123456  --pipe

81921条数据 一瞬间导入完成

注意事项： RESP协议要求，不要有莫名其妙的字符，注意文件类型是Unix编码类型</code></pre>
</blockquote>
<h3 id="Q16：延申：布隆过滤器"><a href="#Q16：延申：布隆过滤器" class="headerlink" title="Q16：延申：布隆过滤器"></a>Q16：延申：布隆过滤器</h3><blockquote>
<p>数据结构及算法篇 / 布隆过滤器</p>
<p>Redis 实现</p>
<p>redis 4.X 以上 提供 布隆过滤器插件</p>
<p>centos中安装redis插件bloom-filter：<a href="https://blog.csdn.net/u013030276/article/details/88350641" target="_blank" rel="noopener">https://blog.csdn.net/u013030276/article/details/88350641</a></p>
<p>语法：<em>[bf.add  key  options]</em></p>
<p>语法：[bf.exists  key  options]</p>
<p>注意: <code>redis 布隆过滤器提供的是 最大内存512M，2亿数据，万分之一的误差率</code></p>
</blockquote>
<h3 id="Q17：Lua脚本相关"><a href="#Q17：Lua脚本相关" class="headerlink" title="Q17：Lua脚本相关"></a>Q17：Lua脚本相关</h3><p>使用Lua脚本的好处：</p>
<ul>
<li>减少网络开销。可以将多个请求通过脚本的形式一次发送，减少网络时延</li>
<li>原子操作，redis会将整个脚本作为一个整体执行，中间不会被其他命令插入。因此在编写脚本的过程中无需担心会出现竞态条件，无需使用事务</li>
<li>复用，客户端发送的脚本会永久存在redis中，这样，其他客户端可以复用这一脚本而不需要使用代码完成相同的逻辑</li>
</ul>
<pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/testLua"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testLua</span> <span class="hljs-params">()</span> </span>&#123;

    String key   = <span class="hljs-string">"mylock"</span>;
    String value = <span class="hljs-string">"xxxxxxxxxxxxxxx"</span>;

    <span class="hljs-comment">//        if redis.call('get', KEYS[1]) == ARGV[1]</span>
    <span class="hljs-comment">//            then</span>
    <span class="hljs-comment">//                return redis.call('del', KEYS[1])</span>
    <span class="hljs-comment">//        else</span>
    <span class="hljs-comment">//            return 0</span>
    <span class="hljs-comment">//        end</span>

    <span class="hljs-comment">// lua脚本，用来释放分布式锁 - 如果使用的较多，可以封装到文件中, 再进行调用</span>
    String luaScript = <span class="hljs-string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del',KEYS[1]) else return 0 end"</span>;
    Object eval = jedis.eval(luaScript, Collections.singletonList(key), Collections.singletonList(value));
    <span class="hljs-keyword">return</span> eval.toString();
&#125;</code></pre>



<h3 id="Q18：性能相关-Redis慢查询分析"><a href="#Q18：性能相关-Redis慢查询分析" class="headerlink" title="Q18：性能相关 - Redis慢查询分析"></a>Q18：性能相关 - Redis慢查询分析</h3><blockquote>
<p>redis 命令会放在redis内置队列中，然后主线程一个个执行，因此 其中一个 命令执行时间过长，会造成成批量的阻塞</p>
<pre><code class="hljs 命令：```slowlog">     slowlog len 获取慢查询记录量
(慢查询队列是先进先出的，因此新的值在满载的时候，旧的会出去)

Redis 慢查询 -&gt; 执行阶段耗时过长 



&#96;&#96;&#96;conf文件设置： </code></pre>
<p>slowlog-low-slower-than 10000 -&gt; 10000微秒,10毫秒 (默认)<br>                            0 -&gt; 记录所有命令<br>                           -1 -&gt; 不记录命令<br>slow-max-len 存放的最大条数</p>
<pre><code class="hljs 慢查询导致原因:">数据分段（更细颗粒度存放数据） 



### Q19：如何提高Redis处理效率? 基于Jedis 的批量操作 Pipelined

&#96;&#96;&#96;java
Jedis jedis &#x3D; new Jedis(&quot;127.0.0.1&quot;, 6379);
Pipeline pipelined &#x3D; jedis.pipelined();
for (String key : keys) &#123;
   pipelined.del(key);
&#125;

pipelined.sync();
jedis.close();

&#x2F;&#x2F; pipelined 实际是封装过一层的指令集 -&gt;  实际应用的还是单条指令，但是节省了网络传输开销（服务端到Redis环境的网络开销） </code></pre>
</blockquote>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%AF%87/">中间件篇</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Redis%E7%AF%87/">Redis篇</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2023/09/12/RocketMQ-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AF%87/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">RocketMQ-消息队列篇</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2023/09/12/Google%E6%97%A0%E6%B3%95%E5%90%8C%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">
                        <span class="hidden-mobile">Google无法同步解决方案</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
              <!-- Comments -->
              <div class="comments" id="comments">
                
                
  <div id="vcomments"></div>
  <script type="text/javascript">
    function loadValine() {
      addScript('https://cdn.staticfile.org/valine/1.4.14/Valine.min.js', function () {
        new Valine({
          el: "#vcomments",
          app_id: "6uM0Qq25J6ydLXiYqdyxxiMC-gzGzoHsz",
          app_key: "oc2dzMKP9uJXsnOOhIxAr94f",
          placeholder: "说点什么吧~",
          path: window.location.pathname,
          avatar: "retro",
          meta: ["nick","mail","link"],
          pageSize: "10",
          lang: "zh-CN",
          highlight: true,
          recordIP: false,
          serverURLs: "",
        });
      });
    }
    createObserver(loadValine, 'vcomments');
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://valine.js.org" target="_blank" rel="nofollow noopener noopener">comments
      powered by Valine.</a></noscript>


              </div>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
	  <i class="iconfont icon-love"></i>
	  <a href="https://cloud.tencent.com/product/wh?from=12331" target="_blank" rel="nofollow noopener">
        <span>Hosted BY 云开发 Cloudbase</span></a>
    </div>
    

    
  <!-- 备案信息 -->
  <div class="beian">
    <a href="http://beian.miit.gov.cn/" target="_blank"
       rel="nofollow noopener">鄂ICP备18012070号</a>
    
  </div>


    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 6,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Redis篇&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>














  <script  src="https://cdn.staticfile.org/mermaid/8.5.0/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>







</body>
</html>
