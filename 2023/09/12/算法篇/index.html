<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="一切都是有可能的，甚至那些不可能的也是.">
  <meta name="author" content="Kerwin">
  <meta name="keywords" content="Java;Python;Vue;前端;后端;多线程;设计模式;并发编程;数据库;">
  <title>算法篇 - Kerwin&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/xcode.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Kerwin</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/article.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2023-09-12 00:31">
      2023年9月12日 凌晨
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      9.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      122
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h1 id="算法篇"><a href="#算法篇" class="headerlink" title="算法篇"></a>算法篇</h1><h2 id="时间复杂度计算方式-（渐进时间复杂度）"><a href="#时间复杂度计算方式-（渐进时间复杂度）" class="headerlink" title="时间复杂度计算方式 （渐进时间复杂度）"></a>时间复杂度计算方式 （渐进时间复杂度）</h2><h3 id="什么是复杂度分析？"><a href="#什么是复杂度分析？" class="headerlink" title="什么是复杂度分析？"></a>什么是复杂度分析？</h3><blockquote>
<p>复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低</p>
<p>常见的复杂度：<br>O(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n^2)（平方阶）、O(n^3)（立方阶）</p>
<p>非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，<br>O(2^n)（指数阶）、O(n!)（阶乘阶）</p>
<p>读作 BIG O n  |  BIG  O  1</p>
</blockquote>
<h3 id="简单计算方式"><a href="#简单计算方式" class="headerlink" title="简单计算方式"></a>简单计算方式</h3><blockquote>
<ol>
<li>只关注循环执行次数最多的一段代码</li>
<li>加法法则：总复杂度等于量级最大的那段代码的复杂度</li>
<li>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</li>
</ol>
<p>简单来说，n 项式则是简单计算最高阶即可（去除所有系数，常熟项）</p>
<p>​                    m，n 多项式则是计算两个值的加，或者相乘</p>
</blockquote>
<h3 id="浅析最好、最坏、平均、均摊时间复杂度"><a href="#浅析最好、最坏、平均、均摊时间复杂度" class="headerlink" title="浅析最好、最坏、平均、均摊时间复杂度"></a>浅析最好、最坏、平均、均摊时间复杂度</h3><pre><code class="hljs java"><span class="hljs-comment">// n 表示数组 array 的长度 | 找x的所在位置</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> x)</span> </span>&#123;
 <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
 <span class="hljs-keyword">int</span> pos = -<span class="hljs-number">1</span>;
 <span class="hljs-keyword">for</span> (; i &lt; n; ++i) &#123;
      <span class="hljs-keyword">if</span> (array[i] == x) &#123;
          pos = i;
          <span class="hljs-keyword">break</span>;
      &#125;
 &#125;
	<span class="hljs-keyword">return</span> pos;
&#125;</code></pre>

<p>最好情况：一次，最坏情况：n次，平均：考虑到各种情况出现的概率以及出现的概率进行加权平均数计算</p>
<p><img src="/2023/09/12/%E7%AE%97%E6%B3%95%E7%AF%87/image-20191227095846923.png" srcset="/img/loading.gif" alt="image-20191227095846923"></p>
<p>结果仍为 0(n)</p>
<pre><code class="hljs 均摊时间复杂度```：摊还分析（平摊分析）">
每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是O(1)



## 排序算法

### 冒泡排序

&#96;&#96;&#96;java
&#x2F;***
 * 最好： O(n)
 * 最坏： O(n2)
 * 空间复杂度: O(1)
 * 稳定的排序算法
 *
 * 5 7 4 8 1
 * &#x3D;&#x3D;&#x3D;》 5 4 7 1 8
 * &#x3D;&#x3D;&#x3D;》 4 5 1 7 8
 * &#x3D;&#x3D;&#x3D;》 4 1 5 7 8
 * &#x3D;&#x3D;&#x3D;》 1 4 5 7 8
 *
 * 以从小到大为例，相邻的两个数字两两比较，小的前移
 * 从每个数字开始，每个数字都对应一次循环比较，因此最坏时间复杂度为：O(n2)
 *&#x2F;
private static void sort (int[] num) &#123;
    int length &#x3D; num.length;
    for (int i &#x3D; 0; i &lt; length; i++) &#123;

        &#x2F;&#x2F; 提前退出冒泡循环的标志位
        boolean flag &#x3D; false;
        for (int k &#x3D; 0; k &lt; length - i - 1; k++) &#123;
            if (num[k] &gt; num[k + 1]) &#123;
                int temp &#x3D; num[k];
                num[k] &#x3D; num[k + 1];
                num[k + 1] &#x3D; temp;
                flag &#x3D; true;
            &#125;
        &#125;

        if (!flag) break;
    &#125;
&#125;</code></pre>

<p><img src="/2023/09/12/%E7%AE%97%E6%B3%95%E7%AF%87/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.png" srcset="/img/loading.gif" alt></p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><pre><code class="hljs java"><span class="hljs-comment">/***</span>
<span class="hljs-comment">    * 最好： O(n2)</span>
<span class="hljs-comment">    * 最坏： O(n2)</span>
<span class="hljs-comment">    * 空间复杂度: O(1)</span>
<span class="hljs-comment">    * 不稳定的排序算法 - 选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性</span>
<span class="hljs-comment">    *</span>
<span class="hljs-comment">    * 5 7 4 8 1</span>
<span class="hljs-comment">    * ===》 5 7 4 8 1</span>
<span class="hljs-comment">    * ===》 1 7 4 8 5  寻找最小的数与之交换 | 更好理解的插入排序</span>
<span class="hljs-comment">    * ===》 1 4 7 8 5</span>
<span class="hljs-comment">    * ===》 1 4 5 7 8</span>
<span class="hljs-comment">    *</span>
<span class="hljs-comment">    * 基于插入排序，从左边开始构建已经排好序的数组，从右侧找到最小的数进行交换</span>
<span class="hljs-comment">    */</span>
   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>[] num)</span> </span>&#123;
       <span class="hljs-keyword">int</span> len = num.length;
       <span class="hljs-keyword">int</span> minIndex, temp;
       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;
           minIndex = i;
           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; len; j++) &#123;
               <span class="hljs-keyword">if</span> (num[j] &lt; num[minIndex]) &#123;
                   minIndex = j;
               &#125;
           &#125;

           temp = num[i];
           num[i] = num[minIndex];
           num[minIndex] = temp;
       &#125;
   &#125;</code></pre>

<p><img src="/2023/09/12/%E7%AE%97%E6%B3%95%E7%AF%87/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.jpg" srcset="/img/loading.gif" alt></p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><pre><code class="hljs java"><span class="hljs-comment">/***</span>
<span class="hljs-comment"> * 最好：O(nlogn)</span>
<span class="hljs-comment"> * 最坏：O(nlogn)</span>
<span class="hljs-comment"> * 空间复杂度：O(n)</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * 稳定排序算法 分解 -&gt; 合并阶段</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * 分治的思想 -&gt; 递归算法</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] sort (<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right) &#123;
    <span class="hljs-keyword">if</span> (left &gt;= right)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; nums[left] &#125;;

    <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;
    <span class="hljs-keyword">int</span>[] leftArr  = sort(nums, left, mid);                   <span class="hljs-comment">// 左有序数组</span>
    <span class="hljs-keyword">int</span>[] rightArr = sort(nums, mid + <span class="hljs-number">1</span>, right);              <span class="hljs-comment">// 右有序数组</span>
    <span class="hljs-keyword">int</span>[] newNum = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[leftArr.length + rightArr.length]; <span class="hljs-comment">// 新有序数组</span>

    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (i &lt; leftArr.length &amp;&amp; j &lt; rightArr.length) &#123;
        <span class="hljs-keyword">if</span> (leftArr[i] &lt; rightArr[j]) &#123;
            newNum[index++] = leftArr[i++];
        &#125; <span class="hljs-keyword">else</span> &#123;
            newNum[index++] = rightArr[j++];
        &#125;
    &#125;

    <span class="hljs-keyword">while</span> (i &lt; leftArr.length)
        newNum[index++] = leftArr[i++];

    <span class="hljs-keyword">while</span> (j &lt; rightArr.length)
        newNum[index++] = rightArr[j++];

    <span class="hljs-keyword">return</span> newNum;
&#125;</code></pre>

<p><img src="/2023/09/12/%E7%AE%97%E6%B3%95%E7%AF%87/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.jpg" srcset="/img/loading.gif" alt></p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><pre><code class="hljs java"><span class="hljs-comment">/***</span>
<span class="hljs-comment"> * 最好： O(n)</span>
<span class="hljs-comment"> * 最坏： O(n2)</span>
<span class="hljs-comment"> * 空间复杂度: O(1)</span>
<span class="hljs-comment"> * 稳定的排序算法</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * 5 7 4 8 1</span>
<span class="hljs-comment"> * ===》 4 5 7 8 1</span>
<span class="hljs-comment"> * ===》 4 5 7 8 1</span>
<span class="hljs-comment"> * ===》 1 4 5 7 8</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * 以从小到大为例, 从第三个数字开始和前面两个数字对比，找到合适的插入位置，一直到最后一位插入完毕</span>
<span class="hljs-comment"> * 算法结束，所以实际循环次数理论为 n - 2，每次对比数字也是2 起步，一直加到n - 1</span>
<span class="hljs-comment"> * 去除其他位阶, 因此最坏时间复杂度为：O(n2)</span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>[] num)</span> </span>&#123;
    <span class="hljs-keyword">int</span> length = num.length;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; length; ++i) &#123;

        <span class="hljs-keyword">int</span> value = num[i];
        <span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>;

        <span class="hljs-comment">// 查找插入的位置</span>
        <span class="hljs-keyword">for</span> (; j &gt;= <span class="hljs-number">0</span>; --j) &#123;
            <span class="hljs-keyword">if</span> (num[j] &gt; value) &#123;
                num[j + <span class="hljs-number">1</span>] = num[j];
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-keyword">break</span>;
            &#125;
        &#125;

        <span class="hljs-comment">// 插入数据</span>
        num[j + <span class="hljs-number">1</span>] = value;
    &#125;
&#125;</code></pre>

<p><img src="/2023/09/12/%E7%AE%97%E6%B3%95%E7%AF%87/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.jpg" srcset="/img/loading.gif" alt></p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><pre><code class="hljs java"><span class="hljs-comment">/****</span>
<span class="hljs-comment"> * 最好：O(nlogn)</span>
<span class="hljs-comment"> * 最坏：O(n2)</span>
<span class="hljs-comment"> * 平均：O(nlogn)</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * 空间复杂度：</span>
<span class="hljs-comment"> *     最好：O(logn)</span>
<span class="hljs-comment"> *     最坏：O( n )</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * 原地，不稳定排序算法</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * 快排基于分治的思想，选择某一焦点，将数据分为三部分，以此类推一直当每小部分数据的节点都为1时完成排序</span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>[] array, <span class="hljs-keyword">int</span> left ,<span class="hljs-keyword">int</span> right)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(left &gt; right) &#123;
        <span class="hljs-keyword">return</span>;
    &#125;

    <span class="hljs-comment">// base中存放基准数</span>
    <span class="hljs-keyword">int</span> base = array[left];
    <span class="hljs-keyword">int</span> i = left, j = right;
    <span class="hljs-keyword">while</span>(i != j) &#123;
        <span class="hljs-comment">// 顺序很重要，先从右边开始往左找，直到找到比base值小的数</span>
        <span class="hljs-keyword">while</span>(array[j] &gt;= base &amp;&amp; i &lt; j) &#123;
            j--;
        &#125;

        <span class="hljs-comment">// 再从左往右边找，直到找到比base值大的数</span>
        <span class="hljs-keyword">while</span>(array[i] &lt;= base &amp;&amp; i &lt; j) &#123;
            i++;
        &#125;

        <span class="hljs-comment">// 上面的循环结束表示找到了位置或者(i&gt;=j)了，交换两个数在数组中的位置</span>
        <span class="hljs-keyword">if</span>(i &lt; j) &#123;
            <span class="hljs-keyword">int</span> tmp = array[i];
            array[i] = array[j];
            array[j] = tmp;
        &#125;
    &#125;

    <span class="hljs-comment">// 将基准数放到中间的位置（基准数归位）</span>
    array[left] = array[i];
    array[i] = base;

    <span class="hljs-comment">// 递归，继续向基准的左右两边执行和上面同样的操作</span>
    <span class="hljs-comment">// i的索引处为上面已确定好的基准值的位置，无需再处理</span>
    sort(array, left, i - <span class="hljs-number">1</span>);
    sort(array, i + <span class="hljs-number">1</span>, right);
&#125;</code></pre>

<p><img src="/2023/09/12/%E7%AE%97%E6%B3%95%E7%AF%87/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.jpg" srcset="/img/loading.gif" alt></p>
<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><pre><code class="hljs java"><span class="hljs-comment">/***</span>
<span class="hljs-comment">    * 桶排序，顾名思义，会用到“桶”，核心思想是将要排序的数据分到几个有序的桶里</span>
<span class="hljs-comment">    * 每个桶里的数据再单独进行排序, 桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了</span>
<span class="hljs-comment">    *</span>
<span class="hljs-comment">    * 缺点：桶排序的缺陷就在于如何合理的把数据分配到桶种</span>
<span class="hljs-comment">    *       当桶的个数数据反而大于数据总量的时候，更不适合</span>
<span class="hljs-comment">    *</span>
<span class="hljs-comment">    * 桶排序的适用：</span>
<span class="hljs-comment">    *     桶排序比较适合用在外部排序中。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中</span>
<span class="hljs-comment">    *     比如处理大文件里的数据，文件数据等等 (核心思想：分治)</span>
<span class="hljs-comment">    *</span>
<span class="hljs-comment">    * 计数排序 -&gt; 属于桶排序的一种特殊情况，例如  50万考生，根据分数进行排序</span>
<span class="hljs-comment">    *                                          100万用户，根据年龄进行排序</span>
<span class="hljs-comment">    */</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123; &#125;</code></pre>

<p><img src="/2023/09/12/%E7%AE%97%E6%B3%95%E7%AF%87/%E6%A1%B6%E6%8E%92%E5%BA%8F.jpg" srcset="/img/loading.gif" alt></p>
<h3 id="基于各种排序算法的场景思考题"><a href="#基于各种排序算法的场景思考题" class="headerlink" title="基于各种排序算法的场景思考题"></a>基于各种排序算法的场景思考题</h3><blockquote>
<ol>
<li>如何对50万考生根据成绩快速的进行排序</li>
<li>内存1G的电脑如何把10个文件各为1G的有序日志文件，按实际排序整合到一个新文件中</li>
<li>数据补全，比如考试成绩确定到小数点后一位，字母补全等等，如 a,ab,abc  可将其转化为<strong>ASCII</strong>，然后补0占位即可</li>
</ol>
<p>主要即结合排序算法中，递归，分治，分区，桶的思想进行思考</p>
<p>如题1，即可使用桶排序，成绩范围为0-900，901个桶即可</p>
<p>如题2，使用十个IO流，每次各自的一条数据，取出最小的，写入新文件中，一行一行的读，一行一行的写，内存占用很低</p>
</blockquote>
<h2 id="字符串匹配算法实践"><a href="#字符串匹配算法实践" class="headerlink" title="字符串匹配算法实践"></a>字符串匹配算法实践</h2><blockquote>
<p>具体的字符串匹配实践，如BF算法，RK算法，BM算法等等</p>
</blockquote>
<h3 id="BF-算法-（-暴力匹配算法-）"><a href="#BF-算法-（-暴力匹配算法-）" class="headerlink" title="BF 算法 （ 暴力匹配算法 ）"></a>BF 算法 （ 暴力匹配算法 ）</h3><blockquote>
<p> BF 算法的思想可以用一句话来概括，那就是，我们在主串中，检查起始位置分别是 0、1、2…n-m 且长度为 m 的 n-m+1 个子串，看有没有跟模式串匹配的 </p>
</blockquote>
<p><img src="/2023/09/12/%E7%AE%97%E6%B3%95%E7%AF%87/image-20191227095938513.png" srcset="/img/loading.gif" alt="image-20191227095938513"></p>
<pre><code class="hljs java"><span class="hljs-comment">/***</span>
<span class="hljs-comment"> * BF 算法思路</span>
<span class="hljs-comment"> * 暴力匹配算法 -&gt;</span>
<span class="hljs-comment"> * abcde</span>
<span class="hljs-comment"> *  bd</span>
<span class="hljs-comment"> *   bd</span>
<span class="hljs-comment"> *    bd...</span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bfHandle</span> <span class="hljs-params">(String content, String target)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (StringUtils.isBlank(content) || StringUtils.isBlank(target) || content.length() &lt; target.length()) &#123;
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    &#125;

    <span class="hljs-comment">// 模拟BF算法思路 省略全字符串匹配 -&gt; 用substring替代</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; content.length(); i++) &#123;
        String current = content.substring(i, target.length() + i);
        <span class="hljs-keyword">if</span> (current.length() &lt; target.length()) &#123;
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
        &#125;

        <span class="hljs-keyword">if</span> (target.equals(current)) &#123;
            <span class="hljs-keyword">return</span> i;
        &#125;
    &#125;

    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
&#125;

<span class="hljs-comment">/***</span>
<span class="hljs-comment"> * BF 算法思路优化</span>
<span class="hljs-comment"> * 1. 根据String 本质是char[]的特点，通过预先下标比对，进行优化</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * 2. 待做：优化一是拿到第一个char去对比,判断是否有对比的必要</span>
<span class="hljs-comment"> * 还可以继续优化 ---&gt; 像是判断鸡蛋在第几层会碎一样，除了从头到尾，还可以从尾到头，根据方案一的优化之后</span>
<span class="hljs-comment"> * 然后从最后一位开始对比，可以更快的确定是否是指定的字符</span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bfHandleImprove</span> <span class="hljs-params">(String content, String target)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (StringUtils.isBlank(content) || StringUtils.isBlank(target) || content.length() &lt; target.length()) &#123;
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    &#125;

    <span class="hljs-comment">// 预先存储第一个char</span>
    <span class="hljs-keyword">char</span> targetChar = target.charAt(<span class="hljs-number">0</span>);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; content.length(); i++) &#123;

        <span class="hljs-comment">// 优化BF算法，预先比对第一个字符即可</span>
        <span class="hljs-keyword">if</span> (content.charAt(i) != targetChar) &#123;
            <span class="hljs-keyword">continue</span>;
        &#125;

        String current = content.substring(i, target.length() + i);
        <span class="hljs-keyword">if</span> (current.length() &lt; target.length()) &#123;
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
        &#125;

        <span class="hljs-keyword">if</span> (target.equals(current)) &#123;
            <span class="hljs-keyword">return</span> i;
        &#125;
    &#125;

    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
&#125;</code></pre>



<h3 id="RK-算法"><a href="#RK-算法" class="headerlink" title="RK 算法"></a>RK 算法</h3><blockquote>
<p> RK算法通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个 子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配 （Hash冲突额外考虑）</p>
<p> 重点：如何更高的效率，通过一次遍历获取所有子串的哈希值</p>
<p> 策略：比如要处理的字符串只包含 a～z 这 26 个小写字母，那我们就用二十六进制来表示一个字符串。我们把 a～z 这 26 个字符映射到 0～25 这 26 个数字，a 就表示 0，b 就表示 1，以此类推，z 表示 25</p>
<p> <img src="/2023/09/12/%E7%AE%97%E6%B3%95%E7%AF%87/c47b092408ebfddfa96268037d53aa9c.jpg" srcset="/img/loading.gif" alt="img"> </p>
<p> 这样即可根据 index[i -1]的hash值推导处index[i]的hash值，这样即可高效的进行对比</p>
<p> 当产生hash冲突时，再对比字符串本身即可，而且如果需要匹配的字符串长度过长，还可以压缩长度，虽然这样会加大hash冲突，但是效率仍然可以大大提高</p>
</blockquote>
<h3 id="BM-算法-最高效算法"><a href="#BM-算法-最高效算法" class="headerlink" title="BM 算法 最高效算法"></a>BM 算法 最高效算法</h3><blockquote>
 <pre><code class="hljs 字符串匹配的算法耗时主要核心：如何减少单位字符串内匹配的次数```">
 **BM算法本质上其实就是在寻找如何跳过更多的字符串，达到仅进行更少的匹配次数的算法**

 因为真正的匹配计算中，不一定真的是一次跳过一个字节，而可能是很多个，因此BM算法实际在寻找如何跳过最多字节的规律，借助这种规律，在模式串与主串匹配的过程中，当模式串和主串某个字符不匹配的时候，能够跳过一些肯定不会匹配的情况，将模式串往后多滑动几位

 

  BM 算法包含两部分，分别是坏字符规则（bad character rule）和好后缀规则（good suffix shift )



####  坏字符规则 

BM 算法的匹配顺序比较特别，它是按照模式串下标从大到小的顺序，倒着匹配的 

![image-20191115144217875](算法篇&#x2F;image-20191115144217875.png)

我们从模式串的末尾往前倒着匹配，当我们发现某个字符没法匹配的时候

**我们把这个没有匹配的字符叫作坏字符（主串中的字符）** 

![image-20191115144249440](算法篇&#x2F;image-20191115144249440.png)

我们拿坏字符 c 在模式串中查找，发现模式串中并不存在这个字符，也就是说，字符 c 与模式串中的任何字符都不可能匹配。这个时候，我们可以将模式串直接往后滑动三位，将模式串滑动到 c 后面的位置，再从模式串的末尾字符开始比较 

![image-20191115144359955](算法篇&#x2F;image-20191115144359955.png)

这个时候，我们发现，模式串中最后一个字符 d，还是无法跟主串中的 a 匹配，这个时候，还能将模式串往后滑动三位吗？答案是不行的。因为这个时候，坏字符 a 在模式串中是存在的，模式串中下标是 0 的位置也是字符 a。这种情况下，我们可以将模式串往后滑动两位，让两个 a 上下对齐，然后再从模式串的末尾字符开始，重新匹配 

![image-20191115144554974](算法篇&#x2F;image-20191115144554974.png)

当发生不匹配的时候，我们把坏字符对应的模式串中的字符下标记作 si。如果坏字符在模式串中存在，我们把这个坏字符在模式串中的下标记作 xi。如果不存在，我们把 xi 记作 -1。那模式串往后移动的位数就等于 si-xi。（注意，我这里说的下标，都是字符在模式串的下标） 

![image-20191115145041597](算法篇&#x2F;image-20191115145041597.png)

不过，单纯使用坏字符规则还是不够的。因为根据 si-xi 计算出来的移动位数，有可能是负数，比如主串是 aaaaaaaaaaaaaaaa，模式串是 baaa。不但不会向后滑动模式串，还有可能倒退。所以，BM 算法还需要用到“好后缀规则” 



####  好后缀规则 

好后缀规则实际上跟坏字符规则的思路很类似。下面这幅图。当模式串滑动到图中的位置的时候，模式串和主串有 2 个字符是匹配的，倒数第 3 个字符发生了不匹配的情况 

![image-20191115151453142](算法篇&#x2F;image-20191115151453142.png)

滑动规则如下：

![image-20191115151629066](算法篇&#x2F;image-20191115151629066.png)

当好后缀匹配不到第二个的时候，如何处理呢？

![image-20191115151708875](算法篇&#x2F;image-20191115151708875.png)

即：以bc为标准点，向后移动，同时匹配字符串bc，及字符串c，这样可以保证不会过度滑动

&#96;&#96;&#96;java
&#x2F;&#x2F; 代码实现略 注意重复数据配置缓存 -&gt; 通过散列表实现，坏字符在模式串中下标位置的快速查询 </code></pre>
</blockquote>
<h3 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h3><blockquote>
<p>朴素算法（BF算法）：有点类似双指针，一个指针指字符串本身，一个指针指需要匹配的串<br>主指针：BBC ABCDAB ABCDABCDABDE<br>从指针：ABCDABD<br>每次都是主指针，从指针，一个字符串一个字符串的比对，如果不适配，则主指针从下一个开始元素开始，从指针归于开始位置，再进行匹配<br>（注意：主指针的每一次移动都进行了字符串的匹配）</p>
<p>KMP算法：在理解朴素算法的基础上，我们依然需要从头到尾移动主指针，但是为了提高性能，我们可以根据已有的对比的数据进行一定的处理，达到更少的匹配次数，即：</p>
<pre><code class="hljs 主指针依然从头指到目标位置，从指针依然从头指到尾部，但是一次比对失败后，利用已有的数据，让主指针尽可能多的移动，移动但不进行对比，到达比对位置起点后，同样的利用已知数据，从指针也并非从头开始进行对比，这样一来可以大大的提高字串查询效率```">
而KMP算法的核心即如何寻找到这种规律：求解著名的Next数组



### AC自动机  多模式串匹配算法

场景：过滤敏感词汇 -》

主串一个，模式串可能有上千个，此时我们需要的多模式串匹配的算法思路，否则单模式串的方式会损耗大量的性能



多模式串匹配算法：&#96;&#96;&#96;AC自动机 </code></pre>

<ul>
<li>将多个模式串构建成 Trie 树 </li>
<li>在 Trie 树上构建失败指针（相当于 KMP 中的失效函数 next 数组） </li>
</ul>
<p><img src="/2023/09/12/%E7%AE%97%E6%B3%95%E7%AF%87/image-20191127093626600.png" srcset="/img/loading.gif" alt="image-20191127093626600"></p>
<p>即 -》 abcf 匹配 敏感词汇：</p>
<ol>
<li>从a字符入口，匹配到b，c 节点匹配失败</li>
<li>指向bcd，c.next匹配再次失败，指向c</li>
<li>c匹配成功，因此c字符匹配成功，进行业务处理</li>
</ol>
</blockquote>
<h2 id="数据结构与算法实战算法实战篇"><a href="#数据结构与算法实战算法实战篇" class="headerlink" title="数据结构与算法实战算法实战篇"></a>数据结构与算法实战算法实战篇</h2><pre><code class="hljs 以下内容为开拓思路```">


### 朴素贝叶斯算法-过滤垃圾短信

- 基于黑名单过滤  ---  瑕疵：数据存储在手机导致数据量过于庞大，存储到服务器导致网络依赖
- 基于规则过滤 

&gt; 是否包含特殊单词，词语，号码是否符合正常规则，短信格式判断，内容判断等等
&gt;
&gt; 瑕疵：
&gt;
&gt; 1. 规则不好提取
&gt;
&gt; 2. 当规则被识别后，垃圾短信完全可以绕过扫描机制

- 基于概率的过滤器

&gt; 基础理论算法：朴素贝叶斯算法
&gt;
&gt; 简单来说就是计算，多个事件A,B 各自单独发生概率，以及互相影响情况下的发生概率
&gt;
&gt; 
&gt;
&gt; 这样一来即可进行综合的过滤，多管齐下：
&gt;
&gt; 1. 在网络情况下通过网络比对
&gt; 2. 网络状态不好时，通过复杂的规则比对 ---》 即对基于概率计算的方式进行更细颗粒的比对
&gt;
&gt; 比如判断号码是异常号码的前提下，且出现了反动词语，且出现了等等其他情况，综合计算朴素贝叶斯算法的结果，以此判断是否需要进行过滤，而不是简单的单一规则符合即可



### 位图-布隆过滤器

&gt; 为什么需要布隆过滤器？
&gt;
&gt; 布隆过滤器的作用可以通过哈希表进行替代，那为什么还需要布隆过滤器呢？因为它极端省内存
&gt;
&gt; 比如：
&gt;
&gt; 假设我们要爬取 10 亿个网页，为了判重，我们把这 10 亿网页链接存储在散列表中。大约需要多少内存？假设一个 URL 的平均长度是 64 字节，那单纯存储这 10 亿个 URL，需要大约 60GB 的内存空间
&gt;
&gt; 
&gt;
&gt; 布隆过滤器的基本原理：
&gt;
&gt; ![1577116880503](算法篇&#x2F;1577116880503.png)
&gt;
&gt; 我们再存储一个数，假设为100，计算出f1,f2,f3 为：0，1，4 与之对应的值都是1，那么布隆过滤器可以告诉我们100这个数可能已经存在，如果计算得2，3，5 则100这个数一定不存在，这即是其简单的原理，通过存储简单的0，1来大大的减少内存的消耗
&gt;
&gt; 
&gt;
&gt; 应用：比如Redis缓存使用时，我们为了避免缓存穿透，对一定不存在的值构造一个布隆过滤器，用以排除无效的查询



### 向量空间-实现一个简单的音乐推荐系统

&gt; 我们先不管这些高大上的名词，如果真的让你去实现一个音乐推荐系统，你会怎么做？
&gt;
&gt; - 通过找到口味相似的用户，把其他人的喜爱歌曲推荐给用户
&gt; - 通过用户喜欢的歌曲找到相似的歌曲进行推荐

#### 基于相似用户做推荐

只需要计算用户口味是否相似即可，那么如何计算用户的口味相似是否相似？

统计两个人共同喜欢的歌曲数量，再深度计算喜欢程度，我们可以思考一个量化统计的方案，比如：

![1577117602803](算法篇&#x2F;1577117602803.png)

我们可能得到这样一个结果：

![1577117647459](算法篇&#x2F;1577117647459.png)

&gt; 欧几里得距离（Euclidean distance）：欧几里得距离是用来计算两个向量之间的距离的

![1577117703785](算法篇&#x2F;1577117703785.png)



为什么要引入欧几里得距离？因为我们现在可以得到非常细化的分数，我们需要利用这些分数，就应该有一个明确的理论依据的计算方式，因此可以计算出各自的值为：

![1577117757400](算法篇&#x2F;1577117757400.png)

毫无疑问，我们和小明最相似，因此把小明喜欢的歌推荐给我们，可能是最适合的。



#### 基于相似歌曲做推荐

一样的思路，人工对歌曲进行标注其实非常带有主观色彩，因此用户的真实数据才是最好的记录，我们可以利用已有的数据进行合理的计算

![1577117916655](算法篇&#x2F;1577117916655.png)

计算欧几里得距离，差值越小，即可表明两首歌的风格越相似，当然，数据量小的话可能会出大问题，但是推荐系统就是这样，当数据量越来越大的时候，它就会越来越趋于准确





## 一、回溯法

&gt; 回溯法大多使用递归的技巧进行处理，详情如下：
&gt;
&gt; &#x2F;***
&gt;
&gt;  * 递归需要满足的三个条件
&gt;  * 1. 一个问题的解可以分解为几个子问题的解
&gt;  * 2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
&gt;  * 3. 存在递归终止条件
&gt;   * 总结：写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件， 最后将递推公式和终止条件翻译成代码
&gt; *&#x2F;



&#96;&#96;&#96; 算法实战：走台阶问题</code></pre>

<pre><code class="hljs java"><span class="hljs-comment">/***</span>
<span class="hljs-comment"> * 走台阶: 1 2 3 5 8 13</span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">goStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (num == <span class="hljs-number">1</span> || num == <span class="hljs-number">2</span>) &#123;
        <span class="hljs-keyword">return</span> num;
    &#125;
    <span class="hljs-keyword">return</span> goStairs(num - <span class="hljs-number">1</span>) + goStairs(num - <span class="hljs-number">2</span>);
&#125;


<span class="hljs-comment">/***</span>
<span class="hljs-comment"> * 优化走台阶: 1 2 3 5 8 13</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">goStairsMore</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (num == <span class="hljs-number">1</span> || num == <span class="hljs-number">2</span>) &#123;
        <span class="hljs-keyword">return</span> num;
    &#125;

    <span class="hljs-keyword">if</span> (!map.containsKey(num)) &#123;
        <span class="hljs-keyword">int</span> value = goStairsMore(num - <span class="hljs-number">1</span>) + goStairsMore(num - <span class="hljs-number">2</span>);
        map.put(num, value);
        <span class="hljs-keyword">return</span> value;
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-keyword">return</span> map.get(num);
    &#125;
&#125;</code></pre>



<pre><code class="hljs 算法实战：倒序输出一个正整数```">
&#96;&#96;&#96;java
&#x2F;***
 * 倒序输出一个正整数
 *&#x2F;
private static void printOrderNum(int num) &#123;
    if (num &gt;&#x3D; 10) &#123;
        System.out.print(num % 10);
        printOrderNum(num &#x2F;&#x3D; 10);
    &#125; else &#123;
        System.out.print(num);
    &#125;
&#125;</code></pre>



<pre><code class="hljs 算法实战：角谷定理```">
&#96;&#96;&#96;java
&#x2F;***
 * 角谷定理。输入一个自然数，若为偶数，则把它除以2，若为奇数，则把它乘以3加1。经过如此有限次运算后，总可以得到自然数值1。
 * 求经过多少次可得到自然数1
 *&#x2F;
private static int jiaoGu(int number, int num) &#123;
    num++;
    if (number &#x3D;&#x3D; 1) &#123;
        return num;
    &#125;
    int value &#x3D; number % 2 &#x3D;&#x3D; 0 ? number &#x2F; 2 : number * 3 + 1;
    return jiaoGu(value, num);
&#125;</code></pre>



<pre><code class="hljs 算法实战：验证指定的字符串是否为反转字符```">
&#96;&#96;&#96;java
&#x2F;***
 * 编写一个方法用于验证指定的字符串是否为反转字符，返回true和false
 * 请用递归算法实现
 *&#x2F;
private static boolean isReturnString(String string) &#123;
    char head &#x3D; string.charAt(0);
    char foot &#x3D; string.charAt(string.length() - 1);

    if (head !&#x3D; foot) &#123;
        return false;
    &#125;

    if (string.length() &#x3D;&#x3D; 1 || string.length() &#x3D;&#x3D; 2) &#123;
        return true;
    &#125;
    return isReturnString(string.substring(1, string.length() - 1));
&#125;</code></pre>



<pre><code class="hljs 算法实战：一个射击运动员打靶,靶一共有10环,连开10枪打中90环的可能性有多少种```">
&#96;&#96;&#96;java
&#x2F;***
 * 一个射击运动员打靶,靶一共有10环,连开10枪打中90环的可能性有多少种
 *&#x2F;
private static int   sum &#x3D; 0;
private static void  getNum(int score, int num) &#123;
    if (score &lt; 0 || score &gt; num * 10) &#123;
        return;
    &#125;

    if (num &#x3D;&#x3D; 0) &#123;
        sum++;
    &#125;

    for (int i &#x3D; 0; i &lt; 11; i++) &#123;
        getNum(score - i, num - 1);
    &#125;
&#125;</code></pre>



<h2 id="二、二分查找"><a href="#二、二分查找" class="headerlink" title="二、二分查找"></a>二、二分查找</h2><blockquote>
<p>注意事项：</p>
<ol>
<li>二分查找必须依然顺序表结构</li>
<li>针对有序数据</li>
<li>数据量太小不适合使用二分查找</li>
<li>数据量太大不适合使用二分查找 -&gt; 因为数据需要连续的存储空间，因此数据量非常大的情况，空间占用也非常高</li>
</ol>
</blockquote>
<pre><code class="hljs 简单二分查找```">
&#96;&#96;&#96;java
&#x2F;**
 * 二分法查找 | 要求为有序数组
 * @param array  数组
 * @param num    元素
 *&#x2F;
private static boolean search (int[] array, int num) &#123;
    if (array.length &#x3D;&#x3D; 0) &#123;
        return false;
    &#125;

    int left  &#x3D; 0;
    int right &#x3D; array.length - 1;
    while (left &lt;&#x3D; right) &#123;
        int mid &#x3D; (left + right) &#x2F; 2;
        if (array[mid] &#x3D;&#x3D; num) &#123;
            return true;
        &#125; else if (array[mid] &gt; num) &#123;
            right &#x3D; mid;
        &#125; else &#123;
            &#x2F;&#x2F; 因为mid 肯定不是，因此可以多 + 1
            left &#x3D; mid + 1;
        &#125;
    &#125;
    return false;
&#125;</code></pre>



<pre><code class="hljs 二分查找">
&gt; 1. 查找第一个值等于给定值的元素
&gt; 2. 找到最后一个等于给定值的元素
&gt; 3. 查找第一个大于等于给定值的元素
&gt; 4. 查找最后一个小于等于给定值的元素
&gt;
&gt; 即给定的有序集合中包含重复的元素，如何抉择？



&#96;&#96;&#96;查找第一个值等于给定值的元素</code></pre>

<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 有序重复元素的数据, 寻找第一个符合要求的元素下标</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * 关键在于 符合要求时候的判断，是否前面的一个元素不符合要求</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param</span> array  数组</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param</span> value  元素</span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">searchFirstValue</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>[] array, <span class="hljs-keyword">int</span> value)</span> </span>&#123;
    <span class="hljs-keyword">int</span> left  = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> right = array.length - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;
        <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;
        <span class="hljs-keyword">if</span> (array[mid] &gt; value) &#123;
            right = mid - <span class="hljs-number">1</span>;
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (array[mid] &lt; value) &#123;
            left = mid + <span class="hljs-number">1</span>;
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">if</span> ((mid == <span class="hljs-number">0</span>) || (array[mid - <span class="hljs-number">1</span>] != value)) <span class="hljs-keyword">return</span> mid;
            <span class="hljs-keyword">else</span> left = mid - <span class="hljs-number">1</span>;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
&#125;</code></pre>



<pre><code class="hljs 查找最后一个值等于给定值的元素```">
&#96;&#96;&#96;java
public int bsearch(int[] a, int n, int value) &#123;
    int low &#x3D; 0;
    int high &#x3D; n - 1;
    while (low &lt;&#x3D; high) &#123;
        int mid &#x3D;  low + ((high - low) &gt;&gt; 1);
        if (a[mid] &gt; value) &#123;
            high &#x3D; mid - 1;
        &#125; else if (a[mid] &lt; value) &#123;
            low &#x3D; mid + 1;
        &#125; else &#123;
            if ((mid &#x3D;&#x3D; n - 1) || (a[mid + 1] !&#x3D; value)) return mid;
            else low &#x3D; mid + 1;
        &#125;
    &#125;
    return -1;
&#125;</code></pre>



<pre><code class="hljs 查找第一个大于等于给定值的元素```">
&#96;&#96;&#96;java

public int bsearch(int[] a, int n, int value) &#123;
    int low &#x3D; 0;
    int high &#x3D; n - 1;
    while (low &lt;&#x3D; high) &#123;
        int mid &#x3D;  low + ((high - low) &gt;&gt; 1);
        if (a[mid] &gt;&#x3D; value) &#123;
            if ((mid &#x3D;&#x3D; 0) || (a[mid - 1] &lt; value)) return mid;
            else high &#x3D; mid - 1;
        &#125; else &#123;
            low &#x3D; mid + 1;
        &#125;
    &#125;
    return -1;
&#125;</code></pre>



<pre><code class="hljs 查找最后一个小于等于给定值的元素```">
&#96;&#96;&#96;java
public int bsearch7(int[] a, int n, int value) &#123;
    int low &#x3D; 0;
    int high &#x3D; n - 1;
    while (low &lt;&#x3D; high) &#123;
        int mid &#x3D;  low + ((high - low) &gt;&gt; 1);
        if (a[mid] &gt; value) &#123;
            high &#x3D; mid - 1;
        &#125; else &#123;
            if ((mid &#x3D;&#x3D; n - 1) || (a[mid + 1] &gt; value)) return mid;
            else low &#x3D; mid + 1;
        &#125;
    &#125;
    return -1;
&#125;</code></pre>





<h2 id="三、递推法"><a href="#三、递推法" class="headerlink" title="三、递推法"></a>三、递推法</h2><blockquote>
<p>概念：递推算法是一种简单的算法，即通过已知条件，利用特定关系得出中间推论，直至得到结果的算法。递推算法分为顺推和逆推两种。</p>
<p>递推算法适合有着明显规律的场合</p>
</blockquote>
<pre><code class="hljs 兔子生崽的问题```">
&#96;&#96;&#96;java
如果有两个月大的兔子以后每个月都可以产一对小兔子，而一对小兔子出生两个月后可以在生小兔子，也就是1月份出生，3月份才可以产崽子。那么假定一年内没有发生死亡事件，那么现在有一对小兔子一年后共有多少对兔子。
案例分析：
1月 1对兔子
2月 1对兔子
3月 2对兔子 一对成熟兔子
4月 3对兔子 
5月 5对兔子 两对成熟兔子
6月 8对兔子 三对成熟兔子
。。。。。。
规律：前两个月都是一对兔子，以后每个月的兔子的对数是前两个月的总和
除1,2月份的计算公式：n月  Fn &#x3D; (Fn-1)+(Fn-2)

public class Recurrence &#123;
    public int recurrence(int months)&#123;
        int a &#x3D; 1;&#x2F;&#x2F;第1个月
        int b &#x3D; 1;&#x2F;&#x2F;第2个月
        int c &#x3D; 1;&#x2F;&#x2F;第n个月
        while (months &gt; 2)&#123;
            c &#x3D; a + b;
            a &#x3D; b;
            b &#x3D; c;
            months--;
        &#125;
        return c;
	&#125;
&#125;</code></pre>



<pre><code class="hljs 爬楼梯```">
&#96;&#96;&#96;java
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
注意：给定 n 是一个正整数。
案例分析
一层 1
两层 2
三层 3
四层 5
五层 8
......
规律分析：与兔子题不同的一点在于第一个数和第二个数
除1,2层的计算公式：n层  Fn &#x3D; (Fn-1)+(Fn-2)
public class upStairs&#123;
	public int climbStairs(int n) &#123;
        if (n &#x3D;&#x3D; 0) return 0;
        int last &#x3D; 0;
        int newLast &#x3D; 1;
        int res &#x3D; last + newLast;
        if (n &#x3D;&#x3D; 1) return res;
        for (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;
            last &#x3D; newLast;
            newLast &#x3D; res;
            res &#x3D; last + newLast;
        &#125;
        return res;
    &#125;
&#125;</code></pre>



<h2 id="四、贪心算法"><a href="#四、贪心算法" class="headerlink" title="四、贪心算法"></a>四、贪心算法</h2><blockquote>
<p>贪心算法在求解某个问题时，总是做出眼前的最大利益，也就是说只顾眼前不顾大局，所以他是局部最优解</p>
<p>贪心算法不是对所有问题都能得到整体最好的解决办法，关键是<strong>贪心策略</strong>的选择，选择的贪心策略必须具备无后效性，即某个状态以前的状态不会影响以后的状态，只与当前状态有关</p>
<p> 贪心算法两个重要的特点是：<br>（1）贪心策略<br>（2）通过局部最优解能够得到全局最优解 </p>
</blockquote>
<pre><code class="hljs 加油站```">
</code></pre>
<p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p>
<p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p>
<p>说明:<br>    如果题目有解，该答案即为唯一答案。<br>    输入数组均为非空数组，且长度相同。<br>    输入数组中的元素均为非负数。</p>
<p>输入:<br>gas  = [1,2,3,4,5]<br>cost = [3,4,5,1,2]</p>
<p>输出: 3</p>
<p>解释:<br>从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油<br>开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油<br>开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油<br>开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油<br>开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油<br>开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。<br>因此，3 可为起始索引。</p>
<pre><code class="hljs angelscript">
```java
<span class="hljs-comment">// 如果A站不能到B站，那么A，B之间到任何一个站都不能到B站，（B站是A站第一个不能到的站）</span>
<span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> canCompleteCircuit(<span class="hljs-built_in">int</span>[] gas, <span class="hljs-built_in">int</span>[] cost) &#123;
    <span class="hljs-built_in">int</span> n = gas.length;
    <span class="hljs-built_in">int</span> total_tank = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">int</span> curr_tank = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">int</span> starting_station = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;
        total_tank += gas[i] - cost[i];
        curr_tank += gas[i] - cost[i];
        <span class="hljs-keyword">if</span> (curr_tank &lt; <span class="hljs-number">0</span>) &#123;
            starting_station = i + <span class="hljs-number">1</span>;
            curr_tank = <span class="hljs-number">0</span>;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> total_tank &gt;= <span class="hljs-number">0</span> ? starting_station : <span class="hljs-number">-1</span>;
&#125;</code></pre>

<h2 id="五、分治法"><a href="#五、分治法" class="headerlink" title="五、分治法"></a>五、分治法</h2><blockquote>
<pre><code class="hljs 分治法的精髓：```">分--将问题分解为规模更小的子问题；
治--将这些规模更小的子问题逐个击破；
合--将已解决的子问题合并，最终得出“母”问题的解；



&#96;&#96;&#96;最大子序和 </code></pre>
</blockquote>
<pre><code class="hljs java"><span class="hljs-comment">// 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</span>

<span class="hljs-comment">// 输入: [-2,1,-3,4,-1,2,1,-5,4],</span>
<span class="hljs-comment">// 输出: 6</span>
<span class="hljs-comment">// 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;
        <span class="hljs-keyword">int</span> len = nums.length;
        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        &#125;
        <span class="hljs-keyword">return</span> maxSubArraySum(nums, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxCrossingSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> right)</span> </span>&#123;
        <span class="hljs-comment">// 一定会包含 nums[mid] 这个元素</span>
        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> leftSum = Integer.MIN_VALUE;
        <span class="hljs-comment">// 左半边包含 nums[mid] 元素，最多可以到什么地方</span>
        <span class="hljs-comment">// 走到最边界，看看最值是什么</span>
        <span class="hljs-comment">// 计算以 mid 结尾的最大的子数组的和</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = mid; i &gt;= left; i--) &#123;
            sum += nums[i];
            <span class="hljs-keyword">if</span> (sum &gt; leftSum) &#123;
                leftSum = sum;
            &#125;
        &#125;
        sum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> rightSum = Integer.MIN_VALUE;
        <span class="hljs-comment">// 右半边不包含 nums[mid] 元素，最多可以到什么地方</span>
        <span class="hljs-comment">// 计算以 mid+1 开始的最大的子数组的和</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = mid + <span class="hljs-number">1</span>; i &lt;= right; i++) &#123;
            sum += nums[i];
            <span class="hljs-keyword">if</span> (sum &gt; rightSum) &#123;
                rightSum = sum;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> leftSum + rightSum;

    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArraySum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (left == right) &#123;
            <span class="hljs-keyword">return</span> nums[left];
        &#125;
        <span class="hljs-keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="hljs-number">1</span>;
        <span class="hljs-keyword">return</span> max3(maxSubArraySum(nums, left, mid),
                maxSubArraySum(nums, mid + <span class="hljs-number">1</span>, right),
                maxCrossingSum(nums, left, mid, right));
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">max3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1, <span class="hljs-keyword">int</span> num2, <span class="hljs-keyword">int</span> num3)</span> </span>&#123;
        <span class="hljs-keyword">return</span> Math.max(num1, Math.max(num2, num3));
    &#125;
&#125;</code></pre>



<pre><code class="hljs 搜索二位矩阵```">
&#96;&#96;&#96;java
编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：
	每行的元素从左到右升序排列
	每列的元素从上到下升序排列

给定矩阵
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
给定 target &#x3D; 5，返回 true
给定 target &#x3D; 20，返回 false

public class Solution &#123;
    public boolean searchMatrix(int[][] matrix, int target) &#123;
        int row &#x3D; matrix.length-1;
        int col &#x3D; 0;

        while (row &gt;&#x3D; 0 &amp;&amp; col &lt; matrix[0].length) &#123;
            if (matrix[row][col] &gt; target) &#123;
                row--;
            &#125; else if (matrix[row][col] &lt; target) &#123;
                col++;
            &#125; else &#123; 
                &#x2F;&#x2F;找到了target
                return true;
            &#125;
        &#125;

        return false;
    &#125;
&#125;</code></pre>

<h2 id="六、动态规划法"><a href="#六、动态规划法" class="headerlink" title="六、动态规划法"></a>六、动态规划法</h2><blockquote>
<p>A * “1+1+1+1+1+1+1+1 =？” *</p>
<p>A : “上面等式的值是多少”<br>B : <em>计算</em> “8!”</p>
<p>A <em>在上面等式的左边写上 “1+” *<br>A : “此时等式的值为多少”<br>B : *quickly</em> “9!”<br>A : “你怎么这么快就知道答案了”<br>A : “只要在8的基础上加1就行了”<br>A : “所以你不用重新计算因为你记住了第一个等式的值为8!动态规划算法也可以说是 ‘记住求过的解来节省时间’”</p>
</blockquote>
<pre><code class="hljs 动态规划实战-切钢条```">
![image-20191227092802025](算法篇&#x2F;image-20191227092802025.png)

&gt; 给一段长度小于等于10的钢条，如何切割效益最大？
&gt;
&gt; &#96;&#96;&#96;java
&gt; &#x2F;&#x2F; 已知条件
&gt; private static int[] arr &#x3D; new int[11];
&gt; static &#123;
&gt;     arr[0] &#x3D; 0;
&gt;     arr[1] &#x3D; 1;
&gt;     arr[2] &#x3D; 5;
&gt;     arr[3] &#x3D; 8;
&gt;     arr[4] &#x3D; 9;
&gt;     arr[5] &#x3D; 10;
&gt;     arr[6] &#x3D; 17;
&gt;     arr[7] &#x3D; 17;
&gt;     arr[8] &#x3D; 20;
&gt;     arr[9] &#x3D; 24;
&gt;     arr[10] &#x3D; 30;
&gt; &#125;
&gt;</code></pre>



<p>我们通过普通递归，推导备忘录算法，再推导动态规划，来看看其演进的过程：</p>
<pre><code class="hljs java"><span class="hljs-comment">/***</span>
<span class="hljs-comment"> * 递归方法</span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cut</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> length)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (length == <span class="hljs-number">0</span>) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    &#125;

    <span class="hljs-keyword">int</span> result = Integer.MIN_VALUE;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= length; i++) &#123;
        result = Math.max(result, arr[i] + cut(arr, length - i));
    &#125;
    <span class="hljs-keyword">return</span> result;
&#125;

递归算法的反思：
    例如我们在计算<span class="hljs-number">8</span>的时候，分解为<span class="hljs-number">3</span>，<span class="hljs-number">5</span> -》 <span class="hljs-number">1</span>，<span class="hljs-number">7</span>
    分解为<span class="hljs-number">3</span>，<span class="hljs-number">5</span>的时候又把<span class="hljs-number">5</span>进行分解
    分解为<span class="hljs-number">1</span>，<span class="hljs-number">7</span>的时候又可以把<span class="hljs-number">7</span>分解为<span class="hljs-number">2</span>，<span class="hljs-number">5</span>，又对<span class="hljs-number">5</span>进行了分解
    
    简单来说，如果打印此纪录：System.out.println(length - <span class="hljs-number">1</span>);
    则可以发现有非常多的重复计算</code></pre>

<p>计算思路演示图，<code>图和题目不符</code>，但是思想是一致的，即递归算法是<code>自上而下的</code>穷举遍历，很多计算重复了</p>
<p><img src="/2023/09/12/%E7%AE%97%E6%B3%95%E7%AF%87/image-20191227093808655.png" srcset="/img/loading.gif" alt="image-20191227093808655"></p>
<pre><code class="hljs 递归法的演进">
&#96;&#96;&#96;java
&#x2F;***
 * 备忘录算法
 *&#x2F;
private static Map&lt;Integer, Integer&gt; map &#x3D; new HashMap&lt;&gt;();
private static int cutMap (int[] arr, int length) &#123;
    if (length &#x3D;&#x3D; 0) &#123;
        return 0;
    &#125;

    int result &#x3D; Integer.MIN_VALUE;
    for (int i &#x3D; 1; i &lt;&#x3D; length; i++) &#123;
        if (map.containsKey(length - i)) &#123;
            result &#x3D; Math.max(result, arr[i] + map.get(length - i));
        &#125; else &#123;
            int curr &#x3D; cutMap(arr, length - i);
            map.put(length - i, curr);
            result &#x3D; Math.max(result, arr[i] + curr);
        &#125;
    &#125;
    return result;
&#125;

备忘录算法其实就做了一件事，杜绝重复计算，以此极大的提高效率，而且备忘录算法非常简单，能够写出递归
    即可非常自然的实现备忘录</code></pre>



<pre><code class="hljs 备忘录算法的演进">
&gt; 上文说到，动态规划的实质是&#96;&#96;&#96;记住求过的解来节省时间&#96;&#96;&#96;，这个目的其实备忘录算法已经实现了，只不过备忘录算法仍然有递归的成分在，难免性能较低，能否更加直观的计算呢？

还是上文的思路图，如果我们&#96;&#96;&#96;自下而上&#96;&#96;&#96;去进行计算，是不是可以更加直观的利用求过的解来解决问题？

![image-20191227094354358](算法篇&#x2F;image-20191227094354358.png)

&#96;&#96;&#96;java
&#x2F;**
 * 动态规划
 *&#x2F;
private static int dynamicHandle (int[] arr, int length) &#123;
    &#x2F;&#x2F; result数组保存已经求过的解
    int[] result &#x3D; new int[length + 1];
    for (int i &#x3D; 1; i &lt;&#x3D; length; i++) &#123;
        int num &#x3D; Integer.MIN_VALUE;
        for (int j &#x3D; 1; j &lt;&#x3D; i; j++) &#123;
            num &#x3D; Math.max(num, arr[j] + result[i - j]);
        &#125;
        &#x2F;&#x2F; 保存求过的解
        result[i] &#x3D; num;
    &#125;
    return result[length];
&#125;</code></pre>



<pre><code class="hljs 动态规划实战```">
&#96;&#96;&#96;java
&#x2F;&#x2F; 走楼梯问题,一次只能走一步或者走两步，问走n楼,一共多少种走法

&#x2F;***
 * 递归算法
 *&#x2F;
private static int goFlow (int num) &#123;
    if (num &lt; 3) &#123;
        return num;
    &#125;
    return goFlow(num - 1) + goFlow(num - 2);
&#125;

&#x2F;***
 * 备忘录算法-存取值
 *&#x2F;
private static int goFlowByMap (int num, HashMap&lt;Integer,Integer&gt; map) &#123;
    if (num &lt; 3) &#123;
        return num;
    &#125;

    if (map &#x3D;&#x3D; null) &#123;
        map &#x3D; new HashMap&lt;&gt;();
    &#125;

    if (map.containsKey(num)) &#123;
        return map.get(num);
    &#125; else &#123;
        int value &#x3D; goFlowByMap(num - 1, map) + goFlowByMap(num -2, map);
        map.put(num, value);
        return value;
    &#125;
&#125;

&#x2F;***
 * 动态规划算法 - 关键点有两个，一个是找出一个数据变化的i，n关系，另一个是用代码实现这种i，n关系
 * 如本题中的关键逻辑在于: d(i) &#x3D; d(i-1) + d(i-2),所以动态的存取这两个值即可
 * 自下向上
 *&#x2F;
private static int goFlowByDP (int num) &#123;
    if (num &lt; 3) &#123;
        return num;
    &#125;

    int a &#x3D; 1;
    int b &#x3D; 2;
    int temp &#x3D; 0;

    for (int i &#x3D; 3; i &lt;&#x3D; num; i++) &#123;
        temp &#x3D; a + b;
        a &#x3D; b;
        b &#x3D; temp;
    &#125;

    return temp;
&#125;</code></pre>
            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95%E7%AF%87/">数据结构及算法篇</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E7%AE%97%E6%B3%95%E7%AF%87/">算法篇</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2023/09/12/%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98%E7%AF%87/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">算法实战篇</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2023/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/">
                        <span class="hidden-mobile">数据结构篇</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
              <!-- Comments -->
              <div class="comments" id="comments">
                
                
  <div id="vcomments"></div>
  <script type="text/javascript">
    function loadValine() {
      addScript('https://cdn.staticfile.org/valine/1.4.14/Valine.min.js', function () {
        new Valine({
          el: "#vcomments",
          app_id: "6uM0Qq25J6ydLXiYqdyxxiMC-gzGzoHsz",
          app_key: "oc2dzMKP9uJXsnOOhIxAr94f",
          placeholder: "说点什么吧~",
          path: window.location.pathname,
          avatar: "retro",
          meta: ["nick","mail","link"],
          pageSize: "10",
          lang: "zh-CN",
          highlight: true,
          recordIP: false,
          serverURLs: "",
        });
      });
    }
    createObserver(loadValine, 'vcomments');
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://valine.js.org" target="_blank" rel="nofollow noopener noopener">comments
      powered by Valine.</a></noscript>


              </div>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
	  <i class="iconfont icon-love"></i>
	  <a href="https://cloud.tencent.com/product/wh?from=12331" target="_blank" rel="nofollow noopener">
        <span>Hosted BY 云开发 Cloudbase</span></a>
    </div>
    

    
  <!-- 备案信息 -->
  <div class="beian">
    <a href="http://beian.miit.gov.cn/" target="_blank"
       rel="nofollow noopener">鄂ICP备18012070号</a>
    
  </div>


    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 6,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "算法篇&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>














  <script  src="https://cdn.staticfile.org/mermaid/8.5.0/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>







</body>
</html>
