<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>不要做迂腐的好人：用真诚与博弈好好生活</title>
    <link href="/2023/09/14/%E4%B8%8D%E8%A6%81%E5%81%9A%E8%BF%82%E8%85%90%E7%9A%84%E5%A5%BD%E4%BA%BA%EF%BC%9A%E7%94%A8%E7%9C%9F%E8%AF%9A%E4%B8%8E%E5%8D%9A%E5%BC%88%E5%A5%BD%E5%A5%BD%E7%94%9F%E6%B4%BB/"/>
    <url>/2023/09/14/%E4%B8%8D%E8%A6%81%E5%81%9A%E8%BF%82%E8%85%90%E7%9A%84%E5%A5%BD%E4%BA%BA%EF%BC%9A%E7%94%A8%E7%9C%9F%E8%AF%9A%E4%B8%8E%E5%8D%9A%E5%BC%88%E5%A5%BD%E5%A5%BD%E7%94%9F%E6%B4%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="不要做迂腐的好人：用真诚与博弈好好生活"><a href="#不要做迂腐的好人：用真诚与博弈好好生活" class="headerlink" title="不要做迂腐的好人：用真诚与博弈好好生活"></a>不要做迂腐的好人：用真诚与博弈好好生活</h1><p>标签： #Thinking&#x2F;知与行 #Share #博弈论 #处世之道</p><br><h2 id="痛苦与不理解"><a href="#痛苦与不理解" class="headerlink" title="痛苦与不理解"></a>痛苦与不理解</h2><p>Scene one：</p><p>在一次读书会里遇到这样一个事情，有个女生自信满满的询问：<strong>怎么样才能实现跨级晋升？</strong></p><p>在场的人可能心里都有数，但都没有直接回复，然后她说：主动和老板去沟通，问老板想要跨级晋升，需要实现怎样的目标和达到怎样的能力。我心里突然间响起了两个声音，第一个声音是说：为什么她能不顾公平破坏惯例去争取自己想要的。第二个声音是说：其实我也想这样勇敢且清晰的表达诉求。</p><p>Scene two：</p><p>老黄牛的痛楚：努努力力本本分分的工作，但可能工作内容越来越多，甚至还会被PUA。</p><p>优柔寡断、心怀疑虑、每天活得特别累，被自己的思绪困扰。</p><p>Scene three：</p><p>在看房阶段天然的抵触中介，在找工作时天然的不信任HR，在工作中排斥与领导沟通，总担心暴露自己的想法。</p><br><h2 id="《坏世界研究》-搞政治是国家间的生存方式"><a href="#《坏世界研究》-搞政治是国家间的生存方式" class="headerlink" title="《坏世界研究》 -  搞政治是国家间的生存方式"></a>《坏世界研究》 -  搞政治是国家间的生存方式</h2><p><strong>第一个问题：什么样的世界算是一个好世界？</strong></p><p>这个是政治哲学研究的最高问题：什么样的制度，什么样的体制，什么样的政治框架是好政治。</p><p>所以本书就对比和分析了东西方自古以来的各种政治哲学理论，从古典到现代对于最佳政治体制的论述，作者本人最推崇的是中国周朝的</p><p>天下体制，它的特点就是化敌为友，扩大边界，是一种世界政治。</p><p>但问题就在于，无论多么优越的体制都不是无懈可击的，人总有办法把一个好世界变成坏世界，所以就不得不面对第二个问题。</p><p><strong>第二个问题：人如何在一个坏世界里生存？</strong></p><p>为什么说我们的世界是一个坏世界？或者说什么样的世界算是一个坏世界？作者观点是：一个世界只要满足两个条件，就可能成为一个坏世界，也因此一定会成为一个坏世界。</p><p>一个是资源稀缺，另外一个就是人性自私。资源稀缺就是我们一共只有这么点东西。人性自私就是所有人都想把最好的留给自己，趋利避害，想占便宜，还不想负责任。</p><p>所以如果我们把最坏的情况都考虑进去的话，那这个世界一定是一个坏世界。</p><p>而对付一个坏世界的唯一手段就是搞政治，不管是国家之间、城邦之间，还是个人之间的政治，因为所有人都想为自己谋取利益，而为自</p><p>己谋取利益的唯一障碍就是其他人，其他人得同意你才能得到你想得到的东西。</p><p>每个人想得到的东西可能是不一样的，但是我们都想得到点东西，这一点是一样的，对所有人都是一样的，</p><br><h2 id="社会的规训与桎梏"><a href="#社会的规训与桎梏" class="headerlink" title="社会的规训与桎梏"></a>社会的规训与桎梏</h2><p>社会的规训通过教育，影视传媒，社会模仿逐渐的深入每个人的心中，在大多数成年人心中，都有一个列表，这其中就储存了社会文</p><p>化的规训条款，人在大多数情况下，都不会突破这些条款。</p><p>我发自内心的希望自己是一个良善之人，但这并不代表我需要时刻为他人着想、并不代表我需要压抑自己的情绪与诉求、并不代表我需要</p><p>完全按照社会期待的最容易受到剥削之人的形象去成长。</p><br><h2 id="《合作的进化》-用真诚与博弈好好生活"><a href="#《合作的进化》-用真诚与博弈好好生活" class="headerlink" title="《合作的进化》 - 用真诚与博弈好好生活"></a>《合作的进化》 - 用真诚与博弈好好生活</h2><p>思考一个问题：<strong>在与他人的持续交往中，人什么时候应该合作，什么时候只需为自己着想?</strong></p><p>推荐一款网页游戏：<a href="https://dccxi.com/trust/">https://dccxi.com/trust/</a></p><p>可以从游戏中感受一下本书的核心观点，具有统计与数学价值的科学观点。</p><p>在这个世界里，没有人想做坏人，所有人都是他自己那条故事线上的好人。</p><p>不同的教育、经历与工作给予了他们不一样的性格和处事方式，每个人都是英雄，都是自己的英雄。但他们可能做出伤害别人的事情，可</p><p>能会做出让你觉得匪夷所思的事情，所以你只看到自己那条故事线是不够的。你得看到别人的故事线，你得以别人的视角看到别人的故事</p><p>线，你得看到所有的这些故事线是如何穿插交错的，看到这个游戏是如何布局的。</p><br><p>而在限定场景下，几方采取的策略互相影响，为了各自的利益而做出选择的过程，就是博弈。</p><p>如果你尝试玩了上文的游戏，你会发现在持续性交往关系中 <strong>”一报还一报“</strong> 可能是最佳的理想策略。</p><p>”以德报怨“ 的原文是：</p><blockquote><p>《论语 宪问》：“或曰：‘以德报怨何如？’子曰：‘何以报德？以直报怨，以德报德。’”</p></blockquote><p>所以，停止做一个压抑自我情绪以满足他人与社会期望的迂腐好人。</p><p>我们要认识到：</p><ol><li>Scene one 中，主动与Ld沟通，表达自身诉求并不是破坏公平的表现，而是明确工作重点与方向，是值得学习的事情。</li><li>Scene two 中，面对痛苦的事情，自我反思后努力修正，如果是他人的过错，也需要明确的 “报答” 回去，但采取的方式可以是聪明的。</li><li>Scene three中，中介、猎头和HR与我们都是博弈与合作关系，在谋求各自利益最大值时不一定是纯粹的零和博弈，多沟通多展示自己的能力，引导对方与你进行合作，可能会有更多意想不到的收获。</li></ol><p>为什么这个简单的策略可以受到感性与理性的推崇？因为：</p><ol><li>它是善良的，是促进合作的：不首先背叛（对抗）；如何对方善良则原来过往的背叛（对抗）；</li><li>它对于恶（背叛与对抗）是有惩罚作用的。</li></ol><p>愿大家都能成为心之所向的自己，与善良同行，  与背叛相抗。</p><p>以上</p>]]></content>
    
    
    <categories>
      
      <category>articles</category>
      
    </categories>
    
    
    <tags>
      
      <tag>不要做迂腐的好人：用真诚与博弈好好生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JProfiler定位大对象与获取参数</title>
    <link href="/2023/09/08/JProfiler%E5%AE%9A%E4%BD%8D%E5%A4%A7%E5%AF%B9%E8%B1%A1%E4%B8%8E%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0/"/>
    <url>/2023/09/08/JProfiler%E5%AE%9A%E4%BD%8D%E5%A4%A7%E5%AF%B9%E8%B1%A1%E4%B8%8E%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="JProfiler-定位大对象与获取参数"><a href="#JProfiler-定位大对象与获取参数" class="headerlink" title="JProfiler 定位大对象与获取参数"></a>JProfiler 定位大对象与获取参数</h1><p>标签： #技术&#x2F;JVM #效能工具&#x2F;内存分析工具 #Share </p><h2 id="JProfiler-分析"><a href="#JProfiler-分析" class="headerlink" title="JProfiler 分析"></a>JProfiler 分析</h2><h3 id="查询最大对象"><a href="#查询最大对象" class="headerlink" title="查询最大对象"></a>查询最大对象</h3><p>获取最大对象</p><p><img src="/2023/09/08/JProfiler%E5%AE%9A%E4%BD%8D%E5%A4%A7%E5%AF%B9%E8%B1%A1%E4%B8%8E%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0/image-20230908161650967.png" alt="image-20230908161650967"></p><h3 id="分析GC路径"><a href="#分析GC路径" class="headerlink" title="分析GC路径"></a>分析GC路径</h3><p>在图表中展示</p><p><img src="/2023/09/08/JProfiler%E5%AE%9A%E4%BD%8D%E5%A4%A7%E5%AF%B9%E8%B1%A1%E4%B8%8E%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0/image-20230908161732042.png" alt="image-20230908161732042"></p><h3 id="获取最上层相关线程"><a href="#获取最上层相关线程" class="headerlink" title="获取最上层相关线程"></a>获取最上层相关线程</h3><p><img src="/2023/09/08/JProfiler%E5%AE%9A%E4%BD%8D%E5%A4%A7%E5%AF%B9%E8%B1%A1%E4%B8%8E%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0/image-20230908161812258.png" alt="image-20230908161812258"></p><h3 id="查看堆栈"><a href="#查看堆栈" class="headerlink" title="查看堆栈"></a>查看堆栈</h3><p><img src="/2023/09/08/JProfiler%E5%AE%9A%E4%BD%8D%E5%A4%A7%E5%AF%B9%E8%B1%A1%E4%B8%8E%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0/image-20230908161830134.png" alt="image-20230908161830134"></p><p>另一种方式：</p><p><img src="/2023/09/08/JProfiler%E5%AE%9A%E4%BD%8D%E5%A4%A7%E5%AF%B9%E8%B1%A1%E4%B8%8E%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0/image-20230908161849603.png" alt="image-20230908161849603"></p><h3 id="获取相关请求的参数"><a href="#获取相关请求的参数" class="headerlink" title="获取相关请求的参数"></a>获取相关请求的参数</h3><p>思路：根据当前堆栈，分析整个链路请求中的对象，例如本次堆栈的对象是 <code>com.jd.o2o.pms.api.openplat.request.SkuMainInfoRequest</code></p><p>然后再到类中进行查询，例如：</p><p><img src="/2023/09/08/JProfiler%E5%AE%9A%E4%BD%8D%E5%A4%A7%E5%AF%B9%E8%B1%A1%E4%B8%8E%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0/image-20230908162017209.png" alt="image-20230908162017209"></p><p>也可以进入图表进行确认，是否线程堆栈一致</p><p>查看参数即可（选择对象或双击即可）：</p><p><img src="/2023/09/08/JProfiler%E5%AE%9A%E4%BD%8D%E5%A4%A7%E5%AF%B9%E8%B1%A1%E4%B8%8E%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0/image-20230908162107184.png" alt="image-20230908162107184"></p>]]></content>
    
    
    <categories>
      
      <category>文章系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JProfiler定位大对象与获取参数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoTemplate的优化引发FullGC导致服务假死</title>
    <link href="/2023/08/24/MongoTemplate%E7%9A%84%E4%BC%98%E5%8C%96%E5%BC%95%E5%8F%91FullGC%E5%AF%BC%E8%87%B4%E6%9C%8D%E5%8A%A1%E5%81%87%E6%AD%BB/"/>
    <url>/2023/08/24/MongoTemplate%E7%9A%84%E4%BC%98%E5%8C%96%E5%BC%95%E5%8F%91FullGC%E5%AF%BC%E8%87%B4%E6%9C%8D%E5%8A%A1%E5%81%87%E6%AD%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="MongoTemplate的优化引发FullGC导致服务假死"><a href="#MongoTemplate的优化引发FullGC导致服务假死" class="headerlink" title="MongoTemplate的优化引发FullGC导致服务假死"></a>MongoTemplate的优化引发FullGC导致服务假死</h1><p>标签： #技术&#x2F;JVM #效能工具&#x2F;内存分析工具 #Share </p><h2 id="问题表现"><a href="#问题表现" class="headerlink" title="问题表现"></a>问题表现</h2><ol><li>内部收到JVM告警，其表现为：</li></ol><p><img src="/2023/08/24/MongoTemplate%E7%9A%84%E4%BC%98%E5%8C%96%E5%BC%95%E5%8F%91FullGC%E5%AF%BC%E8%87%B4%E6%9C%8D%E5%8A%A1%E5%81%87%E6%AD%BB/image-20230823102630723.png" alt="image-20230823102630723"></p><p><img src="/2023/08/24/MongoTemplate%E7%9A%84%E4%BC%98%E5%8C%96%E5%BC%95%E5%8F%91FullGC%E5%AF%BC%E8%87%B4%E6%9C%8D%E5%8A%A1%E5%81%87%E6%AD%BB/image-20230823102646362.png" alt="image-20230823102646362"></p><ol start="2"><li>外部应用反馈接口可用率&#x2F;耗时严重波动</li></ol><p><img src="/2023/08/24/MongoTemplate%E7%9A%84%E4%BC%98%E5%8C%96%E5%BC%95%E5%8F%91FullGC%E5%AF%BC%E8%87%B4%E6%9C%8D%E5%8A%A1%E5%81%87%E6%AD%BB/image-20230823102546257.png" alt="image-20230823102546257"></p><h2 id="止损方案"><a href="#止损方案" class="headerlink" title="止损方案"></a>止损方案</h2><ol><li>观察核心接口的响应时间，在发现低响应机器时立即下线JSF流量</li><li>观察UMP的内存使用情况，发现较为异常GC机器，提前下线JSF流量</li><li>观察MDC情况，发现CPU异常情况，提前下线JSF流量</li></ol><h2 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h2><p>由于发现及时，响应及时，再加上是B端流程，各个下游都有相关的兼容策略，所以仅是告警较多，没有产生大的业务影响。</p><h2 id="排查思路"><a href="#排查思路" class="headerlink" title="排查思路"></a>排查思路</h2><p>当晚我们组织了几个人从多个角度分别去排查：</p><ol><li><p>JVM堆栈进行分析</p><p><strong>基于该条线路定位到了内存中的大对象，相关方法</strong></p></li><li><p>业务流量、多维监控、机器日志、异常请求</p><p><strong>基于该条线路定位到了某一次Trace请求一共花了50分钟才结束，也间接知道了相关方法</strong></p></li><li><p>脑暴思考发生这种周期性问题的场景，例如周期性请求、MQ重试等，观察相关的数据</p></li></ol><h2 id="快速定位的手段-Dump日志分析"><a href="#快速定位的手段-Dump日志分析" class="headerlink" title="快速定位的手段 Dump日志分析"></a>快速定位的手段 Dump日志分析</h2><p>实际上我们在定位该问题时花费的时间较长，原因是Dump日志过大以及相关分析能力不够熟练，但同一个错误不犯第二次，未来再出现类似情况有信心在10分钟之内定位。</p><p>定位相关问题必做的两件事：</p><ol><li>保留问题现场</li><li>问题机器务必摘掉流量</li></ol><p>由于该问题是典型的OOM导致疯狂FullGC，那一定存在大对象，利用行云&#x2F;机器的Jmap命令可以获取其Dump日志，我们采用的是行云工具：</p><p><img src="/2023/08/24/MongoTemplate%E7%9A%84%E4%BC%98%E5%8C%96%E5%BC%95%E5%8F%91FullGC%E5%AF%BC%E8%87%B4%E6%9C%8D%E5%8A%A1%E5%81%87%E6%AD%BB/image-20230823104412082.png" alt="image-20230823104412082"></p><h3 id="困境：Dump日志过大"><a href="#困境：Dump日志过大" class="headerlink" title="困境：Dump日志过大"></a>困境：Dump日志过大</h3><p>这是我们在定位问题时遇到的第一个问题，Dump日志过大，压缩包为1.8G左右，解压后文件大小为10.8G左右，下载传输本来就很耗时，同事们的<code>MAT工具</code>第一次尝试打开的时候还总失败，给MAT工具加大内存后，打开一个超大Dump日志还比较随缘，要么电脑死机，要么需要10分钟左右。</p><p>后续又研究了一下，同一文件打开的速度如下：</p><p>MemoryAnalyzerTool：10分钟左右且需要主动调节最大内存，不太稳定。</p><p>Visual VM：20分钟左右且需要主动调节最大内存，打开后如果涉及分析引用，又需要几十分钟。</p><p>为了未来定位更加高效，从市面上筛选了一下更新的分析工具，最终确定到这一款：<strong>YourKit Java Profiler</strong>。</p><p>下载地址为：<a href="https://www.yourkit.com/java/profiler/download/">https://www.yourkit.com/java/profiler/download/</a></p><p>这款软件导入11G左右的Dump日志（Mac 16G内存电脑 M1芯片）只需要40秒左右，后续涉及计算的部分大概也都是5秒钟之内能够响应。</p><h3 id="YourKitJavaProfiler"><a href="#YourKitJavaProfiler" class="headerlink" title="YourKitJavaProfiler"></a>YourKitJavaProfiler</h3><p>基于上述问题整个分析与操作的过程如下：</p><ol><li><p>将拿到的文件解压后修改后缀名为：.hprof</p></li><li><p>导入YourKitJavaProfiler中（File - Open snapshop…）</p><p>需要大概几十秒到1分钟的时间，进度条非常给力，不会让人害怕突然崩掉</p></li><li><p>选择类视图，排序后找到堆当中明细异常的对象（很好发现）</p></li></ol><p><img src="/2023/08/24/MongoTemplate%E7%9A%84%E4%BC%98%E5%8C%96%E5%BC%95%E5%8F%91FullGC%E5%AF%BC%E8%87%B4%E6%9C%8D%E5%8A%A1%E5%81%87%E6%AD%BB/image-20230823110114279.png" alt="image-20230823110114279"></p><ol start="4"><li>右键，进入该对象的深入分析</li></ol><p>可以看到这个对象的占用非常高，查看其GC Roots 可以看到似乎是一个ArrayList里放了77万个该对象，另外相关的线程名是：<strong>JSF-BZ-22000-203-T-15</strong></p><p><img src="/2023/08/24/MongoTemplate%E7%9A%84%E4%BC%98%E5%8C%96%E5%BC%95%E5%8F%91FullGC%E5%AF%BC%E8%87%B4%E6%9C%8D%E5%8A%A1%E5%81%87%E6%AD%BB/image-20230823110250540.png" alt="image-20230823110250540"></p><ol start="5"><li>从Incoming References中也可以得到相同的结果</li></ol><p><img src="/2023/08/24/MongoTemplate%E7%9A%84%E4%BC%98%E5%8C%96%E5%BC%95%E5%8F%91FullGC%E5%AF%BC%E8%87%B4%E6%9C%8D%E5%8A%A1%E5%81%87%E6%AD%BB/image-20230823110509659.png" alt="image-20230823110509659"></p><ol start="6"><li>知道线程名后，进入线程界面进行查询</li></ol><p>该模型可以支持按线程名或ID查询，然后就是熟悉的调用链路了，按照从下往上看的原则，慢慢找的话，一定可以找到和我们相关的异常之处。</p><p>可以点击 <strong>Thread ID：610</strong>，进入更细节的链路之中。</p><p><img src="/2023/08/24/MongoTemplate%E7%9A%84%E4%BC%98%E5%8C%96%E5%BC%95%E5%8F%91FullGC%E5%AF%BC%E8%87%B4%E6%9C%8D%E5%8A%A1%E5%81%87%E6%AD%BB/image-20230823110617149.png" alt="image-20230823110617149"></p><ol start="7"><li>拿到请求入参</li></ol><p>我们发现整个调用链路中有一个核心对象承接了请求入参，代码如下：</p><pre><code class="hljs java"><span class="hljs-comment">// SkuMainInfoRequest类即是请求体</span>ServiceResponse&lt;SkuMainParterResponse&gt; <span class="hljs-title function_">updateSkuBaseInfo</span><span class="hljs-params">(SkuMainInfoRequest request)</span></code></pre><p>我们拿这个对象去搜索，可以得到更细节的内容</p><p><img src="/2023/08/24/MongoTemplate%E7%9A%84%E4%BC%98%E5%8C%96%E5%BC%95%E5%8F%91FullGC%E5%AF%BC%E8%87%B4%E6%9C%8D%E5%8A%A1%E5%81%87%E6%AD%BB/image-20230823111029690.png" alt="image-20230823111029690"></p><ol start="8"><li>拿到入参和入口后，用安全的机器多调用几次，查看表现是否符合预期，然后继续定位Bug，修复上线即可。</li></ol><h2 id="问题根因"><a href="#问题根因" class="headerlink" title="问题根因"></a>问题根因</h2><p>由于上文的分析流程，我们很容易就知道了到底什么参数什么情形引起了该问题，继续分析发现其实很简单，即：</p><p>某一次 IN 查询时IN的是一个包含Null值的集合（不符合预期，相关数据起码几十万条），如下：</p><p><img src="/2023/08/24/MongoTemplate%E7%9A%84%E4%BC%98%E5%8C%96%E5%BC%95%E5%8F%91FullGC%E5%AF%BC%E8%87%B4%E6%9C%8D%E5%8A%A1%E5%81%87%E6%AD%BB/image-20230823111335575.png" alt="image-20230823111335575"></p><p><strong>其实按照我们朴素的直觉来看，这样的问题应该是一个慢查询，带来的影响应该是慢查询导致线程耗尽，服务器受影响，不应该是疯狂FullGC的。</strong></p><p>在跟进MongoTemplate的客户端代码后发现，它底层在进行 <strong>find</strong> 查询时使用的是游标的方式。</p><p>核心方法：org.springframework.data.mongodb.core.MongoTemplate#executeFindMultiInternal</p><p>截图：</p><p><img src="/2023/08/24/MongoTemplate%E7%9A%84%E4%BC%98%E5%8C%96%E5%BC%95%E5%8F%91FullGC%E5%AF%BC%E8%87%B4%E6%9C%8D%E5%8A%A1%E5%81%87%E6%AD%BB/image-20230823111559708.png" alt="image-20230823111559708"></p><p><strong>怎么说呢，感谢MongoTemplate做出的优化，不然我们遇到的问题可能是数据库宕机，那就非常糟糕了。</strong></p><p>所以结论就是：</p><p>业务代码中某一次判断不太合适，让程序执行了一次 IN NULL 的操作（涉及几十万条数据），由于MongoTemplate的底层优化，让我们避免了数据库宕机的风险，但是导致拿的数据太多存储在内存之中，一直触发FullGC，进而服务器假死。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>花了一定时间研究内存分析工具之后，深感其能力的强大，也让我有信心在下次遇到类似问题时，5-10分钟即可定位。</p><p>另外，在发现工具用的相当不顺手时，也要果断的寻找新的解决之道。</p>]]></content>
    
    
    <categories>
      
      <category>文章系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MongoTemplate的优化引发FullGC导致服务假死</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ChatGPT之自然语言与编程语言的疯狂转换-代码实战与应用灵感</title>
    <link href="/2023/08/20/ChatGPT%E4%B9%8B%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E7%96%AF%E7%8B%82%E8%BD%AC%E6%8D%A2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98%E4%B8%8E%E5%BA%94%E7%94%A8%E7%81%B5%E6%84%9F/"/>
    <url>/2023/08/20/ChatGPT%E4%B9%8B%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E7%96%AF%E7%8B%82%E8%BD%AC%E6%8D%A2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98%E4%B8%8E%E5%BA%94%E7%94%A8%E7%81%B5%E6%84%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="ChatGPT之自然语言与编程语言的疯狂转换-代码实战与应用灵感"><a href="#ChatGPT之自然语言与编程语言的疯狂转换-代码实战与应用灵感" class="headerlink" title="ChatGPT之自然语言与编程语言的疯狂转换-代码实战与应用灵感"></a>ChatGPT之自然语言与编程语言的疯狂转换-代码实战与应用灵感</h1><p>标签： #Ai  #ChatGPT #ChatGPT-Calling #Share</p><h2 id="如何拥有一位-“私人”-AI"><a href="#如何拥有一位-“私人”-AI" class="headerlink" title="如何拥有一位 “私人” AI"></a>如何拥有一位 “私人” AI</h2><p>众所周知，目前的众多大模型都不会对外提供实时的讯息（<strong>因为没有接入网络</strong>）以及<strong>持久化存储</strong>的能力，而且AI还会主动的忽略你提及的私人信息。</p><p><img src="/2023/08/20/ChatGPT%E4%B9%8B%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E7%96%AF%E7%8B%82%E8%BD%AC%E6%8D%A2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98%E4%B8%8E%E5%BA%94%E7%94%A8%E7%81%B5%E6%84%9F/image-20230818154626320.png" alt="image-20230818154626320"></p><p>但真的完全没有办法吗？据我所知，目前仍然有两种方案来解决这个问题，分别是：**LangChain **与 <strong>Funtion Calling</strong>.</p><h3 id="LangChain"><a href="#LangChain" class="headerlink" title="LangChain"></a>LangChain</h3><p><strong>LangChain</strong>是一个开源的框架，它可以让AI开发人员把像GPT-4这样的大型语言模型（LLM）和外部数据结合起来。</p><p>目前支持的语言：JavaScript、TypeScript、Python。</p><p>它的基本作用是将用户提供的数据集（文本、PDF、图片等）拆分，将其存入向量存储中，最后将其转化为 <code>Prompt-Completin</code>，将其用作训练的最终答案。</p><p>即，如果你现在有了一个大型语言模型（例如清华大学开源的CPM-Bee），你希望将特定领域知识灌输给它，你一定要想到且必须使用：<code>LangChain</code>。</p><p>在近期的文章中经常有在本地跑大模型的文章，如果涉及到喂数据，那一定少不了使用该框架。</p><h3 id="Function-Calling"><a href="#Function-Calling" class="headerlink" title="Function Calling"></a>Function Calling</h3><blockquote><p>Developers can now describe Functions to GPT-4-0613 and gpt-3.5-turbo-0613, and have the model intelligently choose to output a JSON object containing arguments to call those functions. This is a new way to more reliably connect GPT’s capabilities with external tools and APIs.</p></blockquote><p>图示如下：</p><p><img src="/2023/08/20/ChatGPT%E4%B9%8B%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E7%96%AF%E7%8B%82%E8%BD%AC%E6%8D%A2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98%E4%B8%8E%E5%BA%94%E7%94%A8%E7%81%B5%E6%84%9F/image-20230818155251888.png" alt="image-20230818155251888"></p><p>核心点在于 Function 是一种类似于编码能力一样的<code>输入</code> + <code>输出</code>。</p><p>它最简单的表现形式，例如各大APP中内置的智能客服，我们一般都预设了问题及答案，这一组<code> 问题+答案</code>就是一个类似于编程领域的<code>Function</code>，GPT将会在你发问时，分析并匹配最接近的<code>Function</code>，然后<code>基于预设的Function执行结果</code>，再次发问（<strong>此步可以极大的命中核心诉求，同时一定程度上让GPT联网了，懂的更多了</strong>）。</p><p>值得注意的是：</p><ol><li>GPT仍然不会持久化任何信息，仅会在当前对话上下文中短暂的记忆。</li><li>Function 的执行可以是纯粹的自然语言，也可以是编程语言（<strong>无论是爬虫还是数据库、还是某一个Api</strong>）</li></ol><p>Function Calling 能力的添加在一定程度上解决了用户喂脏数据和获取新数据的矛盾点，是一个质的飞跃，同时也让<strong>非研发工作者有了更加轻松便捷的调用算力的能力</strong>。</p><h2 id="应用灵感"><a href="#应用灵感" class="headerlink" title="应用灵感"></a>应用灵感</h2><p>由于FunctionCalling的存在，我们可以让ChatGPT “连上网”（其实是用户自定义的任何内容），这样一来，ChatGPT的可定制化程度就大大提高了，可以做私域知识库，智能客服或者私人助理等等，它的上限完全取决于你<strong>如何调用算力</strong>。</p><p><strong>如何用自然语言更大程度的调用算力。</strong></p><p>这句话非常关键。</p><p>例如本次的黑客马拉松我就有一个想法是尝试做一下基于GPT的智能比价（实际没有立项），有兴趣的话可以看看它与传统方案的对比。</p><h3 id="传统方案"><a href="#传统方案" class="headerlink" title="传统方案"></a>传统方案</h3><ol><li>爬虫想办法去爬数据</li><li>产品、业务思考哪些东西可以作为特征来进行比对</li><li>算法基于产品的文档（特征集），对其进行开发，主要内容是品相似度识别，找到一堆商品中哪一个是其竞对商品</li><li>投入使用</li><li>产品、业务继续提需求（新特征，例如奶粉要更多的关注是几段奶粉）</li><li>反复迭代开发<br></li></ol><h3 id="Function-Calling-方案"><a href="#Function-Calling-方案" class="headerlink" title="Function Calling 方案"></a>Function Calling 方案</h3><ol><li>爬虫想办法去爬数据</li><li>算法打通ChatGPT，构建好交互平台，让用户（产品&#x2F;业务）可以自行定义Function（配合爬虫）</li><li><strong>产品、业务思考哪些东西可以作为特征来进行比对，自己随时调整Function的语义</strong></li><li>投入使用<br></li></ol><h2 id="丐版代码实战"><a href="#丐版代码实战" class="headerlink" title="丐版代码实战"></a>丐版代码实战</h2><p>由于篇幅有限，我会把用伪代码的形式写出来，只讲关键的部分，代码全文地址请跳转：<a href="https://joyspace.jd.com/pages/38ddsF4kt4fl7FVvHtcQ">JoySpace</a>.</p><pre><code class="hljs java"><span class="hljs-comment">// 构建预设的Functions</span><span class="hljs-type">Function</span> <span class="hljs-variable">functions</span> <span class="hljs-operator">=</span> 构建预设的Functions(参数：定义语义场景);<span class="hljs-comment">// 发起提问</span><span class="hljs-type">String</span> <span class="hljs-variable">content1</span> <span class="hljs-operator">=</span> 构建普通对话请求（参数：基本参数，问题，functions);<span class="hljs-comment">// 解析答案，判断是否命中预设的Functions，继续提问，并获得最终答案</span><span class="hljs-type">String</span> <span class="hljs-variable">content2</span> <span class="hljs-operator">=</span> 再次构建对话请求（参数：基本参数，问题，functions，上一轮中命中function的返回结果);</code></pre><p>我将其中的流程报文都打印出来了，各位可以观察下：</p><p>我的问题是: 请为我输出 小米13Pro 这款手机在京东的网页地址。</p><p>首次回答内容: Message(role&#x3D;assistant, content&#x3D;null, name&#x3D;null, functionCall&#x3D;FunctionCallResult(name&#x3D;search, arguments&#x3D;{<br>  “Keyword”: “小米13Pro”,<br>  “source”: “京东”<br>}))</p><p>基于提问提取GPT理解的问题: {<br>  “Keyword”: “小米13Pro”,<br>  “source”: “京东”<br>}</p><p>最终交互结果: Message(role&#x3D;assistant, content&#x3D;小米13Pro在京东的网页地址有多个，以下是其中一些地址：</p><ol><li><a href="https://item.jd.com/10067055332237.html">小米13Pro 京东地址1</a></li><li><a href="https://item.jd.com/10075157114400.html">小米13Pro 京东地址2</a></li><li><a href="https://item.jd.com/100045105170.html">小米13Pro 京东地址3</a></li><li><a href="https://item.jd.com/100053600196.html">小米13Pro 京东地址4</a></li><li><a href="https://item.jd.com/10067055899492.html">小米13Pro 京东地址5</a></li><li><a href="https://item.jd.com/10069063608017.html">小米13Pro 京东地址6</a></li><li><a href="https://item.jd.com/100049739386.html">小米13Pro 京东地址7</a></li></ol><p>你可以点击链接查看详细信息。, name&#x3D;null, functionCall&#x3D;null)</p><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>其中有一个环节有一点点违背程序员的直观感受，就是 <strong>Function的构建</strong>，我构建的函数是这样的：</p><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>  <span class="hljs-attr">&quot;Keyword&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;string&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Keyword you want to search, for example: 华为GT2Pro, ViVo手机&quot;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;source&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;string&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;The platform you want to search, for example: 拼多多, 淘宝, 京东&quot;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span></code></pre><p>它的意思是，需要GPT把我的提问，提取两个字段，一个字段叫 <code>Keyword</code>，一个字段叫 <code>source</code> ，后面是它们的描述。</p><p>而GPT是完全基于描述从我的问题中，找到参数的，即上文的：</p><pre><code class="hljs java">基于提问提取GPT理解的问题: &#123;  <span class="hljs-string">&quot;Keyword&quot;</span>: <span class="hljs-string">&quot;小米13Pro&quot;</span>,  <span class="hljs-string">&quot;source&quot;</span>: <span class="hljs-string">&quot;京东&quot;</span>&#125;</code></pre><p>实际上，我一开始是这么写的：</p><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>  <span class="hljs-attr">&quot;Keyword&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;string&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;你想要搜索的关键词，例如: 华为GT2Pro, ViVo手机&quot;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;source&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;string&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;你想要搜索的平台，例如: 拼多多, 淘宝, 京东&quot;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span></code></pre><p>但是GPT完全无法理解我的用意 😅。</p><h2 id="所以为什么Prompt这么重要？"><a href="#所以为什么Prompt这么重要？" class="headerlink" title="所以为什么Prompt这么重要？"></a>所以为什么Prompt这么重要？</h2><p>本来在日常的使用中就很能体会到Prompt正确与否，非常影响Ai的智能。</p><p>而这次编程的经历更是让我感知到，在现在，<strong>想要正确且合理的调用算力，能否让AI理解是核心所在！</strong></p><h2 id="稀奇古怪的想法"><a href="#稀奇古怪的想法" class="headerlink" title="稀奇古怪的想法"></a>稀奇古怪的想法</h2><p>所以未来AI对某一个Prompt响应非常古怪，我们又能怎么办呢？AI研究员又会怎么去DEBUG呢？非常期待那一天的来临。</p><p>最后，感谢<a href="http://wqadmin.jd.com/webstatic/prompt/#/index?cate=1"><strong>Hi-Prompt</strong></a>平台小伙伴们提供了这么棒的工具，用起来非常流畅。</p>]]></content>
    
    
    <categories>
      
      <category>AIGC-文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ChatGPT之自然语言与编程语言的疯狂转换-代码实战与应用灵感</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓系统桌面小组件</title>
    <link href="/2023/08/20/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E6%A1%8C%E9%9D%A2%E5%B0%8F%E7%BB%84%E4%BB%B6/"/>
    <url>/2023/08/20/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E6%A1%8C%E9%9D%A2%E5%B0%8F%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="安卓系统桌面小组件"><a href="#安卓系统桌面小组件" class="headerlink" title="安卓系统桌面小组件"></a>安卓系统桌面小组件</h1><p>标签： #效能工具&#x2F;桌面小工具  #Share</p><h2 id="桌面小工具的妙用"><a href="#桌面小工具的妙用" class="headerlink" title="桌面小工具的妙用"></a>桌面小工具的妙用</h2><p>在之前的体验中，仅有Mac的桌面小工具做的比较，因为有其独特设计的Bar系统，如图所示：</p><p><img src="/2023/08/20/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E6%A1%8C%E9%9D%A2%E5%B0%8F%E7%BB%84%E4%BB%B6/image-20230817153514689.png"></p><p>近期，随着安卓系统的更新，手机端也实现了类似的功能，可以将APP内的某一界面直接转化成组件置于桌面上，方便快速使用，其核心点有二：</p><ol><li>这是一个对历史结构的再渲染（因为有绝对没有更新过的APP也实现了此种效果）</li><li>可以将部分界面作为组件实时的放在手机桌面，<strong>实现非常丰富的展示以及快速使用的能力</strong></li></ol><p>Eg：</p><p><img src="/2023/08/20/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E6%A1%8C%E9%9D%A2%E5%B0%8F%E7%BB%84%E4%BB%B6/image-20230817154756519.png"></p>]]></content>
    
    
    <categories>
      
      <category>效能工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安卓系统桌面小组件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于性缘脑</title>
    <link href="/2023/08/14/%E5%85%B3%E4%BA%8E%E6%80%A7%E7%BC%98%E8%84%91/"/>
    <url>/2023/08/14/%E5%85%B3%E4%BA%8E%E6%80%A7%E7%BC%98%E8%84%91/</url>
    
    <content type="html"><![CDATA[<h1 id="关于性缘脑"><a href="#关于性缘脑" class="headerlink" title="关于性缘脑"></a>关于性缘脑</h1><p>标签： #Thinking&#x2F;两性  #Share</p><h2 id="性缘脑的定义"><a href="#性缘脑的定义" class="headerlink" title="性缘脑的定义"></a>性缘脑的定义</h2><p>性缘脑一词出自《比恋爱脑更可怕的是性缘脑：它思维极大地限制了我与外界联结的可能性》的文章，在社交媒体上引起了广泛关注。</p><p>它是一种思维模式，指的是将恋爱看作最重要的社交关系，甘于放弃亲缘关系（父母家人之间）、友缘（朋友、闺蜜之间）等社会联系，</p><p>同时将任何关系都曲解为性缘关系的思维方式。</p><p>例如：”性缘脑“ 的人遇到一个异性时，脑海中第一想法就是：<strong>对方能不能和自己成为异性缘关系。</strong></p><h2 id="性缘脑自测"><a href="#性缘脑自测" class="headerlink" title="性缘脑自测"></a>性缘脑自测</h2><p>“性缘脑”是一种新的心理学概念，它指的是一种将<strong>性</strong>视为关键因素的思维方式。</p><p><strong>1.与异性的关系难以纯洁</strong></p><p>遇见一个异性，你会下意识地审视TA的各方面条件，<strong>看会不会成为自己的男&#x2F;女友</strong>。</p><p><strong>2.患得患失</strong></p><p>在内心或者说脑海中会形成一种概念观察、<strong>猜想对方是否也对自己有意思</strong>，两人能否发展为男女朋友的亲密关系；</p><p><strong>3.社交心理障碍</strong></p><p>当对这个人产生兴趣后，会把全部注意力都放在对方的身上，从而忽略了周围的其他人或者事物，因此导致<strong>思维、感受、行为能力都受到了限制</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>Thinking</category>
      
    </categories>
    
    
    <tags>
      
      <tag>关于性缘脑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于一元论认知</title>
    <link href="/2023/07/27/%E5%85%B3%E4%BA%8E%E4%B8%80%E5%85%83%E8%AE%BA%E8%AE%A4%E7%9F%A5/"/>
    <url>/2023/07/27/%E5%85%B3%E4%BA%8E%E4%B8%80%E5%85%83%E8%AE%BA%E8%AE%A4%E7%9F%A5/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="link-https-www-notion-so-851abcba694b41e8844f28200685db20notionID-851abcba-694b-41e8-844f-28200685db20"><a href="#link-https-www-notion-so-851abcba694b41e8844f28200685db20notionID-851abcba-694b-41e8-844f-28200685db20" class="headerlink" title="link: https://www.notion.so/851abcba694b41e8844f28200685db20notionID: 851abcba-694b-41e8-844f-28200685db20"></a>link: <a href="https://www.notion.so/851abcba694b41e8844f28200685db20">https://www.notion.so/851abcba694b41e8844f28200685db20</a><br>notionID: 851abcba-694b-41e8-844f-28200685db20</h2><h1 id="关于一元论认知"><a href="#关于一元论认知" class="headerlink" title="关于一元论认知"></a>关于一元论认知</h1><p>标签： #Thinking&#x2F;哲学观  #Share</p><p><strong>「关于一元论是幸存者而非受害者的论调。」</strong></p><p>由于当下世界信息渠道的拓展，每个人都可以将自己的想法和观点Push至社交媒体，其中有些人可能会因为个人体悟不同&#x2F;吸引眼球&#x2F;吸引特定群体的原因，说一些与主流相佐的论调。</p><p>例如今天看到有一个结论让我比较在意，它说：相信一元论的人是幸存者而非受害者。</p><p>举的例子是问一个小男孩坏情绪和好情绪哪个更重要，小男生回答道：都很重要。</p><p>于是引出一元论种种的好，其中评论区也指出，对123456789数字分类，它们都是数字。</p><p>我始终相信一个判定智者的观点：<font color="#ff0000">可以在大脑中容纳多种不同的甚至对立的观点。</font></p><p>仍以123456789数字分类为例，你可以它们都看成数字，也可以以1357，2468分类成奇数，偶数。</p><p>我们看待这个世界的哲学观和宇宙观，仍然应该是：<font color="#ff0000">辩证法</font>，它才是真正的，可以拓展和兼容其它的认识论。</p><p>至于未来有没有更科学的体系？静待未来发生。</p>]]></content>
    
    
    <categories>
      
      <category>Thinking</category>
      
    </categories>
    
    
    <tags>
      
      <tag>关于一元论认知</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zettelkasten 卡片盒笔记法</title>
    <link href="/2023/07/21/Zettelkasten%20%E5%8D%A1%E7%89%87%E7%9B%92%E7%AC%94%E8%AE%B0%E6%B3%95/"/>
    <url>/2023/07/21/Zettelkasten%20%E5%8D%A1%E7%89%87%E7%9B%92%E7%AC%94%E8%AE%B0%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Zettelkasten-卡片盒笔记法是什么？"><a href="#Zettelkasten-卡片盒笔记法是什么？" class="headerlink" title="Zettelkasten 卡片盒笔记法是什么？"></a>Zettelkasten 卡片盒笔记法是什么？</h1><p>标签： #效能工具&#x2F;Zettelkasten #Share</p><p>简单来说，Zettelkasten 是一种比标签更高级的卡片笔记方法，开智部落王浚宇在《卡片大法的神奇之处》提到：</p><blockquote><p>卡片是精致小巧的万用盒子：卡片就像生活中我们都会需要的盒子一样，也许男生更倾向于放一些自己珍藏的小物件，姑娘直接当成了首饰盒。和硕大的背包比起来，盒子的容量是有限的，需要想清楚自己要放什么样的东西进去，这样就会降低负荷，并且放进去的东西质量也更高，我们的卡片有些类似，容量小的好处是负荷降低，放进去的是线索、是高质量的内容。</p></blockquote><p>德国社会学者 Niklas Luhmann（卢曼）使用 Zettelkasten 卡片盒笔记法写了 70 多本书和 400 多篇学术文章。在 <a href="https://writingcooperative.com/zettelkasten-how-one-german-scholar-was-so-freakishly-productive-997e4e0ca125">Zettelkasten — How One German Scholar Was So Freakishly Productive</a> 这篇文章当中详细介绍了他的写作方法的机理。</p><p>用文件或文件夹来组织笔记的方式会导致笔记形成僵硬的结构，我们只能通过书本目录组织它，或随着时间不断新增按照时间线组织，而如果我们将每个块（chunk）打散，笔记变得自由浮动，但问题也随之而来：我们很难再追踪到它们之间的相互关系了。</p><p><img src="/2023/07/21/Zettelkasten%20%E5%8D%A1%E7%89%87%E7%9B%92%E7%AC%94%E8%AE%B0%E6%B3%95/%E5%83%B5%E7%A1%AC%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E6%B5%AE%E5%8A%A8%E7%9A%84%E7%9F%A5%E8%AF%86.jpeg" alt="僵硬的结构和浮动的知识"></p><center>左：僵硬的结构 右：自由浮动的知识</center><p>接着我们尝试体现知识点之间的关系：大部分人都采用了文件夹或者列表的方式，把这些卡片分门别类归档到不同的文件夹里面，比如印象笔记的笔记本，或笔记本组。但现实世界的复杂问题，其实不可能只在某一个领域（即文件夹）内找到合适的答案，领域的划分也会限制「创意」或「灵感」的产生。</p><p>标签的发明大大改进了笔记系统，但按标签查看笔记也很局限：我们一次只能看到几个标签内的内容，此外的内容则被遮蔽了，因此在组织信息和资料方面实用性并不很高。</p><p>所以更好的办法是：我们应该用网络结构（web）来组织我们的笔记 —— 不仅仅依靠标签，还要把所有笔记连接在一起。我们可以每次只关注在这张网络的某个连接点上，但更重要的是，我们同时也能看到更多的联结发生在背后。</p>]]></content>
    
    
    <categories>
      
      <category>Zettelkasten</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zettelkasten 卡片盒笔记法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zettelkasten 如何实践</title>
    <link href="/2023/07/21/Zettelkasten%20%E5%A6%82%E4%BD%95%E5%AE%9E%E8%B7%B5/"/>
    <url>/2023/07/21/Zettelkasten%20%E5%A6%82%E4%BD%95%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="Zettelkasten-如何实践"><a href="#Zettelkasten-如何实践" class="headerlink" title="Zettelkasten 如何实践"></a>Zettelkasten 如何实践</h1><p>标签： #效能工具&#x2F;Zettelkasten  #Share</p><p>我们已经知晓 [[Zettelkasten 卡片盒笔记法]]，本篇就是网状结构的一个小小测试。<br>Zettelkasten 卡片盒方法突出了<code>建立联系</code>重要性，其实有刻意区分了三种类型的卡片笔记：Literature Notes、Bibliographical Notes、Permanent Notes。</p><ul><li><p>Literature Notes 是 a) 简短地 b) 用自己的话（而非“复制粘贴”）记录你在看的文献笔记，迫使你真正理解原文的意思。</p></li><li><p>Bibliographical Notes 则需要你添加参考信息，将上面的Literature Notes跟原文联系起来。而这一步，恰恰是 Roam 或 Obsidian 工具发挥价值最大的地方，甚至做到了完全自动化。（稍后会进一步解释我的工作流。</p></li><li><p>Permanent Notes 是最重要的一步，回顾每一个卡片笔记，同时思考它们与你所学的内容、你的兴趣、思考或研究的关系。你的目标不是收集尽可能多的笔记，而是为你现有的想法、论点和讨论增加新的价值。</p></li></ul><p><img src="/2023/07/21/Zettelkasten%20%E5%A6%82%E4%BD%95%E5%AE%9E%E8%B7%B5/Zettelkasten%E7%9A%84%E6%AD%A5%E9%AA%A4.jpeg" alt="Zettelkasten"></p><p>至此，你才算是真正增加了所谓<code>知识</code>，这儿会有个 re-read 的陷阱：当你回看之前的<code>收藏</code>的已读内容时，大脑会因为熟悉感而误以为自己 “学到了” ，而这恰恰是你之前所有 “复制粘贴” 的文字最大的问题。</p><ul><li><p>第一步：首先，使用 Zettelkasten 方法迫使你写作。 特别是，根据这种方法，你必须用自己的话写笔记，以确保你将来能够理解它们，任何一个写过东西的人都知道，把东西写下来会迫使你把模糊的概念变成清晰的想法。</p></li><li><p>第二步：其次，无论何时添加新笔记，使用 Zettelkasten 方法要迫使自己查找可以链接到的已有笔记。比如上面的 [[Zettelkasten 卡片盒笔记法]]。 这样可以拓宽你的思维，迫使你去思考新的想法和你以前遇到过的其他想法之间的关系。</p></li><li><p>第三步：Zettelkasten 可以储存一系列想法。Zettelkasten 就是关于连接想法的。 因此，今天你可以有一系列的想法，把它们作为一系列相互联系的记录存储在你的卡片盒当中；然后，在未来的任何时候，你可以通过添加新的记录并将它们与以前的记录联系起来，延续这一系列的思考</p></li><li><p>第四步：利用其它工具，如<code>Anki</code> 来特意间隔重复加深记忆，从而在写卡片时能够更加主动得由大脑来触发我的联想。</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.jimmylv.info/2020-06-03-zettelkasten-in-action/">基于 Obsidian 的 Zettelkasten 卡片盒笔记法实践</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Zettelkasten</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zettelkasten 如何实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于婚姻的答案</title>
    <link href="/2023/07/21/%E5%85%B3%E4%BA%8E%E5%A9%9A%E5%A7%BB%E7%9A%84%E7%AD%94%E6%A1%88/"/>
    <url>/2023/07/21/%E5%85%B3%E4%BA%8E%E5%A9%9A%E5%A7%BB%E7%9A%84%E7%AD%94%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="关于婚姻的答案"><a href="#关于婚姻的答案" class="headerlink" title="关于婚姻的答案"></a>关于婚姻的答案</h1><p>标签： #Thinking&#x2F;婚姻  #Share</p><h3 id="婚姻是一个必然结果吗"><a href="#婚姻是一个必然结果吗" class="headerlink" title="婚姻是一个必然结果吗"></a>婚姻是一个必然结果吗</h3><p>在当代（2023）的中国，依然有部分少数民族保持着走婚的习俗，即：没有明确的一对一的伴侣关系，基于个人喜好自由结合，结合后的生命结晶（孩子）由母系家族抚养成人，其中舅舅扮演的角色类似于当下的父亲。</p><h3 id="婚姻的起源"><a href="#婚姻的起源" class="headerlink" title="婚姻的起源"></a>婚姻的起源</h3><p>恩格斯的《家庭、国家和私有制的起源》一书中可以了解到婚姻制度的发展过程，总之它是复杂原因下演化出来的社会习俗（制度），在某些程度上起到维护统治、巩固阶级、保障个人权益相关的作用。</p><h3 id="关于人为什么要结婚"><a href="#关于人为什么要结婚" class="headerlink" title="关于人为什么要结婚"></a>关于人为什么要结婚</h3><p>在与雨桐聊天时，提到了这个问题，其实也不是完全没有答案，但是可能因为问题太大，或者过于严肃（答案正确与否影响很大），导致不敢对其做真正的思考和记录。</p><p>在听播客时，偶尔听到了答案，和我的理想模型比较相似，顺便也基于自己的答案整理，总结一下：</p><ul><li><strong>生理需求</strong>：动物性的生理需求</li><li><strong>发展需求</strong>：作为社会人的自我发展，个人成长的旅伴（1 + 1 &gt;&gt; 2）</li><li><strong>情感需求</strong>：作为人的生命情感（爱），以及陪伴、对于社会性<code>理想生活（白头偕老，儿孙满堂）</code>的向往</li><li><strong>财富需求</strong>：社会分工下合力创造财富的能力（1 + 1 &gt; 2）</li><li><strong>社会需求</strong>：作为社会人，社会制度，习俗的社会身份要求</li></ul><p>在人生的路上不想做纯粹的理性人，但是考虑上述的内容，也是对自己所爱之人负责任的表现。<br>所以，勇敢的写下答案，即使它不完美。</p>]]></content>
    
    
    <categories>
      
      <category>Thinking</category>
      
    </categories>
    
    
    <tags>
      
      <tag>关于婚姻的答案</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java远程DeBug解决方案</title>
    <link href="/2023/05/18/Java%E8%BF%9C%E7%A8%8BDeBug%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2023/05/18/Java%E8%BF%9C%E7%A8%8BDeBug%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="Java远程DEBUG解决方案"><a href="#Java远程DEBUG解决方案" class="headerlink" title="Java远程DEBUG解决方案"></a>Java远程DEBUG解决方案</h1><p>标签： #Share</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>JPDA（Java Platform Debugger Architecture）是Sun公司开发的 java平台调试体系，它主要有三个层次组成，即 Java 虚拟机工具接口（JVMTI），Java 调试线协议（JDWP）以及 Java 调试接口（JDI）</p><p>JVMTI（JVMDI）: jdk1.4 之前称为JVMDI，之后改为了JVMTI，它是虚拟机的本地接口，其相当于 Thread 的 sleep、yield native 方法</p><p>JDWP（Java Debug Wire Protocol）：java调试网络协议，其描述了调试信息的格式，以及在被调试的进程（server）和调试器（client）之间传输的请求</p><p>JDI：java调试接口，虚拟机的高级接口，调试器（client）自己实现 JDI 接口，比如 idea、eclipse 等</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>参考文章：<a href="https://www.cnblogs.com/wl-blog/p/15838574.html">https://www.cnblogs.com/wl-blog/p/15838574.html</a></p><p>执行步骤：</p><ol><li>服务启动时增加命令（开启DEBUG相关模块、指定服务器端口）</li><li>开启服务所在的远程服务器相关端口</li><li>本地IDE新建远程DEBUG模块，配置相关参数即可</li></ol><p>注意事项：</p><ol><li><code>DEBUG执行的代码块一定要相同（整体代码可以不一样）</code></li><li><code>断点执行一定要完全执行结束，不然会占据相当高的内存空间（也可重启解决）</code></li></ol><h2 id="京东到家实践参考"><a href="#京东到家实践参考" class="headerlink" title="京东到家实践参考"></a>京东到家实践参考</h2><p>参考文章：<a href="https://confluence.corp.imdada.cn/pages/viewpage.action?pageId=85747261">https://confluence.corp.imdada.cn/pages/viewpage.action?pageId=85747261</a></p><ol><li><p>服务启动时增加命令（开启DEBUG相关模块）</p><p>Tomcat：-agentlib:jdwp&#x3D;transport&#x3D;dt_socket,address&#x3D;8088,suspend&#x3D;n,server&#x3D;y</p><pre><code class="hljs sh"><span class="hljs-built_in">export</span> maxParameterCount=<span class="hljs-string">&quot;1000&quot;</span><span class="hljs-built_in">export</span> acceptCount=<span class="hljs-string">&quot;1000&quot;</span><span class="hljs-built_in">export</span> maxSpareThreads=<span class="hljs-string">&quot;750&quot;</span><span class="hljs-built_in">export</span> maxThreads=<span class="hljs-string">&quot;1000&quot;</span><span class="hljs-built_in">export</span> minSpareTHreads=<span class="hljs-string">&quot;50&quot;</span><span class="hljs-built_in">export</span> URIEncoding=<span class="hljs-string">&quot;UTF-8&quot;</span><span class="hljs-built_in">export</span> JAVA_OPTS=<span class="hljs-string">&quot;-Djava.library.path=/usr/local/lib -server -Xms2048m -Xmx4096m -XX:MaxMetaspaceSize=256m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/export/Logs -Djava.awt.headless=true -Dsun.net.client.defaultConnectTimeout=60000 -Dsun.net.client.defaultReadTimeout=60000 -Djmagick.systemclassloader=no -Dnetworkaddress.cache.ttl=300 -Dsun.net.inetaddr.ttl=300 -Dump.key.prefix=pre_ -agentlib:jdwp=transport=dt_socket,address=8088,suspend=n,server=y&quot;</span></code></pre><p>Application：setsid <code>java -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005</code> -jar</p><pre><code class="hljs sh">// 案例、关注第三行<span class="hljs-built_in">nohup</span> <span class="hljs-string">&quot;<span class="hljs-variable">$JAVACMD</span>&quot;</span> <span class="hljs-variable">$&#123;TTL_AGENT:-&#125;</span> <span class="hljs-variable">$&#123;PFINDER_AGENT:-&#125;</span> <span class="hljs-variable">$JAVA_OPTS</span>\  <span class="hljs-variable">$OPTS_MEMORY</span> \  -agentlib:jdwp=transport=dt_socket,server=y,<span class="hljs-built_in">suspend</span>=n,address=5005 \  -XX:-OmitStackTraceInFastThrow\  -classpath <span class="hljs-string">&quot;<span class="hljs-variable">$CLASSPATH</span>&quot;</span> \  -Dbasedir=<span class="hljs-string">&quot;<span class="hljs-variable">$BASEDIR</span>&quot;</span> \  -Dfile.encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> \  -Dcom.sun.management.jmxremote\    -Dcom.sun.management.jmxremote.port=52001\    -Dcom.sun.management.jmxremote.authenticate=<span class="hljs-literal">false</span>\    -Dcom.sun.management.jmxremote.ssl=<span class="hljs-literal">false</span>\</code></pre></li><li><p>服务启动时增加命令（开启DEBUG相关模块、指定服务器端口）</p><p>由于京东云对外暴露的接口只有80和443，所以5005端口无法直接访问</p><p>因此，配置负载均衡进行转发（<code>TCP协议</code>）</p><p><img src="/2023/05/18/Java%E8%BF%9C%E7%A8%8BDeBug%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20221101161032494.png" alt="image-20221101161032494"></p></li><li><p>本地IDE新建远程DEBUG模块，配置相关参数即可</p><p>Host可以直接IP或者域名都可，端口理论上是任意的，只要能匹配上即可，例如这里就是80，上面是5005转发至80端口</p><p><img src="/2023/05/18/Java%E8%BF%9C%E7%A8%8BDeBug%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20221101161123024.png" alt="image-20221101161123024"></p><p>切换至远程DEBUG，开启调试后，控制台会输出相应日志：</p><p>Connected to the target VM, address: ‘stockcentero2o-remotedebug.o2ostock.svc.lf06.n.jd.local:80’, transport: ‘socket’</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Tips篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java远程DeBug解决方案</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单测实践</title>
    <link href="/2023/03/03/%E5%8D%95%E6%B5%8B%E5%AE%9E%E8%B7%B5/"/>
    <url>/2023/03/03/%E5%8D%95%E6%B5%8B%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="单测实践"><a href="#单测实践" class="headerlink" title="单测实践"></a>单测实践</h1><p>标签： #Share</p><h2 id="认知与误区"><a href="#认知与误区" class="headerlink" title="认知与误区"></a>认知与误区</h2><p>我之前以为的单测：</p><ul><li>基于整个Spring体系（测试Profile&#x2F;预发Profile）运行代码、连接实际的数据库、Redis、中间件</li><li>模拟实际数据，拿到对应的返回结果</li></ul><p>理论上来说，这样的思路也没问题，因为在实际单测的场景中确实有一部分代码需要实际与中间件交互，来排查问题、整合数据、或者干脆测试环境DeBug。</p><p>新的领域：单测不仅仅可以通过完全复刻环境的方式进行，也可以通过<code>模拟</code>来进行，其本质是修改字节码，让其返回我需要的数据，进而保障整个方法的运行，保障方法内部if else的覆盖。</p><h2 id="Jacoco-实践"><a href="#Jacoco-实践" class="headerlink" title="Jacoco 实践"></a>Jacoco 实践</h2><h1 id="接入方式"><a href="#接入方式" class="headerlink" title="接入方式"></a>接入方式</h1><p>以离线方式为例(方便后续使用Powermock对静态方法、构造方法进行mock)</p><h2 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h2><pre><code class="hljs apache"><span class="hljs-section">&lt;properties&gt;</span>  <span class="hljs-section">&lt;jacoco.version&gt;</span><span class="hljs-attribute">0</span>.<span class="hljs-number">8</span>.<span class="hljs-number">2</span>&lt;/jacoco.version&gt;<span class="hljs-section">&lt;/properties&gt;</span></code></pre><p>在最外层的pom中全局引入jacoco依赖：</p><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.jacoco<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>org.jacoco.agent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">classifier</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">classifier</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;jacoco.version&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></span></code></pre><p>全局plugin</p><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.22.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">systemPropertyVariables</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">jacoco-agent.destfile</span>&gt;</span>target/jacoco.exec<span class="hljs-tag">&lt;/<span class="hljs-name">jacoco-agent.destfile</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">systemPropertyVariables</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><span class="language-xml">  <span class="hljs-comment">&lt;!-- 生成JaCoCo覆盖率数据插件 --&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.jacoco<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jacoco-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;jacoco.version&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>default-instrument<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span></span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>instrument<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>default-restore-instrumented-classes<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span></span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>restore-instrumented-classes<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span></span><span class="language-xml">      <span class="hljs-comment">&lt;!-- attached to Maven test phase --&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>default-report<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span></span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>report<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span></span></code></pre><h2 id="在IDEA中统计单元测试覆盖率"><a href="#在IDEA中统计单元测试覆盖率" class="headerlink" title="在IDEA中统计单元测试覆盖率"></a>在IDEA中统计单元测试覆盖率</h2><ol><li>在执行测试方法时，选择 <strong>Run with Converage</strong></li></ol><p><img src="/2023/03/03/%E5%8D%95%E6%B5%8B%E5%AE%9E%E8%B7%B5/link.png" alt="img"></p><ol start="2"><li>在执行完成后，会出现单元测试覆盖率统计界面</li></ol><p><img src="/2023/03/03/%E5%8D%95%E6%B5%8B%E5%AE%9E%E8%B7%B5/image-20230303140406664.png" alt="image-20230303140406664"></p><h2 id="PowerMock-编码"><a href="#PowerMock-编码" class="headerlink" title="PowerMock 编码"></a>PowerMock 编码</h2><h3 id="maven接入"><a href="#maven接入" class="headerlink" title="maven接入"></a>maven接入</h3><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">mockito.version</span>&gt;</span>3.12.4<span class="hljs-tag">&lt;/<span class="hljs-name">mockito.version</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">powermock.version</span>&gt;</span>2.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">powermock.version</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mockito<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mockito-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;mockito.version&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.powermock<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>powermock-module-junit4<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;powermock.version&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.powermock<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>powermock-api-mockito2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;powermock.version&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span></code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><a href="https://github.com/powermock/powermock/wiki/Mockito">https://github.com/powermock/powermock/wiki/Mockito</a></p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><pre><code class="hljs java"><span class="hljs-meta">@RunWith(MockitoJUnitRunner.class)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderServiceImplTest</span> &#123;    <span class="hljs-meta">@Mock</span>    <span class="hljs-keyword">private</span> OrderQueryServiceRpc mockOrderQueryServiceRpc;    <span class="hljs-meta">@InjectMocks</span>    <span class="hljs-keyword">private</span> OrderServiceImpl orderServiceImplUnderTest;    <span class="hljs-meta">@Test</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetOrderInfoByOrderId4OrderSystemCancel</span> <span class="hljs-params">()</span> &#123;        <span class="hljs-comment">// Setup</span>        <span class="hljs-comment">// Configure OrderQueryServiceRpc.getOrderByOrderId(...).</span>        <span class="hljs-keyword">final</span> <span class="hljs-type">OrderDTO</span> <span class="hljs-variable">orderDTO</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderDTO</span>();        orderDTO.setOrderId(<span class="hljs-number">0L</span>);        orderDTO.setSrcOrderId(<span class="hljs-string">&quot;srcOrderId&quot;</span>);        orderDTO.setSrcPlatId(<span class="hljs-number">0</span>);        orderDTO.setSrcOrderType(<span class="hljs-number">0</span>);        orderDTO.setSrcInnerType(<span class="hljs-number">0</span>);        orderDTO.setSrcInnerOrderId(<span class="hljs-number">0L</span>);        orderDTO.setOrderType(<span class="hljs-number">0</span>);        orderDTO.setOrderStatus(<span class="hljs-number">0</span>);        orderDTO.setOrderStatusTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GregorianCalendar</span>(<span class="hljs-number">2020</span>, Calendar.JANUARY, <span class="hljs-number">1</span>).getTime());        orderDTO.setOrderStartTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GregorianCalendar</span>(<span class="hljs-number">2020</span>, Calendar.JANUARY, <span class="hljs-number">1</span>).getTime());        <span class="hljs-keyword">final</span> ServiceResponse&lt;OrderDTO&gt; orderDTOServiceResponse = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceResponse</span>&lt;&gt;(orderDTO);        when(mockOrderQueryServiceRpc.getOrderByOrderId(eq(<span class="hljs-number">0L</span>), any(String[].class))).thenReturn(orderDTOServiceResponse);        <span class="hljs-comment">// Run the test</span>        <span class="hljs-keyword">final</span> List&lt;SystemCancelOrderDto&gt; result = orderServiceImplUnderTest.getOrderInfoByOrderId4OrderSystemCancel(<span class="hljs-number">0L</span>);        <span class="hljs-comment">// Verify the results</span>    &#125;&#125;</code></pre><h3 id="插件-快速自动化"><a href="#插件-快速自动化" class="headerlink" title="插件 快速自动化"></a>插件 快速自动化</h3><p>Squaretest</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><strong>JUnit5</strong> 要引入 <strong>mockito-junit-jupiter</strong> 包，并使用 <strong>@ExtendWith</strong> 注解来引入</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- mockito for junit5 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mockito<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mockito-junit-jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.23.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h1 id="单元测试准则"><a href="#单元测试准则" class="headerlink" title="单元测试准则"></a>单元测试准则</h1><h3 id="1-保持单元测试小巧-快速"><a href="#1-保持单元测试小巧-快速" class="headerlink" title="1. 保持单元测试小巧, 快速"></a>1. 保持单元测试小巧, 快速</h3><p>理论上, 任何代码提交前都应该完整跑一遍所有测试套件. 保持测试代码执行迅捷能够缩短迭代开发周期.</p><h3 id="2-单元测试应该是全自动且无交互"><a href="#2-单元测试应该是全自动且无交互" class="headerlink" title="2. 单元测试应该是全自动且无交互"></a>2. 单元测试应该是全自动且无交互</h3><p>测试套件通常是定期执行的, 执行过程必须完全自动化才有意义. 需要人工检查输出结果的测试不是一个好的单元测试.</p><h3 id="3-让单元测试很容易跑起来"><a href="#3-让单元测试很容易跑起来" class="headerlink" title="3. 让单元测试很容易跑起来"></a>3. 让单元测试很容易跑起来</h3><p>对开发环境进行配置, 最好是敲条命令或是点个按钮就能把单个测试用例或测试套件跑起来.</p><h3 id="4-对测试进行评估"><a href="#4-对测试进行评估" class="headerlink" title="4. 对测试进行评估"></a>4. 对测试进行评估</h3><p>对执行的测试进行覆盖率分析, 得到精确的代码执行覆盖率, 并调查哪些代码未被执行.</p><h3 id="5-立即修正失败的测试"><a href="#5-立即修正失败的测试" class="headerlink" title="5. 立即修正失败的测试"></a>5. 立即修正失败的测试</h3><p>每个开发人员在提交前都应该保证新的测试用例执行成功, 当有代码提交时, 现有测试用例也都能跑通.</p><p>如果一个定期执行的测试用例执行失败, 整个团队应该放下手上的工作优先解决这个问题.</p><h3 id="6-把测试维持在单元级别"><a href="#6-把测试维持在单元级别" class="headerlink" title="6. 把测试维持在单元级别"></a>6. 把测试维持在单元级别</h3><p>单元测试即类 (Class) 的测试. 一个 “测试类” 应该只对应于一个 “被测类”, 并且 “被测类” 的行为应该被隔离测试. 必须谨慎避免使用单元测试框架来测试整个程序的工作流, 这样的测试既低效又难维护. 工作流测试 (译注: 指跨模块&#x2F;类的数据流测试) 有它自己的地盘, 但它绝不是单元测试, 必须单独建立和执行.</p><h3 id="7-由简入繁"><a href="#7-由简入繁" class="headerlink" title="7. 由简入繁"></a>7. 由简入繁</h3><p>最简单的测试也远远胜过完全没有测试. 一个简单的 “测试类” 会促使建立 “被测类” 基本的测试骨架, 可以对构建环境, 单元测试环境, 执行环境以及覆盖率分析工具等有效性进行检查, 同时也可以证明 “被测类” 能够被整合和调用.</p><p>下面便是单元测试版的<em>Hello, world!</em>:</p><pre><code class="hljs reasonml">void test<span class="hljs-constructor">DefaultConstruction()</span>&#123;   Foo foo = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Foo()</span>;   <span class="hljs-keyword">assert</span><span class="hljs-constructor">NotNull(<span class="hljs-params">foo</span>)</span>;&#125;</code></pre><h3 id="8-保持测试的独立性"><a href="#8-保持测试的独立性" class="headerlink" title="8. 保持测试的独立性"></a>8. 保持测试的独立性</h3><p>为了保证测试稳定可靠且便于维护, 测试用例之间决不能有相互依赖, 也不能依赖执行的先后次序.</p><h3 id="9-Keep-tests-close-to-the-class-being-tested"><a href="#9-Keep-tests-close-to-the-class-being-tested" class="headerlink" title="9. Keep tests close to the class being tested"></a>9. Keep tests close to the class being tested</h3><p>[译注: 有意翻译该规则, 个人认为本条规则值得商榷, 大部分 C++, Objective-C和 Python 库均把测试代码从功能代码目录中独立出来, 通常是创建一个和<code>src</code>目录同级的<code>tests</code>目录, 被测模块&#x2F;类名之前也常常<em>不加</em><code>Test</code>前缀. 这么做保证功能代码和测试代码隔离, 目录结构清晰, 并且发布源码的时候更容易排除测试用例.]</p><p>If the class to test is Foo the test class should be called FooTest (not TestFoo) and kept in the same package (directory) as Foo. Keeping test classes in separate directory trees makes them harder to access and maintain.</p><p>Make sure the build environment is configured so that the test classes doesn’t make its way into production libraries or executables.</p><h3 id="10-合理的命名测试用例"><a href="#10-合理的命名测试用例" class="headerlink" title="10. 合理的命名测试用例"></a>10. 合理的命名测试用例</h3><p>确保每个方法只测试 “被测类” 的一个明确特性, 并相应的命名测试方法. 典型的命名俗定是<code>test[what]</code>, 比如<code>testSaveAs()</code>,<code>testAddListener()</code>,<code>testDeleteProperty()</code>等.</p><h3 id="11-只测公有接口"><a href="#11-只测公有接口" class="headerlink" title="11. 只测公有接口"></a>11. 只测公有接口</h3><p>单元测试可以被定义为<em>通过类的公有 API 对类进行测试</em>. 一些测试工具允许测试一个类的私有成员, 但这种做法应该避免, 它让测试变得繁琐而且更难维护. 如果有私有成员确实需要进行直接测试, 可以考虑把它重构到工具类的公有方法中. 但要注意这么做是为了改善设计, 而不是帮助测试.</p><h3 id="12-看成是黑盒"><a href="#12-看成是黑盒" class="headerlink" title="12. 看成是黑盒"></a>12. 看成是黑盒</h3><p>站在第三方使用者的角度, 测试一个类是否满足规定的需求. 并设法让它出问题.</p><h3 id="13-看成是白盒"><a href="#13-看成是白盒" class="headerlink" title="13. 看成是白盒"></a>13. 看成是白盒</h3><p>毕竟被测试类是程序员自写自测的, 应该在最复杂的逻辑部分多花些精力测试.</p><h3 id="14-芝麻函数也要测试"><a href="#14-芝麻函数也要测试" class="headerlink" title="14. 芝麻函数也要测试"></a>14. 芝麻函数也要测试</h3><p>通常建议所有重要的函数都应该被测试到, 一些芝麻方法比如简单的<code>setter</code>和<code>getter</code>都可以忽略. 但是仍然有充分的理由支持测试芝麻函数:</p><ul><li><em>芝麻</em>很难定义. 对于不同的人有不同的理解.</li><li>从黑盒测试的观点看, 是无法知道哪些代码是芝麻级别的.</li><li>即便是再芝麻的函数, 也可能包含错误, 通常是 “复制粘贴” 代码的后果:</li></ul><pre><code class="hljs csharp"><span class="hljs-keyword">private</span> <span class="hljs-built_in">double</span> weight_;<span class="hljs-keyword">private</span> <span class="hljs-built_in">double</span> x_, y_;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setWeight</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> weight</span>)</span>&#123;  weight = weight_;  <span class="hljs-comment">// error</span>&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">getX</span>()</span>&#123;  <span class="hljs-keyword">return</span> x_;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">getY</span>()</span>&#123;  <span class="hljs-keyword">return</span> x_;  <span class="hljs-comment">// error</span>&#125;</code></pre><p>因此建议测试所有方法. 毕竟芝麻用例也容易测试.</p><h3 id="15-先关注执行覆盖率"><a href="#15-先关注执行覆盖率" class="headerlink" title="15. 先关注执行覆盖率"></a><a href="https://github.com/yangyubo/zh-unit-testing-guidelines#15-%E5%85%88%E5%85%B3%E6%B3%A8%E6%89%A7%E8%A1%8C%E8%A6%86%E7%9B%96%E7%8E%87">1</a>5. 先关注执行覆盖率</h3><p>区别对待<em>执行覆盖率</em>和<em>实际测试覆盖率</em>. 测试的最初目标应该是确保较高的执行覆盖率. 这样能保证代码在<em>少量</em>参数值输入时能执行成功. 一旦执行覆盖率就绪, 就应该开始改进测试覆盖率了. 注意, 实际的测试覆盖率很难衡量 (而且往往趋近于 0%).</p><p>思考以下公有方法:</p><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setLength</span><span class="hljs-params">(<span class="hljs-type">double</span> length)</span></span>;</code></pre><p>调用<code>setLength(1.0)</code>你可能会得到 100% 的执行覆盖率. 但要达到 100% 的实际测试覆盖率, 有多少个<code>double</code>浮点数这个方法就必须被调用多少次, 并且要一一验证行为的正确性. 这无疑是不可能的任务.</p><h3 id="16-覆盖边界值"><a href="#16-覆盖边界值" class="headerlink" title="16. 覆盖边界值"></a>16. 覆盖边界值</h3><p>确保参数边界值均被覆盖. 对于数字, 测试负数, 0, 正数, 最小值, 最大值, NaN (非数字), 无穷大等. 对于字符串, 测试空字符串, 单字符, 非 ASCII 字符串, 多字节字符串等. 对于集合类型, 测试空, 1, 第一个, 最后一个等. 对于日期, 测试 1月1号, 2月29号, 12月31号等. 被测试的类本身也会暗示一些特定情况下的边界值. 要点是尽可能彻底的测试这些边界值, 因为它们都是主要 “疑犯”.</p><h3 id="17-提供一个随机值生成器"><a href="#17-提供一个随机值生成器" class="headerlink" title="17. 提供一个随机值生成器"></a>17. 提供一个随机值生成器</h3><p>当边界值都覆盖了, 另一个能进一步改善测试覆盖率的简单方法就是生成随机参数, 这样每次执行测试都会有不同的输入.</p><p>想要做到这点, 需要提供一个用来生成基本类型 (如: 浮点数, 整型, 字符串, 日期等) 随机值的工具类. 生成器应该覆盖各种类型的所有取值范围.</p><p>如果测试时间比较短, 可以考虑再裹上一层循环, 覆盖尽可能多的输入组合. 下面的例子是验证两次转换 little endian 和 big endian 字节序后是否返回原值. 由于测试过程很快, 可以让它跑上个一百万次.</p><pre><code class="hljs reasonml">void test<span class="hljs-constructor">ByteSwapper()</span>&#123;  <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++) &#123;    double v0 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Random</span>.</span></span>get<span class="hljs-constructor">Double()</span>;    double v1 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteSwapper</span>.</span></span>swap(v0);    double v2 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteSwapper</span>.</span></span>swap(v1);    <span class="hljs-keyword">assert</span><span class="hljs-constructor">Equals(<span class="hljs-params">v0</span>, <span class="hljs-params">v2</span>)</span>;  &#125;&#125;</code></pre><h3 id="18-每个特性只测一次"><a href="#18-每个特性只测一次" class="headerlink" title="18. 每个特性只测一次"></a>18. 每个特性只测一次</h3><p>在测试模式下, 有时会情不自禁的滥用断言. 这种做法会导致维护更困难, 需要极力避免. 仅对测试方法名指示的特性进行明确测试.</p><p>因为对于一般性代码而言, 保证测试代码尽可能少是一个重要目标.</p><h3 id="19-使用显式断言"><a href="#19-使用显式断言" class="headerlink" title="19. 使用显式断言"></a>19. 使用显式断言</h3><p>应该总是优先使用<code>assertEquals(a, b)</code>而不是<code>assertTrue(a == b)</code>, 因为前者会给出更有意义的测试失败信息. 在事先不确定输入值的情况下, 这条规则尤为重要, 比如之前使用随机参数值组合的例子.</p><h3 id="20-提供反向测试"><a href="#20-提供反向测试" class="headerlink" title="20. 提供反向测试"></a>20. 提供反向测试</h3><p>反向测试是指刻意编写问题代码, 来验证鲁棒性和能否正确的处理错误.</p><p>假设如下方法的参数如果传进去的是负数, 会立马抛出异常:</p><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">setLength</span><span class="hljs-params">(<span class="hljs-type">double</span> length)</span> <span class="hljs-keyword">throws</span> IllegalArgumentExcepti</code></pre><p>可以用下面的方法来测试这个特例是否被正确处理:</p><pre><code class="hljs scss">try &#123;  <span class="hljs-built_in">setLength</span>(-<span class="hljs-number">1.0</span>);  <span class="hljs-built_in">fail</span>();  <span class="hljs-comment">// If we get here, something went wrong</span>&#125;catch (IllegalArgumentException exception) &#123;  <span class="hljs-comment">// If we get here, all is fine</span>&#125;</code></pre><h3 id="21-代码设计时谨记测试"><a href="#21-代码设计时谨记测试" class="headerlink" title="21. 代码设计时谨记测试"></a>21. 代码设计时谨记测试</h3><p>编写和维护单元测试的代价是很高的, 减少代码中的公有接口和循环复杂度是降低成本, 使高覆盖率测试代码更易于编写和维护的有效方法.</p><p>一些建议:</p><blockquote><ul><li>使类成员常量化, 在构造函数中进行初始化. 减少<code>setter</code>方法的数量.</li><li>限制过度使用继承和公有虚函数.</li><li>通过使用友元类 (C++) 或包作用域 (Java) 来减少公有接口.</li><li>避免不必要的逻辑分支.</li><li>在逻辑分支中编写尽可能少的代码.</li><li>在公有和私有接口中尽量多用异常和断言验证参数参数的有效性.</li><li>限制使用快捷函数. 对于黑箱而言, 所有方法都必须一视同仁的进行测试. 思考以下简短的例子:</li></ul><pre><code class="hljs processing"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">scale</span>(<span class="hljs-type">double</span> x0, <span class="hljs-type">double</span> y0, <span class="hljs-type">double</span> scaleFactor)&#123;  <span class="hljs-comment">// scaling logic</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">scale</span>(<span class="hljs-type">double</span> x0, <span class="hljs-type">double</span> y0)&#123;  <span class="hljs-built_in">scale</span>(x0, y0, <span class="hljs-number">1.0</span>);&#125;</code></pre><ul><li>删除后者可以简化测试, 但用户代码的工作量也将略微增加.</li></ul></blockquote><h3 id="22-不要访问预设的外部资源"><a href="#22-不要访问预设的外部资源" class="headerlink" title="22. 不要访问预设的外部资源"></a>22. 不要访问预设的外部资源</h3><p>单元测试代码不应该假定外部的执行环境, 以便在任何时候&#x2F;任何地方都能执行. 为了向测试提供必需的资源, 这些资源应该由测试本身提供.</p><p>比如一个解析某类型文件的类, 可以把文件内容嵌入到测试代码里, 在测试的时候写入到临时文件, 测试结束再删除, 而不是从预定的地址直接读取.</p><h3 id="23-权衡测试成本"><a href="#23-权衡测试成本" class="headerlink" title="23. 权衡测试成本"></a>23. 权衡测试成本</h3><p>不写单元测试的代价很高, 但是写单元测试的代价同样很高. 要在这两者之间做适当的权衡, 如果用执行覆盖率来衡量, 业界标准通常在 80% 左右.</p><p>很典型的, 读写外部资源的错误处理和异常处理就很难达到百分百的执行覆盖率. 模拟数据库在事务处理到一半时发生故障并不是办不到, 但相对于进行大范围的代码审查, 代价可能太大了.</p><h3 id="24-安排测试优先次序"><a href="#24-安排测试优先次序" class="headerlink" title="24. 安排测试优先次序"></a>24. 安排测试优先次序</h3><p>单元测试是典型的自底向上过程, 如果没有足够的资源测试一个系统的所有模块, 就应该先把重点放在较底层的模块.</p><h3 id="25-测试代码要考虑错误处理"><a href="#25-测试代码要考虑错误处理" class="headerlink" title="25. 测试代码要考虑错误处理"></a>25. 测试代码要考虑错误处理</h3><p>考虑下面的这个例子:</p><pre><code class="hljs reasonml">Handle handle = manager.get<span class="hljs-constructor">Handle()</span>;<span class="hljs-keyword">assert</span><span class="hljs-constructor">NotNull(<span class="hljs-params">handle</span>)</span>;String handleName = handle.get<span class="hljs-constructor">Name()</span>;<span class="hljs-keyword">assert</span><span class="hljs-constructor">Equals(<span class="hljs-params">handleName</span>, <span class="hljs-string">&quot;handle-01&quot;</span>)</span>;</code></pre><p>如果第一个断言失败, 后续语句会导致代码崩溃, 剩下的测试都无法执行. 任何时候都要为测试失败做好准备, 避免单个失败的测试项中断整个测试套件的执行. 上面的例子可以重写成:</p><pre><code class="hljs lasso"><span class="hljs-keyword">Handle</span> <span class="hljs-keyword">handle</span> = manager.getHandle();assertNotNull(<span class="hljs-keyword">handle</span>);<span class="hljs-keyword">if</span> (<span class="hljs-keyword">handle</span> == <span class="hljs-built_in">null</span>) <span class="hljs-keyword">return</span>;<span class="hljs-built_in">String</span> handleName = <span class="hljs-keyword">handle</span>.getName();assertEquals(handleName, <span class="hljs-string">&quot;handle-01&quot;</span>);</code></pre><h3 id="26-写测试用例重现-bug"><a href="#26-写测试用例重现-bug" class="headerlink" title="26. 写测试用例重现 bug"></a>26. 写测试用例重现 bug</h3><p>每上报一个 bug, 都要写一个测试用例来重现这个 bug (即无法通过测试), 并用它作为成功修正代码的检验标准.</p><h3 id="27-了解局限"><a href="#27-了解局限" class="headerlink" title="27. 了解局限"></a>27. 了解局限</h3><p><em>单元测试永远无法证明代码的正确性!!</em></p><p>一个跑失败的测试可能表明代码有错误, 但一个跑成功的测试什么也证明不了.</p><p>单元测试最有效的使用场合是在一个较低的层级验证并文档化需求, 以及<em>回归测试</em>: 开发或重构代码时，不会破坏已有功能的正确性.</p>]]></content>
    
    
    <categories>
      
      <category>质量保障篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单测实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS网站变灰代码</title>
    <link href="/2023/02/06/CSS%E7%BD%91%E7%AB%99%E5%8F%98%E7%81%B0%E4%BB%A3%E7%A0%81/"/>
    <url>/2023/02/06/CSS%E7%BD%91%E7%AB%99%E5%8F%98%E7%81%B0%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="清明悼念"><a href="#清明悼念" class="headerlink" title="清明悼念"></a>清明悼念</h1><p>标签： #Share</p><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>2020年4月4日，举国悼念，所有网站均变成灰色的CSS代码，如下：</p><pre><code class="hljs css"><span class="hljs-selector-class">.gray</span> &#123;    -webkit-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);    -moz-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);    -ms-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);    -o-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);    <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);    <span class="hljs-attribute">filter</span>: progid:DXImageTransform.Microsoft.<span class="hljs-built_in">BasicImage</span>(grayscale=<span class="hljs-number">1</span>);&#125;</code></pre><p>对body元素增加样式即可</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>“如果有后人来撰写今天的历史，那他们将发现没有任何文字词藻能够写尽这场灾难的残酷，也没有任何语言修辞能描述人类为生</p><p>存所付出的艰苦卓绝的努力。</p><p>我们将怀揣火种走过黑暗长夜，跨过战友的遗骸，踏过荆棘和深渊，最终在累累尸骨上重新点燃种族延续的火炬。</p><p>我知道你们并不需要历史来记载功勋，也无谓那些空虚华美的称颂。</p><p>只要山川河流、千万英灵，见证过我们前仆后继的跋涉和永不放弃的努力。”</p><p>​<strong>—— 敬平凡的人类</strong></p>]]></content>
    
    
    <categories>
      
      <category>前端篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS网站变灰代码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CV程序员的一次进步</title>
    <link href="/2023/02/06/CV%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%B8%80%E6%AC%A1%E8%BF%9B%E6%AD%A5/"/>
    <url>/2023/02/06/CV%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%B8%80%E6%AC%A1%E8%BF%9B%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<p>标签： #Share</p><h2 id="CV程序员的一次进步"><a href="#CV程序员的一次进步" class="headerlink" title="CV程序员的一次进步"></a>CV程序员的一次进步</h2><blockquote><p>原文链接：<a href="https://juejin.im/post/5dfe2e72518825125f39a2de?utm_source=gold_browser_extension">掘金</a></p></blockquote><h3 id="一、调整顺序，让程序更高效"><a href="#一、调整顺序，让程序更高效" class="headerlink" title="一、调整顺序，让程序更高效"></a>一、调整顺序，让程序更高效</h3><p>假设业务需求是这样：会员，第一次登陆时，需要发一条感谢短信。如果没有经过思考，代码直接这样写了</p><pre><code class="hljs scss"><span class="hljs-built_in">if</span>(isUserVip &amp;&amp; isFirstLogin)&#123;    <span class="hljs-built_in">sendMsg</span>();&#125;复制代码</code></pre><p><strong>假设总共有5个请求，isUserVip通过的有3个请求，isFirstLogin通过的有1个请求。</strong> 那么以上代码，isUserVip执行的次数为5次，isFirstLogin执行的次数也是3次，如下：</p><p><img src="/2023/02/06/CV%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%B8%80%E6%AC%A1%E8%BF%9B%E6%AD%A5/16f4312ee2db2f80" alt="img"></p><p><strong>如果调整一下isUserVip和isFirstLogin的顺序呢？</strong></p><pre><code class="hljs java"><span class="hljs-keyword">if</span>(isFirstLogin &amp;&amp; isUserVip )&#123;    sendMsg();&#125;</code></pre><p>isFirstLogin执行的次数是5次，isUserVip执行的次数是1次，如下：</p><p><img src="/2023/02/06/CV%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%B8%80%E6%AC%A1%E8%BF%9B%E6%AD%A5/16f4319b9710a1a9" alt="img"></p><p><strong>酱紫你的程序是否更高效呢？</strong></p><h3 id="二、是否创建了不必要的对象。"><a href="#二、是否创建了不必要的对象。" class="headerlink" title="二、是否创建了不必要的对象。"></a>二、是否创建了不必要的对象。</h3><p>举个粟子吧，判断用户会员是否处于有效期，通常有以下类似代码：</p><pre><code class="hljs java"><span class="hljs-comment">//判断用户会员是否在有效期</span><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isUserVIPValid</span><span class="hljs-params">()</span> &#123;  <span class="hljs-type">Date</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();  <span class="hljs-type">Calendar</span> <span class="hljs-variable">gmtCal</span> <span class="hljs-operator">=</span> Calendar.getInstance();  gmtCal.set(<span class="hljs-number">2019</span>, Calendar.JANUARY, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);  <span class="hljs-type">Date</span> <span class="hljs-variable">beginTime</span> <span class="hljs-operator">=</span> gmtCal.getTime();  gmtCal.set(<span class="hljs-number">2020</span>, Calendar.JANUARY, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);  Date endTime= gmtCal.getTime();  <span class="hljs-keyword">return</span> now.compareTo(beginTime) &gt;= <span class="hljs-number">0</span> &amp;&amp; now.compareTo(endTime) &lt;= <span class="hljs-number">0</span>;&#125;</code></pre><p>但是呢，每次调用isUserVIPValid方法，都会创建Calendar和Date对象。其实吧，除了New Date，其他对象都是不变的，我们可以<strong>抽出全局变量</strong>，<strong>避免创建了不必要的对象</strong>，从而提高程序效率，如下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Date BEGIN_TIME;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Date END_TIME;    <span class="hljs-keyword">static</span> &#123;        <span class="hljs-type">Calendar</span> <span class="hljs-variable">gmtCal</span> <span class="hljs-operator">=</span> Calendar.getInstance();        gmtCal.set(<span class="hljs-number">2019</span>, Calendar.JANUARY, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);        BEGIN_TIME = gmtCal.getTime();        gmtCal.set(<span class="hljs-number">2020</span>, Calendar.JANUARY, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);        END_TIME = gmtCal.getTime();    &#125;    <span class="hljs-comment">//判断用户会员是否在有效期</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isUserVIPValid</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">Date</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();        <span class="hljs-keyword">return</span> now.compareTo(BEGIN_TIME) &gt;= <span class="hljs-number">0</span> &amp;&amp; now.compareTo(END_TIME) &lt;= <span class="hljs-number">0</span>;    &#125;&#125;</code></pre><h3 id="三、有没有查多了数据？"><a href="#三、有没有查多了数据？" class="headerlink" title="三、有没有查多了数据？"></a>三、有没有查多了数据？</h3><p>大家都知道，查库是比较耗时的操作，尤其数据量大的时候。所以，查询DB时，我们取所需就好，没有必要大包大揽。</p><p>假设业务场景是这样：查询某个用户是否是会员。曾经看过实现代码是这样。。。</p><pre><code class="hljs java">List&lt;Long&gt; userIds = sqlMap.queryList(<span class="hljs-string">&quot;select userId from user where vip=1&quot;</span>);<span class="hljs-type">boolean</span> <span class="hljs-variable">isVip</span> <span class="hljs-operator">=</span> userIds.contains(userId);</code></pre><p>为什么先把所有会有查出来，再判断是否包含这个useId，来确定useId是否是会员呢？直接把userId传进sql，它不香吗？如下：</p><pre><code class="hljs java"><span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> sqlMap.queryObject(<span class="hljs-string">&quot;select userId from user where userId=&#x27;userId&#x27; and vip=&#x27;1&#x27; &quot;</span>)<span class="hljs-type">boolean</span> <span class="hljs-variable">isVip</span> <span class="hljs-operator">=</span> userId！=<span class="hljs-literal">null</span>;</code></pre><p>实际上，我们除了把查询条件都传过去，避免数据库查多余的数据回来，还可以通过<strong>select 具体字段</strong>代替<code>select *</code>，从而使程序更高效。</p><h3 id="四、加了一行通知类的代码，总不能影响到主要流程吧。"><a href="#四、加了一行通知类的代码，总不能影响到主要流程吧。" class="headerlink" title="四、加了一行通知类的代码，总不能影响到主要流程吧。"></a>四、加了一行通知类的代码，总不能影响到主要流程吧。</h3><p>假设业务流程这样：需要在用户登陆时，添加个短信通知它的粉丝。 很容易想到的实现流程如下：</p><p><img src="/2023/02/06/CV%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%B8%80%E6%AC%A1%E8%BF%9B%E6%AD%A5/16f47ecebb5949d7" alt="img"></p><p>假设提供sendMsgNotify服务的<strong>系统挂了</strong>，或者<strong>调用sendMsgNotify失败</strong>了，那么用户登陆就失败了。。。</p><p>一个通知功能导致了登陆主流程不可用，明显的捡了芝麻丢西瓜。那么有没有鱼鱼熊掌兼得的方法呢？有的，给发短信接口<strong>捕获异常处理</strong>，或者<strong>另开线程异步处理</strong>，如下：</p><p><img src="/2023/02/06/CV%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%B8%80%E6%AC%A1%E8%BF%9B%E6%AD%A5/16f47f59d45320c4" alt="img"></p><p>因此，我们添加通知类等不是非主要，可降级的接口时，应该静下心来考虑是否会影响主要流程，思考怎么处理最好。</p><h3 id="五、对空指针保持嗅觉，如使用equals比较时，常量或确定值放左边。"><a href="#五、对空指针保持嗅觉，如使用equals比较时，常量或确定值放左边。" class="headerlink" title="五、对空指针保持嗅觉，如使用equals比较时，常量或确定值放左边。"></a>五、对空指针保持嗅觉，如使用equals比较时，常量或确定值放左边。</h3><p>NullPointException在Java世界早已司空见惯，我们在写代码时，可以三思而后写，尽量避免低级的空指针问题。</p><p>比如有以下业务场景，判断用户是否是会员，经常可见如下代码：</p><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">isVip</span> <span class="hljs-operator">=</span> user.getUserFlag().equals(<span class="hljs-string">&quot;1&quot;</span>);</code></pre><p>如果让这个行代码上生产环境，待君蓦然回首，可能那空指针bug，就在灯火阑珊处。显然，这样可能会产生空指针异常，因为user.getUserFlag()可能是null。</p><p>怎样避免空指针问题呢？把常量1放到左边就可以啦，如下：</p><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">isVip</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1&quot;</span>.equals(user.getUserFlag());</code></pre><h3 id="六、你的关键业务代码是否有日志保驾护航？"><a href="#六、你的关键业务代码是否有日志保驾护航？" class="headerlink" title="六、你的关键业务代码是否有日志保驾护航？"></a>六、你的关键业务代码是否有日志保驾护航？</h3><p>关键业务代码无论身处何地，都应该有足够的<strong>日志</strong>保驾护航。</p><p>比如：<strong>你实现转账业务，转个几百万，然后转失败了，接着客户投诉，然后你还没有打印到日志，想想那种水深火热的困境下，你却毫无办法</strong>。。。</p><p>那么，你的转账业务都<strong>需要那些日志信息</strong>呢？至少，方法调用前，入参需要打印需要吧，接口调用后，需要捕获一下异常吧，同时打印异常相关日志吧，如下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(TransferDTO transferDTO)</span>&#123;    log.info(<span class="hljs-string">&quot;invoke tranfer begin&quot;</span>);    <span class="hljs-comment">//打印入参</span>    log.info(<span class="hljs-string">&quot;invoke tranfer,paramters:&#123;&#125;&quot;</span>,transferDTO);    <span class="hljs-keyword">try</span> &#123;      res=  transferService.transfer(transferDTO);    &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;     log.error(<span class="hljs-string">&quot;transfer fail,cifno:&#123;&#125;，account：&#123;&#125;&quot;</span>,transferDTO.getCifno（），     transferDTO.getaccount（）)     log.error(<span class="hljs-string">&quot;transfer fail,exception:&#123;&#125;&quot;</span>,e);    &#125;    log.info(<span class="hljs-string">&quot;invoke tranfer end&quot;</span>);    &#125;</code></pre><p>除了打印足够的日志，我们还需要注意一点是，<strong>日志级别别混淆使用</strong>，别本该打印info的日志，你却打印成error级别，告警半夜三更催你起来排查问题就不好了。</p><h3 id="七、对于行数比较多的函数，是否可以划分小函数来优化呢？"><a href="#七、对于行数比较多的函数，是否可以划分小函数来优化呢？" class="headerlink" title="七、对于行数比较多的函数，是否可以划分小函数来优化呢？"></a>七、对于行数比较多的函数，是否可以划分小函数来优化呢？</h3><p>我们在维护老代码的时候，经常会见到一坨坨的代码，有些<strong>函数几百行甚至上千行</strong>，阅读起来比较吃力。</p><p>假设现在有以下代码</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Vector&lt;Order&gt; orders = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>&lt;Order&gt;();    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printOwing</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">//print banner</span>        System.out.println(<span class="hljs-string">&quot;****************&quot;</span>);        System.out.println(<span class="hljs-string">&quot;*****customer Owes *****&quot;</span>);        System.out.println(<span class="hljs-string">&quot;****************&quot;</span>);        <span class="hljs-comment">//calculate totalAmount</span>        <span class="hljs-type">Enumeration</span> <span class="hljs-variable">env</span> <span class="hljs-operator">=</span> orders.elements();        <span class="hljs-type">double</span> <span class="hljs-variable">totalAmount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.0</span>;        <span class="hljs-keyword">while</span> (env.hasMoreElements()) &#123;            <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> (Order) env.nextElement();            totalAmount += order.getAmout();        &#125;        <span class="hljs-comment">//print details</span>        System.out.println(<span class="hljs-string">&quot;name:&quot;</span> + name);        System.out.println(<span class="hljs-string">&quot;amount:&quot;</span> + totalAmount);    &#125;&#125;</code></pre><p><strong>划分为功能单一的小函数后：</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Vector&lt;Order&gt; orders = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>&lt;Order&gt;();    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printOwing</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">//print banner</span>        printBanner();        <span class="hljs-comment">//calculate totalAmount</span>        <span class="hljs-type">double</span> <span class="hljs-variable">totalAmount</span> <span class="hljs-operator">=</span> getTotalAmount();        <span class="hljs-comment">//print details</span>        printDetail(totalAmount);    &#125;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">printBanner</span><span class="hljs-params">()</span>&#123;        System.out.println(<span class="hljs-string">&quot;****************&quot;</span>);        System.out.println(<span class="hljs-string">&quot;*****customer Owes *****&quot;</span>);        System.out.println(<span class="hljs-string">&quot;****************&quot;</span>);    &#125;    <span class="hljs-type">double</span> <span class="hljs-title function_">getTotalAmount</span><span class="hljs-params">()</span>&#123;        <span class="hljs-type">Enumeration</span> <span class="hljs-variable">env</span> <span class="hljs-operator">=</span> orders.elements();        <span class="hljs-type">double</span> <span class="hljs-variable">totalAmount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.0</span>;        <span class="hljs-keyword">while</span> (env.hasMoreElements()) &#123;            <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> (Order) env.nextElement();            totalAmount += order.getAmout();        &#125;        <span class="hljs-keyword">return</span> totalAmount;    &#125;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">printDetail</span><span class="hljs-params">(<span class="hljs-type">double</span> totalAmount)</span>&#123;        System.out.println(<span class="hljs-string">&quot;name:&quot;</span> + name);        System.out.println(<span class="hljs-string">&quot;amount:&quot;</span> + totalAmount);    &#125;    &#125;</code></pre><p>一个过于<strong>冗长</strong>的函数或者一段<strong>需要注释才能让人理解</strong>用途的代码，可以考虑把它切分成一个功能明确的函数单元，并定义清晰简短的函数名，这样会让代码变得更加优雅。</p><h3 id="八、某些可变因素，如红包皮肤等等，做成配置化是否会更好呢。"><a href="#八、某些可变因素，如红包皮肤等等，做成配置化是否会更好呢。" class="headerlink" title="八、某些可变因素，如红包皮肤等等，做成配置化是否会更好呢。"></a>八、某些可变因素，如红包皮肤等等，做成配置化是否会更好呢。</h3><p>假如产品提了个红包需求，圣诞节的时候，红包皮肤为圣诞节相关的，春节的时候，红包皮肤等。</p><p>如果在代码写死控制，可有类似以下代码：</p><pre><code class="hljs java"><span class="hljs-keyword">if</span>(duringChristmas)&#123;   img = redPacketChristmasSkin;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(duringSpringFestival)&#123;   img =  redSpringFestivalSkin;&#125;......</code></pre><p>如果到了元宵节的时候，运营小姐姐突然又有想法，红包皮肤换成灯笼相关的，这时候，是不是要去修改代码了，重新发布了？</p><p>从一开始，实现一张红包皮肤的配置表，将红包皮肤做成配置化呢？更换红包皮肤，只需修改一下表数据就好了。</p><h3 id="九、多余的import-类，局部变量，没引用是不是应该删除"><a href="#九、多余的import-类，局部变量，没引用是不是应该删除" class="headerlink" title="九、多余的import 类，局部变量，没引用是不是应该删除"></a>九、多余的import 类，局部变量，没引用是不是应该删除</h3><p>如果看到代码存在没使用的import 类，没被使用到的局部变量等，就删掉吧，如下这些：</p><p><img src="/2023/02/06/CV%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%B8%80%E6%AC%A1%E8%BF%9B%E6%AD%A5/16f4b8634695bf0b" alt="img"></p><p>这些没被引用的局部变量，如果没被使用到，就删掉吧，它又不是陈年的女儿红，留着会越发醇香。它还是会一起被编译的，就是说它还是耗着资源的呢。</p><h3 id="十、查询大表时，是否加了索引，你的sql走了索引嘛。"><a href="#十、查询大表时，是否加了索引，你的sql走了索引嘛。" class="headerlink" title="十、查询大表时，是否加了索引，你的sql走了索引嘛。"></a>十、查询大表时，是否加了索引，你的sql走了索引嘛。</h3><p>查询数据量比较大的表时，我们需要确认三点：</p><ul><li>你的表是否建了索引</li><li>你的查询sql是否命中索引</li><li>你的sql是否还有优化余地</li></ul><p>一般情况下，数据量超过10万的表，就要考虑给表加索引了。哪些情况下，索引会失效呢？like通配符、索引列运算等会导致索引失效。有兴趣的朋友可以看一下我这篇文章。 <a href="https://juejin.im/post/5de99dd2518825125e1ba49d">后端程序员必备：索引失效的十大杂症</a></p><h3 id="十一、你的方法到底应该返回空集合还是-null呢？"><a href="#十一、你的方法到底应该返回空集合还是-null呢？" class="headerlink" title="十一、你的方法到底应该返回空集合还是 null呢？"></a>十一、你的方法到底应该返回空集合还是 null呢？</h3><p>如果返回null，调用方在忘记检测的时候，可能会抛出空指针异常。返回一个空集合呢，就省去该问题了。</p><p>mybatis查询的时候，如果返回一个集合，结果为空时也会返回一个空集合，而不是null。</p><p><strong>正例</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;UserResult&gt; <span class="hljs-title function_">getUserResultList</span><span class="hljs-params">()</span>&#123;    <span class="hljs-keyword">return</span> Collections.EMPTY_LIST;&#125;</code></pre><h3 id="十二、初始化集合时尽量指定其大小"><a href="#十二、初始化集合时尽量指定其大小" class="headerlink" title="十二、初始化集合时尽量指定其大小"></a>十二、初始化集合时尽量指定其大小</h3><p>阿里开发手册推荐了这一点</p><p><img src="/2023/02/06/CV%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%B8%80%E6%AC%A1%E8%BF%9B%E6%AD%A5/16f4c63cf25c4b13" alt="img"></p><p>假设你的map要存储的元素个数是15个左右，最优写法如下</p><pre><code class="hljs java"><span class="hljs-comment">//initialCapacity = 15/0.75+1=21</span><span class="hljs-type">Map</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>(<span class="hljs-number">21</span>);</code></pre><h3 id="十三、查询数据库时，如果数据返回过多，考虑分批进行。"><a href="#十三、查询数据库时，如果数据返回过多，考虑分批进行。" class="headerlink" title="十三、查询数据库时，如果数据返回过多，考虑分批进行。"></a>十三、查询数据库时，如果数据返回过多，考虑分批进行。</h3><p>假设你的订单表有10万数据要更新状态，不能一次性查询所有未更新的订单，要分批。</p><p><strong>反例：</strong></p><pre><code class="hljs java">List&lt;Order&gt; list = sqlMap.queryList(<span class="hljs-string">&quot;select * from Order where status=&#x27;0&#x27;&quot;</span>);<span class="hljs-keyword">for</span>(Order order:list)&#123;  order.setStatus(<span class="hljs-number">1</span>);  sqlMap.update(order);  &#125;</code></pre><p><strong>正例：</strong></p><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> sqlMap.queryCount(select <span class="hljs-title function_">count</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span> from Order <span class="hljs-type">where</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span><span class="hljs-string">&#x27;0&#x27;</span>);<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;    <span class="hljs-type">int</span> size=sqlMap.batchUpdate(params);    <span class="hljs-keyword">if</span>（size&lt;<span class="hljs-number">500</span>）&#123;        <span class="hljs-keyword">break</span>;    &#125;&#125;</code></pre><h3 id="十四、你的接口是否考虑到幂等性-并发情况呢？"><a href="#十四、你的接口是否考虑到幂等性-并发情况呢？" class="headerlink" title="十四、你的接口是否考虑到幂等性,并发情况呢？"></a>十四、你的接口是否考虑到幂等性,并发情况呢？</h3><p><strong>幂等性是什么？</strong> 一次和多次请求某一个资源对于资源本身应该具有同样的结果。就是说，其任意多次执行对资源本身所产生的影响均与一次执行的影响相同。</p><p><strong>为什么需要幂等性？</strong></p><ul><li>用户在APP上连续点击了多次提交订单，总不能生成多个订单吧</li><li>用户因为网络卡了，连续点击发送消息，接受者总不能收到重复的同一条消息吧。</li></ul><p><strong>假设有业务场景：</strong></p><p>用户点击下载按钮，系统开始下载文件，用户再次点击下载，会提示文件正在下载中。</p><p>有一部分人会这样实现：</p><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> sqlMap.selectCount(<span class="hljs-string">&quot;select count(1) from excel where state=1&quot;</span>);<span class="hljs-keyword">if</span>(count&lt;=<span class="hljs-number">0</span>)&#123;    Excel.setStatus(<span class="hljs-number">1</span>);    updateExcelStatus();    downLoadExcel();&#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-string">&quot;文件正在下载中&quot;</span>&#125;</code></pre><p>我们可以看一下，两个请求过来可能会有什么问题？</p><p><img src="/2023/02/06/CV%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%B8%80%E6%AC%A1%E8%BF%9B%E6%AD%A5/16f4d0dc9516f996" alt="img"></p><p>执行流程：</p><ul><li>第一步，A查询没有下载中的文件。</li><li>第二步，B查询没有下载中的文件。</li><li>第三步，A开始下载文件</li><li>第四部，B 开始下载文件</li></ul><p>显然，这样有问题，同时两个文件在下载了。正确的实现方式呢？</p><pre><code class="hljs java"><span class="hljs-keyword">if</span>(updateExcelStatus(<span class="hljs-number">1</span>)&#123;    downLoadExcel(); &#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-string">&quot;文件正在下载中&quot;</span>&#125;</code></pre><h3 id="十五、用一个私有构造器强化你的工具类，此不美哉？"><a href="#十五、用一个私有构造器强化你的工具类，此不美哉？" class="headerlink" title="十五、用一个私有构造器强化你的工具类，此不美哉？"></a>十五、用一个私有构造器强化你的工具类，此不美哉？</h3><p>工具类的方法都是静态方法，通过类来直接调用即可。但是有些调用方可能会先实例化，再用对象去调用，而这就不好了。怎么避免这种情况，让你的工具类到达可控状态呢，<strong>添加私有构造器</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringUtis</span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-title function_">StringUtis</span><span class="hljs-params">()</span>&#123;&#125; <span class="hljs-comment">///私有构造类，防止意外实例出现</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> bool <span class="hljs-title function_">validataString</span><span class="hljs-params">(String str)</span>&#123;    &#125;&#125;</code></pre><h3 id="十六、基本不变的用户数据，缓存起来，性能是否有所提升呢"><a href="#十六、基本不变的用户数据，缓存起来，性能是否有所提升呢" class="headerlink" title="十六、基本不变的用户数据，缓存起来，性能是否有所提升呢"></a>十六、基本不变的用户数据，缓存起来，性能是否有所提升呢</h3><p>假设你的接口需要查询很多次数据库，获取到各中数据，然后再根据这些数据进行各种排序等等操作，这一系列猛如虎的操作下来，接口性能肯定不好。典型应用场景比如：直播列表这些。</p><p>那么，怎么优化呢？剖析你排序的各部分数据，实时变的数据，继续查DB，不变的数据，如用户年龄这些，搞个定时任务，把它们从DB拉取到缓存，直接走缓存。</p><p>因此，这个点的思考就是，在恰当地时机，适当的使用缓存。</p>]]></content>
    
    
    <categories>
      
      <category>程序人生篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CV程序员的一次进步</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docsify篇</title>
    <link href="/2023/02/06/Docsify%E7%AF%87/"/>
    <url>/2023/02/06/Docsify%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="Docsify"><a href="#Docsify" class="headerlink" title="Docsify"></a>Docsify</h1><p>标签： #Share</p><p>docsify 是一个动态生成文档网站的工具。不同于 GitBook、Hexo 的地方是它不会生成将 .md 转成 .html 文件，所有转换工作都是在运行时进行。</p><p>这将非常实用，如果只是需要快速的搭建一个小型的文档网站，或者不想因为生成的一堆 .html 文件“污染” commit 记录，只需要创建一个 index.html 就可以开始写文档而且直接部署在 GitHub Pages。</p><h2 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h2><p><a href="https://docsify.js.org/#/zh-cn/quickstart">https://docsify.js.org/#/zh-cn/quickstart</a></p><h2 id="提前准备"><a href="#提前准备" class="headerlink" title="提前准备"></a>提前准备</h2><blockquote><p>安装Node.js   进行相关配置即可</p></blockquote><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><pre><code class="hljs stylus"><span class="hljs-number">1</span>.合适位置创建文件夹，作为根目录<span class="hljs-number">2</span>.文件夹下(cmd 当前文件夹)执行 npm <span class="hljs-selector-tag">i</span> docsify-cli -g   <span class="hljs-number">3</span><span class="hljs-selector-class">.docsify</span> init ./docs</code></pre><h2 id="开始写文档"><a href="#开始写文档" class="headerlink" title="开始写文档"></a><a href="https://docsify.js.org/#/zh-cn/quickstart?id=%E5%BC%80%E5%A7%8B%E5%86%99%E6%96%87%E6%A1%A3">开始写文档</a></h2><p>初始化成功后，可以看到 <code>./docs</code> 目录下创建的几个文件</p><ul><li><code>index.html</code> 入口文件</li><li><code>README.md</code> 会做为主页内容渲染</li><li><code>.nojekyll</code> 用于阻止 GitHub Pages 会忽略掉下划线开头的文件</li></ul><p>直接编辑 <code>docs/README.md</code> 就能更新网站内容</p><h2 id="个人建议的基本配置"><a href="#个人建议的基本配置" class="headerlink" title="个人建议的基本配置"></a>个人建议的基本配置</h2><blockquote><ol><li>开启封面，好看的封面</li><li>文档书写时注意一级，二级标题，图片等</li><li>必要位置的Logo，文档标题，html标题等等</li><li>开启全局搜索功能</li><li>代码高亮</li></ol></blockquote><h2 id="基本配置Demo"><a href="#基本配置Demo" class="headerlink" title="基本配置Demo"></a>基本配置Demo</h2><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Kerwin&#x27;s Demo<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge,chrome=1&quot;</span> /&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;Description&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;vue.css&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;icon&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://img.alicdn.com/tfs/TB1kCs_er_I8KJjy1XaXXbsxpXa-419-495.png&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;image/png&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-property">$docsify</span> = &#123;</span><span class="language-javascript">      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;This is Kerwin Demo&#x27;</span>,</span><span class="language-javascript">      <span class="hljs-attr">repo</span>: <span class="hljs-string">&#x27;Kerwin&#x27;</span>,</span><span class="language-javascript">  <span class="hljs-attr">coverpage</span>: <span class="hljs-literal">true</span>,</span><span class="language-javascript">  <span class="hljs-attr">search</span>: <span class="hljs-string">&#x27;auto&#x27;</span>,</span><span class="language-javascript">  search : [</span><span class="language-javascript">        <span class="hljs-string">&#x27;/&#x27;</span></span><span class="language-javascript">  ],</span><span class="language-javascript">  <span class="hljs-attr">search</span>: &#123;</span><span class="language-javascript">  <span class="hljs-attr">placeholder</span>: <span class="hljs-string">&#x27;搜索&#x27;</span>,</span><span class="language-javascript">  <span class="hljs-attr">noData</span>: <span class="hljs-string">&#x27;No Results!&#x27;</span></span><span class="language-javascript">  &#125;</span><span class="language-javascript">    &#125;</span><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;docsify.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//unpkg.com/docsify/lib/plugins/search.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//unpkg.com/prismjs/components/prism-java.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//unpkg.com/prismjs/components/prism-python.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//unpkg.com/prismjs/components/prism-sql.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h2 id="GitHub部署"><a href="#GitHub部署" class="headerlink" title="GitHub部署"></a>GitHub部署</h2><p>网上搜索资料即可，比较简单</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><pre><code class="hljs awk">docsify serve docs  <span class="hljs-regexp">//</span> 运行即可</code></pre>]]></content>
    
    
    <categories>
      
      <category>工具篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docsify篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FastJson使用记录</title>
    <link href="/2023/02/06/FastJson%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/02/06/FastJson%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="FastJson-getBytes"><a href="#FastJson-getBytes" class="headerlink" title="FastJson getBytes"></a>FastJson getBytes</h1><p>标签： #Share</p><blockquote><p>在使用FastJson过程中出现了</p><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> com.alibaba.fastjson.JSONException: can not cast to <span class="hljs-type">int</span>, value : [-<span class="hljs-number">119</span>,<span class="hljs-number">80</span>,<span class="hljs-number">78</span>,<span class="hljs-number">71</span>,<span class="hljs-number">13</span>]</code></pre><p>异常，现来分析其报错原因</p></blockquote><h2 id="getBytes-异常"><a href="#getBytes-异常" class="headerlink" title="getBytes 异常"></a>getBytes 异常</h2><pre><code class="hljs java"><span class="hljs-comment">// ImgUtilApp 具备 byte[] 变量</span><span class="hljs-type">ImgUtilApp</span> <span class="hljs-variable">imgUtilApp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImgUtilApp</span>();imgUtilApp.setBytes(bytes);<span class="hljs-comment">// FastJson</span><span class="hljs-type">JSONObject</span> <span class="hljs-variable">fastJson</span> <span class="hljs-operator">=</span> (JSONObject) JSON.toJSON(imgUtilApp);System.out.println(fastJson.getBytes(<span class="hljs-string">&quot;bytes&quot;</span>));<span class="hljs-comment">// 异常:</span>Exception in thread <span class="hljs-string">&quot;main&quot;</span> com.alibaba.fastjson.JSONException: can not cast to <span class="hljs-type">int</span>, value : [-<span class="hljs-number">119</span>,<span class="hljs-number">80</span>,<span class="hljs-number">78</span>,<span class="hljs-number">71</span>,<span class="hljs-number">13</span>]</code></pre><h2 id="getBytes-源码"><a href="#getBytes-源码" class="headerlink" title="getBytes 源码"></a>getBytes 源码</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] castToBytes(Object value) &#123;    <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-type">byte</span>[]) &#123;        <span class="hljs-keyword">return</span> (<span class="hljs-type">byte</span>[])((<span class="hljs-type">byte</span>[])value);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> String) &#123;        <span class="hljs-keyword">return</span> IOUtils.decodeBase64((String)value);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONException</span>(<span class="hljs-string">&quot;can not cast to int, value : &quot;</span> + value);    &#125;&#125;<span class="hljs-comment">// 从代码可以看出只支持 byte[]类型获取，或者 String -&gt; Base64 转成 byte[]</span></code></pre><h2 id="正确使用方式"><a href="#正确使用方式" class="headerlink" title="正确使用方式"></a>正确使用方式</h2><pre><code class="hljs java"><span class="hljs-type">JSONObject</span> <span class="hljs-variable">fastJson</span> <span class="hljs-operator">=</span> (JSONObject) JSON.toJSON(imgUtilApp);fastJson.put(<span class="hljs-string">&quot;bytesDemo&quot;</span>, bytes);System.out.println(fastJson.getBytes(<span class="hljs-string">&quot;bytesDemo&quot;</span>));<span class="hljs-comment">// 主动put byte[]类型，方可直接取出</span></code></pre><h2 id="问题产生原因"><a href="#问题产生原因" class="headerlink" title="问题产生原因"></a>问题产生原因</h2><ul><li>没有深刻认识标准JSON的数据结构，JsonObject，JsonArray，Inteager，String，Boolean…..</li><li>byte[] 在进行parse的时候会被主动解析成 JsonArray，因此它的类型已经被改变</li><li>看到 getBytes Api 想当然的以为和 getString 一样的顺滑，但是忽略了本身数据结构的特性导致该问题的产生</li></ul>]]></content>
    
    
    <categories>
      
      <category>Tips篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FastJson使用记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git-IDEA-技巧</title>
    <link href="/2023/02/06/Git-IDEA-%E6%8A%80%E5%B7%A7/"/>
    <url>/2023/02/06/Git-IDEA-%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="Git-IDEA-技巧"><a href="#Git-IDEA-技巧" class="headerlink" title="Git-IDEA-技巧"></a>Git-IDEA-技巧</h1><p>标签： #Share</p><h2 id="GitHub高级搜索"><a href="#GitHub高级搜索" class="headerlink" title="GitHub高级搜索"></a>GitHub高级搜索</h2><h3 id="仓库名搜索"><a href="#仓库名搜索" class="headerlink" title="仓库名搜索"></a>仓库名搜索</h3><pre><code class="hljs avrasm"><span class="hljs-symbol">in:</span>name spring boot</code></pre><h3 id="Stars-forks-搜索"><a href="#Stars-forks-搜索" class="headerlink" title="Stars | forks 搜索"></a>Stars | forks 搜索</h3><pre><code class="hljs avrasm"><span class="hljs-meta"># 注意 stars:&gt;3000 中间要连起来,不要有空格</span><span class="hljs-symbol">in:</span>name spring boot stars:&gt;<span class="hljs-number">3000</span>                 ...forks:&gt;<span class="hljs-number">1000</span></code></pre><h3 id="ReadMe搜索"><a href="#ReadMe搜索" class="headerlink" title="ReadMe搜索"></a>ReadMe搜索</h3><pre><code class="hljs avrasm"><span class="hljs-symbol">in:</span>readme spring boot</code></pre><h3 id="描述搜索"><a href="#描述搜索" class="headerlink" title="描述搜索"></a>描述搜索</h3><pre><code class="hljs avrasm"><span class="hljs-symbol">in:</span>description 微服务</code></pre><h3 id="语言限定"><a href="#语言限定" class="headerlink" title="语言限定"></a>语言限定</h3><pre><code class="hljs avrasm"><span class="hljs-symbol">language:</span>java</code></pre><h3 id="Push时间限定"><a href="#Push时间限定" class="headerlink" title="Push时间限定"></a>Push时间限定</h3><pre><code class="hljs apache"><span class="hljs-attribute">Pushed</span>:&gt;<span class="hljs-number">2019</span>-<span class="hljs-number">10</span></code></pre><h2 id="Git-项目构建-添加-gitignore文件"><a href="#Git-项目构建-添加-gitignore文件" class="headerlink" title="Git 项目构建 添加.gitignore文件"></a>Git 项目构建 添加.gitignore文件</h2><h3 id="gitignore-Content"><a href="#gitignore-Content" class="headerlink" title=".gitignore Content"></a>.gitignore Content</h3><pre><code class="hljs python">HELP.mdtarget/!.mvn/wrapper/maven-wrapper.jar!**/src/main/**!**/src/test/**<span class="hljs-comment">### STS ###</span>.apt_generated.classpath.factorypath.project.settings.springBeans.sts4-cache<span class="hljs-comment">### IntelliJ IDEA ###</span>.idea*.iws*.iml*.ipr<span class="hljs-comment">### NetBeans ###</span>/nbproject/private//nbbuild//dist//nbdist//.nb-gradle/build/<span class="hljs-comment">### VS Code ###</span>.vscode/</code></pre><h3 id="Git-初次提交-操作步骤"><a href="#Git-初次提交-操作步骤" class="headerlink" title="Git 初次提交 操作步骤"></a>Git 初次提交 操作步骤</h3><pre><code class="hljs java"><span class="hljs-comment">// 1. 第一步 commit，push .gitignore 文件</span><span class="hljs-comment">// 2. 之后再提交即不用重复处理非必要文件</span><span class="hljs-comment">// 3. 如果 .gitignore 不起作用的处理办法:</span><span class="hljs-comment">// 清理相关缓存</span>git rm -r --cached .git add .<span class="hljs-comment">// 再进行提交</span>    <span class="hljs-comment">// 同时：注意初次提交时是否提交了多余的内容</span></code></pre><h3 id="Windows-Cmd-集成-Git-Bash"><a href="#Windows-Cmd-集成-Git-Bash" class="headerlink" title="Windows Cmd 集成 Git Bash"></a>Windows Cmd 集成 Git Bash</h3><p><code>安装 Git Bash</code></p><pre><code class="hljs python"><span class="hljs-comment"># Path 变量添加如下路径:     测试验证：改变了系统级别CMD的功能，利用Java执行的linux 命令也可以支持</span>F:\Git\Git\cmdF:\Git\Git\usr\<span class="hljs-built_in">bin</span>F:\Git\Git\mingw64\<span class="hljs-built_in">bin</span></code></pre><h3 id="Git合并多次提交结果为一次"><a href="#Git合并多次提交结果为一次" class="headerlink" title="Git合并多次提交结果为一次"></a>Git合并多次提交结果为一次</h3><p><a href="https://www.cnblogs.com/itplay/p/11732353.html">原文介绍文章链接</a></p><h2 id="IDEA调试技巧"><a href="#IDEA调试技巧" class="headerlink" title="IDEA调试技巧"></a>IDEA调试技巧</h2><h3 id="断点指定条件"><a href="#断点指定条件" class="headerlink" title="断点指定条件"></a>断点指定条件</h3><p><img src="/2023/02/06/Git-IDEA-%E6%8A%80%E5%B7%A7/1573740941349.png" alt="1573740941349"></p><h3 id="方法调用跳回"><a href="#方法调用跳回" class="headerlink" title="方法调用跳回"></a>方法调用跳回</h3><p><img src="/2023/02/06/Git-IDEA-%E6%8A%80%E5%B7%A7/1573741222341.png" alt="1573741222341"></p><h3 id="多线程调试"><a href="#多线程调试" class="headerlink" title="多线程调试"></a>多线程调试</h3><p><img src="/2023/02/06/Git-IDEA-%E6%8A%80%E5%B7%A7/640.webp" alt="img"></p><h3 id="调式中修改变量测试效果"><a href="#调式中修改变量测试效果" class="headerlink" title="调式中修改变量测试效果"></a>调式中修改变量测试效果</h3><p><img src="/2023/02/06/Git-IDEA-%E6%8A%80%E5%B7%A7/1573741336421.png" alt="1573741336421"></p><h3 id="IDEA快捷键"><a href="#IDEA快捷键" class="headerlink" title="IDEA快捷键"></a>IDEA快捷键</h3><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">ctrl</span> + Alt + C         ---&gt;</span> 抽取变量<span class="hljs-function"><span class="hljs-title">ctrl</span> + Alt + V         ---&gt;</span> 抽取表达式<span class="hljs-function"><span class="hljs-title">ctrl</span> + Alt + M         ---&gt;</span> 抽取方法C<span class="hljs-function"><span class="hljs-title">trl</span> + O               ---&gt;</span>  重写父类方法 C<span class="hljs-function"><span class="hljs-title">trl</span> + H               ---&gt;</span>  查看类的关系Shift + Alt + R        弹出重构菜单 原:Ctrl+Alt+Shift+TShift + Alt + E        Extract菜单，帮助快速提取代码等Shift + Alt + Z        操作菜单，<span class="hljs-keyword">if</span>，<span class="hljs-keyword">do</span> <span class="hljs-keyword">while</span>等等IDEA ----&gt;  iter       增强<span class="hljs-keyword">for</span>循环自动填充list.fori  list.<span class="hljs-keyword">for</span>    自动填充Annotate               鼠标右键显示代码最近是谁提交的DeBug时                选中某一行，然后 Evaluate Expression  Debug时执行代码KeyMap                 快捷键查找，如下图所示 可以通过快捷键进行查找ctrl + shift +  + | -  一键把缩略或者打开所有方法ctrl + + | -           缩略当前方法</code></pre><p><img src="/2023/02/06/Git-IDEA-%E6%8A%80%E5%B7%A7/1571794285538.png"></p><h3 id="IDEA-全局搜索-替换功能"><a href="#IDEA-全局搜索-替换功能" class="headerlink" title="IDEA 全局搜索 | 替换功能"></a>IDEA 全局搜索 | 替换功能</h3><pre><code class="hljs java"><span class="hljs-comment">// 1. 全局搜索和全局替换 有文件类型筛选功能，指定路径范围， 作用范围等等</span><span class="hljs-comment">// 2. 全局搜索 全局替换支持正则表达式</span>如 通过正则全局替换： css\?v=.+?<span class="hljs-string">&quot;   ---》  css&quot;</span>js\?v=.+?<span class="hljs-string">&quot;    ---》   js&quot;</span>pdf\?v=.+?<span class="hljs-string">&quot;   ---》  pdf&quot;</span>    <span class="hljs-string">&quot;/(.+?js)&quot;</span>   <span class="hljs-string">&quot;/(.+?css)&quot;</span>    <span class="hljs-string">&quot;/(.+?pdf)&quot;</span>===&gt; <span class="hljs-string">&quot;/$1?v=$&#123;oem_resource_version&#125;&quot;</span>    这也给我们启示，不要重复造轮子，好好利用当下的现有工具</code></pre><h3 id="IDEA-便利设置"><a href="#IDEA-便利设置" class="headerlink" title="IDEA 便利设置"></a>IDEA 便利设置</h3><blockquote><p>Window -&gt; Editor Tabs -&gt; Tabs Placement，取消勾选 Show Tabs In Single Row选项</p></blockquote><h3 id="IDEA-全局检查"><a href="#IDEA-全局检查" class="headerlink" title="IDEA 全局检查"></a>IDEA 全局检查</h3><ol><li>全局扫描错误，异常，警告  Analyze Inspect Code… </li><li>Ctrl + Alt + Shift + I  -&gt; 输入需要插件的警告类型即可全局扫描</li></ol><h3 id="IDEA-导入-插件项目方法"><a href="#IDEA-导入-插件项目方法" class="headerlink" title="IDEA 导入 插件项目方法"></a>IDEA 导入 插件项目方法</h3><blockquote><pre><div class="caption"><span>.iml文件</span></div><code class="hljs 注意:```插件项目需要平常无所谓的">1. 注意项目SDK，设置Platform Settings idea SDK，设置 Project SDK为idea SDK2. 添加Configurations为Plugin终极解决方案：如果始终无法导入，建议新建同名插件项目，然后进行文件替换注意 .iml文件，git相关文件即可### IDEA 快捷键打日志</code></pre><p>快捷键：自定义，如 logp<br>内容：logger.info(“$METHOD_NAME$::”$ARGUMENTS$);<br>参数一：methodName();<br>参数二：groovyScript(“def result&#x3D;’’; def params&#x3D;&quot;${_1}&quot;.replaceAll(‘[\\[|\\]|\\s]’, ‘’).split(‘,’).toList();for(i &#x3D; 0; i &lt; params.size(); i++) {if(i&#x3D;&#x3D;0){result+&#x3D;’+&quot; ‘ + params[i] + ‘ :&quot;+ ‘+params[i];}else{result+&#x3D;’ +&quot;; ‘ + params[i] + ‘ :&quot;+ ‘+params[i];}}; return result;”, methodParameters());</p></blockquote><pre><code class="hljs clean">![image<span class="hljs-number">-20201122213200577</span>](Git-IDEA-技巧/image<span class="hljs-number">-20201122213200577.</span>png)### IDEA 显示Git更新涉及的文件可能无意间点到显示差异导致Git查看无法显示涉及的文件，IDEA搜索快捷键：Version Control Systems | File History | Show Details然后进入Git，选择更新的记录，使用快捷键即可![image<span class="hljs-number">-20210121203609799</span>](Git-IDEA-技巧/image<span class="hljs-number">-20210121203609799.</span>png)### Eclipse导入SpringBoot项目方法基于Maven的方式导入之后，如果pom.xml报未知错误，是由于Maven版本不兼容导致，处理办法：```xml<span class="hljs-comment">// 设置Maven版本为3.1.1 然后Update项目即可</span>&lt;maven-jar-plugin.version&gt;<span class="hljs-number">3.1</span><span class="hljs-number">.1</span>&lt;/maven-jar-plugin.version&gt;</code></pre><h2 id="Pycharm-环境构建-统一依赖文件"><a href="#Pycharm-环境构建-统一依赖文件" class="headerlink" title="Pycharm 环境构建 统一依赖文件"></a>Pycharm 环境构建 统一依赖文件</h2><p><code>统一设置为 系统python.exe 共享依赖即可   ---&gt;  注意设置Default Setting</code></p><p><img src="/2023/02/06/Git-IDEA-%E6%8A%80%E5%B7%A7/image-20191120153539863.png" alt="image-20191120153539863"></p><ul><li>更改pip源，注意刷新：<a href="https://mirrors.aliyun.com/pypi/simple/">https://mirrors.aliyun.com/pypi/simple/</a></li><li>插件，快捷键参考IDEA即可</li></ul><h2 id="Maven-镜像"><a href="#Maven-镜像" class="headerlink" title="Maven 镜像"></a>Maven 镜像</h2><h3 id="配置阿里云镜像-并强制项目启用"><a href="#配置阿里云镜像-并强制项目启用" class="headerlink" title="配置阿里云镜像 - 并强制项目启用"></a>配置阿里云镜像 - 并强制项目启用</h3><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置阿里云Maven镜像--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Nexus aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span></code></pre><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 启用阿里云镜像下载依赖 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>nexus-aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pluginRepositories</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">pluginRepository</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">pluginRepository</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pluginRepositories</span>&gt;</span></code></pre><h2 id="监听端口技巧"><a href="#监听端口技巧" class="headerlink" title="监听端口技巧"></a>监听端口技巧</h2><h3 id="伪造服务端监听端口"><a href="#伪造服务端监听端口" class="headerlink" title="伪造服务端监听端口"></a>伪造服务端监听端口</h3><pre><code class="hljs java"><span class="hljs-comment">// 伪造6379 redis-服务端，监听  jedis发送的协议内容</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SocketApp</span> &#123;        <span class="hljs-comment">/***</span><span class="hljs-comment">     * 监听 6379 传输的数据</span><span class="hljs-comment">     * JVM端口需要进行设置</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>  &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">6379</span>);            <span class="hljs-type">Socket</span> <span class="hljs-variable">redis</span> <span class="hljs-operator">=</span> serverSocket.accept();            <span class="hljs-type">byte</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">2048</span>];            redis.getInputStream().read(result);            System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(result));        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span class="hljs-comment">// jedis连接-发送命令</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;        <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);        jedis.set(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;This is value.&quot;</span>);        jedis.close();    &#125;&#125;<span class="hljs-comment">// 监听命令内容如下：</span>*<span class="hljs-number">3</span>$<span class="hljs-number">3</span>SET$<span class="hljs-number">3</span>key$<span class="hljs-number">14</span></code></pre><h2 id="开发技巧"><a href="#开发技巧" class="headerlink" title="开发技巧"></a>开发技巧</h2><h3 id="链接分享实战"><a href="#链接分享实战" class="headerlink" title="链接分享实战"></a>链接分享实战</h3><blockquote><p>分享处理技巧：</p><ol><li>为了不暴露真实的地址，利用转发比重定向更好</li><li>通过设计短链表，通过key映射真正的参数信息，进行页面请求转发即可</li><li>复杂界面请求多的情况下，接口需要一一处理支持分享功能</li></ol></blockquote><h3 id="复杂业务代码设计思路"><a href="#复杂业务代码设计思路" class="headerlink" title="复杂业务代码设计思路"></a>复杂业务代码设计思路</h3><blockquote><p>代码设计思路：</p><ol><li>业务场景代码设计和最基础的数据结构及算法设计相同，需要更多的注意边界条件</li><li>具体需求层次，实现顺序，考虑影响范围 -》 实现思路最好从具体出发，向全量范围拓展</li><li>自行拆解需求，满足更多的场景使用</li><li>永远不要相信所谓的前提条件，用户和测试永远不会按照最理想的情况运行</li></ol><p>最好结合图进行绘制和处理</p></blockquote><h3 id="新增简单功能需要注意的问题"><a href="#新增简单功能需要注意的问题" class="headerlink" title="新增简单功能需要注意的问题"></a>新增简单功能需要注意的问题</h3><blockquote><p>代码设计思路：</p><ol><li>此简单功能，有没有其他影响功能？如果有，则需要找出来一并修改</li><li>此功能有没有类似功能，搜索类似功能关键词，找到其涉及的所有功能</li><li>根据类似功能及相关涉及的功能进行优化，检查，避免简单需求有其定式思维，导致BUG的增加</li></ol></blockquote><h2 id="IDEA-样式收集"><a href="#IDEA-样式收集" class="headerlink" title="IDEA 样式收集"></a>IDEA 样式收集</h2><ul><li>IDEA  <a href="https://plugins.jetbrains.com/plugin/11938-one-dark-theme/versions"> One-Dark-Theme </a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Tips篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git-IDEA-技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GitHub无法访问解决办法</title>
    <link href="/2023/02/06/GitHub%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <url>/2023/02/06/GitHub%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="GitHub无法访问解决办法"><a href="#GitHub无法访问解决办法" class="headerlink" title="GitHub无法访问解决办法"></a>GitHub无法访问解决办法</h1><p>标签： #Share</p><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p>解析域名与IP映射，但前提一定要找准！</p><h2 id="GitHub原始项目"><a href="#GitHub原始项目" class="headerlink" title="GitHub原始项目"></a>GitHub原始项目</h2><p><a href="https://github.com/521xueweihan/GitHub520">https://github.com/521xueweihan/GitHub520</a></p><h2 id="核心办法自我实践"><a href="#核心办法自我实践" class="headerlink" title="核心办法自我实践"></a>核心办法自我实践</h2><p>知乎链接：<a href="https://zhuanlan.zhihu.com/p/158938544">https://zhuanlan.zhihu.com/p/158938544</a></p><p>官方域名映射地址查询：<a href="https://github.com.ipaddress.com/">https://github.com.ipaddress.com/</a></p><p><img src="/2023/02/06/GitHub%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/image-20210228160005643.png" alt="image-20210228160005643"></p><p><strong>刷新DNS解析</strong></p><pre><code class="hljs bash">ipconfig /flushdns</code></pre>]]></content>
    
    
    <categories>
      
      <category>Tips篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GitHub无法访问解决办法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Guava的两种本地缓存策略</title>
    <link href="/2023/02/06/Guava%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/"/>
    <url>/2023/02/06/Guava%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="Guava的两种本地缓存策略"><a href="#Guava的两种本地缓存策略" class="headerlink" title="Guava的两种本地缓存策略"></a>Guava的两种本地缓存策略</h1><p>标签： #Share</p><p>缓存在很多场景下都需要使用，如果电商网站的商品类别的查询，订单查询，用户基本信息的查询等等，针对这种读多写少的业务，都可以考虑使用到缓存。在一般的缓存系统中，除了分布式缓存，还会有多级缓存，在提升一定性能的前提下，可以在一定程度上避免缓存击穿或缓存雪崩，也能降低分布式缓存的负载。</p><h2 id="GuavaCache的优点"><a href="#GuavaCache的优点" class="headerlink" title="GuavaCache的优点"></a>GuavaCache的优点</h2><p>1）很好的封装了get、put操作，能够集成数据源。一般我们在业务中操作缓存都会操作缓存和数据源两部分。例如：put数据时，先插入DB再删除原来的缓存，get数据时，先查缓存，命中则返回，没有命中时需要查询DB，再把查询结果放入缓存中。Guava封装了这么多步骤，只需要调用一次get&#x2F;put方法即可</p><p>2）它是线程安全的缓存，与ConcurrentMap相似，但前者增加了更多的元素失效策略，后者只能显示的移除元素</p><p>3）GuavaCache提供了三种基本的缓存回收方式：基于容量回收、定时回收和基于引用回收。定时回收有两种：按照写入时间，最早写入的最先回收；按照访问时间，最早访问的最早回收</p><p>4）它可以监控加载&#x2F;命中情况</p><h2 id="Cache类型本地缓存"><a href="#Cache类型本地缓存" class="headerlink" title="Cache类型本地缓存"></a>Cache类型本地缓存</h2><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mine.localcache.guava;<span class="hljs-keyword">import</span> com.google.common.cache.Cache;<span class="hljs-keyword">import</span> com.google.common.cache.CacheBuilder;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">import</span> java.util.concurrent.Callable;<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<span class="hljs-comment">/**</span><span class="hljs-comment"> * ******************************</span><span class="hljs-comment"> * author：      柯贤铭</span><span class="hljs-comment"> * createTime:   2019/7/30 14:21</span><span class="hljs-comment"> * description:  Guava 本地缓存 -&gt; Cache类型</span><span class="hljs-comment"> *               用于SpringBoot项目中,启用单例模式 项目启动时进行初始化</span><span class="hljs-comment"> * pay attention -&gt; A. 注意不要重复实例化, 最好交由IOC管理</span><span class="hljs-comment"> *                  B. 注意如果是写操作则获取缓存值后拷贝一份副本，然后传递该副本，进行修改操作</span><span class="hljs-comment"> *                  C. 支持自定义call回调</span><span class="hljs-comment"> * version:      V1.0</span><span class="hljs-comment"> * ******************************</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CacheUtil</span> &#123;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 构造方法 - 进行初始化</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> maxSize      最大容量</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> invalidTime  刷新时间 | 基于分钟级别</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CacheUtil</span><span class="hljs-params">(<span class="hljs-type">long</span> maxSize, <span class="hljs-type">long</span> invalidTime)</span> &#123;        init(maxSize, invalidTime);    &#125;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 初始化</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span> <span class="hljs-params">(<span class="hljs-type">long</span> maxSize, <span class="hljs-type">long</span> invalidTime)</span> &#123;        <span class="hljs-comment">// 缓存</span>        cache = CacheBuilder.newBuilder()                <span class="hljs-comment">// 设置缓存在写入invalidTime分钟后失效</span>                .expireAfterWrite(invalidTime, TimeUnit.MINUTES)                <span class="hljs-comment">// 设置缓存个数</span>                .maximumSize(maxSize)                .concurrencyLevel(Runtime.getRuntime().availableProcessors())                .recordStats()                .build();    &#125;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * Guava Cache类型缓存</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> Cache cache;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 对外暴露的方法 -&gt; 从缓存中取value，没取到会返回null</span><span class="hljs-comment">     *</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getValue</span> <span class="hljs-params">(String key)</span> &#123;        <span class="hljs-keyword">return</span> cache.getIfPresent(key);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 对外暴露的方法 -&gt; 从缓存中取value，没取到会执行call</span><span class="hljs-comment">     *</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getValue</span> <span class="hljs-params">(String key, Callable callable)</span> <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-keyword">return</span> cache.get(key, callable);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 对外暴露的方法 -&gt; put</span><span class="hljs-comment">     *</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putValue</span> <span class="hljs-params">(String key, Object value)</span> &#123;        cache.put(key, value);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 对外暴露的方法 -&gt; putMap</span><span class="hljs-comment">     *</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putMap</span> <span class="hljs-params">(String key, Map map)</span> &#123;        cache.putAll(map);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 对外暴露的方法 -&gt; 判断是否存在key</span><span class="hljs-comment">     *</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">constainsKey</span> <span class="hljs-params">(String key)</span> &#123;        <span class="hljs-keyword">return</span> cache.asMap().containsKey(key);    &#125;&#125;</code></pre><h2 id="Loading类型缓存"><a href="#Loading类型缓存" class="headerlink" title="Loading类型缓存"></a>Loading类型缓存</h2><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mine.localcache.guava;<span class="hljs-keyword">import</span> com.google.common.cache.CacheBuilder;<span class="hljs-keyword">import</span> com.google.common.cache.CacheLoader;<span class="hljs-keyword">import</span> com.google.common.cache.LoadingCache;<span class="hljs-keyword">import</span> com.google.common.util.concurrent.ListenableFuture;<span class="hljs-keyword">import</span> com.google.common.util.concurrent.ListeningExecutorService;<span class="hljs-keyword">import</span> com.google.common.util.concurrent.MoreExecutors;<span class="hljs-keyword">import</span> java.util.concurrent.ExecutionException;<span class="hljs-keyword">import</span> java.util.concurrent.LinkedBlockingQueue;<span class="hljs-keyword">import</span> java.util.concurrent.ThreadPoolExecutor;<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<span class="hljs-comment">/**</span><span class="hljs-comment"> * ******************************</span><span class="hljs-comment"> * author：      柯贤铭</span><span class="hljs-comment"> * createTime:   2019/7/30 14:21</span><span class="hljs-comment"> * description:  Guava 本地缓存 -&gt; LoadingCache类型</span><span class="hljs-comment"> *               用于SpringBoot项目中,启用单例模式 项目启动时进行初始化</span><span class="hljs-comment"> *               博文参考: https://www.cnblogs.com/csonezp/p/10011031.html</span><span class="hljs-comment"> * pay attention -&gt; A. 注意不要重复实例化, 最好交由IOC管理</span><span class="hljs-comment"> *                  B. 注意重写与之匹配的数据源获取方法 - getFromDB</span><span class="hljs-comment"> *                  C. 注意如果是写操作则获取缓存值后拷贝一份副本，然后传递该副本，进行修改操作</span><span class="hljs-comment"> *                  D. 注意绝对不要返回null值作为value, 会引发InvalidCacheLoadException异常</span><span class="hljs-comment"> *                     对于该情况可以自定义处理方式, 主动将其捕获</span><span class="hljs-comment"> *                  E. 此类型缓存提倡自动加载缓存数据, 因此尽量避免手动put</span><span class="hljs-comment"> *                     如果需要更灵活的方案可以使用Cache类型</span><span class="hljs-comment"> *                  F. 灵活设置参数, 启用自动失效策略或者自动刷新策略</span><span class="hljs-comment"> * version:      V1.0</span><span class="hljs-comment"> * ******************************</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoadingCacheUtil</span> &#123;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 构造方法 - 进行初始化</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> maxSize      最大容量</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> refreshTime  刷新时间 | 基于分钟级别</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LoadingCacheUtil</span><span class="hljs-params">(<span class="hljs-type">long</span> maxSize, <span class="hljs-type">long</span> refreshTime)</span> &#123;        init(maxSize, refreshTime);    &#125;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 初始化</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span> <span class="hljs-params">(<span class="hljs-type">long</span> maxSize, <span class="hljs-type">long</span> refreshTime)</span> &#123;        <span class="hljs-comment">// 刷新线程池 -&gt; 如果数据都没了则启用后台线程进行刷新,让用户无感知 -&gt; 核心线程数 1, 最大线程数 2</span>        backgroundRefreshPools = MoreExecutors.listeningDecorator(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;()));        <span class="hljs-comment">// 缓存</span>        cache = CacheBuilder.newBuilder()                <span class="hljs-comment">// 缓存刷新时间</span>                .refreshAfterWrite(refreshTime, TimeUnit.MINUTES)                <span class="hljs-comment">// 设置缓存在写入invalidTime分钟后失效</span>                <span class="hljs-comment">//.expireAfterWrite(refreshTime, TimeUnit.MINUTES)</span>                <span class="hljs-comment">// 设置缓存个数</span>                .maximumSize(maxSize)                .concurrencyLevel(Runtime.getRuntime().availableProcessors())                .recordStats()                .build(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CacheLoader</span>&lt;String, Object&gt;() &#123;                    <span class="hljs-comment">// 当本地缓存命没有中时，调用load方法获取结果并将结果缓存</span>                    <span class="hljs-meta">@Override</span>                    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">load</span><span class="hljs-params">(String appKey)</span> &#123;                        <span class="hljs-keyword">return</span> getFromDB(appKey);                    &#125;                    <span class="hljs-comment">// 刷新时，开启一个新线程异步刷新，老请求直接返回旧值，防止耗时过长</span>                    <span class="hljs-meta">@Override</span>                    <span class="hljs-keyword">public</span> ListenableFuture&lt;Object&gt; <span class="hljs-title function_">reload</span><span class="hljs-params">(String key, Object oldValue)</span> &#123;                        <span class="hljs-keyword">return</span> backgroundRefreshPools.submit(() -&gt; getFromDB(key));                    &#125;                    <span class="hljs-comment">// 数据库进行查询</span>                    <span class="hljs-keyword">private</span> Object <span class="hljs-title function_">getFromDB</span> <span class="hljs-params">(String key)</span> &#123;                        <span class="hljs-comment">// return entryMapper.selectByName(name)</span>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;                    &#125;                &#125;);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 后台处理线程池</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> ListeningExecutorService backgroundRefreshPools;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * Guava LoadingCache类型缓存</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> LoadingCache cache;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 对外暴露的方法 -&gt; 从缓存中取value，没取到会自动重载缓存,如果载入为null则触发异常</span><span class="hljs-comment">     *</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getValue</span> <span class="hljs-params">(String key)</span> <span class="hljs-keyword">throws</span> ExecutionException &#123;        <span class="hljs-keyword">return</span> cache.get(key);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 对外暴露的方法 -&gt; 判断是否存在key</span><span class="hljs-comment">     *</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">constainsKey</span> <span class="hljs-params">(String key)</span> &#123;        <span class="hljs-keyword">return</span> cache.asMap().containsKey(key);    &#125;&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>1.本地缓存其实很多种数据结构都支持，比如线程安全的ConcurrentHashMap，用该结构配合TimerTask定时清除key，也可以实现，但是一是自己写的代码肯定没有谷歌工具厉害，另外一点，缓存更重要的特性不是可存可取，而是可以自动的去识别哪些key更活跃，哪些key不活跃，删除掉，<br>因此基于LRU算法，Google提供的Guava就可以很好的满足这一点</p></li><li><p>2.Cache类型缓存更像ConcurrentHashMap，有点随便存随便取的意思，同时支持定时回收，也支持get不到缓存内容时走call回调接口去数据，总的来说非常方便</p></li><li><p>3.LoadingCache类型缓存相比而言用的更加规范一些,它提供的思想是有一套完整的DB方案，提供定时刷新缓存,提供默认load方法，reload方法，相比于Cache，它要求更加严格，比如缓存内容不可返回null等等,也不建议手动put数据，而是专门通过DB的途径去刷新数据，因此真正的生产环境用的会更多一些</p></li></ul><blockquote><p>QQ：806857264</p><p>GitHub：<a href="https://github.com/kkzhilu">https://github.com/kkzhilu</a></p><p>如有什么问题，望指正，互相交流</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Guava的两种本地缓存策略</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript定时器及回调用法</title>
    <link href="/2023/02/06/JavaScript%E5%AE%9A%E6%97%B6%E5%99%A8%E5%8F%8A%E5%9B%9E%E8%B0%83%E7%94%A8%E6%B3%95/"/>
    <url>/2023/02/06/JavaScript%E5%AE%9A%E6%97%B6%E5%99%A8%E5%8F%8A%E5%9B%9E%E8%B0%83%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript定时器及回调用法"><a href="#JavaScript定时器及回调用法" class="headerlink" title="JavaScript定时器及回调用法"></a>JavaScript定时器及回调用法</h1><p>标签： #Share</p><h3 id="循环定时任务"><a href="#循环定时任务" class="headerlink" title="循环定时任务"></a>循环定时任务</h3><pre><code class="hljs javascript"><span class="hljs-comment">// 假设现在有这样一个需求：我需要请求一个接口，根据返回结果判断需不需要重复请求，直到达到某一条件为止,停止请求执行某操作</span>&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;    <span class="hljs-keyword">var</span> timer;    <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>;    <span class="hljs-keyword">function</span> <span class="hljs-title function_">tim</span>(<span class="hljs-params"></span>)&#123;        timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;            index++;            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>())            <span class="hljs-keyword">if</span> (index === <span class="hljs-number">5</span>) &#123;                <span class="hljs-variable language_">window</span>.<span class="hljs-built_in">clearInterval</span>(timer)            &#125;        &#125;, <span class="hljs-number">500</span>);    &#125;&lt;/script&gt;</code></pre><h3 id="循环请求并获取返回值-拿到返回值后执行操作"><a href="#循环请求并获取返回值-拿到返回值后执行操作" class="headerlink" title="循环请求并获取返回值 - 拿到返回值后执行操作"></a>循环请求并获取返回值 - 拿到返回值后执行操作</h3><h4 id="回调函数方法"><a href="#回调函数方法" class="headerlink" title="回调函数方法"></a>回调函数方法</h4><pre><code class="hljs java">&lt;script&gt;    function <span class="hljs-title function_">getSomething</span><span class="hljs-params">(cb)</span> &#123;         <span class="hljs-type">var</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;         setTimeout(function() &#123;             r = <span class="hljs-number">2</span>;             cb(r);         &#125;, <span class="hljs-number">100</span>);    &#125;    function <span class="hljs-title function_">compute</span><span class="hljs-params">(x)</span> &#123;     alert(x * <span class="hljs-number">2</span>);    &#125;    getSomething(compute);&lt;/script&gt;</code></pre><h4 id="promise方法"><a href="#promise方法" class="headerlink" title="promise方法"></a>promise方法</h4><pre><code class="hljs java">function <span class="hljs-title function_">getSomething</span><span class="hljs-params">()</span> &#123;     <span class="hljs-type">var</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;     <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(function(resolve) &#123;         setTimeout(function() &#123;          r = <span class="hljs-number">2</span>;          resolve(r);         &#125;, <span class="hljs-number">10</span>);     &#125;);&#125;function <span class="hljs-title function_">compute</span><span class="hljs-params">(x)</span> &#123; alert(x * <span class="hljs-number">2</span>);&#125;getSomething().then(compute);</code></pre><h4 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h4><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getSomething</span>(<span class="hljs-params"></span>) &#123;     <span class="hljs-keyword">var</span> r = <span class="hljs-number">0</span>;     <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;         r = <span class="hljs-number">2</span>;         it.<span class="hljs-title function_">next</span>(r);     &#125;, <span class="hljs-number">10</span>);&#125;<span class="hljs-keyword">function</span> *<span class="hljs-title function_">compute</span>(<span class="hljs-params">it</span>) &#123;     <span class="hljs-keyword">var</span> x = <span class="hljs-keyword">yield</span> <span class="hljs-title function_">getSomething</span>();     <span class="hljs-title function_">alert</span>(x * <span class="hljs-number">2</span>);&#125;<span class="hljs-keyword">var</span> it = <span class="hljs-title function_">compute</span>();it.<span class="hljs-title function_">next</span>();</code></pre><h4 id="promise-generator"><a href="#promise-generator" class="headerlink" title="promise + generator"></a>promise + generator</h4><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getSomething</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">var</span> r = <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) &#123;        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;            r = <span class="hljs-number">2</span>;            <span class="hljs-title function_">resolve</span>(r);        &#125;, <span class="hljs-number">10</span>);    &#125;);&#125;<span class="hljs-keyword">function</span>* <span class="hljs-title function_">compute</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">var</span> x = <span class="hljs-keyword">yield</span> <span class="hljs-title function_">getSomething</span>();    <span class="hljs-title function_">alert</span>(x * <span class="hljs-number">2</span>);&#125;<span class="hljs-keyword">var</span> it = <span class="hljs-title function_">compute</span>();it.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) &#123;    it.<span class="hljs-title function_">next</span>(value);&#125;);</code></pre><h4 id="ES7-终极方案"><a href="#ES7-终极方案" class="headerlink" title="ES7 - 终极方案"></a>ES7 - 终极方案</h4><pre><code class="hljs javascript">&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;    <span class="hljs-keyword">function</span> <span class="hljs-title function_">getSomething</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">var</span> r = <span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) &#123;            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;                r = <span class="hljs-number">2</span>;                <span class="hljs-title function_">resolve</span>(r);            &#125;, <span class="hljs-number">10</span>);        &#125;);    &#125;    <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">compute</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">var</span> x = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getSomething</span>();        <span class="hljs-title function_">alert</span>(x * <span class="hljs-number">2</span>);    &#125;    <span class="hljs-comment">// 直接调用compute()方法 -&gt; x为同步请求返回结果，输出4</span>    <span class="hljs-title function_">compute</span>(); <span class="hljs-comment">// 表示getSomething获取返回值后执行resolve状态 -&gt;  </span>    <span class="hljs-comment">// 当.then()前的方法执行完后再执行then()内部的程序，这样就避免了，数据没获取到等的问题</span>    <span class="hljs-title function_">getSomething</span>().<span class="hljs-title function_">then</span>(compute);&lt;/script&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript定时器及回调用法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java语法糖之泛型</title>
    <link href="/2023/02/06/Java%E8%AF%AD%E6%B3%95%E7%B3%96%E4%B9%8B%E6%B3%9B%E5%9E%8B/"/>
    <url>/2023/02/06/Java%E8%AF%AD%E6%B3%95%E7%B3%96%E4%B9%8B%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="聊一聊-JAVA-泛型中的通配符-T，E，K，V，？"><a href="#聊一聊-JAVA-泛型中的通配符-T，E，K，V，？" class="headerlink" title="聊一聊-JAVA 泛型中的通配符 T，E，K，V，？"></a>聊一聊-JAVA 泛型中的通配符 T，E，K，V，？</h1><p>标签： #Share</p><blockquote><p>原文来源：掘金</p><p>原文链接：<a href="https://juejin.im/post/5d5789d26fb9a06ad0056bd9?utm_source=gold_browser_extension">https://juejin.im/post/5d5789d26fb9a06ad0056bd9?utm_source=gold_browser_extension</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许开发者在编译时检测到非法的类型。</p><p>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p><h2 id="泛型带来的好处"><a href="#泛型带来的好处" class="headerlink" title="泛型带来的好处"></a>泛型带来的好处</h2><p>在没有泛型的情况的下，通过对类型 Object 的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是本身就是一个安全隐患。</p><p>那么泛型的好处就是在编译的时候能够检查类型安全，并且所有的强制转换都是自动和隐式的。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlmapperGeneric</span>&lt;T&gt; &#123;<span class="hljs-keyword">private</span> T t;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T t)</span> &#123; <span class="hljs-built_in">this</span>.t = t; &#125;    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> t; &#125;      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-comment">// do nothing</span>    &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">    * 不指定类型</span><span class="hljs-comment">    */</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">noSpecifyType</span><span class="hljs-params">()</span>&#123;    <span class="hljs-type">GlmapperGeneric</span> <span class="hljs-variable">glmapperGeneric</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GlmapperGeneric</span>();    glmapperGeneric.set(<span class="hljs-string">&quot;test&quot;</span>);    <span class="hljs-comment">// 需要强制类型转换</span>    <span class="hljs-type">String</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> (String) glmapperGeneric.get();    System.out.println(test);  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">    * 指定类型</span><span class="hljs-comment">    */</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">specifyType</span><span class="hljs-params">()</span>&#123;    GlmapperGeneric&lt;String&gt; glmapperGeneric = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GlmapperGeneric</span>();    glmapperGeneric.set(<span class="hljs-string">&quot;test&quot;</span>);    <span class="hljs-comment">// 不需要强制类型转换</span>    <span class="hljs-type">String</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> glmapperGeneric.get();    System.out.println(test);  &#125;&#125;</code></pre><p>上面这段代码中的 specifyType 方法中 省去了强制转换，可以在编译时候检查类型安全，可以用在类，方法，接口上。</p><h2 id="泛型中通配符"><a href="#泛型中通配符" class="headerlink" title="泛型中通配符"></a>泛型中通配符</h2><p>我们在定义泛型类，泛型方法，泛型接口的时候经常会碰见很多不同的通配符，比如 T，E，K，V 等等，这些通配符又都是什么意思呢？</p><h3 id="常用的-T，E，K，V，？"><a href="#常用的-T，E，K，V，？" class="headerlink" title="常用的 T，E，K，V，？"></a>常用的 T，E，K，V，？</h3><p>本质上这些个都是通配符，没啥区别，只不过是编码时的一种约定俗成的东西。比如上述代码中的 T ，我们可以换成 A-Z 之间的任何一个 字母都可以，并不会影响程序的正常运行，但是如果换成其他的字母代替 T ，在可读性上可能会弱一些。<strong>通常情况下，T，E，K，V，？ 是这样约定的：</strong></p><ul><li>？ 表示不确定的 java 类型</li><li>T (type) 表示具体的一个java类型</li><li>K V (key value) 分别代表java键值中的Key Value</li><li>E (element) 代表Element</li></ul><h3 id="？-无界通配符"><a href="#？-无界通配符" class="headerlink" title="？ 无界通配符"></a>？ <strong>无界通配符</strong></h3><p>先从一个小例子看起，原文在 <a href="https://link.juejin.im/?target=https://codeday.me/bug/20180113/116421.html">这里</a> 。</p><p>我有一个父类 Animal 和几个子类，如狗、猫等，现在我需要一个动物的列表，我的第一个想法是像这样的：</p><pre><code class="hljs xml">List<span class="hljs-tag">&lt;<span class="hljs-name">Animal</span>&gt;</span> listAnimals</code></pre><p>但是老板的想法确实这样的：</p><pre><code class="hljs php">List<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> Animal&gt; listAnimals</code></pre><p>为什么要使用通配符而不是简单的泛型呢？通配符其实在声明局部变量时是没有什么意义的，但是当你为一个方法声明一个参数时，它是非常重要的。</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countLegs</span> <span class="hljs-params">(List&lt;? extends Animal &gt; animals )</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">retVal</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> ( Animal animal : animals )    &#123;        retVal += animal.countLegs();    &#125;    <span class="hljs-keyword">return</span> retVal;&#125;<span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countLegs1</span> <span class="hljs-params">(List&lt; Animal &gt; animals )</span>&#123;    <span class="hljs-type">int</span> <span class="hljs-variable">retVal</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> ( Animal animal : animals )    &#123;        retVal += animal.countLegs();    &#125;    <span class="hljs-keyword">return</span> retVal;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;    List&lt;Dog&gt; dogs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">// 不会报错</span>    countLegs( dogs );<span class="hljs-comment">// 报错</span>    countLegs1(dogs);&#125;</code></pre><p><img src="/2023/02/06/Java%E8%AF%AD%E6%B3%95%E7%B3%96%E4%B9%8B%E6%B3%9B%E5%9E%8B/image-20201104235544754.png" alt="image-20201104235544754"></p><p>所以，对于不确定或者不关心实际要操作的类型，可以使用无限制通配符（尖括号里一个问号，即 &lt;?&gt; ），表示可以持有任何类型。像 countLegs 方法中，限定了上届，但是不关心具体类型是什么，所以对于传入的 Animal 的所有子类都可以支持，并且不会报错。而 countLegs1 就不行。</p><h3 id="上界通配符-extends-E"><a href="#上界通配符-extends-E" class="headerlink" title="上界通配符 &lt; ? extends E&gt;"></a>上界通配符 &lt; ? extends E&gt;</h3><blockquote><p>上届：用 extends 关键字声明，表示参数化的类型可能是所指定的类型，或者是此类型的子类。</p></blockquote><p>在类型参数中使用 extends 表示这个泛型中的参数必须是 E 或者 E 的子类，这样有两个好处：</p><ul><li>如果传入的类型不是 E 或者 E 的子类，编译不成功</li><li>泛型中可以使用 E 的方法，要不然还得强转成 E 才能使用</li></ul><pre><code class="hljs java"><span class="hljs-keyword">private</span> &lt;K <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>, E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">B</span>&gt; E <span class="hljs-title function_">test</span><span class="hljs-params">(K arg1, E arg2)</span>&#123;    <span class="hljs-type">E</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> arg2;    arg2.compareTo(arg1);    <span class="hljs-comment">//.....</span>    <span class="hljs-keyword">return</span> result;&#125;复制代码</code></pre><blockquote><p>类型参数列表中如果有多个类型参数上限，用逗号分开</p></blockquote><h3 id="下界通配符-super-E"><a href="#下界通配符-super-E" class="headerlink" title="下界通配符 &lt; ? super E&gt;"></a>下界通配符 &lt; ? super E&gt;</h3><blockquote><p>下界: 用 super 进行声明，表示参数化的类型可能是所指定的类型，或者是此类型的父类型，直至 Object</p></blockquote><p>在类型参数中使用 super 表示这个泛型中的参数必须是 E 或者 E 的父类。</p><pre><code class="hljs scala"><span class="hljs-keyword">private</span> &lt;<span class="hljs-type">T</span>&gt; void test(<span class="hljs-type">List</span>&lt;? <span class="hljs-keyword">super</span> <span class="hljs-type">T</span>&gt; dst, <span class="hljs-type">List</span>&lt;<span class="hljs-type">T</span>&gt; src)&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-type">T</span> t : src) &#123;        dst.add(t);    &#125;&#125;public static void main(<span class="hljs-type">String</span>[] args) &#123;    <span class="hljs-type">List</span>&lt;<span class="hljs-type">Dog</span>&gt; dogs = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();    <span class="hljs-type">List</span>&lt;<span class="hljs-type">Animal</span>&gt; animals = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();    <span class="hljs-keyword">new</span> <span class="hljs-type">Test3</span>().test(animals,dogs);&#125;<span class="hljs-comment">// Dog 是 Animal 的子类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;&#125;</code></pre><p>dst 类型 “大于等于” src 的类型，这里的“大于等于”是指 dst 表示的范围比 src 要大，因此装得下 dst 的容器也就能装 src 。</p><h3 id="？-和-T-的区别"><a href="#？-和-T-的区别" class="headerlink" title="？ 和 T 的区别"></a>？ 和 T 的区别</h3><p><img src="/2023/02/06/Java%E8%AF%AD%E6%B3%95%E7%B3%96%E4%B9%8B%E6%B3%9B%E5%9E%8B/image-20201104235617914.png" alt="image-20201104235617914">？和 T 都表示不确定的类型，区别在于我们可以对 T 进行操作，但是对 ？ 不行，比如如下这种 ：</p><pre><code class="hljs abnf">// 可以T t <span class="hljs-operator">=</span> operate()<span class="hljs-comment">;</span>// 不可以？ car <span class="hljs-operator">=</span> operate()<span class="hljs-comment">;</span></code></pre><p>简单总结下：</p><p>T 是一个 确定的 类型，通常用于泛型类和泛型方法的定义，？是一个 不确定 的类型，通常用于泛型方法的调用代码和形参，不能用于定义类和泛型方法。</p><h4 id="区别1：通过-T-来-确保-泛型参数的一致性"><a href="#区别1：通过-T-来-确保-泛型参数的一致性" class="headerlink" title="区别1：通过 T 来 确保 泛型参数的一致性"></a>区别1：通过 T 来 确保 泛型参数的一致性</h4><pre><code class="hljs typescript"><span class="hljs-comment">// 通过 T 来 确保 泛型参数的一致性</span><span class="hljs-keyword">public</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span>&gt; <span class="hljs-built_in">void</span><span class="hljs-title function_">test</span>(<span class="hljs-title class_">List</span>&lt;T&gt; dest, <span class="hljs-title class_">List</span>&lt;T&gt; src)<span class="hljs-comment">//通配符是 不确定的，所以这个方法不能保证两个 List 具有相同的元素类型</span><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span><span class="hljs-title function_">test</span>(<span class="hljs-title class_">List</span>&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span>&gt; dest, <span class="hljs-title class_">List</span>&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span>&gt; src)复制代码</code></pre><p>像下面的代码中，约定的 T 是 Number 的子类才可以，但是申明时是用的 String ，所以就会飘红报错。</p><p><img src="/2023/02/06/Java%E8%AF%AD%E6%B3%95%E7%B3%96%E4%B9%8B%E6%B3%9B%E5%9E%8B/image-20201104235641462.png" alt="image-20201104235641462"></p><p>不能保证两个 List 具有相同的元素类型的情况</p><pre><code class="hljs haxe">GlmapperGeneric&lt;<span class="hljs-keyword">String</span>&gt; glmapperGeneric = <span class="hljs-keyword">new</span> <span class="hljs-type">GlmapperGeneric</span>&lt;&gt;();List&lt;<span class="hljs-keyword">String</span>&gt; dest = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();List&lt;Number&gt; src = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();glmapperGeneric.testNon(dest,src);复制代码</code></pre><p>上面的代码在编译器并不会报错，但是当进入到 testNon 方法内部操作时（比如赋值），对于 dest 和 src 而言，就还是需要进行类型转换。</p><h4 id="区别2：类型参数可以多重限定而通配符不行"><a href="#区别2：类型参数可以多重限定而通配符不行" class="headerlink" title="区别2：类型参数可以多重限定而通配符不行"></a>区别2：类型参数可以多重限定而通配符不行</h4><p><img src="/2023/02/06/Java%E8%AF%AD%E6%B3%95%E7%B3%96%E4%B9%8B%E6%B3%9B%E5%9E%8B/image-20201104235710004.png" alt="image-20201104235710004"></p><p>使用 &amp; 符号设定多重边界（Multi Bounds)，指定泛型类型 T 必须是 MultiLimitInterfaceA 和 MultiLimitInterfaceB 的共有子类型，此时变量 t 就具有了所有限定的方法和属性。对于通配符来说，因为它不是一个确定的类型，所以不能进行多重限定。</p><h4 id="区别3：通配符可以使用超类限定而类型参数不行"><a href="#区别3：通配符可以使用超类限定而类型参数不行" class="headerlink" title="区别3：通配符可以使用超类限定而类型参数不行"></a>区别3：通配符可以使用超类限定而类型参数不行</h4><p>类型参数 T 只具有 一种 类型限定方式：</p><pre><code class="hljs actionscript">T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span></code></pre><p>但是通配符 ? 可以进行 两种限定：</p><pre><code class="hljs actionscript">? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>? <span class="hljs-keyword">super</span> A</code></pre><h2 id="Class-和-Class-区别"><a href="#Class-和-Class-区别" class="headerlink" title="Class&lt;T&gt; 和 Class&lt;?&gt; 区别"></a><code>Class&lt;T&gt;</code> 和 <code>Class&lt;?&gt;</code> 区别</h2><p>前面介绍了 ？ 和 T 的区别，那么对于，<code>Class&lt;T&gt;</code> 和 <code>&lt;Class&lt;?&gt;</code> 又有什么区别呢？<br><code>Class&lt;T&gt;</code> 和 <code>Class&lt;?&gt;</code></p><p>最常见的是在反射场景下的使用，这里以用一段发射的代码来说明下。</p><pre><code class="hljs reasonml"><span class="hljs-comment">// 通过反射的方式生成  multiLimit </span><span class="hljs-comment">// 对象，这里比较明显的是，我们需要使用强制类型转换</span>MultiLimit multiLimit = (MultiLimit)<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Class</span>.</span></span><span class="hljs-keyword">for</span><span class="hljs-constructor">Name(<span class="hljs-string">&quot;com.glmapper.bridge.boot.generic.MultiLimit&quot;</span>)</span>.<span class="hljs-keyword">new</span><span class="hljs-constructor">Instance()</span>;复制代码</code></pre><p>对于上述代码，在运行期，如果反射的类型不是 MultiLimit 类，那么一定会报 java.lang.ClassCastException 错误。</p><p>对于这种情况，则可以使用下面的代码来代替，使得在在编译期就能直接 检查到类型的问题：</p><p><img src="/2023/02/06/Java%E8%AF%AD%E6%B3%95%E7%B3%96%E4%B9%8B%E6%B3%9B%E5%9E%8B/image-20201104235733862.png" alt="image-20201104235733862"></p><p><code>Class&lt;T&gt;</code> 在实例化的时候，T 要替换成具体类。<code>Class&lt;?&gt;</code> 它是个通配泛型，? 可以代表任何类型，所以主要用于声明时的限制情况。比如，我们可以这样做申明：</p><pre><code class="hljs delphi"><span class="hljs-comment">// 可以</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">Class</span>&lt;?&gt; clazz;<span class="hljs-comment">// 不可以，因为 T 需要指定类型</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">Class</span>&lt;T&gt; clazzT;</code></pre><p>所以当不知道定声明什么类型的 Class 的时候可以定义一 个Class&lt;?&gt;。</p><p><img src="/2023/02/06/Java%E8%AF%AD%E6%B3%95%E7%B3%96%E4%B9%8B%E6%B3%9B%E5%9E%8B/image-20201104235755696.png" alt="image-20201104235755696"></p><p>那如果也想 <code>public Class&lt;T&gt; clazzT;</code> 这样的话，就必须让当前的类也指定 T ，</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test3</span>&lt;T&gt; &#123;    <span class="hljs-keyword">public</span> Class&lt;?&gt; clazz;    <span class="hljs-comment">// 不会报错</span>    <span class="hljs-keyword">public</span> Class&lt;T&gt; clazzT;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java语法糖之泛型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lambda初次使用很慢？从JIT到类加载再到实现原理</title>
    <link href="/2023/02/06/Lambda%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8%E5%BE%88%E6%85%A2%EF%BC%9F%E4%BB%8EJIT%E5%88%B0%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%86%8D%E5%88%B0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <url>/2023/02/06/Lambda%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8%E5%BE%88%E6%85%A2%EF%BC%9F%E4%BB%8EJIT%E5%88%B0%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%86%8D%E5%88%B0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Lambda初次使用很慢？从JIT到类加载再到实现原理"><a href="#Lambda初次使用很慢？从JIT到类加载再到实现原理" class="headerlink" title="Lambda初次使用很慢？从JIT到类加载再到实现原理"></a>Lambda初次使用很慢？从JIT到类加载再到实现原理</h1><p>标签： #Share</p><h2 id="问题回顾"><a href="#问题回顾" class="headerlink" title="问题回顾"></a>问题回顾</h2><p>描述的话不多说，直接上图：</p><p><img src="/2023/02/06/Lambda%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8%E5%BE%88%E6%85%A2%EF%BC%9F%E4%BB%8EJIT%E5%88%B0%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%86%8D%E5%88%B0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/image-20200629234626454.png" alt="image-20200629234626454"></p><p>看到输出结果了吗？为什么第一次和第二次的时间相差如此之多？咱们一起琢磨琢磨，<strong>也可以先去看看结论再回过头看分析</strong></p><blockquote><p>注：并非仅第二次快，而是除了第一次，之后的每一次都很快</p></blockquote><h2 id="给与猜想"><a href="#给与猜想" class="headerlink" title="给与猜想"></a>给与猜想</h2><ol><li>是否和操作系统预热有关？</li><li>是否和JIT（即时编译）有关？</li><li>是否和ClassLoader类加载有关？</li><li>是否和<code>Lambda</code>有关，并非<code>foreach</code>的问题</li></ol><h2 id="验证猜想"><a href="#验证猜想" class="headerlink" title="验证猜想"></a>验证猜想</h2><h3 id="操作系统预热"><a href="#操作系统预热" class="headerlink" title="操作系统预热"></a>操作系统预热</h3><p>操作系统预热这个概念是我咨询一位大佬得到的结论，在百度 &#x2F; Google 中并未搜索到相应的词汇，但是在模拟测试中，我用 <font color="red">普通遍历</font> 的方式进行测试：</p><p><img src="/2023/02/06/Lambda%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8%E5%BE%88%E6%85%A2%EF%BC%9F%E4%BB%8EJIT%E5%88%B0%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%86%8D%E5%88%B0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/image-20200630003352129.png" alt="image-20200630003352129"></p><p>基本上每次都是前几次速度较慢，后面的速度更快，因此 <font color="red">可能</font> 有这个因素影响，但差距并不会很大，因此该结论并不能作为问题的答案。</p><h3 id="JIT-即时编译"><a href="#JIT-即时编译" class="headerlink" title="JIT 即时编译"></a>JIT 即时编译</h3><p>首先介绍一下什么是JIT即时编译：</p><blockquote><p>当 JVM 的初始化完成后，类在调用执行过程中，执行引擎会把字节码转为机器码，然后在操作系统中才能执行。在字节码转换为机器码的过程中，虚拟机中还存在着一道编译，那就是<code>即时编译</code>。</p><p>最初，JVM 中的字节码是由解释器（ Interpreter ）完成编译的，当虚拟机发现某个方法或代码块的运行特别频繁的时候，就会把这些代码认定为<code>热点代码</code>。</p><p>为了提高热点代码的执行效率，在运行时，即时编译器（JIT，Just In Time）会把这些代码编译成与本地平台相关的机器码，并进行各层次的优化，然后保存到内存中</p></blockquote><p>再来一个概念，<code>回边计数器</code></p><blockquote><p>回边计数器用于统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为 “回边”（Back Edge）</p><p>建立回边计数器的主要目的是为了触发 OSR（On StackReplacement）编译，即栈上编译，在一些循环周期比较长的代码段中，当循环达到回边计数器阈值时，<code>JVM 会认为这段是热点代码</code>，JIT 编译器就会将这段代码编译成机器语言并缓存，在该循环时间段内，会直接将执行代码替换，执行缓存的机器语言</p></blockquote><p>从上述的概念中，我们应该可以得到一个结论：第一条所谓的操作系统预热 <font color="red">大概率不正确</font>，因为普通遍历方法执行N次，后续执行的时间占用比较小，很可能是因为JIT导致的。</p><p>那 JIT即时编译 是否是最终的答案？我们想办法把 JIT 关掉来测试一下，通过查询资料发现了如下内容：</p><p><em><strong>Procedure</strong></em></p><ul><li><p>Use the <strong>-D</strong> option on the JVM command line to set the <strong>java.compiler</strong> property to NONE or the empty string.</p><p>Type the following command at a shell or command prompt:</p><pre><code class="hljs bash">java -Djava.compiler=NONE &lt;class&gt;</code></pre></li></ul><blockquote><p>注：该段内容来自IBM官方资料，地址见 &lt;收获&gt; ，咱们先不要停止思考</p></blockquote><p>通过配置 IDEA JVM 参数：</p><p><img src="/2023/02/06/Lambda%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8%E5%BE%88%E6%85%A2%EF%BC%9F%E4%BB%8EJIT%E5%88%B0%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%86%8D%E5%88%B0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/image-20200630005126426.png" alt="image-20200630005126426"></p><p>执行问题中的代码测试结果如下：</p><pre><code class="hljs bash"><span class="hljs-comment"># 禁用前</span>foreach time one: 38分割线...foreach time two: 1<span class="hljs-comment"># 禁用后</span>foreach time one: 40分割线...foreach time two: 5</code></pre><p>我测试了很多次，结果都很相近，因此得到可以得到另一个结论：<code>JIT </code>并非引发该问题的原因（但是它的确能提高执行效率）</p><h3 id="难道和类加载有关？"><a href="#难道和类加载有关？" class="headerlink" title="难道和类加载有关？"></a>难道和类加载有关？</h3><p>在进行类加载验证时，我依然无法放弃 <code>JIT</code> ，因此查阅了很多资料，知道了某个命令可以查看 <code>JIT</code>编译的耗时情况，命令如下：</p><pre><code class="hljs bash">java -XX:+CITime com.code.jvm.preheat.Demo &gt;&gt; log.txt</code></pre><p>解释一下命令的意思</p><pre><code class="hljs bash"><span class="hljs-comment"># 执行的目录</span>C:\Users\Kerwin\Desktop\Codes\Kerwin-Code-Study\target\classes&gt;<span class="hljs-comment"># 命令含义：Prints time spent in JIT Compiler. (Introduced in 1.4.0.)</span><span class="hljs-comment"># 打印JIT编译所消耗的时间</span>-XX:+CITime<span class="hljs-comment"># 代表我指定的类</span>com.code.jvm.preheat.Demo<span class="hljs-comment"># 输出至log.txt文件，方便观看</span>&gt;&gt; log.txt</code></pre><p>展示一下某一次结果的全部内容：</p><pre><code class="hljs bash">foreach time one: 35分割线...foreach time two: 1Accumulated compiler <span class="hljs-built_in">times</span> (<span class="hljs-keyword">for</span> compiled methods only)  Total compilation time   :  0.044 s    Standard compilation   :  0.041 s, Average : 0.000    On stack replacement   :  0.003 s, Average : 0.002    Detailed C1 Timings       Setup time:         0.000 s ( 0.0%)       Build IR:           0.010 s (38.8%)         Optimize:            0.001 s ( 2.3%)         RCE:                 0.000 s ( 0.7%)       Emit LIR:           0.010 s (40.7%)         LIR Gen:           0.002 s ( 9.3%)         Linear Scan:       0.008 s (31.0%)       LIR Schedule:       0.000 s ( 0.0%)       Code Emission:      0.003 s (12.4%)       Code Installation:  0.002 s ( 8.2%)       Instruction Nodes:   9170 nodes  Total compiled methods   :    162 methods    Standard compilation   :    160 methods    On stack replacement   :      2 methods  Total compiled bytecodes :  13885 bytes    Standard compilation   :  13539 bytes    On stack replacement   :    346 bytes  Average compilation speed: 312157 bytes/s  nmethod code size        : 168352 bytes  nmethod total size       : 276856 bytes</code></pre><p>分别测试的结果如下：</p><table><thead><tr><th>类型</th><th>Total compilation time（JIT编译总耗时）</th></tr></thead><tbody><tr><td>两次 foreach（lambda） 循环</td><td>0.044 s</td></tr><tr><td>两次 foreach （普通）循环</td><td>0.016 s</td></tr><tr><td>两次 增强for循环</td><td>0.015 s</td></tr><tr><td>一次 foreach（lambda） 一次增强for循环</td><td>0.046 s</td></tr></tbody></table><p>通过上述测试结果，反正更加说明了一个问题：<font color="red">只要有 Lambda 参与的程序，编译时间总会长一些</font></p><p>再次通过查询资料，了解了新的命令</p><pre><code class="hljs bash">java -verbose:class -verbose:jni -verbose:gc -XX:+PrintCompilation com.code.jvm.preheat.Demo</code></pre><p>解释一下命令的意思</p><pre><code class="hljs bash"><span class="hljs-comment"># 输出jvm载入类的相关信息</span>-verbose:class<span class="hljs-comment"># 输出native方法调用的相关情况</span>-verbose:jni<span class="hljs-comment"># 输出每次GC的相关情况</span>-verbose:gc<span class="hljs-comment"># 当一个方法被编译时打印相关信息</span>-XX:+PrintCompilation</code></pre><p>对包含Lambda和不包含的分别执行命令，得到的结果如下：</p><p>从日志文件大小来看，就相差了十几kb</p><blockquote><p>注：文件过大，仅展示部分内容</p></blockquote><pre><code class="hljs bash"><span class="hljs-comment"># 包含Lambda</span>[Loaded java.lang.invoke.LambdaMetafactory from D:\JDK\jre1.8\lib\rt.jar]<span class="hljs-comment"># 中间省略了很多内容，LambdaMetafactory 是最明显的区别（仅从名字上发现）</span>[Loaded java.lang.invoke.InnerClassLambdaMetafactory<span class="hljs-variable">$1</span> from D:\JDK\jre1.8\lib\rt.jar]   5143  220       4       java.lang.String::equals (81 bytes)[Loaded java.lang.invoke.LambdaForm<span class="hljs-variable">$MH</span>/471910020 from java.lang.invoke.LambdaForm]   5143  219       3       jdk.internal.org.objectweb.asm.ByteVector::&lt;init&gt; (13 bytes)[Loaded java.lang.invoke.LambdaForm<span class="hljs-variable">$MH</span>/531885035 from java.lang.invoke.LambdaForm]   5143  222       3       jdk.internal.org.objectweb.asm.ByteVector::putInt (74 bytes)   5143  224       3       com.code.jvm.preheat.Demo$$Lambda<span class="hljs-variable">$1</span>/834600351::accept (8 bytes)   5143  225       3       com.code.jvm.preheat.Demo::lambda$getTime<span class="hljs-variable">$0</span> (6 bytes)   5144  226       4       com.code.jvm.preheat.Demo$$Lambda<span class="hljs-variable">$1</span>/834600351::accept (8 bytes)   5144  223       1       java.lang.Integer::intValue (5 bytes)   5144  221       3       jdk.internal.org.objectweb.asm.ByteVector::putByteArray (49 bytes)   5144  224       3       com.code.jvm.preheat.Demo$$Lambda<span class="hljs-variable">$1</span>/834600351::accept (8 bytes)   made not entrant   5145  227 %     4       java.util.ArrayList::forEach @ 27 (75 bytes)   5146    3       3       java.lang.String::equals (81 bytes)   made not entrantforeach time one: 50分割线...   5147  227 %     4       java.util.ArrayList::forEach @ -2 (75 bytes)   made not entrantforeach time two: 1[Loaded java.lang.Shutdown from D:\JDK\jre1.8\lib\rt.jar][Loaded java.lang.Shutdown<span class="hljs-variable">$Lock</span> from D:\JDK\jre1.8\lib\rt.jar]<span class="hljs-comment"># 不包含Lambda</span>   5095   45       1       java.util.ArrayList::access<span class="hljs-variable">$100</span> (5 bytes)   5095   46       1       java.lang.Integer::intValue (5 bytes)   5096   47       3       java.util.ArrayList<span class="hljs-variable">$Itr</span>::hasNext (20 bytes)   5096   49       3       java.util.ArrayList<span class="hljs-variable">$Itr</span>::checkForComodification (23 bytes)   5096   48       3       java.util.ArrayList<span class="hljs-variable">$Itr</span>::next (66 bytes)   5096   50       4       java.util.ArrayList<span class="hljs-variable">$Itr</span>::hasNext (20 bytes)   5096   51       4       java.util.ArrayList<span class="hljs-variable">$Itr</span>::checkForComodification (23 bytes)   5096   52       4       java.util.ArrayList<span class="hljs-variable">$Itr</span>::next (66 bytes)   5097   47       3       java.util.ArrayList<span class="hljs-variable">$Itr</span>::hasNext (20 bytes)   made not entrant   5097   49       3       java.util.ArrayList<span class="hljs-variable">$Itr</span>::checkForComodification (23 bytes)   made not entrant   5097   48       3       java.util.ArrayList<span class="hljs-variable">$Itr</span>::next (66 bytes)   made not entrant   5099   53 %     4       com.code.jvm.preheat.Demo::getTimeFor @ 11 (47 bytes)   5101   50       4       java.util.ArrayList<span class="hljs-variable">$Itr</span>::hasNext (20 bytes)   made not entrantforeach time one: 7分割线...   5102   54       3       java.util.ArrayList<span class="hljs-variable">$Itr</span>::hasNext (20 bytes)   5102   55       4       java.util.ArrayList<span class="hljs-variable">$Itr</span>::hasNext (20 bytes)   5103   53 %     4       com.code.jvm.preheat.Demo::getTimeFor @ -2 (47 bytes)   made not entrantforeach time two: 1   5103   54       3       java.util.ArrayList<span class="hljs-variable">$Itr</span>::hasNext (20 bytes)   made not entrant[Loaded java.lang.Shutdown from D:\JDK\jre1.8\lib\rt.jar][Loaded java.lang.Shutdown<span class="hljs-variable">$Lock</span> from D:\JDK\jre1.8\lib\rt.jar]</code></pre><p>我们可以结合JIT编译时间，结合JVM载入类的日志发现两个结论：</p><ol><li>凡是使用了Lambda，JVM会额外加载 <code>LambdaMetafactory</code>类，且耗时较长</li><li>在<code>第二次调用Lambda方法</code>时，JVM就不再需要额外加载 <code>LambdaMetafactory</code>类，因此执行较快</li></ol><p>完美印证了之前提出的问题：<font color="red">为什么第一次 foreach 慢，以后都很快</font>，但这就是真相吗？我们继续往下看</p><h3 id="排除-foreach-的干扰"><a href="#排除-foreach-的干扰" class="headerlink" title="排除 foreach 的干扰"></a>排除 foreach 的干扰</h3><p>先来看看 <code>ArrayList</code>中 <code>foreach</code>方法的实现：</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> E&gt; action)</span> &#123;    Objects.requireNonNull(action);    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">expectedModCount</span> <span class="hljs-operator">=</span> modCount;    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>    <span class="hljs-keyword">final</span> E[] elementData = (E[]) <span class="hljs-built_in">this</span>.elementData;    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.size;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;        action.accept(elementData[i]);    &#125;    <span class="hljs-keyword">if</span> (modCount != expectedModCount) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();    &#125;&#125;</code></pre><p>乍一看，好像也没什么特别，我们来试试把 Consumer 预先定义好，代码如下：</p><p><img src="/2023/02/06/Lambda%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8%E5%BE%88%E6%85%A2%EF%BC%9F%E4%BB%8EJIT%E5%88%B0%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%86%8D%E5%88%B0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/image-20200630015101773.png" alt="image-20200630015101773"></p><p>可以发现速度很快，检查 <code>JIT编译时间</code>，检查<code>类加载</code>情况，发现耗时短，且无<code>LambdaMetafactory</code>加载</p><p>根据刚才得到的结论，我们试试把 <code>Consumer </code> 用 <code>Lambda</code>的方式定义一下</p><pre><code class="hljs bash">Consumer consumer = o -&gt; &#123;    int curr = (int) o;&#125;;<span class="hljs-comment"># 执行结果耗时</span>foreach time: 3</code></pre><p>再来看看编译时间和类加载，<font color="red">赫然发现：JIT编译时间较长，且有LambdaMetafactory加载</font></p><h2 id="重新探究Lambda的实现原理"><a href="#重新探究Lambda的实现原理" class="headerlink" title="重新探究Lambda的实现原理"></a>重新探究Lambda的实现原理</h2><p><code>Lambda</code>表达式实现原理的细节，我之后会再出一篇新的文章，今天就先说一下结论：</p><ul><li>匿名内部类在编译阶段会多出一个类，而<code>Lambda</code>不会，它仅会多生成一个函数</li><li>该函数会在运行阶段，会通过<code>LambdaMetafactory</code>工厂来生成一个class，进行后续的调用</li></ul><p><em><strong>为什么<code>Lamdba</code>要如此实现？</strong></em></p><p>匿名内部类有一定的缺陷：</p><ol><li>编译器为每个匿名内部类生成一个新的类文件，生成许多类文件是不可取的，因为每个类文件在使用之前都需要加载和验证，这会影响应用程序的启动性能，加载可能是一个昂贵的操作，包括磁盘I&#x2F;O和解压缩JAR文件本身。</li><li>如果lambdas被转换为匿名内部类，那么每个lambda都有一个新的类文件。由于每个匿名内部类都将被加载，它将占用JVM的元空间，如果JVM将每个此类匿名内部类中的代码编译为机器码，那么它将存储在代码缓存中。</li><li>此外，这些匿名内部类将被实例化为单独的对象。因此，匿名内部类会增加应用程序的内存消耗。</li><li>最重要的是，从一开始就选择使用匿名内部类来实现lambdas，这将限制未来lambda实现更改的范围，以及它们根据未来JVM改进而演进的能力。</li></ol><blockquote><p>内容参考：<a href="https://www.infoq.com/articles/Java-8-Lambdas-A-Peek-Under-the-Hood/">https://www.infoq.com/articles/Java-8-Lambdas-A-Peek-Under-the-Hood/</a></p></blockquote><h2 id="真相"><a href="#真相" class="headerlink" title="真相"></a>真相</h2><p>在理解了匿名内部类以及<code>Lambda</code>表达式的实现原理后，对<code>Lambda</code>耗时长的原因反而更懵逼，毕竟匿名内部类的生成一个新类和<code>Lambda</code>生成一个新方法所耗时间差别不会太多，然后运行期间同样有Class产生，耗时也不应该有太大的区别，到底哪里出现了问题呢？</p><p>再次通过科学上网，最终找到了答案：</p><blockquote><p>You are obviously encountering the first-time initialization overhead of lambda expressions. As already mentioned in the comments, the classes for lambda expressions are generated at runtime rather than being loaded from your class path.</p><p>However, being generated isn’t the cause for the slowdown. After all, generating a class having a simple structure can be even faster than loading the same bytes from an external source. And the inner class has to be loaded too. But when the application hasn’t used lambda expressions before, even the framework for generating the lambda classes has to be loaded (Oracle’s current implementation uses ASM under the hood). This is the actual cause of the slowdown, loading and initialization of a dozen internally used classes, not the lambda expression itself.</p></blockquote><p>大概翻译过来如下：</p><p><strong>显然，您遇到了lambda表达式的首次初始化开销。正如注释中已经提到的，lambda表达式的类是在运行时生成的，而不是从类路径加载的。</strong></p><p><strong>然而，生成类并不是速度变慢的原因。毕竟，生成一个结构简单的类比从外部源加载相同的字节还要快。内部类也必须加载。但是，当应用程序以前没有使用lambda表达式时，甚至必须加载用于生成lambda类的框架（Oracle当前的实现在幕后使用ASM）。这是导致十几个内部使用的类（而不是lambda表达式本身）减速、加载和初始化的真正原因。</strong></p><p><font color="red">真相：</font>应用程序初次使用Lambda时，<font color="red"><strong>必须加载用于生成Lambda类的框架</strong></font>，因此需要更多的编译，加载的时间</p><p>回过头去看看类加载的日志，赫然发现了<code>ASM框架</code>的引入：</p><pre><code class="hljs bash">[Loaded jdk.internal.org.objectweb.asm.ClassVisitor from F:\Java_JDK\JDK1.8\jre\lib\rt.jar][Loaded jdk.internal.org.objectweb.asm.ClassWriter from F:\Java_JDK\JDK1.8\jre\lib\rt.jar][Loaded jdk.internal.org.objectweb.asm.ByteVector from F:\Java_JDK\JDK1.8\jre\lib\rt.jar][Loaded jdk.internal.org.objectweb.asm.Item from F:\Java_JDK\JDK1.8\jre\lib\rt.jar][Loaded jdk.internal.org.objectweb.asm.MethodVisitor from F:\Java_JDK\JDK1.8\jre\lib\rt.jar][Loaded jdk.internal.org.objectweb.asm.MethodWriter from F:\Java_JDK\JDK1.8\jre\lib\rt.jar][Loaded jdk.internal.org.objectweb.asm.Type from F:\Java_JDK\JDK1.8\jre\lib\rt.jar][Loaded jdk.internal.org.objectweb.asm.Label from F:\Java_JDK\JDK1.8\jre\lib\rt.jar][Loaded jdk.internal.org.objectweb.asm.Frame from F:\Java_JDK\JDK1.8\jre\lib\rt.jar][Loaded jdk.internal.org.objectweb.asm.AnnotationVisitor from F:\Java_JDK\JDK1.8\jre\lib\rt.jar][Loaded jdk.internal.org.objectweb.asm.AnnotationWriter from F:\Java_JDK\JDK1.8\jre\lib\rt.jar]</code></pre><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul><li>导致 foreach 测试时数据不正常的罪魁祸首是：<code>Lambda表达式</code></li><li><code>Lambda表达式</code> 在应用程序中首次使用时，需要额外加载ASM框架，因此需要更多的编译，加载的时间</li><li><code>Lambda表达式 </code>的底层实现并非匿名内部类的语法糖，而是其优化版</li><li>foreach 的底层实现其实和增强 for循环没有本质区别，一个是外部迭代器，一个是内部迭代器而已</li><li>通过 foreach + Lambda 的写法，效率并不低，只不过需要提前进行<code>预热(加载框架)</code></li></ul><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ul><li>JIT 即时编译的概念和相关命令</li><li>IBM 官方资料库，<a href="https://www.ibm.com/support/knowledgecenter/SSYKE2_8.0.0/welcome/welcome_javasdk_version.html">地址</a></li><li>Oracle 关于JVM命令大全，<a href="https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html">地址</a>  |   国内博主翻译版本 <a href="https://www.cnblogs.com/jack204/archive/2012/07/02/2572932.html">地址</a></li><li>Lambda底层实现文章，<a href="https://www.infoq.com/articles/Java-8-Lambdas-A-Peek-Under-the-Hood/">地址</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lambda初次使用很慢？从JIT到类加载再到实现原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MarkDown画图篇</title>
    <link href="/2023/02/06/MarkDown%E7%94%BB%E5%9B%BE%E7%AF%87/"/>
    <url>/2023/02/06/MarkDown%E7%94%BB%E5%9B%BE%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="MarkDown画图技巧"><a href="#MarkDown画图技巧" class="headerlink" title="MarkDown画图技巧"></a>MarkDown画图技巧</h1><p>标签： #Share</p><h2 id="横向流程图源码格式"><a href="#横向流程图源码格式" class="headerlink" title="横向流程图源码格式"></a>横向流程图源码格式</h2><pre><code class="hljs mermaid">graph LRA[方形] --&gt;B(圆角)  B --&gt; C&#123;条件a&#125;  C --&gt;|a=1| D[结果1]  C --&gt;|a=2| E[结果2]  C --&gt;|a=3| B  F[横向流程图]</code></pre><h2 id="竖向流程图源码格式"><a href="#竖向流程图源码格式" class="headerlink" title="竖向流程图源码格式"></a>竖向流程图源码格式</h2><pre><code class="hljs mermaid">graph TDA[方形] --&gt;B(圆角)    B --&gt; C&#123;条件a&#125;    C --&gt;|a=1| D[结果1]    C --&gt;|a=2| E[结果2]    F[竖向流程图]</code></pre><h2 id="标准流程图源码格式"><a href="#标准流程图源码格式" class="headerlink" title="标准流程图源码格式"></a>标准流程图源码格式</h2><pre><code class="hljs flow">st=&gt;start: 开始框op=&gt;operation: 处理框cond=&gt;condition: 判断框(是或否?)sub1=&gt;subroutine: 子流程io=&gt;inputoutput: 输入输出框e=&gt;end: 结束框st-&gt;op-&gt;condcond(yes)-&gt;io-&gt;econd(no)-&gt;sub1(right)-&gt;op</code></pre><h2 id="注释画图实战"><a href="#注释画图实战" class="headerlink" title="注释画图实战"></a>注释画图实战</h2><pre><code class="hljs mermaid"> sequenceDiagram   Note over Boot: 启动类   Note over PDFThread: 线程类   Note over PDFWorker: 执行类 Boot-&gt;&gt;PDFThread: Boot类启动线程   PDFThread-&gt;&gt;PDFWorker: 线程类调用真正工作Worker   loop 队列处理       PDFThread-&gt;PDFThread: 考虑成功与失败情况处理方案   end      PDFWorker--&gt;&gt;PDFThread: Worker响应执行结果Note right of PDFWorker: 注意参数校验 &lt;br/&gt;文件格式校验</code></pre>]]></content>
    
    
    <categories>
      
      <category>工具篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MarkDown画图篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql技巧及面试篇</title>
    <link href="/2023/02/06/Mysql%E6%8A%80%E5%B7%A7%E5%8F%8A%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
    <url>/2023/02/06/Mysql%E6%8A%80%E5%B7%A7%E5%8F%8A%E9%9D%A2%E8%AF%95%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL技巧及面试篇"><a href="#MySQL技巧及面试篇" class="headerlink" title="MySQL技巧及面试篇"></a>MySQL技巧及面试篇</h1><p>标签： #Share</p><h2 id="MySQL技巧篇"><a href="#MySQL技巧篇" class="headerlink" title="MySQL技巧篇"></a>MySQL技巧篇</h2><h3 id="如何记录慢SQL"><a href="#如何记录慢SQL" class="headerlink" title="如何记录慢SQL"></a>如何记录慢SQL</h3><p>配置项：<code>slow_query_log</code></p><p>可以使用<code>show variables like ‘slov_query_log’</code>查看是否开启，如果状态值为<code>OFF</code>，可以使用<code>set GLOBAL slow_query_log = on</code>来开启，它会在<code>datadir</code>下产生一个<code>xxx-slow.log</code>的文件。</p><p><strong>设置临界时间</strong></p><p>配置项：<code>long_query_time</code></p><p>查看：<code>show VARIABLES like &#39;long_query_time&#39;</code>，单位秒</p><p>设置：<code>set long_query_time=0.5</code></p><p>实操时应该从长时间设置到短的时间，即将最慢的SQL优化掉</p><p><strong>查看日志</strong></p><p>一旦SQL超过了我们设置的临界时间就会被记录到<code>xxx-slow.log</code>中</p><h3 id="压测工具mysqlslap"><a href="#压测工具mysqlslap" class="headerlink" title="压测工具mysqlslap"></a>压测工具mysqlslap</h3><p>安装MySQL时附带了一个压力测试工具<code>mysqlslap</code>（位于<code>bin</code>目录下）</p><p><strong>自动生成sql测试</strong></p><pre><code class="hljs shell">C:\Users\zaw&gt;mysqlslap --auto-generate-sql -uroot -prootmysqlslap: [Warning] Using a password on the command line interface can be insecure.Benchmark        Average number of seconds to run all queries: 1.219 seconds        Minimum number of seconds to run all queries: 1.219 seconds        Maximum number of seconds to run all queries: 1.219 seconds        Number of clients running queries: 1        Average number of queries per client: 0</code></pre><p><strong>并发测试</strong></p><pre><code class="hljs shell">C:\Users\zaw&gt;mysqlslap --auto-generate-sql --concurrency=100 -uroot -prootmysqlslap: [Warning] Using a password on the command line interface can be insecure.Benchmark        Average number of seconds to run all queries: 3.578 seconds        Minimum number of seconds to run all queries: 3.578 seconds        Maximum number of seconds to run all queries: 3.578 seconds        Number of clients running queries: 100        Average number of queries per client: 0        C:\Users\zaw&gt;mysqlslap --auto-generate-sql --concurrency=150 -uroot -prootmysqlslap: [Warning] Using a password on the command line interface can be insecure.Benchmark        Average number of seconds to run all queries: 5.718 seconds        Minimum number of seconds to run all queries: 5.718 seconds        Maximum number of seconds to run all queries: 5.718 seconds        Number of clients running queries: 150        Average number of queries per client: 0</code></pre><p><strong>多轮测试</strong></p><pre><code class="hljs shell">C:\Users\zaw&gt;mysqlslap --auto-generate-sql --concurrency=150 --iterations=10 -uroot -prootmysqlslap: [Warning] Using a password on the command line interface can be insecure.Benchmark        Average number of seconds to run all queries: 5.398 seconds        Minimum number of seconds to run all queries: 4.313 seconds        Maximum number of seconds to run all queries: 6.265 seconds        Number of clients running queries: 150        Average number of queries per client: 0</code></pre><p><strong>存储引擎测试</strong></p><pre><code class="hljs shell">C:\Users\zaw&gt;mysqlslap --auto-generate-sql --concurrency=150 --iterations=3 --engine=innodb -uroot -prootmysqlslap: [Warning] Using a password on the command line interface can be insecure.Benchmark        Running for engine innodb        Average number of seconds to run all queries: 5.911 seconds        Minimum number of seconds to run all queries: 5.485 seconds        Maximum number of seconds to run all queries: 6.703 seconds        Number of clients running queries: 150        Average number of queries per client: 0</code></pre><h2 id="MySQL面试篇"><a href="#MySQL面试篇" class="headerlink" title="MySQL面试篇"></a>MySQL面试篇</h2><h3 id="Q1：如何快速导入大量数据"><a href="#Q1：如何快速导入大量数据" class="headerlink" title="Q1：如何快速导入大量数据"></a>Q1：如何快速导入大量数据</h3><p>在恢复数据时，可能会导入大量的数据。此时为了快速导入，需要掌握一些技巧：</p><p>导入时先禁用索引和约束：</p><pre><code class="hljs mysql">alter table table-name disable keys</code></pre><p>待数据导入完成之后，再开启索引和约束，一次性创建索引</p><pre><code class="hljs mysql">alter table table-name enable keys</code></pre><p>数据库如果使用的引擎是<code>Innodb</code>，那么它默认会给每条写指令加上事务（这也会消耗一定的时间），因此建议先手动开启事务，再执行一定量的批量导入，最后手动提交事务。</p><p>如果批量导入的SQL指令格式相同只是数据不同，那么你应该先<code>prepare</code>预编译一下，这样也能节省很多重复编译的时间。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql技巧及面试篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis篇</title>
    <link href="/2023/02/06/MyBatis%E7%AF%87/"/>
    <url>/2023/02/06/MyBatis%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="Mybatis篇"><a href="#Mybatis篇" class="headerlink" title="Mybatis篇"></a>Mybatis篇</h1><p>标签： #Share</p><blockquote><p>首先推荐一个简单的Mybatis原理视频教程，可以作为入门教程进行学习：<a href="https://b23.tv/av57161139/p1">点我</a>  (该教程讲解的是如何手写简易版Mybatis)</p></blockquote><h2 id="执行流程的理解"><a href="#执行流程的理解" class="headerlink" title="执行流程的理解"></a>执行流程的理解</h2><blockquote><p>理解Mybatis的简单流程后自己手写一个，可以解决百分之70的面试问题和开发中遇到的困惑，此乃重中之重</p></blockquote><p>假如我们要自己设计一个半自动的仿Mybatis框架，有哪些环节是必不可少的呢？思考再三，必然有以下环节：</p><ul><li>相关配置文件加载（XML类型，接口类型则可以省略）</li><li>接口代理（JDK 动态代理）</li><li>针对XML或者接口进行解析 &#x3D;&#x3D;》即把<code>不可直接执行的SQL</code>处理为携带参数，返回值明确的数据结构</li><li>JDBC模块执行，并返回对应的返回值类型</li></ul><p>如果仅考虑这三点的话，其实实现一个简单的ORM框架就很容易了，再附加一些反射和正则表达式等等就可以搞定了.</p><p>那如果去参考Mybatis，我们来看看它的几个环节是如何设计的：</p><p>其实大致思路一样，需要一个数据结构去存储全部的变量，通过接口代理的方式调用Sqlsession里面内置的方法，<code>不同的是真正的执行者又加了一层，是 Executor</code>，再通过原始JDBC返回数据给调用者，当然，<strong>真正的Mybatis包含了众多的设计模式以及数据源，缓存，动态SQL，数据库事务，延迟加载处理</strong>等等</p><p>为了验证mybatis的执行流程，采用了两种方式去调用接口，如下所示：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;    <span class="hljs-comment">// 指定全局配置文件</span>    <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;    <span class="hljs-comment">// 读取配置文件</span>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(resource);    <span class="hljs-comment">// 构建sqlSessionFactory</span>    <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();    <span class="hljs-comment">// Mapper 编程方式</span>    <span class="hljs-type">ScriptDirDao</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(ScriptDirDao.class);    System.out.println(mapper.selectOne(<span class="hljs-number">1</span>));    <span class="hljs-comment">// ibatis 编程方式 ---&gt; 注意由于没有显式设置提交, 因此两个sql执行使用的是同一次sqlsession, 即默认触发了一级缓存</span>    <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> sqlSession.selectOne(<span class="hljs-string">&quot;com.mycode.mybatis.ScriptDirDao.selectOne&quot;</span>, <span class="hljs-number">1</span>);    System.out.println(object);&#125;</code></pre><blockquote><p>ibatis编程方式实际就是通过 namespace+方法名定位具体的接口方法，然后传递参数并执行</p><p>正常使用方式就是基于上述的基本流程做了一层自动的返回值映射，接口方法的匹配</p></blockquote><p>这里有个小点需要强调下，真正的执行者是<code>Executor</code>，我们每次在使用以下代码：</p><pre><code class="hljs java"><span class="hljs-comment">// 构建sqlSessionFactory</span><span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<span class="hljs-comment">// Mapper 编程方式</span><span class="hljs-type">ScriptDirDao</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(ScriptDirDao.class);System.out.println(mapper.selectOne(<span class="hljs-number">1</span>));</code></pre><p>通过查看源码也可以看到，SqlSession接口的默认实现类是<code>DefaultSqlSession</code></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultSqlSession</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SqlSession</span> &#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Configuration configuration;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Executor executor;  <span class="hljs-comment">// 执行者</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> autoCommit;  <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> dirty;  <span class="hljs-keyword">private</span> List&lt;Cursor&lt;?&gt;&gt; cursorList;  .......&#125;</code></pre><p>而方法真正的执行，如selectList方法：</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="hljs-title function_">selectList</span><span class="hljs-params">(String statement, Object parameter, RowBounds rowBounds)</span> &#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-type">MappedStatement</span> <span class="hljs-variable">ms</span> <span class="hljs-operator">=</span> configuration.getMappedStatement(statement);        <span class="hljs-keyword">return</span> executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        <span class="hljs-keyword">throw</span> ExceptionFactory.wrapException(<span class="hljs-string">&quot;Error querying database.  Cause: &quot;</span> + e, e);    &#125; <span class="hljs-keyword">finally</span> &#123;        ErrorContext.instance().reset();    &#125;&#125;</code></pre><h2 id="深度分析文章参考"><a href="#深度分析文章参考" class="headerlink" title="深度分析文章参考"></a>深度分析文章参考</h2><p><a href="https://juejin.im/post/5dcaa0fd51882557486c2de6">源码分析Mybatis MapperProxy初始化之Mapper对象的扫描与构建</a> (作者：掘金- <a href="https://juejin.im/user/5d9742c4f265da5b7a753c36">中间件兴趣圈</a>)</p><p><a href="https://juejin.im/post/5dcd4d8ef265da0bea052777">源码分析Mybatis MappedStatement的创建流程</a>(作者：掘金- <a href="https://juejin.im/user/5d9742c4f265da5b7a753c36">中间件兴趣圈</a>)</p><p><a href="https://juejin.im/post/5dd148175188254c635876d1#heading-5">Mybatis执行SQL的4大基础组件详解</a>(作者：掘金- <a href="https://juejin.im/user/5d9742c4f265da5b7a753c36">中间件兴趣圈</a>)</p><p><a href="https://tech.meituan.com/2018/01/19/mybatis-cache.html">源码解析MyBatis Sharding-Jdbc SQL语句执行流程详解</a>(作者：掘金- <a href="https://juejin.im/user/5d9742c4f265da5b7a753c36">中间件兴趣圈</a>)</p><p><a href="https://tech.meituan.com/2018/01/19/mybatis-cache.html">mybatis 一级二级缓存原理及使用建议</a>(美团技术团队-官方博客)</p><h2 id="面试题集锦"><a href="#面试题集锦" class="headerlink" title="面试题集锦"></a>面试题集锦</h2><blockquote><p>Myabtis的细节使用和执行原理其实都很好理解，对于源码感兴趣的可以深挖，但大多时候建议点到为止即可</p><p>还是着眼当下 面向面试要点进行针对性学习（<strong>不包括一些简单的使用问题</strong>）</p></blockquote><h3 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{}和${}的区别是什么？"></a>#{}和${}的区别是什么？</h3><p> #{} 是预编译处理，${}是字符串替换。Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 的<br>set 方法来赋值；<br>Mybatis 在处理时，就是把时，就是把{}替换成变量的值。<br>使用#{}可以有效的防止 SQL 注入，提高系统安全性 </p><p>PS：mybatis执行的本质还是SQL，因此回归本质可以简单理解为一个对于PreparedStatement ，一个对应 Statement </p><h3 id="通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应，请问，这个-Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？（id是否可以相同）"><a href="#通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应，请问，这个-Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？（id是否可以相同）" class="headerlink" title="通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？（id是否可以相同）"></a>通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？（id是否可以相同）</h3><p>Dao 接口即 Mapper 接口，接口的全限名，就是映射文件中的 namespace 的值；接口的方法名，就是映射文件中 Mapper 的 Statement 的 id 值；接口方法内的参数，就是传递给 sql 的参数</p><pre><code class="hljs 实现原理：```Mapper接口的工作原理是JDK动态代理，mybatis会对每一个mapper代理生成一个mapperProxy对象，代理对象会拦截接口方法，转而自动对应到sqlsession上，最终由```Executor```执行">```参数不同，方法不可重载```，为什么？上文说到mybatis有一个环节是解析XML文件或者解析接口，它会去构建一个叫做 MapperStatement 对象去存储mapper的相关信息，每一个dao接口方法在执行的时候到底是如何定位找到对应的MapperStatement 的呢？源码逻辑图：![1](http://ww1.sinaimg.cn/large/006j28Gply1gbkub983z8j30q107e3zc.jpg)![2](http://ww1.sinaimg.cn/large/006j28Gply1gbkuchgemwj30re06f74o.jpg)```java// 这个 mappedStatements 即protected final Map&lt;String, MappedStatement&gt; mappedStatements = new StrictMap&lt;MappedStatement&gt;(&quot;Mapped Statements collection&quot;);// Key即 XML文件中配置的&lt;mapper namespace=&quot;com.mycode.mybatis.ScriptDirDao&quot;&gt;&lt;select id=&quot;selectOne&quot; resultMap=&quot;BaseResultMap&quot;&gt;    namespace + id ===》 全限名（NameSpace）+方法名</code></pre><h3 id="Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</h3><p>第一种是使用 标签，逐一定义数据库列名和对象属性名之间的映射关系<br>第二种是使用 sql 列的别名功能，将列的别名书写为对象属性名，有了列名与属性名的映射关系后，Mybatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的 </p><h3 id="Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？"></a>Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？</h3><p> Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载，association 指的就是一对一，collection 指的就是一对多查询，在 Mybatis配置文件中，可以配置是否启用延迟加载 lazyLoadingEnabled&#x3D;true|false</p><p>它的原理是，使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 a.getB().getName()，拦截器 invoke()方法发现 a.getB()是null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName()法的调用，这就是延迟加载的基本原理</p><h3 id="Mybatis-的一级、二级缓存"><a href="#Mybatis-的一级、二级缓存" class="headerlink" title="Mybatis 的一级、二级缓存"></a>Mybatis 的一级、二级缓存</h3><p>一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存，无法关闭</p><p>二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态),可在它的映射文件中配置</p><p>对于缓存数据更新机制，当某一个作用域(一级缓存 Session&#x2F;二级缓存Namespaces)的进行了 C&#x2F;U&#x2F;D 操作后，默认该作用域下所有 select 中的缓存将被 clear</p><h3 id="简述-Mybatis-的插件运行原理，以及如何编写一个插件"><a href="#简述-Mybatis-的插件运行原理，以及如何编写一个插件" class="headerlink" title="简述 Mybatis 的插件运行原理，以及如何编写一个插件"></a>简述 Mybatis 的插件运行原理，以及如何编写一个插件</h3><p>Mybatis 仅可以编写针对 ParameterHandler、ResultSetHandler、StatementHandler、Executor 这 4 种接口的插件，Mybatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 InvocationHandler 的 invoke()方法，当然，只会拦截那些你指定需要拦截的方法</p><p>编写插件：实现 Mybatis 的 Interceptor 接口并复写 intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，需要在配置文件中配置你编写的插件 </p><blockquote><p>Mybatis 的插件实际在执行的流程留下了一些固定的环节，允许你自行做一些处理，我们自己利用接口扫描，在代码执行的某个阶段去调用目标方法，也可以实现这种类似插件的做法</p><p>Demo：<a href="https://juejin.im/post/5e37fc40e51d4527214b9fce">SpringBoot代码生成器</a> 包含自定义接口拦截，实现了类似的插件效果</p></blockquote><p>以下问题来源于掘金文章<a href="https://juejin.im/post/5de9ab066fb9a016554eb6a6?utm_source=gold_browser_extension#heading-2">【面试官之你说我听】-MyBatis常见面试题</a>(作者:<strong>Ccww</strong>)</p><h3 id="数据库链接中断如何处理"><a href="#数据库链接中断如何处理" class="headerlink" title="数据库链接中断如何处理"></a>数据库链接中断如何处理</h3><p>数据库的访问底层是通过tcp实现的，当链接中断是程序是无法得知，导致程序一直会停顿一段时间在这，最终会导致用户体验不好，因此面对数据库连接中断的异常，该怎么设置mybatis呢？</p><p>connection操作底层是一个循环处理操作，因此可以进行时间有关的参数：</p><ul><li>max_idle_time ： 表明最大的空闲时间，超过这个时间socket就会关闭</li><li>connect_timeout ： 表明链接的超时时间</li></ul><h3 id="在开发过程中，经常遇到插入重复的现象，这种情况该如何解决呢？"><a href="#在开发过程中，经常遇到插入重复的现象，这种情况该如何解决呢？" class="headerlink" title="在开发过程中，经常遇到插入重复的现象，这种情况该如何解决呢？"></a>在开发过程中，经常遇到插入重复的现象，这种情况该如何解决呢？</h3><blockquote><p> 插入的过程一般都是分两步的：先判断是否存在记录，没有存在则插入否则不插入。如果存在并发操作，那么同时进行了第一步，然后大家都发现没有记录，然后都插入了数据从而造成数据的重复 </p></blockquote><p>分布式环境中通过Redis分布式锁解决即可，多线程环节下用普通的Lock锁解决即可</p><h3 id="事务执行过程中宕机的应对处理方式"><a href="#事务执行过程中宕机的应对处理方式" class="headerlink" title="事务执行过程中宕机的应对处理方式"></a>事务执行过程中宕机的应对处理方式</h3><blockquote><p>数据库插入百万级数据的时候，还没操作完，但是把服务器重启了，数据库会继续执行吗？ 还是直接回滚了？</p></blockquote><p>不会自动继续执行，不会自动直接回滚 ,但可以依据事务日志进行回滚或者进行执行。</p><p>事务开启时，事务中的操作，都会先写入存储引擎的日志缓冲中，在事务提交之前，这些缓冲的日志都需要提前刷新到磁盘上持久化 ，两种类型：</p><blockquote><p>在事务执行的过程中，除了记录redo log，还会记录一定量的undo log。</p></blockquote><ul><li>redo log  ：按语句的执行顺序，依次交替的记录在一起</li><li>undo log： 主要为事务的回滚服务。undo log记录了数据在每个操作前的状态，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作</li></ul><h3 id="Mybatis都有哪些Executor执行器？它们之间的区别是什么？"><a href="#Mybatis都有哪些Executor执行器？它们之间的区别是什么？" class="headerlink" title="Mybatis都有哪些Executor执行器？它们之间的区别是什么？"></a>Mybatis都有哪些Executor执行器？它们之间的区别是什么？</h3><p>Mybatis有三种基本的Executor执行器，<strong>SimpleExecutor、ReuseExecutor、BatchExecutor。</strong></p><ul><li><strong>SimpleExecutor：</strong>每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</li><li><strong>ReuseExecutor：</strong>执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用Statement对象。</li><li><strong>BatchExecutor：</strong>执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</li></ul><p>作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内</p><p>在Mybatis配置文件中，可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数</p><h2 id="记一次Mybatis使用错误：集合遍历"><a href="#记一次Mybatis使用错误：集合遍历" class="headerlink" title="记一次Mybatis使用错误：集合遍历"></a>记一次Mybatis使用错误：集合遍历</h2><pre><code class="hljs sql"><span class="hljs-keyword">Parameter</span> ‘customerIdList’ <span class="hljs-keyword">not</span> found. Available parameters <span class="hljs-keyword">are</span> [collection, list]</code></pre><p><code>情景还原</code></p><pre><code class="hljs xml">DAO 层：Long selectCustomerCountList(List customerIdList);XML文件：<span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectCustomerCountList&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;java.util.List&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;java.lang.Long&quot;</span>&gt;</span>select count(1) from np_customer_info where id in<span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;customerIdList&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>  #&#123;item, jdbcType=INTEGER&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>结果：报错-&gt;Parameter ‘customerIdList’ not found. Available parameters are [collection, list]</code></pre><p><code>分析</code></p><p>当我们传递一个 List 实例或者数组作为参数对象传给 MyBatis。当你这么做的时 候,<strong>MyBatis 会自动将它包装在一个 Map 中,用名称</strong></p><p><strong>作为键，List 实例将会以“list” 作为键,而数组实例将会以“array”作为键</strong> </p><p>因此需要进行修改和调整，方式如下：</p><p>方案一： 将我们的XML中collection属性值设置为list </p><pre><code class="hljs xml">DAO 层：Long selectCustomerCountList( List customerIdList);XML文件：<span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectCustomerCountList&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;java.util.List&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;java.lang.Long&quot;</span>&gt;</span>select count(1) from np_customer_info where id in<span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">......</span></span><span class="hljs-tag">&lt;/<span class="hljs-attr">foreach</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre><p>方案二： 利用注解@Param指定我们的入参名称 </p><pre><code class="hljs xml">DAO层：Long selectCustomerCountList(@Param(&quot;customerIdList&quot;) List customerIdList);XML文件：<span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectCustomerCountList&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;java.util.List&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;java.lang.Long&quot;</span>&gt;</span>select count(1) from np_customer_info where id in<span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;customerIdList&quot;</span> <span class="hljs-attr">....</span>   </span><span class="hljs-tag">&lt;/<span class="hljs-attr">foreach</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre><p>方案三： 将我们的List包装成Map参数进行传递 </p><pre><code class="hljs xml">Service层：public Long selectCustomerCountMap(List customerIdList) &#123;   Map maps = new HashMap();maps.put(&quot;customerIds&quot;, customerIdList);return customerMapper.selectCustomerCountMap(maps);&#125;DAO层：Long selectCustomerCountMap(Map maps);XML文件：<span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectCustomerCountMap&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;java.util.Map&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;java.lang.Long&quot;</span>&gt;</span>    select count(1) from np_customer_info where id in    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;customerIds&quot;</span> <span class="hljs-attr">.....</span>   </span><span class="hljs-tag">    &lt;/<span class="hljs-attr">foreach</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>Myabtis也有其缺点，重复代码实在太多，在这里推荐我的另一篇文章，SpringBoot &amp; Mybatis代码生成器，解决百分之90的重复代码，数据库建好即可CRUD，所有XML都是手写，欢迎尝试一下</p><p>点击 &#x3D;&#x3D;&#x3D;》 <a href="https://juejin.im/post/5e37fc40e51d4527214b9fce">SpringBoot代码生成器</a></p><p>集中感谢几位作者：</p><p>掘金-<a href="https://juejin.im/user/5cd27385e51d453f146bb8e7">Ccww</a></p><p>掘金- <a href="https://juejin.im/user/5d9742c4f265da5b7a753c36">中间件兴趣圈</a></p><p>美团技术团队-<a href="https://tech.meituan.com/2018/01/19/mybatis-cache.html">官方博客</a></p>]]></content>
    
    
    <categories>
      
      <category>框架篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MyBatis篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PhantomJS篇</title>
    <link href="/2023/02/06/PhantomJS%E7%AF%87/"/>
    <url>/2023/02/06/PhantomJS%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="PhantomJS-篇"><a href="#PhantomJS-篇" class="headerlink" title="PhantomJS 篇"></a>PhantomJS 篇</h1><p>标签： #Share</p><p>PhantomJS 组件常用在爬虫领域，但是它也有其非常灵活的一面，即用作截取网页长图，或者将网页内容存储为PDF</p><h2 id="PhantomJS-下载"><a href="#PhantomJS-下载" class="headerlink" title="PhantomJS 下载"></a>PhantomJS 下载</h2><p><a href="https://phantomjs.org/download.html">地址</a></p><p><a href="https://phantomjs.org/api/webpage/">API文档库</a></p><h2 id="Windows使用"><a href="#Windows使用" class="headerlink" title="Windows使用"></a>Windows使用</h2><p>下载完成后，直接解压即可直接进行使用，同时调用PhantomJS.exe时需要配合JS一同使用，以转出PNG图片或者PDF为例</p><p><code>JS文件</code></p><pre><code class="hljs javascript"><span class="hljs-comment">// JS -&gt; 可直接运行生成PDF或者PNG   HTML转PDF需求解决方案：HTML -&gt; PNG -&gt; PDF或者HTML -&gt; PDF</span><span class="hljs-keyword">var</span> page = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpage&#x27;</span>).<span class="hljs-title function_">create</span>(),    system = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;system&#x27;</span>),    address, output, size;<span class="hljs-keyword">if</span> (system.<span class="hljs-property">args</span>.<span class="hljs-property">length</span> &lt; <span class="hljs-number">3</span> || system.<span class="hljs-property">args</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">5</span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Usage: rasterize.js URL filename&#x27;</span>);    phantom.<span class="hljs-title function_">exit</span>(<span class="hljs-number">1</span>);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 目标地址</span>    address = system.<span class="hljs-property">args</span>[<span class="hljs-number">1</span>];<span class="hljs-comment">// 输出地址</span>    output  = system.<span class="hljs-property">args</span>[<span class="hljs-number">2</span>];<span class="hljs-comment">// 尺寸 1200*7000</span>size    = system.<span class="hljs-property">args</span>[<span class="hljs-number">3</span>].<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;*&#x27;</span>);    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(page.<span class="hljs-property">settings</span>.<span class="hljs-property">userAgent</span> );page.<span class="hljs-property">settings</span>.<span class="hljs-property">loadImages</span> = <span class="hljs-literal">true</span>;    page.<span class="hljs-property">paperSize</span> = &#123;<span class="hljs-attr">width</span>: size[<span class="hljs-number">0</span>], <span class="hljs-attr">height</span>: size[<span class="hljs-number">1</span>], <span class="hljs-attr">orientation</span>: <span class="hljs-string">&#x27;portrait&#x27;</span>, <span class="hljs-attr">border</span>: <span class="hljs-string">&#x27;0.5cm&#x27;</span> &#125;;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;open page now&quot;</span>);    page.<span class="hljs-title function_">open</span>(address, <span class="hljs-keyword">function</span> (<span class="hljs-params">status</span>) &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(status);        <span class="hljs-comment">// 预留一定的渲染时间</span>        <span class="hljs-variable language_">window</span>.<span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;            page.<span class="hljs-title function_">render</span>(output);            page.<span class="hljs-title function_">close</span>();            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Render ok&#x27;</span>);            phantom.<span class="hljs-title function_">exit</span>();        &#125;, <span class="hljs-number">3000</span>);    &#125;);&#125;;</code></pre><p><code>命令如下</code></p><pre><code class="hljs shell">F:\browsers\phantomjs-2.1.1-windows\bin&gt;phantomjs.exe html2pdf.js &quot;参数一:URL&quot; &quot;参数二:输出文件地址可以为xxx.png或者xxx.pdf&quot; &quot;尺寸如:1200*6500&quot;</code></pre><blockquote><p>命令参数根据JS文件调整即可  输出文件为 .pdf 即输出PDF文件，为.png即输出截图图片</p><p>与此同时JS文件中的尺寸大小可以直接调整为如A4纸等等</p></blockquote><h2 id="JS文件Tips"><a href="#JS文件Tips" class="headerlink" title="JS文件Tips"></a>JS文件Tips</h2><pre><code class="hljs javascript"><span class="hljs-comment">// 如果想要强行对PDF内容进行分页，对需要分页的内容增加以下样式即可</span>.<span class="hljs-property">pdf</span>-page &#123;page-<span class="hljs-keyword">break</span>-<span class="hljs-attr">before</span>: always;page-<span class="hljs-keyword">break</span>-<span class="hljs-attr">after</span>: always;page-<span class="hljs-keyword">break</span>-<span class="hljs-attr">inside</span>: avoid;&#125;</code></pre><h2 id="Linux环境使用"><a href="#Linux环境使用" class="headerlink" title="Linux环境使用"></a>Linux环境使用</h2><p>PhantomJS 安装步骤：</p><ul><li>下载安装包并解压</li><li>安装依赖软件： yum -y install wget fontconfig</li><li>设置环境变量：ln -s &#x2F;目标地址&#x2F;bin   &#x2F;usr&#x2F;bin&#x2F;</li><li>phantomjs -v 检测是否安装成功</li><li>安装中文字体：<br>centos中执行 ：yum install bitmap-fonts bitmap-fonts-cjk<br>ubuntu中执行：sudo apt-get install ttf-wqy-zenhei              #文泉驿-正黑 （全平台兼容字体）</li></ul><p>其余使用方式同windows一致，通过 phantomjs xxx.js 参数一 参数二….</p><p>值得注意的是：Linux的PDF渲染效果不如Windows,Mac好</p><h2 id="PNG图片转PDF代码技巧"><a href="#PNG图片转PDF代码技巧" class="headerlink" title="PNG图片转PDF代码技巧"></a>PNG图片转PDF代码技巧</h2><blockquote><p>可以直接将PNG图片完美塞入到PDF中，缺点即不可直接复制文字</p></blockquote><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 生成PDF --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.itextpdf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>itextpdf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.5.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PDFUtils</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">imgToPdf</span> <span class="hljs-params">(String imgUrl, String pdfUrl)</span> <span class="hljs-keyword">throws</span> IOException, DocumentException &#123;        <span class="hljs-type">Document</span> <span class="hljs-variable">doc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Document</span>(PageSize.A4, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>);        PdfWriter.getInstance(doc, <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(pdfUrl));        doc.open();        <span class="hljs-comment">// Img</span>        <span class="hljs-type">Image</span> <span class="hljs-variable">png</span> <span class="hljs-operator">=</span> Image.getInstance(imgUrl);        png.setAlignment(Image.MIDDLE);        doc.setPageSize(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>(png.getPlainWidth(), png.getPlainHeight() + <span class="hljs-number">300F</span>));        doc.newPage();        doc.add(png);        doc.close();    &#125;&#125;</code></pre><h2 id="中文乱码问题"><a href="#中文乱码问题" class="headerlink" title="中文乱码问题"></a>中文乱码问题</h2><p>在使用Ubuntu服务器作为截图以及渲染PDF介质时，会遇到很坑的中文乱码问题，一般解决办法是下载安装文泉驿宋体，但是经过</p><p>测试，在苹果手机，电脑等依然会是乱码，因此针对ubuntu服务器，可以使用文泉驿正黑字体解决乱码问题：</p><pre><code class="hljs shell">sudo apt-get install ttf-wqy-zenhei      #文泉驿-正黑 （全平台兼容字体）</code></pre><p>Ubuntu如果需要安装其他字体，参考步骤：</p><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装字体管理工具</span>sudo apt-get install font-manager<span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_"># </span><span class="language-bash">查看现有字体（可查看到字体安装位置）</span>fc-list</code></pre><p>安装字体：</p><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装字体</span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_"># </span><span class="language-bash">方式一：</span><span class="hljs-meta prompt_"># </span><span class="language-bash">在/usr/share/fonts目录下，新建如 chinese文件夹，将需要的tff文件复制进文件夹，如微软雅黑等</span><span class="hljs-meta prompt_"># </span><span class="language-bash">然后执行如下命令：</span>mkfontscalemkfontdirfc-cache -fv （刷新字体缓存）<span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_"># </span><span class="language-bash">方式二，通过软件安装：</span>sudo apt-get install ttf-wqy-microhei   #文泉驿-微米黑sudo apt-get install ttf-wqy-zenhei     #文泉驿-正黑 （全平台兼容字体）sudo apt-get install xfonts-wqy         #文泉驿-点阵宋体<span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_"># </span><span class="language-bash">注意通过软件安装的方式，其实也是在/usr/share/fonts目录下新建了文件夹并移入了tff字体，因此卸载逻辑和下面一致</span></code></pre><p>卸载字体：</p><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">卸载字体的方式非常简单，例如我们新建了chinese目录，只需要 <span class="hljs-built_in">rm</span> -rf ....chinese（包含字体的目录）</span><span class="hljs-meta prompt_"># </span><span class="language-bash">再刷新字体缓存即可</span>rm -rf /usr/share/fonts/demofc-cache -fv</code></pre>]]></content>
    
    
    <categories>
      
      <category>工具篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PhantomJS篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx篇</title>
    <link href="/2023/02/06/Nginx%E7%AF%87/"/>
    <url>/2023/02/06/Nginx%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="Nginx篇"><a href="#Nginx篇" class="headerlink" title="Nginx篇"></a>Nginx篇</h1><p>标签： #Share</p><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>Nginx是一款轻量级的 Web服务器 &#x2F; 反向代理服务器 &#x2F; 电子邮件（IMAP&#x2F;POP3）代理服务器，主要的优点是：</p><ol><li><p>支持高并发连接，尤其是静态界面，官方测试Nginx能够支撑5万并发连接</p></li><li><p>内存占用极低</p></li><li><p>配置简单，使用灵活，可以基于自身需要增强其功能，同时支持自定义模块的开发</p><p>使用灵活：可以根据需要，配置不同的负载均衡模式，URL地址重写等功能</p></li><li><p>稳定性高，在进行反向代理时，宕机的概率很低</p></li><li><p>支持热部署，应用启动重载非常迅速</p></li></ol><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><h3 id="Windows版"><a href="#Windows版" class="headerlink" title="Windows版"></a>Windows版</h3><p><strong>安装</strong></p><p>文件下载地址：<a href="http://nginx.org/en/docs/windows.html">http://nginx.org/en/docs/windows.html</a></p><p>如果下载很慢可以用该链接：</p><p>百度云盘链接: <a href="https://pan.baidu.com/s/1r3mSEGhmz4HA46Cw9w6QTQ">https://pan.baidu.com/s/1r3mSEGhmz4HA46Cw9w6QTQ</a> 提取码: d8bi</p><p>解压即可</p><p><strong>基本命令</strong></p><pre><code class="hljs bash"><span class="hljs-comment"># 启动</span><span class="hljs-comment"># 建议使用第一种，第二种会使窗口一直处于执行中，不能进行其他命令操作</span>C:\server\nginx-1.19.2&gt; start nginxC:\server\nginx-1.19.2&gt; nginx.exe<span class="hljs-comment"># 停止</span><span class="hljs-comment"># stop是快速停止nginx，可能并不保存相关信息；quit是完整有序的停止nginx，并保存相关信息</span>C:\server\nginx-1.19.2&gt; nginx.exe -s stopC:\server\nginx-1.19.2&gt; nginx.exe -s quit<span class="hljs-comment"># 重载Nginx</span><span class="hljs-comment"># 当配置信息修改，需要重新载入这些配置时使用此命令</span>C:\server\nginx-1.19.2&gt; nginx.exe -s reload<span class="hljs-comment"># 重新打开日志文件</span>C:\server\nginx-1.19.2&gt; nginx.exe -s reopen<span class="hljs-comment"># 查看Nginx版本</span>C:\server\nginx-1.19.2&gt; nginx -v<span class="hljs-comment"># 查看配置文件是否正确</span>C:\server\nginx-1.19.2&gt; nginx -t</code></pre><p><strong>简单Demo</strong></p><ol><li><p>利用<code>SwitchHost</code>软件编辑域名和IP的映射关系，或到目录<code>C:\Windows\System32\drivers\etc</code>下，编辑<code>hosts</code>文件，增加配置如下（Mac 同理）</p><pre><code class="hljs bash">127.0.0.1  kerwin.demo.com</code></pre><p>PS：推荐使用软件<code>SwitchHost</code>，工作时几乎是必用的</p></li><li><p>修改配置，如图所示：</p><p><img src="/2023/02/06/Nginx%E7%AF%87/image-20200905185840840.png" alt="image-20200905185840840"></p></li></ol><p>效果如图所示：</p><p><img src="/2023/02/06/Nginx%E7%AF%87/image-20200905185913004.png" alt="image-20200905185913004"></p><h2 id="Nginx在架构体系中的作用"><a href="#Nginx在架构体系中的作用" class="headerlink" title="Nginx在架构体系中的作用"></a>Nginx在架构体系中的作用</h2><ul><li>网关 （面向客户的总入口）</li><li>虚拟主机（为不同域名 &#x2F; ip  &#x2F; 端口提供服务。如：VPS虚拟服务器）</li><li>路由（正向代理 &#x2F; 反向代理）</li><li>静态服务器</li><li>负载集群（提供负载均衡）</li></ul><h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p>网关：可以简单的理解为用户请求和服务器响应的关口，即面向用户的总入口</p><p>网关可以拦截客户端所有请求，对该请求进行权限控制、负载均衡、日志管理、接口调用监控等，因此无论使用什么架构体系，都可以使用<code>Nginx</code>作为最外层的网关</p><h3 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h3><p><strong>虚拟主机的定义</strong>：虚拟主机是一种特殊的软硬件技术，它可以将网络上的每一台计算机分成多个虚拟主机，每个虚拟主机可以独立对外提供 www 服务，这样就可以实现一台主机对外提供多个 web 服务，每个虚拟主机之间是独立的，互不影响的。</p><p>通过 Nginx 可以实现虚拟主机的配置，Nginx 支持三种类型的虚拟主机配置</p><ul><li>基于 IP 的虚拟主机</li><li>基于域名的虚拟主机</li><li>基于端口的虚拟主机</li></ul><p>表现形式其实大家多见过，即：</p><pre><code class="hljs bash"><span class="hljs-comment"># 每个 server 就是一个虚拟主机</span>http &#123;    <span class="hljs-comment"># ...</span>    server&#123;        <span class="hljs-comment"># ...</span>    &#125;        <span class="hljs-comment"># ...</span>    server&#123;        <span class="hljs-comment"># ...</span>    &#125;&#125;</code></pre><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>在<code>Nginx</code>的配置文件中，我们经常可以看到这样的配置：</p><pre><code class="hljs bash">location / &#123;<span class="hljs-comment">#....</span>&#125;</code></pre><p><code>location</code>在此处就起到了路由的作用，比如我们在同一个虚拟主机内定义两个不同的路由，如下：</p><pre><code class="hljs bash">location / &#123;proxy_pass https://www.baidu.com/;&#125;location /api &#123;proxy_pass https://apinew.juejin.im/user_api/v1/user/get?aid=2608&amp;user_id=1275089220013336&amp;not_self=1; &#125;</code></pre><p>效果如下：</p><p><img src="/2023/02/06/Nginx%E7%AF%87/image-20200905192200164.png" alt="image-20200905192200164"></p><p>因为路由的存在，为我们后续解决<code>跨域问题</code>提供了一定的思路，同时配置内容和API接口等更加方便</p><p>PS：路由的功能非常强大，<code>支持正则匹配</code></p><h4 id="正向与反向代理"><a href="#正向与反向代理" class="headerlink" title="正向与反向代理"></a>正向与反向代理</h4><p>此处额外解释一下<code>proxy_pass</code>的含义</p><p>在<code>Nginx</code>中配置<code>proxy_pass</code>代理转发时，如果在<code>proxy_pass</code>后面的url加 <code>/</code>，表示绝对根路径；</p><p>如果没有<code>/</code>，表示相对路径</p><p><strong>正向代理</strong></p><ol><li>代理客户;</li><li>隐藏真实的客户，为客户端收发请求，使真实客户端对服务器不可见;</li><li>一个局域网内的所有用户可能被一台服务器做了正向代理，由该台服务器负责 HTTP 请求;</li><li>意味着同服务器做通信的是正向代理服务器;</li></ol><p><strong>反向代理</strong></p><ol><li>代理服务器;</li><li>隐藏了真实的服务器，为服务器收发请求，使真实服务器对客户端不可见;</li><li>负载均衡服务器，将用户的请求分发到空闲的服务器上;</li><li>意味着用户和负载均衡服务器直接通信，即用户解析服务器域名时得到的是负载均衡服务器的 IP ;</li></ol><p><strong>共同点</strong></p><ol><li>都是做为服务器和客户端的中间层</li><li>都可以加强内网的安全性，阻止 web 攻击</li><li>都可以做缓存机制，提高访问速度</li></ol><p><strong>区别</strong></p><ol><li>正向代理其实是客户端的代理,反向代理则是服务器的代理。</li><li>正向代理中，服务器并不知道真正的客户端到底是谁；而在反向代理中，客户端也不知道真正的服务器是谁。</li><li>作用不同。正向代理主要是用来解决访问限制问题；而反向代理则是提供负载均衡、安全防护等作用。</li></ol><h4 id="Nginx代理不同网站图片"><a href="#Nginx代理不同网站图片" class="headerlink" title="Nginx代理不同网站图片"></a>Nginx代理不同网站图片</h4><p>我们利用Nginx可以很轻松代理指定的URL地址，但如果涉及变化的域名该如何处理呢？</p><pre><code class="hljs bash">location /http_proxy &#123;    <span class="hljs-comment"># 域名解析，避免域名无法被识别</span>    resolver 114.114.114.114 223.5.5.5 valid=3600s;    resolver_timeout 3s;        <span class="hljs-comment"># 转发至address参数结果上 参数名：address</span>    proxy_pass  <span class="hljs-string">&quot;<span class="hljs-variable">$arg_address</span>&quot;</span>;        <span class="hljs-comment"># 设置Header</span>    proxy_hide_header Origin;    proxy_set_header Host <span class="hljs-variable">$proxy_host</span>;    proxy_set_header  X-Real-IP  <span class="hljs-variable">$remote_addr</span>;    proxy_set_header  X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;    proxy_set_header X-NginX-Proxy <span class="hljs-literal">true</span>;&#125;</code></pre><p>访问地址（address 参数值可以填任意结果）：</p><pre><code class="hljs bash">http://localhost/http_proxy?address=https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9d30c81602941b69b3c347e5325405e~tplv-k3u1fbpfcp-watermark.image</code></pre><p>即可得到转发后的图片，如下图所示：</p><p><img src="/2023/02/06/Nginx%E7%AF%87/image-20210302015720602.png" alt="image-20210302015720602"></p><h3 id="静态服务器"><a href="#静态服务器" class="headerlink" title="静态服务器"></a>静态服务器</h3><p>静态服务器是<code>Nginx</code>的强项，使用非常容易，在默认配置下本身就是指向了静态的HTML界面，如：</p><pre><code class="hljs bash">location / &#123;root   html;index  index.html index.htm;&#125;</code></pre><p>所以前端同学们，如果构建好了界面，可以进行相应的配置，把界面指向目标文件夹中即可，<code>root</code>指的是<code>html</code>文件夹</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>负载均衡功能是<code>Nginx</code>另一大杀手锏，一共有5种方式，着重介绍一下。</p><h4 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h4><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除，配置如下：</p><pre><code class="hljs bash">upstream tomcatserver &#123;server 192.168.0.1;server 192.168.0.2;&#125;</code></pre><p>轮询策略是默认的负载均衡策略</p><h4 id="指定权重"><a href="#指定权重" class="headerlink" title="指定权重"></a>指定权重</h4><p>即在轮询的基础之上，增加权重的概念，<code>weight</code>和访问比率成正比，用于后端服务器性能不均的情况，配置如下：</p><pre><code class="hljs bash">upstream tomcatserver &#123;server 192.168.0.1 weight=1;server 192.168.0.2 weight=10;&#125;</code></pre><h4 id="IP-Hash"><a href="#IP-Hash" class="headerlink" title="IP Hash"></a>IP Hash</h4><p>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题，配置如下：</p><pre><code class="hljs bash">upstream tomcatserver &#123;ip_hash;server 192.168.0.14:88;server 192.168.0.15:80;&#125;</code></pre><h4 id="fair"><a href="#fair" class="headerlink" title="fair"></a>fair</h4><p>第三方提供的负载均衡策略，按后端服务器的响应时间来分配请求，响应时间短的优先分配，生产环境中有各种情况可能导致响应时间波动，需要慎用</p><pre><code class="hljs bash">upstream tomcatserver &#123;server server1;server server2;fair;&#125;</code></pre><h4 id="url-hash"><a href="#url-hash" class="headerlink" title="url_hash"></a>url_hash</h4><p>第三方提供的负载均衡策略，按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器</p><pre><code class="hljs bash">upstream tomcatserver &#123;server squid1:3128;server squid2:3128;<span class="hljs-built_in">hash</span> <span class="hljs-variable">$request_uri</span>;hash_method crc32;&#125;</code></pre><h2 id="Nginx的模块化设计"><a href="#Nginx的模块化设计" class="headerlink" title="Nginx的模块化设计"></a>Nginx的模块化设计</h2><p>先来看看<code>Nginx</code>模块架构图：</p><p><img src="/2023/02/06/Nginx%E7%AF%87/image-20200905231750989.png" alt="image-20200905231750989"></p><p>这5个模块由上到下重要性一次递减。</p><p>（1）核心模块；</p><p>核心模块是Nginx服务器正常运行必不可少的模块，如同操作系统的内核。它提供了Nginx最基本的核心服务。像进程管理、权限控制、错误日志记录等；</p><p>（2）标准HTTP模块；</p><p>标准HTTP模块支持标准的HTTP的功能，如：端口配置，网页编码设置，HTTP响应头设置等；</p><p>（3）可选HTTP模块；</p><p>可选HTTP模块主要用于扩展标准的HTTP功能，让Nginx能处理一些特殊的服务，如：解析GeoIP请求，SSL支持等；</p><p>（4）邮件服务模块；</p><p>邮件服务模块主要用于支持Nginx的邮件服务；</p><p>（5）第三方模块；</p><p>第三方模块是为了扩展Nginx服务器应用，完成开发者想要的功能，如：Lua支持，JSON支持等；</p><blockquote><p>模块化设计使得Nginx方便开发和扩展，功能很强大</p></blockquote><h2 id="Nginx的请求处理流程"><a href="#Nginx的请求处理流程" class="headerlink" title="Nginx的请求处理流程"></a>Nginx的请求处理流程</h2><p>基于上文中的<code>Nginx</code>模块化结构，我们很容易想到，在请求的处理阶段也会经历诸多的过程，<code>Nginx </code>将各功能模块组织成一条链，当有请求到达的时候，请求依次经过这条链上的部分或者全部模块，进行处理，每个模块实现特定的功能。</p><p>一个 HTTP Request 的处理过程：</p><ul><li>初始化 HTTP Request</li><li>处理请求头、处理请求体</li><li>如果有的话，调用与此请求（URL 或者 Location）关联的 handler</li><li>依次调用各 phase handler 进行处理</li><li>输出内容依次经过 filter 模块处理</li></ul><p><img src="/2023/02/06/Nginx%E7%AF%87/798214-20191223134103333-1313823621.png" alt="img"></p><h2 id="Nginx的多进程模型"><a href="#Nginx的多进程模型" class="headerlink" title="Nginx的多进程模型"></a>Nginx的多进程模型</h2><p>Nginx 在启动后，会有一个 <code>master </code>进程和多个 <code>worker </code>进程。</p><p><code>master </code>进程主要用来管理<code>worker </code>进程，包括接收来自外界的信号，向各 worker 进程发送信号，监控 worker 进程的运行状态以及启动 worker 进程。</p><p> <code>worker </code>进程是用来处理来自客户端的请求事件。多个 worker 进程之间是对等的，它们同等竞争来自客户端的请求，各进程互相独立，一个请求只能在一个 worker 进程中处理。worker 进程的个数是可以设置的，一般会设置与机器 CPU 核数一致，这里面的原因与事件处理模型有关</p><p>Nginx 的进程模型，可由下图来表示：</p><p><img src="/2023/02/06/Nginx%E7%AF%87/8a4bf67b456016f07ea2679dca069051_articlex.png" alt="img"></p><p>这种设计带来以下优点：</p><p><strong>1） 利用多核系统的并发处理能力</strong></p><p>现代操作系统已经支持多核 CPU 架构，这使得多个进程可以分别占用不同的 CPU 核心来工作。Nginx 中所有的 worker 工作进程都是完全平等的。这提高了网络性能、降低了请求的时延。</p><p><strong>2） 负载均衡</strong></p><p>多个 worker 工作进程通过进程间通信来实现负载均衡，即一个请求到来时更容易被分配到负载较轻的 worker 工作进程中处理。这也在一定程度上提高了网络性能、降低了请求的时延。</p><p><strong>3） 管理进程会负责监控工作进程的状态，并负责管理其行为</strong></p><p>管理进程不会占用多少系统资源，它只是用来启动、停止、监控或使用其他行为来控制工作进程。首先，这提高了系统的可靠性，当 worker 进程出现问题时，管理进程可以启动新的工作进程来避免系统性能的下降。其次，管理进程支持 Nginx 服务运行中的程序升级、配置项修改等操作，这种设计使得动态可扩展性、动态定制性较容易实现。</p><h3 id="Nginx如何解决惊群现象"><a href="#Nginx如何解决惊群现象" class="headerlink" title="Nginx如何解决惊群现象"></a>Nginx如何解决惊群现象</h3><p><strong>什么是惊群现象？</strong></p><p>惊群效应（thundering herd）是指多进程（多线程）在同时阻塞等待同一个事件的时候（休眠状态），如果等待的这个事件发生，那么他就会唤醒等待的所有进程（或者线程），但是最终却只能有一个进程（线程）获得这个时间的“控制权”，对该事件进行处理，而其他进程（线程）获取“控制权”失败，只能重新进入休眠状态，这种现象和性能浪费就叫做惊群效应。</p><p>上文中介绍了Nginx的多进程模型，而典型的多进程模型正如文中所说，多个worker进程之间是对等的，因此当一个请求到来的时候，所有进程会同时开始竞争，最终执行的又只有一个，这样势必会造成资源的浪费。</p><p>Nginx解决该问题的思路是：<strong>不让多个进程在同一时间监听接受连接的socket，而是让每个进程轮流监听</strong>，这样当有连接过来的时候，就只有一个进程在监听那肯定就没有惊群的问题。</p><p>具体做法是：利用一把进程间锁，每个进程中都<strong>尝试</strong>获得这把锁，如果获取成功将监听socket加入wait集合中，并设置超时等待连接到来，没有获得锁的进程则将监听socket从wait集合去除。</p><h2 id="事件驱动模型和异步非阻塞IO"><a href="#事件驱动模型和异步非阻塞IO" class="headerlink" title="事件驱动模型和异步非阻塞IO"></a>事件驱动模型和异步非阻塞IO</h2><p>承接上文，我们知道了Nginx的多进程模型后了解到，其工作进程实际上只有几个，但为什么依然能获得如此高的并发性能，当然与其采用的事件驱动模型和异步非阻塞IO的方式来处理请求有关。</p><p>Nginx服务器响应和处理Web请求的过程，是基于事件驱动模型的，它包含事件收集器、事件发送器和事件处理器等三部分基本单元，着重关注<code>事件处理器</code>，而一般情况下事件处理器有这么几种办法：</p><ul><li>事件发送器每传递过来一个请求，目标对象就创建一个新的进程</li><li>事件发送器每传递过来一个请求，目标对象就创建一个新的线程，来进行处理</li><li>事件发送器每传递过来一个请求，目标对象就将其放入一个待处理事件的列表，使用非阻塞I&#x2F;O方式调用</li></ul><p>第三种方式，在编写程序代码时，逻辑比前面两种都复杂。大多数网络服务器采用了第三种方式，逐渐形成了所谓的<code>事件驱动处理库</code>。</p><p><code>事件驱动处理库</code>又被称为<code>多路IO复用方法</code>，最常见的包括以下三种：select模型，poll模型和epoll模型。</p><p>其中Nginx就默认使用的是<code>epoll</code>模型，同时也支持其他事件模型。</p><p><code>epoll</code>的帮助就在于其提供了一种机制，可以让进程同时处理多个并发请求，不用关心IO调用的具体状态。IO调用完全由事件驱动模型来管理，这样一来，当某个工作进程接收到客户端的请求以后，调用IO进行处理，如果不能立即得到结果，就去处理其他的请求；而工作进程在此期间也无需等待响应，可以去处理其他事情；当IO返回时，<code>epoll</code>就会通知此工作进程；该进程得到通知后，会来继续处理未完的请求</p><h2 id="Nginx配置的最佳实践"><a href="#Nginx配置的最佳实践" class="headerlink" title="Nginx配置的最佳实践"></a>Nginx配置的最佳实践</h2><p>在生产环境或者开发环境中Nginx一般会代理多个虚拟主机，如果把所有的配置文件写在默认的<code>nginx.conf</code>中，看起来会非常臃肿，因此建议将每一个虚拟文件单独放置一个文件夹，Nginx支持这样的配置，如下：</p><pre><code class="hljs bash">http &#123;<span class="hljs-comment"># 省略中间配置</span><span class="hljs-comment"># 引用该目录下以 .conf 文件结尾的配置</span>    include /etc/nginx/conf.d/*.conf;&#125;</code></pre><p>具体文件配置如：</p><pre><code class="hljs bash"><span class="hljs-comment"># Demo</span>upstream web_pro_testin &#123;server 10.42.46.70:6003 max_fails=3 fail_timeout=20s;ip_hash;&#125; server &#123;listen 80;server_name web.pro.testin.cn;location / &#123;proxy_pass http://web_pro_testin;proxy_redirect off;proxy_set_header Host <span class="hljs-variable">$host</span>;proxy_set_header X-Real-IP <span class="hljs-variable">$remote_addr</span>;    &#125;     location ~ ^/(WEB-INF)/ &#123;deny all;    &#125;&#125;</code></pre><h2 id="Nginx全量配置参数说明"><a href="#Nginx全量配置参数说明" class="headerlink" title="Nginx全量配置参数说明"></a>Nginx全量配置参数说明</h2><pre><code class="hljs bash"><span class="hljs-comment"># 运行用户</span>user www-data;    <span class="hljs-comment"># 启动进程,通常设置成和cpu的数量相等</span>worker_processes  6;<span class="hljs-comment"># 全局错误日志定义类型，[debug | info | notice | warn | error | crit]</span>error_log  logs/error.log;error_log  logs/error.log  notice;error_log  logs/error.log  info;<span class="hljs-comment"># 进程pid文件</span>pid        /var/run/nginx.pid;<span class="hljs-comment"># 工作模式及连接数上限</span>events &#123;    <span class="hljs-comment"># 仅用于linux2.6以上内核,可以大大提高nginx的性能</span>    use   epoll;         <span class="hljs-comment"># 单个后台worker process进程的最大并发链接数</span>    worker_connections  1024;             <span class="hljs-comment"># 客户端请求头部的缓冲区大小</span>    client_header_buffer_size 4k;        <span class="hljs-comment"># keepalive 超时时间</span>    keepalive_timeout 60;              <span class="hljs-comment"># 告诉nginx收到一个新连接通知后接受尽可能多的连接</span>    <span class="hljs-comment"># multi_accept on;            </span>&#125;<span class="hljs-comment">#设定http服务器，利用它的反向代理功能提供负载均衡支持</span>http &#123;    <span class="hljs-comment"># 文件扩展名与文件类型映射表义</span>    include       /etc/nginx/mime.types;        <span class="hljs-comment"># 默认文件类型</span>    default_type  application/octet-stream;        <span class="hljs-comment"># 默认编码</span>    charset utf-8;        <span class="hljs-comment"># 服务器名字的hash表大小</span>    server_names_hash_bucket_size 128;        <span class="hljs-comment"># 客户端请求头部的缓冲区大小</span>    client_header_buffer_size 32k;        <span class="hljs-comment"># 客户请求头缓冲大小</span>large_client_header_buffers 4 64k;<span class="hljs-comment"># 设定通过nginx上传文件的大小</span>    client_max_body_size 8m;        <span class="hljs-comment"># 开启目录列表访问，合适下载服务器，默认关闭。</span>    autoindex on;    <span class="hljs-comment"># sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，对于普通应用，</span>    <span class="hljs-comment"># 必须设为 on,如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，以平衡磁盘与网络I/O处理速度</span>    sendfile        on;        <span class="hljs-comment"># 此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用</span>    <span class="hljs-comment">#tcp_nopush     on;</span>    <span class="hljs-comment"># 连接超时时间（单秒为秒）</span>    keepalive_timeout  65;            <span class="hljs-comment"># gzip模块设置</span>    gzip on;               <span class="hljs-comment">#开启gzip压缩输出</span>    gzip_min_length 1k;    <span class="hljs-comment">#最小压缩文件大小</span>    gzip_buffers 4 16k;    <span class="hljs-comment">#压缩缓冲区</span>    gzip_http_version 1.0; <span class="hljs-comment">#压缩版本（默认1.1，前端如果是squid2.5请使用1.0）</span>    gzip_comp_level 2;     <span class="hljs-comment">#压缩等级</span>    gzip_types text/plain application/x-javascript text/css application/xml;    gzip_vary on;    <span class="hljs-comment"># 开启限制IP连接数的时候需要使用</span>    <span class="hljs-comment">#limit_zone crawler $binary_remote_addr 10m;</span>   <span class="hljs-comment"># 指定虚拟主机的配置文件，方便管理</span>    include /etc/nginx/conf.d/*.conf;    <span class="hljs-comment"># 负载均衡配置</span>    upstream mysvr &#123;        <span class="hljs-comment"># 请见上文中的五种配置</span>    &#125;   <span class="hljs-comment"># 虚拟主机的配置</span>    server &#123;                <span class="hljs-comment"># 监听端口</span>        listen 80;        <span class="hljs-comment"># 域名可以有多个，用空格隔开</span>        server_name www.jd.com jd.com;                <span class="hljs-comment"># 默认入口文件名称</span>        index index.html index.htm index.php;        root /data/www/jd;        <span class="hljs-comment"># 图片缓存时间设置</span>        location ~ .*.(gif|jpg|jpeg|png|bmp|swf)<span class="hljs-variable">$&#123;</span><span class="hljs-variable">            expires 10d;</span><span class="hljs-variable">        &#125;</span>                 <span class="hljs-comment">#JS和CSS缓存时间设置</span>        location ~ .*.(js|css)?<span class="hljs-variable">$&#123;</span><span class="hljs-variable">            expires 1h;</span><span class="hljs-variable">        &#125;</span>                 <span class="hljs-comment"># 日志格式设定</span>        <span class="hljs-comment">#$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；</span>        <span class="hljs-comment">#$remote_user：用来记录客户端用户名称；</span>        <span class="hljs-comment">#$time_local： 用来记录访问时间与时区；</span>        <span class="hljs-comment">#$request： 用来记录请求的url与http协议；</span>        <span class="hljs-comment">#$status： 用来记录请求状态；成功是200，</span>        <span class="hljs-comment">#$body_bytes_sent ：记录发送给客户端文件主体内容大小；</span>        <span class="hljs-comment">#$http_referer：用来记录从那个页面链接访问过来的；</span>        log_format access <span class="hljs-string">&#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span>        <span class="hljs-string">&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span>        <span class="hljs-string">&#x27;&quot;$http_user_agent&quot; $http_x_forwarded_for&#x27;</span>;                 <span class="hljs-comment"># 定义本虚拟主机的访问日志</span>        access_log  /usr/local/nginx/logs/host.access.log  main;        access_log  /usr/local/nginx/logs/host.access.404.<span class="hljs-built_in">log</span>  log404;                 <span class="hljs-comment"># 对具体路由进行反向代理</span>        location /connect-controller &#123;             proxy_pass http://127.0.0.1:88;            proxy_redirect off;            proxy_set_header X-Real-IP <span class="hljs-variable">$remote_addr</span>;                         <span class="hljs-comment"># 后端的Web服务器可以通过X-Forwarded-For获取用户真实IP</span>            proxy_set_header X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;            proxy_set_header Host <span class="hljs-variable">$host</span>;            <span class="hljs-comment"># 允许客户端请求的最大单文件字节数</span>            client_max_body_size 10m;            <span class="hljs-comment"># 缓冲区代理缓冲用户端请求的最大字节数，</span>            client_body_buffer_size 128k;            <span class="hljs-comment"># 表示使nginx阻止HTTP应答代码为400或者更高的应答。</span>            proxy_intercept_errors on;            <span class="hljs-comment"># nginx跟后端服务器连接超时时间(代理连接超时)</span>            proxy_connect_timeout 90;            <span class="hljs-comment"># 后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据</span>            proxy_send_timeout 90;            <span class="hljs-comment"># 连接成功后，后端服务器响应的超时时间</span>            proxy_read_timeout 90;            <span class="hljs-comment"># 设置代理服务器（nginx）保存用户头信息的缓冲区大小</span>            proxy_buffer_size 4k;            <span class="hljs-comment"># 设置用于读取应答的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k</span>            proxy_buffers 4 32k;            <span class="hljs-comment"># 高负荷下缓冲大小（proxy_buffers*2）</span>            proxy_busy_buffers_size 64k;            <span class="hljs-comment"># 设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长</span>            <span class="hljs-comment"># 设定缓存文件夹大小，大于这个值，将从upstream服务器传</span>            proxy_temp_file_write_size 64k;        &#125;                <span class="hljs-comment"># 动静分离反向代理配置（多路由指向不同的服务端或界面）</span>        location ~ .(jsp|jspx|<span class="hljs-keyword">do</span>)?$ &#123;            proxy_set_header Host <span class="hljs-variable">$host</span>;            proxy_set_header X-Real-IP <span class="hljs-variable">$remote_addr</span>;            proxy_set_header X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;            proxy_pass http://127.0.0.1:8080;        &#125;    &#125;&#125;</code></pre><h2 id="Nginx还能做什么"><a href="#Nginx还能做什么" class="headerlink" title="Nginx还能做什么"></a>Nginx还能做什么</h2><h3 id="解决CORS跨域问题"><a href="#解决CORS跨域问题" class="headerlink" title="解决CORS跨域问题"></a>解决CORS跨域问题</h3><p>思路有两个：</p><ul><li>基于多路由，把跨域的两个请求发到各自的服务器，然后统一访问入口即可避免该问题</li><li>利用Nginx配置Headerd的功能，为其附上相应的请求头</li></ul><h3 id="适配-PC-或移动设备"><a href="#适配-PC-或移动设备" class="headerlink" title="适配 PC 或移动设备"></a>适配 PC 或移动设备</h3><p>根据用户设备不同返回不同样式的站点，以前经常使用的是纯前端的自适应布局，但无论是复杂性和易用性上面还是不如分开编写的好，比如我们常见的淘宝、京东……这些大型网站就都没有采用自适应，而是用分开制作的方式，根据用户请求的 <code>user-agent</code> 来判断是返回 PC 还是 H5 站点</p><h3 id="请求限流"><a href="#请求限流" class="headerlink" title="请求限流"></a>请求限流</h3><p>Nginx按请求速率限速模块使用的是漏桶算法，即能够强行保证请求的实时处理速度不会超过设置的阈值，如：</p><pre><code class="hljs bash">http &#123;    limit_req_zone <span class="hljs-variable">$binary_remote_addr</span> zone=one:10m rate=1r/s;    server &#123;        location /search/ &#123;            limit_req zone=one burst=5 nodelay;        &#125;    &#125;&#125;</code></pre><h3 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h3><p>如：图片防盗链，请求过滤，泛域名转发，配置HTTPS等等</p><p>可参考文章：<a href="https://juejin.im/post/6844904144235413512">《Nginx 从入门到实践，万字详解！》</a></p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="Q1：Nginx一般用作什么？"><a href="#Q1：Nginx一般用作什么？" class="headerlink" title="Q1：Nginx一般用作什么？"></a>Q1：Nginx一般用作什么？</h3><blockquote><p>见上文中Nginx在架构体系中的作用，配合Nginx还能做什么作答即可</p></blockquote><h3 id="Q2：为什么要用Nginx？"><a href="#Q2：为什么要用Nginx？" class="headerlink" title="Q2：为什么要用Nginx？"></a>Q2：为什么要用Nginx？</h3><blockquote><p>理解网关的必要性，以及Nginx保证高可用，负载均衡的能力</p></blockquote><h3 id="Q3：为什么Nginx这么快？"><a href="#Q3：为什么Nginx这么快？" class="headerlink" title="Q3：为什么Nginx这么快？"></a>Q3：为什么Nginx这么快？</h3><p>如果一个server采用一个进程负责一个request的方式，那么进程数就是并发数。那么显而易见的，就是会有很多进程在等待中。等什么？最多的应该是等待网络传输。</p><p>而nginx 的异步非阻塞工作方式正是利用了这点等待的时间。在需要等待的时候，这些进程就空闲出来待命了。因此表现为少数几个进程就解决了大量的并发问题。</p><p>nginx是如何利用的呢，简单来说：同样的4个进程，如果采用一个进程负责一个request的方式，那么，同时进来4个request之后，每个进程就负责其中一个，直至会话关闭。期间，如果有第5个request进来了。就无法及时反应了，因为4个进程都没干完活呢，因此，一般有个调度进程，每当新进来了一个request，就新开个进程来处理。</p><p>nginx不这样，每进来一个request，会有一个worker进程去处理。但不是全程的处理，处理到什么程度呢？处理到可能发生阻塞的地方，比如向上游（后端）服务器转发request，并等待请求返回。那么，这个处理的worker不会这么傻等着，他会在发送完请求后，注册一个事件：“如果upstream返回了，告诉我一声，我再接着干”。于是他就休息去了。此时，如果再有request 进来，他就可以很快再按这种方式处理。而一旦上游服务器返回了，就会触发这个事件，worker才会来接手，这个request才会接着往下走。</p><p>由于web server的工作性质决定了每个request的大部份生命都是在网络传输中，实际上花费在server机器上的时间片不多。这是几个进程就解决高并发的秘密所在。</p><blockquote><p>总结：事件模型，异步非阻塞，多进程模型加上细节优化的共同作用</p></blockquote><h3 id="Q4：什么是正向代理和反向代理"><a href="#Q4：什么是正向代理和反向代理" class="headerlink" title="Q4：什么是正向代理和反向代理"></a>Q4：什么是正向代理和反向代理</h3><blockquote><p>见上文</p></blockquote><h3 id="Q5：Nginx负载均衡的算法有哪些？"><a href="#Q5：Nginx负载均衡的算法有哪些？" class="headerlink" title="Q5：Nginx负载均衡的算法有哪些？"></a>Q5：Nginx负载均衡的算法有哪些？</h3><blockquote><p>见上文</p></blockquote><h3 id="Q6：Nginx如何解决的惊群现象？"><a href="#Q6：Nginx如何解决的惊群现象？" class="headerlink" title="Q6：Nginx如何解决的惊群现象？"></a>Q6：Nginx如何解决的惊群现象？</h3><blockquote><p>见上文</p></blockquote><h3 id="Q7：Nginx为什么不用多线程模型？"><a href="#Q7：Nginx为什么不用多线程模型？" class="headerlink" title="Q7：Nginx为什么不用多线程模型？"></a>Q7：Nginx为什么不用多线程模型？</h3><blockquote><p>深入理解多进程模型加上异步非阻塞IO的好处以及多线程模型中上下文切换的劣势</p></blockquote><h3 id="Q8：Nginx压缩功能有什么坏处吗？"><a href="#Q8：Nginx压缩功能有什么坏处吗？" class="headerlink" title="Q8：Nginx压缩功能有什么坏处吗？"></a>Q8：Nginx压缩功能有什么坏处吗？</h3><blockquote><p>非常耗费服务器的CPU</p></blockquote><h3 id="Q9：Nginx有几种进程模型"><a href="#Q9：Nginx有几种进程模型" class="headerlink" title="Q9：Nginx有几种进程模型?"></a>Q9：Nginx有几种进程模型?</h3><blockquote><p>实际上有两种，多进程和单进程，但是实际工作中都是多进程的</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.im/post/6844903849988227086">【前端词典】如何向老板解释反向代理</a></li><li><a href="https://www.jianshu.com/p/2b95794a3654">[code.nginx] Nginx服务器的事件驱动模型</a></li><li><a href="https://www.cnblogs.com/baby123/p/12052583.html">Nginx模块化设计</a></li><li><a href="https://www.nginx.cn/doc/">Nginx中文文档</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>中间件篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RocketMQ-消息队列篇</title>
    <link href="/2023/02/06/RocketMQ-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AF%87/"/>
    <url>/2023/02/06/RocketMQ-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="RocketMQ-消息队列篇"><a href="#RocketMQ-消息队列篇" class="headerlink" title="RocketMQ-消息队列篇"></a>RocketMQ-消息队列篇</h1><p>标签： #Share</p><h2 id="Windows安装部署"><a href="#Windows安装部署" class="headerlink" title="Windows安装部署"></a>Windows安装部署</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a><strong>下载</strong></h3><p>地址：[<a href="https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.5.2/rocketmq-all-4.5.2-bin-release.zip%5D">https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.5.2/rocketmq-all-4.5.2-bin-release.zip]</a></p><p>选择‘Binary’进行下载</p><p>解压已下载工程</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><blockquote><p>新增系统变量<br>ROCKETMQ_HOME  -&gt;  F:\RocketMQ\rocketmq-4.5.2</p><p>JAVA_HOME             -&gt;  F:\Java_JDK\JDK1.8</p><p>Path 系统变量新增：Maven&#x2F;bin目录</p><p>PS：RocketMQ 消息存储在C:\Users\Administrator\store store目录中  <code>文件占用较大，注意删除不必要的内容</code></p></blockquote><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><blockquote><p>start mqnamesrv.cmd</p><p>start mqbroker.cmd -n 127.0.0.1:9876 autoCreateTopicEnable&#x3D;true</p></blockquote><h3 id="Rocket集成可视化监控插件"><a href="#Rocket集成可视化监控插件" class="headerlink" title="Rocket集成可视化监控插件"></a>Rocket集成可视化监控插件</h3><ol><li><p>任意目录（拉取项目，随便哪里都行）git clone <a href="https://github.com/apache/rocketmq-externals.git">https://github.com/apache/rocketmq-externals.git</a></p></li><li><p>进入‘rocketmq-externals\rocketmq-console\src\main\resources’文件夹，打开‘application.properties’进行配置</p></li><li><p>其实就是一个SpringBoot服务，确定好端口，别重复即可</p><p>server.port&#x3D;8100</p><p>rocketmq.config.namesrvAddr&#x3D;127.0.0.1:9876</p></li><li><p>进入‘\rocketmq-externals\rocketmq-console’文件夹</p><p>执行‘mvn clean package -Dmaven.test.skip&#x3D;true’，编译生成target</p><p>java -jar rocketmq-console-ng-1.0.1.jar</p></li><li><p>根据配置地址访问： <a href="http://127.0.0.1:8100/">http://127.0.0.1:8100</a></p></li></ol><p><code>Rocket可视化监控插件 增加Topic | 自动增加Topic（4.5.2版本）</code></p><p><img src="/2023/02/06/RocketMQ-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AF%87/1569294651705.png" alt="1569294651705"></p><blockquote><p>4.5.2 版本 支持自动创建Topic</p><p>4.3.0 版本 必须通过监控程序配置Topic，否则执行程序报错，没有此路由</p></blockquote><h3 id="SpringBoot集成-RocketMQ"><a href="#SpringBoot集成-RocketMQ" class="headerlink" title="SpringBoot集成 RocketMQ"></a>SpringBoot集成 RocketMQ</h3><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--RocketMQ--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.rocketmq<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>rocketmq-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h2 id="RocketMQ基本概念"><a href="#RocketMQ基本概念" class="headerlink" title="RocketMQ基本概念"></a>RocketMQ基本概念</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>基于RocketMQ的分布式系统，一般可以分为四个集群：Name server、broker、producer、consumer</p><ol><li><p>name server</p><ul><li><p>提供轻量级的服务发现和路由服务；</p></li><li><p>每个节点都存放了全部的路由信息和对应的读写服务；</p></li><li><p>存储支持水平扩展</p></li></ul></li><li><p>broker</p><ul><li>提供满足TOPIC和QUEUE机制的消息存储服务；</li><li>有推和拉两种模式；</li><li>通过2或3拷贝实现高可用；</li><li>提供上亿消息的堆积能力；</li><li>提供故障恢复、统计功能和告警功能；</li></ul></li><li><p>producer</p><ul><li>支持分布式部署，通过负载平衡模块给broker发消息</li><li>支持快速失败</li><li>低延迟</li></ul></li><li><p>consumer</p><ol><li>支持推和拉两种模式</li><li>支持集群消费和广播消费</li></ol></li></ol><h3 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h3><h4 id="Name-Server"><a href="#Name-Server" class="headerlink" title="Name Server"></a>Name Server</h4><blockquote><p>提供Broker管理；Routing管理（路由管理）</p></blockquote><p>NameServer，很多时候称为命名发现服务，其在RocketMQ中起着中转承接的作用，是一个无状态的服务，多个NameServer之间不通信。任何Producer，Consumer，Broker与所有NameServer通信，向NameServer请求或者发送数据。而且都是单向的，Producer和Consumer请求数据，Broker发送数据。正是因为这种单向的通信，RocketMQ水平扩容变得很容易</p><ul><li>提供轻量级的服务发现和路由服务；</li><li>每个节点都存放了全部的路由信息和对应的读写服务；</li><li>存储支持水平扩展</li></ul><p>总结：相比于ZooKeeper提供的分布式锁，发布和订阅，数据一致性，选举等，在RocketMQ是不适用的，因此重写了一套更加轻量级的发现服务，主要用以存储 Broker相关信息以及当前Broker上的topic信息，路由信息等</p><h4 id="Broker-Server"><a href="#Broker-Server" class="headerlink" title="Broker Server"></a>Broker Server</h4><blockquote><p>提供Remoting Module、客户端管理、存储服务、HA服务(主从)、索引服务</p></blockquote><ul><li>提供满足TOPIC和QUEUE机制的消息存储服务；</li><li>有推和拉两种模式；</li><li>通过2或3拷贝实现高可用；</li><li>提供上亿消息的堆积能力；</li><li>提供故障恢复、统计功能和告警功能；</li></ul><h4 id="producer"><a href="#producer" class="headerlink" title="producer"></a>producer</h4><ul><li>支持分布式部署，通过负载平衡模块给broker发消息</li><li>支持快速失败</li><li>低延迟</li></ul><h4 id="consumer"><a href="#consumer" class="headerlink" title="consumer"></a>consumer</h4><ul><li>支持推和拉两种模式</li><li>支持集群消费和广播消费</li></ul><h3 id="核心角色介绍"><a href="#核心角色介绍" class="headerlink" title="核心角色介绍"></a>核心角色介绍</h3><h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><p>生产者发送业务系统产生的消息给broker, RocketMQ提供了多种发送方式：同步的、异步的、单向的</p><h4 id="生产者组"><a href="#生产者组" class="headerlink" title="生产者组"></a>生产者组</h4><p>具有相同角色的生产者被分到一组, 假如原始的生产者在事务后崩溃，broker会联系 同一生产者组中的不同生产者实例，继续提交或回滚事务</p><h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><p>一个消费者从broker拉取信息，并将信息返还给应用。为了我们应用的正确性，提供了两种消费者类型：</p><p>拉式消费者：拉式消费者从broker拉取消息，一旦一批消息被拉取，用户应用系统将发起消费过程。</p><p>推式消费者：推式消费者，从另一方面讲，囊括了消息的拉取、消费过程，并保持了内部的其他工作，留下了一个回调 接口给终端用户去实现，实现在消息到达时要执行的内容。</p><h4 id="消费者组"><a href="#消费者组" class="headerlink" title="消费者组"></a>消费者组</h4><p>具有相同角色的消费者被组在一起，称为消费者组，它完成了负载均衡和容错的目标</p><p>一个消费组中的消费者实例必须有确定的相同的订阅topic</p><h4 id="Topic（主题）"><a href="#Topic（主题）" class="headerlink" title="Topic（主题）"></a>Topic（主题）</h4><p>Topic是一个消息的目录，在这个目录中，生产者传送消息，消费者拉取消息，可以多个消费者订阅同一个topic，一个生产者也可以发送多个topic</p><p>PS：RocketMQ 基于发布订阅模式，发布订阅的核心即 Topic 主题</p><h4 id="Message（消息）"><a href="#Message（消息）" class="headerlink" title="Message（消息）"></a>Message（消息）</h4><p>消息是被传递的信息。一个消息必须有一个Topic，它可以理解为信件上的地址。一个消息也可以有一个可选的tag，和额外的key-value对。 例如：你可以设置业务中的键到你的消息中，在broker服务中查找消息，以便在开发期间诊断问题</p><h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>Topic被分割成一个或多个消息队列。队列分为3中角色：异步主、同步主、从。如果你不能容忍消息丢失，我们建议你部署同步主，并加一个从队列。 如果你容忍丢失，但你希望队列总是可用，你可以部署异步主和从队列。如果你想最简单，你只需要一个异步主，不需要从队列。 消息保存磁盘的方式也有两种，推荐使用的是异步保存，同步保存是昂贵的并会导致性能损失，如果你想要可靠性，我们推荐你使用同步主+从的方式。</p><h4 id="Tag（标签）"><a href="#Tag（标签）" class="headerlink" title="Tag（标签）"></a>Tag（标签）</h4><p>标签，用另外一个词来说，就是子主题，为用户提供额外的灵活性。具有相同Topic的消息可以有不同的tag。</p><h4 id="Broker（队列）"><a href="#Broker（队列）" class="headerlink" title="Broker（队列）"></a>Broker（队列）</h4><p>Broker是RocketMQ的一个主要组件，它接收生产者发送的消息，存储它们并准备处理消费者的拉取请求。它也存储消息相关的元数据， 包括消费组，消费成功的偏移量，主题、队列的信息。</p><h4 id="名称服务"><a href="#名称服务" class="headerlink" title="名称服务"></a>名称服务</h4><p>名称服务主要提供路由信息。生产者&#x2F;消费者客户端寻找topic，并找到通信的队列列表。</p><h4 id="消息的顺序"><a href="#消息的顺序" class="headerlink" title="消息的顺序"></a>消息的顺序</h4><p>当<code>DefaultMQPushConsumer</code>被使用，你就要决定消费消息时，是顺序消费还是同时消费</p><ul><li>顺序消费</li></ul><p>　　顺序消费消息的意思是 消息将按照生产者发送到队列时的顺序被消费掉。如果你被强制要求使用全局的顺序，你要确保你的topic只有一个消息队列。</p><p>如果指定顺序消费，消息被同时消费的数量就是订阅这个topic的消费组的数量。</p><ul><li>同时消费</li></ul><p>　　当同时消费消息时，消息同时消费的最大数量取决于消费客户端指定的线程池的大小。</p><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><h5 id="Producer最佳实践"><a href="#Producer最佳实践" class="headerlink" title="Producer最佳实践"></a><strong>Producer最佳实践</strong></h5><ol><li><p>一个应用尽可能用一个 Topic，消息子类型用 tags 来标识，tags 可以由应用自由设置。<strong>只有发送消息设置了tags，消费方在订阅消息时，才可以利用 tags 在 broker 做消息过滤。</strong></p></li><li><p>每个消息在业务层面的唯一标识码，要设置到 keys 字段，方便将来定位消息丢失问题。由于是哈希索引，请务必保证 key 尽可能唯一，这样可以避免潜在的哈希冲突。</p><p>消息发送成功或者失败，要打印消息日志，务必要打印 sendresult 和 key 字段。</p></li><li><p><strong>对于消息不可丢失应用，务必要有消息重发机制。例如：消息发送失败，存储到数据库，能有定时程序尝试重发或者人工触发重发。</strong></p></li><li><p>某些应用如果不关注消息是否发送成功，请直接使用sendOneWay方法发送消息。</p></li></ol><h5 id="Consumer最佳实践"><a href="#Consumer最佳实践" class="headerlink" title="Consumer最佳实践"></a><strong>Consumer最佳实践</strong></h5><ol><li><strong>消费过程要做到幂等（即消费端去重）</strong></li><li>尽量使用批量方式消费方式，可以很大程度上提高消费吞吐量。</li><li>优化每条消息消费过程</li></ol><h2 id="MQ核心问题"><a href="#MQ核心问题" class="headerlink" title="MQ核心问题"></a>MQ核心问题</h2><h3 id="1-消息队列适合解决的问题"><a href="#1-消息队列适合解决的问题" class="headerlink" title="1.消息队列适合解决的问题"></a>1.消息队列适合解决的问题</h3><p>解决的核心问题主要是：异步、解耦、削峰</p><p>但是引入消息队列也会有很多额外的问题，比如系统复杂性会大大增加，同时需要解决重复下发，重复消费，消费顺序，消息丢失，重试机制等等问题，因此不能滥用，合适的场景用合适的技术</p><h3 id="2-消息模型：主题和队列的区别"><a href="#2-消息模型：主题和队列的区别" class="headerlink" title="2.消息模型：主题和队列的区别"></a>2.消息模型：主题和队列的区别</h3><p><em><strong>一、消息队列的演进</strong></em></p><p><strong>1、初始阶段</strong></p><p>最初的消息队列，就是一个严格意义上的队列。队列是一种数据结构，先进先出，在消息入队出队过程中，保证这些消息严格有序。<strong>早期的消息队列就是按照“队列”的数据结构设计的</strong>。</p><p>队列模型：</p><p><img src="/2023/02/06/RocketMQ-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AF%87/1513968-20190825142246523-84190382.jpg" alt="img"></p><p>生产者（Producer）发消息就是入队操作，消费者（Consumer）收消息就是出队也就是删除操作，服务端存放消息的容器自然就称为“队列”。</p><ul><li>如果有多个<strong>生产者往同一个队列里面发送</strong>消息，这个队列中可以消费到的消息，就是这些生产者生产的所有消息的合集。消息的顺序就是这些生产者<strong>发送消息的自然顺序</strong>。</li><li>如果有<strong>多个消费者接收同一个队列</strong>的消息，这些消费者之间实际上是<strong>竞争的关系</strong>，每个消费者只能收到队列中的一部分消息，也就是说任何<strong>一条消息只能被其中的一个消费者收到</strong>。</li></ul><p><strong>2、发布 - 订阅模型阶段</strong></p><p>如果需要将<strong>一份消息数据分发给多个消费者</strong>，要求<strong>每个消费者都能收到全量的消息</strong>，例如，对于一份订单数据，风控系统、分析系统、支付系统等都需要接收消息。</p><p>这个时候，单个队列就满足不了需求，一个可行的解决方式是，为<strong>每个消费者创建一个单独的队列，让生产者发送多份</strong>。但是同样的一份消息数据被复制到多个队列中会<strong>浪费资源</strong>，更重要的是，生产者必须知道有多少个消费者。为每个消费者单独发送一份消息，这实际上<strong>违背了消息队列“解耦”</strong>这个设计初衷。</p><p>为了解决这个问题，演化出了另外一种消息模型：<strong>发布 - 订阅模型</strong>（Publish-Subscribe Pattern）</p><p><img src="/2023/02/06/RocketMQ-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AF%87/1513968-20190825143621470-571138599.jpg" alt="img"></p><p>消息的发送方称为发布者（Publisher），消息的接收方称为订阅者（Subscriber），服务端存放消息的容器称为主题（Topic）。</p><ul><li>发布者将消息发送到主题中，订阅者在接收消息之前需要先“订阅主题”。</li><li>每份订阅中，订阅者都可以接收到主题的所有消息。</li></ul><p><strong>3、总结：</strong></p><ul><li>在很长的一段时间，队列模式和发布 - 订阅模式是并存的。</li><li>有些消息队列同时支持这两种消息模型，比如 ActiveMQ。</li><li>对比这两种模型，生产者就是发布者，消费者就是订阅者，队列就是主题，并没有本质的区别。它们最大的区别是：<strong>一份消息数据能不能被消费多次的问题</strong>。</li><li>实际上，在这种发布 - 订阅模型中，如果只有一个订阅者，那它和队列模型就基本是一样的了。也就是说，发布 - 订阅模型在功能层面上是可以兼容队列模型的。</li></ul><p><em><strong>二、RabbitMQ 的消息模型</strong></em></p><p>少数依然坚持<strong>使用队列模型</strong>的产品之一。</p><p>RabbitMQ 使用 <strong>Exchange 模块解决多个消费者的问题</strong>。Exchange 位于生产者和队列之间，生产者并不关心将消息发送给哪个队列，而是<strong>将消息发送给 Exchange</strong>，由 Exchange 上<strong>配置的策略</strong>来决定将消息投递到哪些队列中。</p><p><img src="/2023/02/06/RocketMQ-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AF%87/1513968-20190825145306466-1941619714.jpg" alt="img"></p><ul><li>同一份消息如果需要被多个消费者来消费，需要<strong>配置 Exchange 将消息发送到多个队列</strong>，每个队列中都<strong>存放一份完整的消息数据</strong>，可以为一个消费者提供消费服务。</li></ul><p><em><strong>三、RocketMQ 的消息模型</strong></em></p><p>RocketMQ 使用的消息模型是标准的<strong>发布 - 订阅模型</strong>。在 RocketMQ 也有队列（Queue）这个概念。</p><p><strong>消息队列的消费机制：</strong></p><p>几乎所有的消息队列产品都使用一种非常朴素的“<strong>请求 - 确认”机制</strong>，确保消息不会在传递过程中由于网络或服务器故障丢失。</p><p>在生产端，生产者先将消息发送给服务端，也就是 Broker，服务端在收到消息并将消息写入主题或者队列中后，会<strong>给生产者发送确认的响应</strong>。如果生产者没有收到服务端的确认或者收到失败的响应，则会<strong>重新发送消息</strong>。</p><p>在消费端，消费者在收到消息并完成自己的消费业务逻辑（比如，将数据保存到数据库中）后，也会<strong>给服务端发送消费成功的确认</strong>，服务端只有收到消费确认后，才认为一条消息被成功消费，否则它会给消费者<strong>重新发送这条消息</strong>，直到收到对应的消费成功确认。</p><p>这个确认机制很好地<strong>保证了消息传递过程中的可靠性</strong>，但是，引入这个机制在消费端带来了一个问题：<strong>为了确保消息的有序性，在某一条消息被成功消费之前，下一条消息是不能被消费的</strong>，也就是说，每个主题在任意时刻，<strong>至多只能有一个消费者实例在进行消费</strong>，那就<strong>没法通过水平扩展消费者的数量来提升消费端总体的消费性能</strong>。</p><p><strong>为了解决这个问题，RocketMQ 在主题下面增加了队列的概念：</strong></p><p><strong><img src="/2023/02/06/RocketMQ-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AF%87/1513968-20190825151749079-2100411321.jpg" alt="img"></strong></p><ul><li><strong>每个主题包含多个队列</strong>，通过多个队列来实现多实例并行生产和消费。需要注意的是，RocketMQ 只在队列上保证消息的有序性，主题层面是无法保证消息的严格顺序的。</li><li><strong>生产者会往所有队列发消息</strong>，但不是“同一条消息每个队列都发一次”，<strong>每条消息只会往某个队列里面发送一次</strong>。</li><li><strong>一个消费组，每个队列上只能串行消费，多个队列加一起就是并行消费了</strong>，并行度就是队列数量，队列数量越多并行度越大，所以水平扩展可以<strong>提升消费性能。</strong></li><li><strong>每队列每消费组维护一个消费位置（offset）</strong>，记录这个消费组在这个队列上消费到哪儿了。</li><li>订阅者是通过消费组（Consumer Group）来体现的。<strong>每个消费组都消费主题中一份完整的消息</strong>，不同消费组之间消费进度彼此不受影响，也就是说，一条消息被 Consumer Group1 消费过，也会再给 Consumer Group2 消费。</li><li><strong>消费组中包含多个消费者，同一个组内的消费者是竞争消费的关系</strong>，每个消费者负责消费组内的一部分消息。如果一条消息被消费者 Consumer1 消费了，那同组的其他消费者就不会再收到这条消息。</li><li>由于消息需要被不同的组进行多次消费，所以消费完的消息并不会立即被删除，这就需要 RocketMQ <strong>为每个消费组在每个队列上维护一个消费位置（Consumer Offset）</strong>，这个位置之前的消息都被消费过，之后的消息都没有被消费过，每成功消费一条消息，消费位置就加一。我们在使用消息队列的时候<strong>，丢消息的原因大多是由于消费位置处理不当导致的</strong>。</li></ul><p><em><strong>四、Kafka 的消息模型</strong></em></p><p>Kafka 的消息模型和 RocketMQ 是完全一样的，唯一的区别是，在 Kafka 中，队列这个概念的名称不一样，<strong>Kafka 中对应的名称是“分区（Partition）”</strong>，含义和功能是没有任何区别的。</p><p><em><strong>五、总结</strong></em></p><ul><li>常用的消息队列中，<strong>RabbitMQ 采用的是队列模型</strong>，但是它一样可以实现发布 - 订阅的功能。<strong>RocketMQ 和 Kafka 采用的是发布 - 订阅模型</strong>，并且二者的消息模型是基本一致的。</li></ul><h3 id="3-消息丢失怎么办-如何保证消息的可靠性传输"><a href="#3-消息丢失怎么办-如何保证消息的可靠性传输" class="headerlink" title="3.消息丢失怎么办? 如何保证消息的可靠性传输?"></a>3.消息丢失怎么办? 如何保证消息的可靠性传输?</h3><p><strong>首先如何验证消息是否丢失？</strong></p><ul><li>如果是 IT 基础设施比较完善的公司，一般都有分布式链路追踪系统，使用类似的追踪系统可以很方便地追踪每一条消息。</li><li>如果没有这样的追踪系统，我们可以利用消息队列的有序性来验证是否有消息丢失</li></ul><p>即保证消息消费顺序的情况下，根据消息的序号，在消费段判断是否连续</p><p>解决方案：</p><p><strong>消息从生产到消费的过程中，可以划分三个阶段：</strong></p><p><img src="/2023/02/06/RocketMQ-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AF%87/1513968-20190826173227384-497794758.jpg" alt="img"></p><p><strong>1、生产阶段</strong></p><p>消息队列通过最常用的<strong>请求确认机制</strong>，来保证消息的可靠传递：当你代码调用发消息方法时，消息队列客户端会把消息发送到Broker，Broker收到消息后，会给客户端返回一个确认响应，表明消息已收到。客户端收到响应后，完成了一次正常消息的发送。</p><p>有些消息队列在长时间没收到发送确认响应后，会自动重试，如果重试失败，就会以返回值或者异常的方式告知用户。在编写发送消息的代码时，需要注意，<strong>正确处理返回值或者捕获异常</strong>，就可以保证这个阶段的消息不会丢失。</p><p><strong>同步发送时，只要注意捕获异常即可。</strong></p><p><strong>异步发送时，则需要在回调方法里进行检查。这个地方需要特别注意，很多丢消息的原因就是，我们使用了异步发送，却没有在回调中检查发送结果。</strong></p><p><strong>2、存储阶段</strong></p><p>在存储阶段正常情况下，只要Broker在正常运行，就不会出现丢消息的问题；但是如果Broker出现故障，比如进程死掉或者服务器宕机，还是可能会丢失消息的。</p><p>如果对消息的可靠性要求非常高，可以通过配置Broker参数来避免因为宕机丢消息：</p><ul><li>对于单个节点的 Broker，需要配置 Broker 参数，<strong>在收到消息后，将消息写入磁盘后再给 Producer 返回确认响应</strong>，这样即使发生宕机，由于消息已经被写入磁盘，就不会丢失消息，恢复后还可以继续消费。例如，在 RocketMQ 中，需要将刷盘方式 flushDiskType 配置为 SYNC_FLUSH 同步刷盘。</li><li>对于 Broker 是由多个节点组成的集群，需要将 Broker 集群配置成：<strong>至少将消息发送到 2 个以上的节点，再给客户端回复发送确认响应</strong>。这样当某个 Broker 宕机时，其他的 Broker 可以替代宕机的 Broker，也不会发生消息丢失。</li></ul><p><strong>3、消息阶段</strong></p><p>消费阶段采用和生产阶段类似的<strong>确认机制</strong>来保证消息的可靠传递，客户端从 Broker 拉取消息后，执行用户的消费业务逻辑，<strong>成功后，才会给 Broker 发送消费确认响应</strong>。如果 Broker 没有收到消费确认响应，下次拉消息的时候还会返回同一条消息，确保消息不会在网络传输过程中丢失，也不会因为客户端在执行消费逻辑中出错导致丢失。</p><p>在编写消费代码时需要注意的是：不要在收到消息后就立即发送消费确认，而是应该<strong>在执行完所有消费业务逻辑之后，再发送消费确认</strong>。</p><h3 id="4-处理消费过程中的重复消息"><a href="#4-处理消费过程中的重复消息" class="headerlink" title="4.处理消费过程中的重复消息"></a>4.处理消费过程中的重复消息</h3><p>在消息传递过程中，如果出现<strong>传递失败</strong>的情况，发送方会<strong>执行重试</strong>，重试过程中就有可能<strong>产生重复的消息</strong>。如果没有对重复消息进行处理，就可能导致系统的数据出现错误。</p><p>比如，一个消费订单消息，统计下单金额的微服务，如果没有正确处理重复消息，那就会出现重复统计，导致统计结果错误。</p><p><em><strong>一、消息重复的情况必然存在</strong></em></p><p>在MQTT协议中，给出了三种传递消息时能够提供的服务质量标准：</p><ul><li><strong>At most once</strong>：至多一次。最多会被送达一次，也就是说没有消息可靠性保证，允许丢消息。一般都是一些对消息可靠性要求不高的监控场景使用，比如每分钟上报一次机房温度数据，可以接受数据少量丢失。</li><li><strong>At least once</strong>：至少一次。至少会被送达一次，也就是说<strong>不允许丢消息</strong>，但是<strong>允许有少量重复消息出现</strong>。</li><li><strong>Exactly once</strong>：恰好一次。只会被送达一次，不允许丢失也不允许重复，这个是最高等级。</li></ul><p>这个服务质量标准不仅适用于 MQTT，对所有的消息队列都是适用的。常用的<strong>绝大部分消息队列提供的服务质量都是 At least once，包括 RocketMQ、RabbitMQ 和 Kafka</strong> 。也就是说，消息队列很难保证消息不重复。</p><p>注意：Kafka 支持的“Exactly once”和我们刚刚提到的消息传递的服务质量标准“Exactly once”是不一样的，它是 Kafka 提供的另外一个特性，Kafka 中支持的事务也和我们通常意义理解的事务有一定的差异。在 Kafka 中，事务和 Excactly once 主要是为了配合流计算使用的特性。</p><p><em><strong>二、用幂等性解决重复消息问题</strong></em></p><p>幂等本来是一个数学上的概念，它的定义是：如果一个函数f(x)满足：f(f(x)) &#x3D; f(x)，则函数f(x)满足米幂等性。扩展到计算机领域，被用来描述一个操作、方法或者服务。</p><ul><li>一个幂等操作的特点是，其<strong>任意多次执行所产生的影响均与一次执行的影响相同</strong>。</li><li>一个幂等方法，使用同样的参数，对它进行多次调用和一次调用，对系统产生的影响是一样的。所以不用担心重复执行会对系统造成任何改变。</li></ul><p>举例：</p><p>1、在不考虑并发的情况下，“将账户 X 的余额设置为 100 元”，执行一次后对系统的影响是，账户 X 的余额变成了 100 元。只要提供的参数 100 元不变，那即使再执行多少次，账户 X 的余额始终都是 100 元，不会变化，这个操作就是一个幂等的操作。</p><p>2、“将账户 X 的余额加 100 元”，这个操作它就不是幂等的，每执行一次，账户余额就会增加 100 元，执行多次和执行一次对系统的影响（也就是账户的余额）是不一样的。</p><p>如果消费消息的业务逻辑具备幂等性，那就不用担心消息重复的问题，因为同一条消息，<strong>消费一次和消费多次对系统的影响是完全一样的</strong>。消费多次等于消费一次。从对系统的影响结果来说：At least once + 幂等消费 &#x3D; Exactly once。</p><p>实现幂等操作最好的方式是，<strong>从业务逻辑设计上入手，将消费的业务逻辑设计成具备幂等性的操作</strong>。</p><p><strong>常用的设计幂等操作的方法</strong>：</p><p>（1）利用<strong>数据库的唯一约束</strong>实现幂等</p><p>上面提到的那个不具备幂等特性的转账的例子：将账户 X 的余额加 100 元。在这个例子中，我们可以通过改造业务逻辑，让它具备幂等性。</p><p>首先，我们可以限定，对于每个转账单每个账户只可以执行一次变更操作，在分布式系统中，这个限制实现的方法非常多，最简单的是我们在数据库中建一张转账流水表，这个表有三个字段：转账单 ID、账户 ID 和变更金额，然后给转账单 ID 和账户 ID 这两个字段联合起来创建一个唯一约束，这样对于相同的转账单 ID 和账户 ID，表里至多只能存在一条记录。</p><p>这样，我们消费消息的逻辑可以变为：“在转账流水表中<strong>增加一条转账记录，然后再根据转账记录，异步操作更新用户余额即可</strong>。”在转账流水表增加一条转账记录这个操作中，由于我们在这个表中预先定义了“账户 ID 转账单 ID”的唯一约束，<strong>对于同一个转账单同一个账户只能插入一条记录，后续重复的插入操作都会失败</strong>，这样就实现了一个幂等的操作。</p><p>基于这个思路，不光是可以使用关系型数据库，只要是支持类似“INSERT IF NOT EXIST”语义的存储类系统都可以用于实现幂等，比如，你可以用 Redis 的 SETNX 命令来替代数据库中的唯一约束，来实现幂等消费。</p><p>（2）为更新的数据设置前置条件</p><p>给数据变更设置一个前置条件，如果满足条件就更新数据，否则拒绝更新数据，在更新数据的时候，同时变更前置条件中需要判断的数据。这样，重复执行这个操作时，由于第一次更新数据的时候已经变更了前置条件中需要判断的数据，不满足前置条件，则不会重复执行更新数据操作。</p><p>比如，“将账户 X 的余额增加 100 元”这个操作并不满足幂等性，我们可以把这个操作加上一个前置条件，变为：“如果账户 X 当前的余额为 500 元，将余额加 100 元”，这个操作就具备了幂等性。对应到消息队列中的使用时，可以在发消息时在消息体中带上当前的余额，在消费的时候进行判断数据库中，当前余额是否与消息中的余额相等，只有相等才执行变更操作。</p><p>但是，如果我们要更新的数据不是数值，或者我们要做一个比较复杂的更新操作怎么办？用什么作为前置判断条件呢？更加通用的方法是，给你的<strong>数据增加一个版本号属性</strong>，每次更数据前，<strong>比较当前数据的版本号是否和消息中的版本号一致</strong>，如果不一致就拒绝更新数据，<strong>更新数据的同时将版本号 +1</strong>，一样可以实现幂等更新。</p><p>（3）记录并检查操作</p><p>如果上面提到的两种实现幂等方法都不能适用于你的场景，还有一种通用性最强，适用范围最广的实现幂等性方法：记录并检查操作，也称为“Token 机制或者 GUID（全局唯一 ID）机制”，实现的思路特别简单：<strong>在执行数据更新操作之前，先检查一下是否执行过这个更新操作</strong>。这种方法适用范围最广，但是实<strong>现难度和复杂度也比较高，一般不推荐使用</strong>。</p><p>具体的实现方法是，在发送消息时，给每条消息<strong>指定一个全局唯一的 ID</strong>，消费时，先根据这个 ID 检查这条消息是否有被消费过，如果没有消费过，才更新数据，然后<strong>将消费状态置为已消费</strong>。</p><p>在分布式系统中，这个方法其实是非常难实现的。首先，给每个消息指定一个全局唯一的 ID 就是一件不那么简单的事儿，方法有很多，但都不太好同时满足简单、高可用和高性能，或多或少都要有些牺牲。更加麻烦的是，在“检查消费状态，然后更新数据并且设置消费状态”中，<strong>三个操作必须作为一组操作保证原子性</strong>，才能真正实现幂等，否则就会出现 Bug。</p><p>比如说，对于同一条消息：“全局 ID 为 8，操作为：给 ID 为 666 账户增加 100 元”，有可能出现这样的情况：</p><ul><li>t0 时刻：Consumer A 收到条消息，检查消息执行状态，发现消息未处理过，开始执行“账户增加 100 元”；</li><li>t1 时刻：Consumer B 收到条消息，检查消息执行状态，发现消息未处理过，因为这个时刻，Consumer A 还未来得及更新消息执行状态。</li></ul><p>这样就会导致账户被错误地增加了两次 100 元，这是一个在分布式系统中非常容易犯的错误，一定要引以为戒。对于这个问题，当然我们可以用事务来实现，也可以用锁来实现，但是在分布式系统中，无论是分布式事务还是分布式锁都是比较难解决问题。</p><h3 id="5-利用事务消息实现分布式事务"><a href="#5-利用事务消息实现分布式事务" class="headerlink" title="5.利用事务消息实现分布式事务"></a>5.利用事务消息实现分布式事务</h3><p><em><strong>一、消息事务</strong></em></p><p>其实很多场景下，我们“发消息”这个过程，目的往往是<strong>通知另外一个系统或者模块去更新数据</strong>，消息队列中的“事务”，主要解决<strong>消息生产者和消息消费者的数据一致性问题</strong>。</p><p>用户在电商APP上购物时，先把商品加到购物车里，然后几件商品一起下单，最后支付，完成购物流程。</p><p>这个过程中有一个需要用到消息队列的步骤，订单系统创建订单后，发消息给购物车系统，将已下单的商品从购物车中删除。因为从购物车删除已下单商品这个步骤，并不是用户下单支付这个主要流程中必要的步骤，使用消息队列来异步清理购物车是更加合理。</p><p><img src="/2023/02/06/RocketMQ-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AF%87/1513968-20190826151153577-1447206679.jpg" alt="img"></p><p>对于订单系统，它创建订单的过程实际执行了2个步骤的操作：</p><ul><li>在订单库中插入一条订单数据，创建订单；</li><li>发消息给消息队列，消息的内容就是刚刚创建的订单</li></ul><p>对于购物车系统：</p><ul><li>订阅相应的主题，接收订单创建的消息，然后清理购物车，在购物车中删除订单的商品。</li></ul><p>在分布式系统中，上面提到的步骤，任何一个都有可能失败，如果不做任何处理，那就有可能出现订单数据与购物车数据不一致的情况，比如：</p><ul><li>创建了订单，没有清理购物车；</li><li>订单没创建成功，购物车里面的商品却被清掉了。</li></ul><p>所以我们需要解决的问题为：在上述任意步骤都有可能失败的情况下，还要保证订单库和购物车库这两个库的数据一致性。</p><p><em><strong>二、分布式事务</strong></em></p><p>分布式事务就是要在分布式系统中实现事务。在分布式系统中，在保证可用性和不严重牺牲性能的前提下，光是要<strong>实现数据的一致性就已经非常困难了</strong>，显然实现严格的分布式事务是更加不可能完成的任务。所以目前大家所说的分布式事务，更多情况下，是在<strong>分布式系统中事务的不完整实现</strong>，在不同的应用场景中，有不同的实现，目的都是通过一些妥协来解决实际问题。</p><p>常见的分布式事务实现：</p><ul><li>2PC（Two-phase Commit，也叫二阶段提交）</li><li>TCC（Try-Confirm-Cancel）</li><li>事务消息</li></ul><p>每一种实现都有其特定的使用场景，也有各自的问题，都不是完美的解决方案。</p><p><strong>事务消息适用的场景</strong>主要是那些需要<strong>异步更新数据</strong>，并且<strong>对数据实时性要求不太高</strong>的场景。比如在创建订单后，如果出现短暂的几秒，购物车里的商品没有被及时情况，也不是完全不可接受的，只要最终购物车的数据和订单数据保持一致就可。</p><p><em><strong>三、消息队列实现分布式事务</strong></em></p><p><strong>事务消息需要消息队列提供相应的功能才能实现，kafka和RocketMQ都提供了事务相关功能。</strong></p><p><img src="/2023/02/06/RocketMQ-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AF%87/1513968-20190826155000602-1180010007.jpg" alt="img"></p><p>对于订单系统：</p><ul><li>首先，订单系统在消息队列上开启一个事务。</li><li>然后订单系统给消息服务器发送一个“半消息”，这个半消息不是说消息内容不完整，它包含的内容就是完整的消息内容，半消息和普通消息的唯一区别是，在事务提交之前，对于消费者来说，这个消息是不可见的。</li><li>半消息发送成功后，订单系统就可以执行本地事务了，在订单库中创建一条订单记录，并提交订单库的数据库事务。</li><li>然后根据本地事务的执行结果决定提交或者回滚事务消息。如果订单创建成功，那就提交事务消息，购物车系统就可以消费到这条消息继续后续的流程。如果订单创建失败，那就回滚事务消息，购物车系统就不会收到这条消息。这样就基本实现了“要么都成功，要么都失败”的一致性要求。</li></ul><p>对于购物车系统：</p><ul><li>对于购物车系统收到订单创建成功消息清理购物车这个操作来说，失败的处理比较简单，<strong>只要成功执行购物车清理后再提交消费确认即可</strong>，如果失败，<strong>由于没有提交消费确认，消息队列会自动重试</strong>。</li></ul><p><strong>如果在第四步提交事务消息时失败了怎么办？Kafka 和 RocketMQ 给出了 2 种不同的解决方案：</strong></p><p>1、Kafka 的解决方案：</p><p>直接抛出异常，让用户自行处理。我们可以在业务代码中反复重试提交，直到提交成功，或者删除之前创建的订单进行补偿。</p><p>2、RocketMQ 的解决方案：</p><p>在 RocketMQ 中的事务实现中，增加了<strong>事务反查的机制</strong>来解决事务消息提交失败的问题。如果 Producer 也就是订单系统，在提交或者回滚事务消息时发生网络异常，RocketMQ 的 Broker 没有收到提交或者回滚的请求，Broker 会定期去 Producer 上<strong>反查这个事务对应的本地事务的状态</strong>，然后根据反查结果决定提交或者回滚这个事务。为了支撑这个事务反查机制，我们的业务代码需要<strong>实现一个反查本地事务状态的接口</strong>，告知 RocketMQ 本地事务是成功还是失败。</p><p>综合上面讲的通用事务消息的实现和 RocketMQ 的事务反查机制，使用 <strong>RocketMQ 事务消息功能实现分布式事务的流程</strong>如下图：</p><p><img src="/2023/02/06/RocketMQ-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AF%87/1513968-20190826160556408-194504282.jpg" alt="img"></p><h3 id="6-消息队列中的顺序问题"><a href="#6-消息队列中的顺序问题" class="headerlink" title="6.消息队列中的顺序问题"></a>6.消息队列中的顺序问题</h3><p>当我们说顺序时，我们在说什么？</p><p>日常思维中，顺序大部分情况会和时间关联起来，即时间的先后表示事件的顺序关系。</p><p>比如事件A发生在下午3点一刻，而事件B发生在下午4点，那么我们认为事件A发生在事件B之前，他们的顺序关系为先A后B。</p><p>上面的例子之所以成立是因为他们有相同的参考系，即他们的时间是对应的同一个物理时钟的时间。如果A发生的时间是北京时间，而B依赖的时间是东京时间，那么先A后B的顺序关系还成立吗？</p><p><em>如果没有一个绝对的时间参考，那么A和B之间还有顺序吗，或者说怎么断定A和B的顺序？</em></p><p>显而易见的，如果A、B两个事件之间如果是有因果关系的，那么A一定发生在B之前（前因后果，有因才有果）。相反，在没有一个绝对的时间的参考的情况下，若A、B之间没有因果关系，那么A、B之间就没有顺序关系。</p><p><strong>那么，我们在说顺序时，其实说的是：</strong></p><ul><li><strong>有绝对时间参考的情况下，事件的发生时间的关系；</strong></li><li><strong>和没有时间参考下的，一种由因果关系推断出来的happening before的关系；</strong></li></ul><p>在分布式环境中讨论顺序</p><p>当把顺序放到分布式环境（多线程、多进程都可以认为是一个分布式的环境）中去讨论时：</p><ul><li>同一线程上的事件顺序是确定的，可以认为他们有相同的时间作为参考</li><li>不同线程间的顺序只能通过因果关系去推断</li></ul><p><img src="/2023/02/06/RocketMQ-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AF%87/471426-20180521095241718-1995021812.png" alt="img"></p><p><em>（点表示事件，波浪线箭头表示事件间的消息）</em></p><p>上图中，进程P中的事件顺序为p1-&gt;p2-&gt;p3-&gt;p4（时间推断）。而因为p1给进程Q的q2发了消息，那么p1一定在q2之前（因果推断）。但是无法确定p1和q1之间的顺序关系。</p><p>推荐阅读《Time, Clocks, and the Ordering of Events in a Distributed System》，会透彻的分析分布式系统中的顺序问题。</p><p>消息中间件中的顺序消息</p><p>什么是顺序消息</p><p>有了上述的基础之后，我们回到本篇文章的主题中，聊一聊消息中间件中的顺序消息。</p><blockquote><p>顺序消息（FIFO 消息）是 MQ 提供的一种严格按照顺序进行发布和消费的消息类型。顺序消息由两个部分组成：顺序发布和顺序消费。</p><p>顺序消息包含两种类型：</p><p>分区顺序：一个Partition内所有的消息按照先进先出的顺序进行发布和消费</p><p>全局顺序：一个Topic内所有的消息按照先进先出的顺序进行发布和消费</p></blockquote><p>这是阿里云上对顺序消息的定义，把顺序消息拆分成了顺序发布和顺序消费。那么多线程中发送消息算不算顺序发布？</p><p>如上一部分介绍的，多线程中若没有因果关系则没有顺序。那么用户在多线程中去发消息就意味着用户不关心那些在不同线程中被发送的消息的顺序。即多线程发送的消息，不同线程间的消息不是顺序发布的，同一线程的消息是顺序发布的。这是需要用户自己去保障的。</p><p>而对于顺序消费，则需要保证哪些来自同一个发送线程的消息在消费时是按照相同的顺序被处理的（为什么不说他们应该在一个线程中被消费呢？）。</p><p>全局顺序其实是分区顺序的一个特例，即使Topic只有一个分区（以下不在讨论全局顺序，因为全局顺序将面临性能的问题，而且绝大多数场景都不需要全局顺序）。</p><p>如何保证顺序</p><p>在MQ的模型中，顺序需要由3个阶段去保障：</p><ol><li>消息被发送时保持顺序</li><li>消息被存储时保持和发送的顺序一致</li><li>消息被消费时保持和存储的顺序一致</li></ol><p>发送时保持顺序意味着对于有顺序要求的消息，用户应该在同一个线程中采用同步的方式发送。存储保持和发送的顺序一致则要求在同一线程中被发送出来的消息A和B，存储时在空间上A一定在B之前。而消费保持和存储一致则要求消息A、B到达Consumer之后必须按照先A后B的顺序被处理。</p><p>如下图所示：</p><p><img src="/2023/02/06/RocketMQ-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AF%87/471426-20180519131211273-554395305.png" alt="img"></p><p>对于两个订单的消息的原始数据：a1、b1、b2、a2、a3、b3（绝对时间下发生的顺序）：</p><ul><li><p>在发送时，a订单的消息需要保持a1、a2、a3的顺序，b订单的消息也相同，但是a、b订单之间的消息没有顺序关系，这意味着a、b订单的消息可以在不同的线程中被发送出去</p></li><li><p>在存储时，需要分别保证a、b订单的消息的顺序，但是a、b订单之间的消息的顺序可以不保证</p></li><li><ul><li>a1、b1、b2、a2、a3、b3是可以接受的</li><li>a1、a2、b1、b2、a3、b3也是可以接受的</li><li>a1、a3、b1、b2、a2、b3是不能接受的</li></ul></li><li><p>消费时保证顺序的简单方式就是“什么都不做”，不对收到的消息的顺序进行调整，即只要一个分区的消息只由一个线程处理即可；当然，如果a、b在一个分区中，在收到消息后也可以将他们拆分到不同线程中处理，不过要权衡一下收益</p></li></ul><p>开源RocketMQ中顺序的实现<img src="/2023/02/06/RocketMQ-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AF%87/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><img src="/2023/02/06/RocketMQ-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AF%87/471426-20180519131142686-668735225.png" alt="img"></p><p>上图是RocketMQ顺序消息原理的介绍，将不同订单的消息路由到不同的分区中。文档只是给出了Producer顺序的处理，Consumer消费时通过一个分区只能有一个线程消费的方式来保证消息顺序，具体实现如下。</p><p><strong>Producer端</strong></p><p>Producer端确保消息顺序唯一要做的事情就是将消息路由到特定的分区，在RocketMQ中，通过MessageQueueSelector来实现分区的选择。</p><p><img src="/2023/02/06/RocketMQ-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AF%87/471426-20180519131230081-742966938.png" alt="img"><img src="/2023/02/06/RocketMQ-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AF%87/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><ul><li>List<MessageQueue> mqs：消息要发送的Topic下所有的分区</MessageQueue></li><li>Message msg：消息对象</li><li>额外的参数：用户可以传递自己的参数</li></ul><p>比如如下实现就可以保证相同的订单的消息被路由到相同的分区：</p><pre><code class="hljs vbnet"><span class="hljs-type">long</span> orderId = ((<span class="hljs-keyword">Order</span>) <span class="hljs-type">object</span>).getOrderId;<span class="hljs-keyword">return</span> mqs.<span class="hljs-keyword">get</span>(orderId % mqs.size());</code></pre><p><strong>Consumer端</strong></p><p>RocketMQ消费端有两种类型：MQPullConsumer和MQPushConsumer。</p><p>MQPullConsumer由用户控制线程，主动从服务端获取消息，每次获取到的是一个MessageQueue中的消息。PullResult中的List msgFoundList自然和存储顺序一致，用户需要再拿到这批消息后自己保证消费的顺序。</p><p>对于PushConsumer，由用户注册MessageListener来消费消息，在客户端中需要保证调用MessageListener时消息的顺序性。RocketMQ中的实现如下：</p><p><img src="/2023/02/06/RocketMQ-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AF%87/471426-20180519131253178-1043342972.png" alt="img"></p><p><img src="/2023/02/06/RocketMQ-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AF%87/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><ol><li>PullMessageService单线程的从Broker获取消息</li><li>PullMessageService将消息添加到ProcessQueue中（ProcessMessage是一个消息的缓存），之后提交一个消费任务到ConsumeMessageOrderService</li><li>ConsumeMessageOrderService多线程执行，每个线程在消费消息时需要拿到MessageQueue的锁</li><li>拿到锁之后从ProcessQueue中获取消息</li></ol><p>保证消费顺序的核心思想是：</p><ul><li>获取到消息后添加到ProcessQueue中，单线程执行，所以ProcessQueue中的消息是顺序的</li><li>提交的消费任务时提交的是“对某个MQ进行一次消费”，这次消费请求是从ProcessQueue中获取消息消费，所以也是顺序的（无论哪个线程获取到锁，都是按照ProcessQueue中消息的顺序进行消费）</li></ul><p>顺序和异常的关系</p><p>顺序消息需要Producer和Consumer都保证顺序。Producer需要保证消息被路由到正确的分区，消息需要保证每个分区的数据只有一个线程消息，那么就会有一些缺陷：</p><ul><li>发送顺序消息无法利用集群的Failover特性，因为不能更换MessageQueue进行重试</li><li>因为发送的路由策略导致的热点问题，可能某一些MessageQueue的数据量特别大</li><li>消费的并行读依赖于分区数量</li><li>消费失败时无法跳过</li></ul><p>不能更换MessageQueue重试就需要MessageQueue有自己的副本，通过Raft、Paxos之类的算法保证有可用的副本，或者通过其他高可用的存储设备来存储MessageQueue。</p><p>热点问题好像没有什么好的解决办法，只能通过拆分MessageQueue和优化路由方法来尽量均衡的将消息分配到不同的MessageQueue。</p><p>消费并行度理论上不会有太大问题，因为MessageQueue的数量可以调整。</p><p>消费失败的无法跳过是不可避免的，因为跳过可能导致后续的数据处理都是错误的。不过可以提供一些策略，由用户根据错误类型来决定是否跳过，并且提供重试队列之类的功能，在跳过之后用户可以在“其他”地方重新消费到这条消息。</p>]]></content>
    
    
    <categories>
      
      <category>中间件篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RocketMQ-消息队列篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis篇</title>
    <link href="/2023/02/06/Redis%E7%AF%87/"/>
    <url>/2023/02/06/Redis%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis篇"><a href="#Redis篇" class="headerlink" title="Redis篇"></a>Redis篇</h1><p>标签： #Share</p><h2 id="Windows-Redis"><a href="#Windows-Redis" class="headerlink" title="Windows Redis"></a>Windows Redis</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>链接: <a href="https://pan.baidu.com/s/1MJnzX_qRuNXJI09euzkPGA">https://pan.baidu.com/s/1MJnzX_qRuNXJI09euzkPGA</a> 提取码: 2c6w 复制这段内容后打开百度网盘手机App，操作更方便哦</p><p>无脑下一步即可</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>出现错误：</p><p>creating server tcp listening socket 127.0.0.1:6379: bind No error</p><p>解决方案：</p><ol><li>redis-cli.exe</li><li>shutdown</li><li>exit</li><li>redis-server.exe redis.windows.conf</li></ol><p>启动：redis-server.exe redis.windows.conf</p><p>客户端启动：redis-cli.exe  (不修改配置的话默认即可)</p><p>​                        redis-cli.exe -h 127.0.0.1 -p 6379 -a password</p><h2 id="基本文件说明"><a href="#基本文件说明" class="headerlink" title="基本文件说明"></a>基本文件说明</h2><table><thead><tr><th>可执行文件</th><th>作用说明</th></tr></thead><tbody><tr><td>redis-server</td><td>redis服务</td></tr><tr><td>redis-cli</td><td>redis命令行工具</td></tr><tr><td>redis-benchmark</td><td>基准性能测试工具</td></tr><tr><td>redis-check-aof</td><td>AOF持久化文件检测和修复工具</td></tr><tr><td>redis-check-dump</td><td>RDB持久化文件检测和修复工具</td></tr><tr><td>redis-sentinel</td><td>启动哨兵</td></tr><tr><td>redis-trib</td><td>cluster集群构建工具</td></tr></tbody></table><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><table><thead><tr><th>命令</th><th align="left">说明</th></tr></thead><tbody><tr><td>keys  *</td><td align="left">redis允许模糊查询key　　有3个通配符  *、?、[]</td></tr><tr><td>del      key</td><td align="left">删除key</td></tr><tr><td>exists kxm</td><td align="left">判断是否存在</td></tr><tr><td>expire key 20</td><td align="left">设置过期时间 - 秒</td></tr><tr><td>pexpire key 20000</td><td align="left">设置过期时间 - 毫秒</td></tr><tr><td>move kxm 2</td><td align="left">移动key到指定位置库中  2号库</td></tr><tr><td>persist key</td><td align="left">移除过期时间，key将会永久存在   成功设置返回1  否则返回0</td></tr><tr><td>pttl key</td><td align="left">以毫秒为单位返回 key 的剩余的过期时间</td></tr><tr><td>ttl key</td><td align="left">以秒为单位，返回给定 key 的剩余生存时间</td></tr><tr><td>randomkey</td><td align="left">从当前数据库中随机返回一个 key</td></tr><tr><td>rename key newkxy</td><td align="left">更改key的名字，如果重复了会覆盖</td></tr><tr><td>renamenx kxm key</td><td align="left">仅当 newkey 不存在时，将 key 改名为 newkey</td></tr><tr><td>type key</td><td align="left">返回 key 所储存的值的类型</td></tr><tr><td>select 0</td><td align="left">选择第一个库</td></tr><tr><td>ping</td><td align="left">返回PONG 表示连接正常</td></tr><tr><td>quit</td><td align="left">关闭当前连接</td></tr></tbody></table><h2 id="字符串命令"><a href="#字符串命令" class="headerlink" title="字符串命令"></a>字符串命令</h2><p>| 命令                           | 说明                                                         |<br>|  |  |<br>| set key aaa                    | 设置指定 key 的值                                            |<br>| get key                        | 获取指定 key 的值                                            |<br>| getrange key 0 1               | 返回 key 中字符串值的子字符  包含 0 和 1 包含关系            |<br>| getset key aaaaaaaa            | 将给定 key 的值设为 value ，并返回 key 的旧值(old value)     |<br>| mget key kxm                   | 获取所有(一个或多个)给定 key 的值                            |<br>| setex test 5 “this is my test” | 将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位) |<br>| setnx test test                | 只有在 key 不存在时设置 key 的值 （用于分布式锁）            |<br>| strlen test                    | 返回 key 所储存的字符串值的长度                              |<br>| mset key1 “1” key2 “2”         | 同时设置一个或多个 key-value 对                              |<br>| msetnx key3 “a” key2 “b”       | 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在   其中一个失败则全部失败 |<br>| incr key                       | 将 key 中储存的数字值增一 -&gt;  key的值 比如为 数字类型字符串  返回增加后的结果 |<br>| incrby num 1000                | 将 key 中储存的数字值增指定的值 -&gt;  key的值 比如为 数字类型字符串  返回增加后的结果 |<br>| decr key                       | 同 -&gt; 减一                                                   |<br>| decrby num 500                 | 同 -&gt; 减指定值                                               |<br>| append key 1123123             | 如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾  返回字符串长度 |</p><h2 id="哈希-Hash-命令"><a href="#哈希-Hash-命令" class="headerlink" title="哈希(Hash)命令"></a>哈希(Hash)命令</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>hdel key field1 [field2]</td><td>删除一个或多个哈希表字段</td></tr><tr><td>hexistskey field</td><td>查看哈希表 key 中，指定的字段是否存在</td></tr><tr><td>hget key field</td><td>获取存储在哈希表中指定字段的值</td></tr><tr><td>hgetall key</td><td>获取在哈希表中指定 key 的所有字段和值</td></tr><tr><td>hincrby hash yeary 1</td><td>为哈希表 key 中的指定字段的整数值加上增量 increment</td></tr><tr><td>hkeys hash</td><td>获取所有哈希表中的字段</td></tr><tr><td>hlen hash</td><td>获取哈希表中字段的数量</td></tr><tr><td>hmget hash name year</td><td>获取所有给定字段的值</td></tr><tr><td>hmset hash name “i am kxm” year 24</td><td>同时将多个 field-value (域-值)对设置到哈希表 key 中</td></tr><tr><td>hset hash name kxm</td><td>将哈希表 key 中的字段 field 的值设为 value</td></tr><tr><td>hsetnx key field value</td><td>只有在字段 field 不存在时，设置哈希表字段的值</td></tr><tr><td>hvals hash</td><td>获取哈希表中所有值</td></tr><tr><td>hexists hash name</td><td>是否存在</td></tr></tbody></table><blockquote><p>编码:  field value 值由 ziplist 及 hashtable 两种编码格式</p><p>字段较少的时候采用ziplist，字段较多的时候会变成hashtable编码</p></blockquote><h2 id="列表-List-命令"><a href="#列表-List-命令" class="headerlink" title="列表(List)命令"></a>列表(List)命令</h2><p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）</p><p>一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)</p><p>容量 -&gt; 集合,有序集合也是如此</p><p>| 命令                         | 说明                                                         |<br>| —- |  |<br>| lpush list php               | 将一个值插入到列表头部  返回列表长度                         |<br>| lindex list 0                | 通过索引获取列表中的元素                                     |<br>| blpop  key1 [key2 ] timeout  | 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止 |<br>| brpop  key1 [key2 ] timeout  | 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止 |<br>| linsert list before 3 4      | 在值 3 前插入 4   前即为顶                                   |<br>| linsert list after 4 5       | 在值4 后插入5                                                |<br>| llen list                    | 获取列表长度                                                 |<br>| lpop list                    | 移出并获取列表的第一个元素                                   |<br>| lpush list c++ c             | 将一个或多个值插入到列表头部                                 |<br>| lrange list 0 1              | 获取列表指定范围内的元素  包含0和1   -1 代表所有 （lrange list 0 -1） |<br>| lrem list 1 c                | 移除list 集合中 值为 c 的  一个元素，  1 代表count 即移除几个 |<br>| lset list 0 “this is update” | 通过索引设置列表元素的值                                     |<br>| ltrim list 1 5               | 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除 |<br>| rpop list                    | 移除列表的最后一个元素，返回值为移除的元素                   |<br>| rpush list newvalue3         | 从底部添加新值                                               |<br>| rpoplpush list list2         | 转移列表的数据                                               |</p><h2 id="集合-Set-命令"><a href="#集合-Set-命令" class="headerlink" title="集合(Set)命令"></a>集合(Set)命令</h2><p>Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据</p><p>| 命令                                                         | 说明                                                |<br>|  | — |<br>| sadd set java php c c++ python                               | 向集合添加一个或多个成员                            |<br>| scard set                                                    | 获取集合的成员数                                    |<br>| sdiff key1 [key2]                                            | 返回给定所有集合的差集  数学含义差集                |<br>| sdiffstore curr set newset  （sdiffstore destination key1 [key2]） | 把set和 newset的差值存储到curr中                    |<br>| sinter set newset                                            | 返回给定所有集合的交集                              |<br>| sinterstore curr set newset  （sinterstoredestination key1 [key2]） | 同                                                  |<br>| sismember set c#                                             | 判断 member 元素是否是集合 key 的成员               |<br>| smembers set                                                 | 返回集合中的所有成员                                |<br>| srandmember set 2                                            | 随机抽取两个key (抽奖实现美滋滋)                    |<br>| smove set newtest java （smove source destination member）   | 将 member 元素从 source 集合移动到 destination 集合 |<br>| sunion set newset                                            | 返回所有给定集合的并集                              |<br>| srem set java                                                | 删除                                                |<br>| spop set                                                     | 从集合中弹出一个元素                                |<br>| sdiff | sinter | sunion                                    | 操作：集合间运算：差集                              |</p><h2 id="有序集合-sorted-set-命令"><a href="#有序集合-sorted-set-命令" class="headerlink" title="有序集合(sorted set)命令"></a>有序集合(sorted set)命令</h2><p>Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。</p><p>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p><p>有序集合的成员是唯一的,但分数(score)却可以重复。</p><p>| 命令                             | 说明                                                         |<br>| – |  |<br>| zadd sort 1 java 2 python        | 向有序集合添加一个或多个成员，或者更新已存在成员的分数       |<br>| zcard sort                       | 获取有序集合的成员数                                         |<br>| zcount sort 0 1                  | 计算在有序集合中指定区间分数的成员数                         |<br>| zincrby sort 500 java            | 有序集合中对指定成员的分数加上增量 increment                 |<br>| zscore sort java                 | 返回有序集中，成员的分数值                                   |<br>| zrange sort 0 -1                 | 获取指定序号的值，-1代表全部                                 |<br>| zrangebyscore sort 0 5           | 分数符合范围的值                                             |<br>| zrangebyscore sort 0 5 limit 0 1 | 分页 limit  0代表页码，1代表每页显示数量                     |<br>| zrem sort java                   | 移除元素                                                     |<br>| zremrangebyrank sort 0 1         | 按照排名范围删除元素                                         |<br>| zremrangebyscore sort 0 1        | 按照分数范围删除元素                                         |<br>| zrevrank sort c#                 | 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序 |</p><h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><p>开启两个客户端</p><p>A客户端订阅频道： subscribe redisChat                                      （频道名字为 redisChat）</p><p>B客户端发布内容： publish redisChat “Hello, this is my wor”   （内容是 hello….）</p><p>A客户端即为自动收到内容， 原理图如下:</p><p><img src="/2023/02/06/Redis%E7%AF%87/Redis%E7%AF%87%5Cpubsub1.png" alt="img"></p><p><img src="/2023/02/06/Redis%E7%AF%87/Redis%E7%AF%87%5Cpubsub2.png" alt="img"></p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>pubsub channels</td><td>查看当前redis  有多少个频道</td></tr><tr><td>pubsub numsub chat1</td><td>查看某个频道的订阅者数量</td></tr><tr><td>unsubscrible chat1</td><td>退订指定频道</td></tr><tr><td>psubscribe java.*</td><td>订阅一组频道</td></tr></tbody></table><h2 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h2><p>Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：</p><ul><li>批量操作在发送 EXEC 命令前被放入队列缓存</li><li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行</li><li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中</li></ul><p>一个事务从开始到执行会经历以下三个阶段：</p><ul><li>开始事务</li><li>命令入队</li><li>执行事务</li></ul><p><code>注意：redis事务和数据库事务不同，redis事务出错后最大的特点是，一剩下的命令会继续执行，二出错的数据不会回滚</code></p><p>| 命令      | 说明                                                         |<br>| — |  |<br>| multi     | 标记一个事务开始                                             |<br>| exec      | 执行事务                                                     |<br>| discard   | 事务开始后输入命令入队过程中，中止事务                       |<br>| watch key | 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断 |<br>| unwatch   | 取消 WATCH 命令对所有 key 的监视                             |</p><h2 id="Redis-服务器命令"><a href="#Redis-服务器命令" class="headerlink" title="Redis 服务器命令"></a>Redis 服务器命令</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>flushall</td><td>删除所有数据库的所有key</td></tr><tr><td>flushdb</td><td>删除当前数据库的所有key</td></tr><tr><td>save</td><td>同步保存数据到硬盘</td></tr></tbody></table><h2 id="Redis-数据备份与恢复"><a href="#Redis-数据备份与恢复" class="headerlink" title="Redis 数据备份与恢复"></a>Redis 数据备份与恢复</h2><p>Redis <strong>SAVE</strong> 命令用于创建当前数据库的备份</p><p>如果需要恢复数据，只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可。获取 redis 目录可以使用 <strong>CONFIG</strong> 命令</p><h2 id="Redis-性能测试"><a href="#Redis-性能测试" class="headerlink" title="Redis 性能测试"></a>Redis 性能测试</h2><p>redis 性能测试的基本命令如下：</p><pre><code class="hljs stylus">redis目录执行：redis-benchmark <span class="hljs-selector-attr">[option]</span> <span class="hljs-selector-attr">[option value]</span><span class="hljs-comment">// 会返回各种操作的性能报告（100连接，10000请求）</span>redis-benchmark -h <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span> -<span class="hljs-selector-tag">p</span> <span class="hljs-number">6379</span> -c <span class="hljs-number">100</span> -n <span class="hljs-number">10000</span><span class="hljs-comment">// 100个字节作为value值进行压测</span>redis-benchmark -h <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span> -<span class="hljs-selector-tag">p</span> <span class="hljs-number">6379</span> -<span class="hljs-selector-tag">q</span> -d <span class="hljs-number">100</span></code></pre><h2 id="Java-Redis"><a href="#Java-Redis" class="headerlink" title="Java Redis"></a>Java Redis</h2><h3 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h3><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- jedis --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.8.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p><strong>Jedis配置</strong></p><pre><code class="hljs properties"><span class="hljs-comment">############# redis Config #############</span><span class="hljs-comment"># Redis数据库索引（默认为0）</span><span class="hljs-attr">spring.redis.database</span>=<span class="hljs-string">0</span><span class="hljs-comment"># Redis服务器地址</span><span class="hljs-attr">spring.redis.host</span>=<span class="hljs-string">120.79.88.17</span><span class="hljs-comment"># Redis服务器连接端口</span><span class="hljs-attr">spring.redis.port</span>=<span class="hljs-string">6379</span><span class="hljs-comment"># Redis服务器连接密码（默认为空）</span><span class="hljs-attr">spring.redis.password</span>=<span class="hljs-string">123456</span><span class="hljs-comment"># 连接池中的最大空闲连接</span><span class="hljs-attr">spring.redis.jedis.pool.max-idle</span>=<span class="hljs-string">8</span><span class="hljs-comment"># 连接池中的最小空闲连接</span><span class="hljs-attr">spring.redis.jedis.pool.min-idle</span>=<span class="hljs-string">0</span></code></pre><p><strong>JedisConfig</strong></p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JedisConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CachingConfigurerSupport</span> &#123;    <span class="hljs-meta">@Value(&quot;$&#123;spring.redis.host&#125;&quot;)</span>    <span class="hljs-keyword">private</span> String host;    <span class="hljs-meta">@Value(&quot;$&#123;spring.redis.port&#125;&quot;)</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> port;    <span class="hljs-meta">@Value(&quot;$&#123;spring.redis.password&#125;&quot;)</span>    <span class="hljs-keyword">private</span> String password;    <span class="hljs-meta">@Value(&quot;$&#123;spring.redis.max-idle&#125;&quot;)</span>    <span class="hljs-keyword">private</span> Integer maxIdle;    <span class="hljs-meta">@Value(&quot;$&#123;spring.redis.min-idle&#125;&quot;)</span>    <span class="hljs-keyword">private</span> Integer minIdle;    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> JedisPool <span class="hljs-title function_">redisPoolFactory</span><span class="hljs-params">()</span>&#123;        <span class="hljs-type">JedisPoolConfig</span> <span class="hljs-variable">jedisPoolConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPoolConfig</span>();        jedisPoolConfig.setMaxIdle(maxIdle);        jedisPoolConfig.setMinIdle(minIdle);        jedisPoolConfig.setMaxWaitMillis(<span class="hljs-number">3000L</span>);        <span class="hljs-type">int</span> <span class="hljs-variable">timeOut</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;        <span class="hljs-keyword">return</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPool</span>(jedisPoolConfig, host, port, timeOut, password);    &#125;&#125;</code></pre><p><strong>基础使用</strong></p><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringRunner.class)</span><span class="hljs-meta">@SpringBootTest(classes = KerwinBootsApplication.class)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationTests</span> &#123;    <span class="hljs-meta">@Resource</span>    JedisPool jedisPool;    <span class="hljs-meta">@Test</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testJedis</span> <span class="hljs-params">()</span> &#123;        <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> jedisPool.getResource();        jedis.set(<span class="hljs-string">&quot;year&quot;</span>, String.valueOf(<span class="hljs-number">24</span>));    &#125;&#125;</code></pre><h3 id="SpringBoot-redis-staeter-RedisTemplate"><a href="#SpringBoot-redis-staeter-RedisTemplate" class="headerlink" title="SpringBoot redis staeter RedisTemplate"></a>SpringBoot redis staeter RedisTemplate</h3><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- redis --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- redis 2.X 更换为commons-pool2 连接池 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><pre><code class="hljs properties"><span class="hljs-comment">############# redis Config #############</span><span class="hljs-comment"># Redis数据库索引（默认为0）</span><span class="hljs-attr">spring.redis.database</span>=<span class="hljs-string">0</span><span class="hljs-comment"># Redis服务器地址</span><span class="hljs-attr">spring.redis.host</span>=<span class="hljs-string">120.79.88.17</span><span class="hljs-comment"># Redis服务器连接端口</span><span class="hljs-attr">spring.redis.port</span>=<span class="hljs-string">6379</span><span class="hljs-comment"># Redis服务器连接密码（默认为空）</span><span class="hljs-attr">spring.redis.password</span>=<span class="hljs-string">123456</span><span class="hljs-comment"># 连接池最大连接数（使用负值表示没有限制）</span><span class="hljs-attr">spring.redis.jedis.pool.max-active</span>=<span class="hljs-string">200</span><span class="hljs-comment"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span><span class="hljs-attr">spring.redis.jedis.pool.max-wait</span>=<span class="hljs-string">1000ms</span><span class="hljs-comment"># 连接池中的最大空闲连接</span><span class="hljs-attr">spring.redis.jedis.pool.max-idle</span>=<span class="hljs-string">8</span><span class="hljs-comment"># 连接池中的最小空闲连接</span><span class="hljs-attr">spring.redis.jedis.pool.min-idle</span>=<span class="hljs-string">0</span><span class="hljs-comment"># 连接超时时间（毫秒）</span><span class="hljs-attr">spring.redis.timeout</span>=<span class="hljs-string">1000ms</span></code></pre><pre><code class="hljs java"><span class="hljs-comment">//  Cache注解配置类</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisCacheConfig</span> &#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> KeyGenerator <span class="hljs-title function_">simpleKeyGenerator</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> (o, method, objects) -&gt; &#123;            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">stringBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();            stringBuilder.append(o.getClass().getSimpleName());            stringBuilder.append(<span class="hljs-string">&quot;.&quot;</span>);            stringBuilder.append(method.getName());            stringBuilder.append(<span class="hljs-string">&quot;[&quot;</span>);            <span class="hljs-keyword">for</span> (Object obj : objects) &#123;                stringBuilder.append(obj.toString());            &#125;            stringBuilder.append(<span class="hljs-string">&quot;]&quot;</span>);            <span class="hljs-keyword">return</span> stringBuilder.toString();        &#125;;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> CacheManager <span class="hljs-title function_">cacheManager</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisCacheManager</span>(                RedisCacheWriter.nonLockingRedisCacheWriter(redisConnectionFactory),                <span class="hljs-comment">// 默认策略，未配置的 key 会使用这个</span>                <span class="hljs-built_in">this</span>.getRedisCacheConfigurationWithTtl(<span class="hljs-number">15</span>),                <span class="hljs-comment">// 指定 key 策略</span>                <span class="hljs-built_in">this</span>.getRedisCacheConfigurationMap()        );    &#125;    <span class="hljs-keyword">private</span> Map&lt;String, RedisCacheConfiguration&gt; <span class="hljs-title function_">getRedisCacheConfigurationMap</span><span class="hljs-params">()</span> &#123;        Map&lt;String, RedisCacheConfiguration&gt; redisCacheConfigurationMap  = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">16</span>);        redisCacheConfigurationMap.put(<span class="hljs-string">&quot;redisTest&quot;</span>, <span class="hljs-built_in">this</span>.getRedisCacheConfigurationWithTtl(<span class="hljs-number">15</span>));        <span class="hljs-keyword">return</span> redisCacheConfigurationMap;    &#125;    <span class="hljs-keyword">private</span> RedisCacheConfiguration <span class="hljs-title function_">getRedisCacheConfigurationWithTtl</span><span class="hljs-params">(Integer seconds)</span> &#123;        Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonRedisSerializer</span>&lt;&gt;(Object.class);        <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">om</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);        jackson2JsonRedisSerializer.setObjectMapper(om);        <span class="hljs-type">RedisCacheConfiguration</span> <span class="hljs-variable">redisCacheConfiguration</span> <span class="hljs-operator">=</span> RedisCacheConfiguration.defaultCacheConfig();        redisCacheConfiguration = redisCacheConfiguration.serializeValuesWith(                RedisSerializationContext                        .SerializationPair                        .fromSerializer(jackson2JsonRedisSerializer)        ).entryTtl(Duration.ofSeconds(seconds));        <span class="hljs-keyword">return</span> redisCacheConfiguration;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">// RedisAutoConfiguration</span><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableCaching</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisConfig</span> &#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@SuppressWarnings(&quot;all&quot;)</span>    <span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory factory)</span> &#123;        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;String, Object&gt;();        template.setConnectionFactory(factory);        <span class="hljs-type">Jackson2JsonRedisSerializer</span> <span class="hljs-variable">jackson2JsonRedisSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonRedisSerializer</span>(Object.class);        <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">om</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);        jackson2JsonRedisSerializer.setObjectMapper(om);        <span class="hljs-type">StringRedisSerializer</span> <span class="hljs-variable">stringRedisSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>();        <span class="hljs-comment">// key采用String的序列化方式</span>        template.setKeySerializer(stringRedisSerializer);        <span class="hljs-comment">// hash的key也采用String的序列化方式</span>        template.setHashKeySerializer(stringRedisSerializer);        <span class="hljs-comment">// value序列化方式采用jackson</span>        template.setValueSerializer(jackson2JsonRedisSerializer);        <span class="hljs-comment">// hash的value序列化方式采用jackson</span>        template.setHashValueSerializer(jackson2JsonRedisSerializer);        template.afterPropertiesSet();        <span class="hljs-keyword">return</span> template;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">// 基础使用</span><span class="hljs-meta">@Resource</span>RedisTemplate&lt;String,Object&gt; redisTemplate;redisTemplate.opsForList().rightPush(<span class="hljs-string">&quot;user:1:order&quot;</span>, dataList.get(<span class="hljs-number">3</span>).get(<span class="hljs-string">&quot;key&quot;</span>).toString());<span class="hljs-comment">// 注解使用</span><span class="hljs-meta">@Cacheable(value = &quot;redisTest&quot;)</span><span class="hljs-keyword">public</span> TestBean <span class="hljs-title function_">testBeanAnnotation</span> <span class="hljs-params">()</span> &#123;&#125;</code></pre><h2 id="Redis使用场景"><a href="#Redis使用场景" class="headerlink" title="Redis使用场景"></a>Redis使用场景</h2><p>| 类型   | 适用场景                                    |<br>|  | - |<br>| String | 缓存，限流，计数器，分布式锁，分布式session |<br>| Hash   | 存储用户信息，用户主页访问量，组合查询      |<br>| List   | 微博关注人时间轴列表，简单队列              |<br>| Set    | 赞，踩，标签，好友关系                      |<br>| Zset   | 排行榜                                      |</p><p>或者简单消息队列，发布订阅实施消息系统等等</p><h3 id="String-缓存"><a href="#String-缓存" class="headerlink" title="String - 缓存"></a>String - 缓存</h3><pre><code class="hljs java"><span class="hljs-comment">// 1.Cacheable 注解</span><span class="hljs-comment">// controller 调用 service 时自动判断有没有缓存，如果有就走redis缓存直接返回，如果没有则数据库然后自动放入redis中</span><span class="hljs-comment">// 可以设置过期时间，KEY生成规则 （KEY生成规则基于 参数的toString方法）</span><span class="hljs-meta">@Cacheable(value = &quot;yearScore&quot;, key = &quot;#yearScore&quot;)</span><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> List&lt;YearScore&gt; <span class="hljs-title function_">findBy</span> <span class="hljs-params">(YearScore yearScore)</span> &#123;&#125;<span class="hljs-comment">// 2.手动用缓存</span><span class="hljs-keyword">if</span> (redis.hasKey(???) &#123;    <span class="hljs-keyword">return</span> ....&#125; redis.set(find from DB)...</code></pre><h3 id="String-限流-计数器"><a href="#String-限流-计数器" class="headerlink" title="String - 限流 | 计数器"></a>String - 限流 | 计数器</h3><pre><code class="hljs java"><span class="hljs-comment">// 注：这只是一个最简单的Demo 效率低，耗时旧，但核心就是这个意思</span><span class="hljs-comment">// 计数器也是利用单线程incr...等等</span><span class="hljs-meta">@RequestMapping(&quot;/redisLimit&quot;)</span><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testRedisLimit</span><span class="hljs-params">(String uuid)</span> &#123;    <span class="hljs-keyword">if</span> (jedis.get(uuid) != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-type">Long</span> <span class="hljs-variable">incr</span> <span class="hljs-operator">=</span> jedis.incr(uuid);        <span class="hljs-keyword">if</span> (incr &gt; MAX_LIMITTIME) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Failure Request&quot;</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Success Request&quot;</span>;        &#125;    &#125;    <span class="hljs-comment">// 设置Key 起始请求为1，10秒过期  -&gt;  实际写法肯定封装过,这里就是随便一写</span>    jedis.set(uuid, <span class="hljs-string">&quot;1&quot;</span>);    jedis.expire(uuid, <span class="hljs-number">10</span>);    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Success Request&quot;</span>;&#125;</code></pre><h3 id="String-分布式锁-重点"><a href="#String-分布式锁-重点" class="headerlink" title="String - 分布式锁 (重点)"></a>String - 分布式锁 (重点)</h3><pre><code class="hljs java"><span class="hljs-comment">/***</span><span class="hljs-comment"> * 核心思路：</span><span class="hljs-comment"> *     分布式服务调用时setnx,返回1证明拿到，用完了删除，返回0就证明被锁，等...</span><span class="hljs-comment"> *     SET KEY value [EX seconds] [PX milliseconds] [NX|XX]</span><span class="hljs-comment"> *     EX second:设置键的过期时间为second秒</span><span class="hljs-comment"> *     PX millisecond:设置键的过期时间为millisecond毫秒</span><span class="hljs-comment"> *     NX：只在键不存在时，才对键进行设置操作</span><span class="hljs-comment"> *     XX:只在键已经存在时，才对键进行设置操作</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 1.设置锁</span><span class="hljs-comment"> *     A. 分布式业务统一Key</span><span class="hljs-comment"> *     B. 设置Key过期时间</span><span class="hljs-comment"> *     C. 设置随机value,利用ThreadLocal 线程私有存储随机value</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 2.业务处理</span><span class="hljs-comment"> *     ...</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 3.解锁</span><span class="hljs-comment"> *     A. 无论如何必须解锁 - finally (超时时间和finally 双保证)</span><span class="hljs-comment"> *     B. 要对比是否是本线程上的锁，所以要对比线程私有value和存储的value是否一致(避免把别人加锁的东西删除了)</span><span class="hljs-comment"> */</span><span class="hljs-meta">@RequestMapping(&quot;/redisLock&quot;)</span><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testRedisLock</span> <span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">for</span>(;;)&#123;            RedisContextHolder.clear();            <span class="hljs-type">String</span> <span class="hljs-variable">uuid</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString();            <span class="hljs-type">String</span> <span class="hljs-variable">set</span> <span class="hljs-operator">=</span> jedis.set(KEY, uuid, <span class="hljs-string">&quot;NX&quot;</span>, <span class="hljs-string">&quot;EX&quot;</span>, <span class="hljs-number">1000</span>);            RedisContextHolder.setValue(uuid);            <span class="hljs-keyword">if</span> (!<span class="hljs-string">&quot;OK&quot;</span>.equals(set)) &#123;                <span class="hljs-comment">// 进入循环-可以短时间休眠</span>            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 获取锁成功 Do Somethings....</span>                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-comment">// 解锁 -&gt; 保证获取数据，判断一致以及删除数据三个操作是原子的， 因此如下写法是不符合的</span>        <span class="hljs-comment">/*if (RedisContextHolder.getValue() != null &amp;&amp; jedis.get(KEY) != null &amp;&amp; RedisContextHolder.getValue().equals(jedis.get(KEY))) &#123;</span><span class="hljs-comment">                jedis.del(KEY);</span><span class="hljs-comment">            &#125;*/</span>        <span class="hljs-comment">// 正确姿势 -&gt; 使用Lua脚本,保证原子性</span>        <span class="hljs-type">String</span> <span class="hljs-variable">luaScript</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;,KEYS[1]) else return 0 end&quot;</span>;        <span class="hljs-type">Object</span> <span class="hljs-variable">eval</span> <span class="hljs-operator">=</span> jedis.eval(luaScript, Collections.singletonList(KEY), Collections.singletonList(RedisContextHolder.getValue()));    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;锁创建成功-业务处理成功&quot;</span>;&#125;</code></pre><h3 id="String-分布式Session（重点）"><a href="#String-分布式Session（重点）" class="headerlink" title="String - 分布式Session（重点）"></a>String - 分布式Session（重点）</h3><pre><code class="hljs less"><span class="hljs-comment">// 1.首先明白为什么需要分布式session -&gt; nginx负载均衡 分发到不同的Tomcat，即使利用IP分发，可以利用request获取session，但是其中一个挂了，怎么办？？ 所以需要分布式session</span>注意理解其中的区别  <span class="hljs-selector-tag">A</span>服务<span class="hljs-selector-tag">-</span>用户校验服务  <span class="hljs-selector-tag">B</span>服务<span class="hljs-selector-tag">-</span>业务层情况<span class="hljs-selector-tag">A</span>：<span class="hljs-selector-tag">A</span>,<span class="hljs-selector-tag">B</span> 服务单机部署：<span class="hljs-selector-tag">cookie</span>：登录成功后，存储信息到<span class="hljs-selector-tag">cookie</span>，<span class="hljs-selector-tag">A</span>服务自身通过<span class="hljs-selector-tag">request</span>设置<span class="hljs-selector-tag">session</span>，获取<span class="hljs-selector-tag">session</span>，<span class="hljs-selector-tag">B</span>服务通过唯一<span class="hljs-selector-tag">key</span>或者<span class="hljs-selector-tag">userid</span> 查询数据库获取用户信息<span class="hljs-selector-tag">cookie</span>+<span class="hljs-selector-tag">redis</span>：登录成功后，存储信息到<span class="hljs-selector-tag">cookie</span>，<span class="hljs-selector-tag">A</span>服务自身通过<span class="hljs-selector-tag">request</span>设置<span class="hljs-selector-tag">session</span>，获取<span class="hljs-selector-tag">session</span>，<span class="hljs-selector-tag">B</span>服务通过唯一<span class="hljs-selector-tag">key</span>或者<span class="hljs-selector-tag">userid</span> 查询<span class="hljs-selector-tag">redis</span>获取用户信息情况<span class="hljs-selector-tag">B</span>：<span class="hljs-selector-tag">A</span>服务多节点部署，<span class="hljs-selector-tag">B</span>服务多节点部署<span class="hljs-selector-tag">B</span>服务获取用户信息的方式其实是不重要的，必然要查，要么从数据库，要么从<span class="hljs-selector-tag">cookie</span><span class="hljs-selector-tag">A</span>服务：登录成功后，存储唯一<span class="hljs-selector-tag">key</span>到<span class="hljs-selector-tag">cookie</span>， 与此同时，<span class="hljs-selector-tag">A</span>服务需要把<span class="hljs-selector-tag">session</span>（<span class="hljs-selector-tag">KEY-UserInfo</span>）同步到<span class="hljs-selector-tag">redis</span>中，不能存在单纯的<span class="hljs-selector-tag">request</span>（否则<span class="hljs-selector-tag">nginx</span>分发到另一个服务器就完犊子了）官方实现：<span class="hljs-selector-tag">spring-session-data-redis</span>有一个内置拦截器，拦截<span class="hljs-selector-tag">request</span>，<span class="hljs-selector-tag">session</span>通过<span class="hljs-selector-tag">redis</span>交互，普通使用代码依然是<span class="hljs-selector-tag">request</span><span class="hljs-selector-class">.getSession</span>....  但是实际上这个<span class="hljs-selector-tag">session</span>的值已经被该组件拦截，通过<span class="hljs-selector-tag">redis</span>进行同步了</code></pre><h3 id="List-简单队列-栈"><a href="#List-简单队列-栈" class="headerlink" title="List 简单队列-栈"></a>List 简单队列-栈</h3><pre><code class="hljs java"><span class="hljs-comment">// 说白了利用redis - list数据结构 支持从左从右push，从左从右pop</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisStack</span> &#123;    <span class="hljs-meta">@Resource</span>    Jedis jedis;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Stack&quot;</span>;    <span class="hljs-comment">/** push **/</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span> <span class="hljs-params">(String value)</span> &#123;        jedis.lpush(KEY, value);    &#125;    <span class="hljs-comment">/** pop **/</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">pop</span> <span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> jedis.lpop(KEY);    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisQueue</span> &#123;    <span class="hljs-meta">@Resource</span>    JedisPool jedisPool;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Queue&quot;</span>;    <span class="hljs-comment">/** push **/</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span> <span class="hljs-params">(String value)</span> &#123;        <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> jedisPool.getResource();        jedis.lpush(KEY, value);    &#125;    <span class="hljs-comment">/** pop **/</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">pop</span> <span class="hljs-params">()</span> &#123;        <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> jedisPool.getResource();        <span class="hljs-keyword">return</span> jedis.rpop(KEY);    &#125;&#125;</code></pre><h3 id="List-社交类APP-好友列表"><a href="#List-社交类APP-好友列表" class="headerlink" title="List 社交类APP - 好友列表"></a>List 社交类APP - 好友列表</h3><pre><code class="hljs jboss-cli">根据时间显示好友，多个好友列表，求交集，并集  显示共同好友等等<span class="hljs-string">...</span>疑问：难道大厂真的用redis存这些数据吗？？？多大的量啊<span class="hljs-string">...</span> 我个人认为实际是数据库存用户id，然后用算法去处理，更省空间</code></pre><h3 id="Set-抽奖-好友关系（合，并，交集）"><a href="#Set-抽奖-好友关系（合，并，交集）" class="headerlink" title="Set 抽奖 | 好友关系（合，并，交集）"></a>Set 抽奖 | 好友关系（合，并，交集）</h3><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 插入key 及用户idsadd cat:<span class="hljs-number">1</span> <span class="hljs-number">001</span> <span class="hljs-number">002</span> <span class="hljs-number">003</span> <span class="hljs-number">004</span> <span class="hljs-number">005</span> <span class="hljs-number">006</span><span class="hljs-regexp">//</span> 返回抽奖参与人数scard cat:<span class="hljs-number">1</span><span class="hljs-regexp">//</span> 随机抽取一个srandmember cat:<span class="hljs-number">1</span><span class="hljs-regexp">//</span> 随机抽取一人，并移除spop cat:<span class="hljs-number">1</span></code></pre><h3 id="Zset-排行榜"><a href="#Zset-排行榜" class="headerlink" title="Zset 排行榜"></a>Zset 排行榜</h3><pre><code class="hljs crmsh">根据分数实现有序列表微博热搜：每点击一次 分数+<span class="hljs-number">1</span> 即可--- 不用数据库目的是因为避免<span class="hljs-keyword">order</span> <span class="hljs-title">by</span> 进行全表扫描</code></pre><h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><h3 id="Q1-为什么Redis能这么快"><a href="#Q1-为什么Redis能这么快" class="headerlink" title="Q1:为什么Redis能这么快"></a>Q1:为什么Redis能这么快</h3><pre><code class="hljs tex">1.Redis完全基于内存，绝大部分请求是纯粹的内存操作，执行效率高。2.Redis使用单进程单线程模型的(K,V)数据库，将数据存储在内存中，存取均不会受到硬盘IO的限制，因此其执行速度极快，另外单线程也能处理高并发请求，还可以避免频繁上下文切换和锁的竞争，同时由于单线程操作，也可以避免各种锁的使用，进一步提高效率3.数据结构简单，对数据操作也简单，Redis不使用表，不会强制用户对各个关系进行关联，不会有复杂的关系限制，其存储结构就是键值对，类似于HashMap，HashMap最大的优点就是存取的时间复杂度为O(1)5.C语言编写，效率更高6.Redis使用多路I/O复用模型，为非阻塞IO7.有专门设计的RESP协议</code></pre><blockquote><p>针对第四点进行说明 -&gt; </p><p>常见的IO模型有四种：</p><ul><li><p>同步阻塞IO（Blocking IO）：即传统的IO模型。</p></li><li><p>同步非阻塞IO（Non-blocking IO）：默认创建的socket都是阻塞的，非阻塞IO要求socket被设置为NONBLOCK。注意这里所说的NIO并非Java的NIO（New IO）库。</p></li><li><p>IO多路复用（IO Multiplexing）：即经典的Reactor设计模式，有时也称为异步阻塞IO，Java中的Selector和Linux中的epoll都是这种模型。</p></li><li><p>异步IO（Asynchronous IO）：即经典的Proactor设计模式，也称为异步非阻塞IO</p></li></ul><p>同步异步，阻塞非阻塞的概念：</p><p><img src="/2023/02/06/Redis%E7%AF%87/Redis%E7%AF%87%5Cu=3153840595,3774439005&fm=173&app=49&f=JPEG.jpg" alt="img"></p><p><img src="/2023/02/06/Redis%E7%AF%87/Redis%E7%AF%87%5Cu=3983759926,858503315&fm=173&app=49&f=JPEG.jpg" alt="img"></p><p>假设Redis采用同步阻塞IO：</p><p>Redis主程序（服务端 单线程）-&gt; 多个客户端连接（真实情况是如开发人员连接redis，程序 redispool连接redis），这每一个都对应着一个客户端，假设为100个客户端，其中一个进行交互时候，如果采用同步阻塞式，那么剩下的99个都需要原地等待，这势必是不科学的。</p><p>IO多路复用</p><p>Redis 采用  I&#x2F;O 多路复用模型</p><p>I&#x2F;O 多路复用模型中，最重要的函数调用就是 <code>select</code>，该方法的能够同时监控多个文件描述符的可读可写情况，当其中的某些文件描述符可读或者可写时，<code>select</code> 方法就会返回可读以及可写的文件描述符个数</p><p><code>注：redis默认使用的是更加优化的算法：epoll</code></p><p>|            | select                                   | poll                                     | epoll                                                        |<br>| —- | —- | —- |  |<br>| 操作方式   | 遍历                                     | 遍历                                     | 回调                                                         |<br>| 底层实现   | 数组                                     | 链表                                     | 哈希表                                                       |<br>| IO效率     | 每次调用都进行线性遍历，时间复杂度为O(n) | 每次调用都进行线性遍历，时间复杂度为O(n) | 事件通知方式，每当fd就绪，系统注册的回调函数就会被调用，将就绪fd放到readyList里面，时间复杂度O(1) |<br>| 最大连接数 | 1024（x86）或2048（x64）                 | 无上限                                   | 无上限                                                       |</p><p>所以我们可以说Redis是这样的：服务端单线程毫无疑问，多客户端连接时候，如果客户端没有发起任何动作，则服务端会把其视为不活跃的IO流，将其挂起，当有真正的动作时，会通过回调的方式执行相应的事件</p></blockquote><h3 id="Q2-从海量Key里查询出某一个固定前缀的Key"><a href="#Q2-从海量Key里查询出某一个固定前缀的Key" class="headerlink" title="Q2:从海量Key里查询出某一个固定前缀的Key"></a>Q2:从海量Key里查询出某一个固定前缀的Key</h3><blockquote><p>A. 笨办法：KEYS [pattern]  注意key很多的话，这样做肯定会出问题，造成redis崩溃</p><p>B. SCAN cursor [MATCH pattern] [COUNT count] 游标方式查找</p></blockquote><h3 id="Q3-如何通过Redis实现分布式锁"><a href="#Q3-如何通过Redis实现分布式锁" class="headerlink" title="Q3:如何通过Redis实现分布式锁"></a>Q3:如何通过Redis实现分布式锁</h3><pre><code class="hljs">见上文</code></pre><h3 id="Q4-如何实现异步队列"><a href="#Q4-如何实现异步队列" class="headerlink" title="Q4:如何实现异步队列"></a>Q4:如何实现异步队列</h3><pre><code class="hljs vbnet">上文说到利用 redis-list 实现队列假设场景:A服务生产数据 - B服务消费数据，即可利用此种模型构造-生产消费者模型<span class="hljs-number">1</span>. 使用Redis中的List作为队列<span class="hljs-number">2</span>.使用BLPOP <span class="hljs-keyword">key</span> [<span class="hljs-keyword">key</span>...] timeout  -&gt; LPOP <span class="hljs-keyword">key</span> [<span class="hljs-keyword">key</span> ...] timeout:阻塞直到队列有消息或者超时（方案二：解决方案一中，拿数据的时，生产者尚未生产的情况）<span class="hljs-number">3</span>.pub/<span class="hljs-keyword">sub</span>：主题订阅者模式基于reds的终极方案，上文有介绍，基于发布/订阅模式缺点:消息的发布是无状态的，无法保证可达。对于发布者来说，消息是“即发即失”的，此时如果某个消费者在生产者发布消息时下线，重新上线之后，是无法接收该消息的，要解决该问题需要使用专业的消息队列</code></pre><h3 id="Q5-Redis支持的数据类型？"><a href="#Q5-Redis支持的数据类型？" class="headerlink" title="Q5:Redis支持的数据类型？"></a>Q5:Redis支持的数据类型？</h3><pre><code class="hljs">见上文</code></pre><h3 id="Q6-什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？"><a href="#Q6-什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？" class="headerlink" title="Q6:什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？"></a>Q6:什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？</h3><blockquote><p>持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。</p><p>Redis 提供了两种持久化方式:RDB（默认） 和AOF </p><p><strong>RDB：</strong></p><p>rdb是Redis DataBase缩写</p><p>功能核心函数rdbSave(生成RDB文件)和rdbLoad（从文件加载内存）两个函数</p><p><img src="/2023/02/06/Redis%E7%AF%87/1481291-20180925141429889-1694430603.png" alt="img"></p><p>RDB:  把当前进程数据生成快照文件保存到硬盘的过程。分为手动触发和自动触发</p><p>手动触发 -&gt;  save (不推荐，阻塞严重)  bgsave -&gt; （save的优化版，微秒级阻塞）</p><p><code>shutdowm 关闭服务时，如果没有配置AOF，则会使用bgsave持久化数据</code></p><p><strong>bgsave - 工作原理</strong></p><p>会从当前父进程fork一个子进程，然后生成rdb文件</p><p>缺点：频率低，无法做到实时持久化</p><p><strong>AOF:</strong></p><p>Aof是Append-only file缩写，AOF文件存储的也是RESP协议</p><p><img src="/2023/02/06/Redis%E7%AF%87/1481291-20180925141527592-2105439510.png" alt="img"></p><p>每当执行服务器(定时)任务或者函数时flushAppendOnlyFile 函数都会被调用， 这个函数执行以下两个工作</p><p>aof写入保存：</p><p>WRITE：根据条件，将 aof_buf 中的缓存写入到 AOF 文件</p><p>SAVE：根据条件，调用 fsync 或 fdatasync 函数，将 AOF 文件保存到磁盘中。</p><p><strong>存储结构:</strong></p><p>内容是redis通讯协议(RESP )格式的命令文本存储</p><p><strong>原理：</strong></p><p>相当于存储了redis的执行命令(类似mysql的sql语句日志)，数据的完整性和一致性更高</p><p><strong>比较</strong>：</p><p>1、aof文件比rdb更新频率高</p><p>2、aof比rdb更安全</p><p>3、rdb性能更好</p><p>PS：正确停止redis服务 应该基于连接命令 加再上 shutdown -&gt; 否则数据持久化会出现问题</p></blockquote><h3 id="Q7-redis通讯协议-RESP"><a href="#Q7-redis通讯协议-RESP" class="headerlink" title="Q7:redis通讯协议(RESP)"></a>Q7:redis通讯协议(RESP)</h3><blockquote><p>Redis 即 REmote Dictionary Server (远程字典服务)；</p><p>而Redis的协议规范是 Redis Serialization Protocol (Redis序列化协议)</p><p>RESP 是redis客户端和服务端之前使用的一种通讯协议；</p><p>RESP 的特点：实现简单、快速解析、可读性好</p><p>协议如下：</p><p>客户端以规定格式的形式发送命令给服务器</p><pre><code class="hljs routeros"><span class="hljs-built_in">set</span> key value 协议翻译如下：* 3    -&gt;  表示以下有几组命令$ 3    -&gt;  表示命令长度是3<span class="hljs-built_in">SET</span><span class="hljs-variable">$6</span>     -&gt;  表示长度是6keykey<span class="hljs-variable">$5</span>     -&gt;  表示长度是5value完整即：* 3$ 3<span class="hljs-built_in">SET</span><span class="hljs-variable">$6</span>keykey<span class="hljs-variable">$5</span> value</code></pre><p>​       </p><p>服务器在执行最后一条命令后，返回结果，返回格式如下：</p><p>For Simple Strings the first byte of the reply is “+” 回复</p><p>For Errors the first byte of the reply is “-“ 错误</p><p>For Integers the first byte of the reply is “:” 整数</p><p>For Bulk Strings the first byte of the reply is “$” 字符串</p><p>For Arrays the first byte of the reply is “*” 数组</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">// 伪造6379 redis-服务端，监听  jedis发送的协议内容</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SocketApp</span> &#123;        <span class="hljs-comment">/***</span><span class="hljs-comment">     * 监听 6379 传输的数据</span><span class="hljs-comment">     * JVM端口需要进行设置</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>  &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">6379</span>);            <span class="hljs-type">Socket</span> <span class="hljs-variable">redis</span> <span class="hljs-operator">=</span> serverSocket.accept();            <span class="hljs-type">byte</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">2048</span>];            redis.getInputStream().read(result);            System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(result));        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span class="hljs-comment">// jedis连接-发送命令</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;        <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);        jedis.set(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;This is value.&quot;</span>);        jedis.close();    &#125;&#125;<span class="hljs-comment">// 监听命令内容如下：</span>*<span class="hljs-number">3</span>$<span class="hljs-number">3</span>SET$<span class="hljs-number">3</span>key$<span class="hljs-number">14</span></code></pre><h3 id="Q8-redis架构有哪些"><a href="#Q8-redis架构有哪些" class="headerlink" title="Q8:redis架构有哪些"></a>Q8:redis架构有哪些</h3><h4 id="单节点"><a href="#单节点" class="headerlink" title="单节点"></a>单节点</h4><h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><pre><code class="hljs crmsh"><span class="hljs-literal">Master</span>-<span class="hljs-literal">slave</span>  主从赋值，此种结构可以考虑关闭<span class="hljs-literal">master</span>的持久化，只让从数据库进行持久化，另外可以通过读写分离，缓解主服务器压力</code></pre><h4 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h4><pre><code class="hljs crmsh">Redis sentinel 是一个分布式系统中监控 redis 主从服务器，并在主服务器下线时自动进行故障转移。其中三个特性：监控（Monitoring）：    Sentinel  会不断地检查你的主服务器和从服务器是否运作正常。提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作。特点：<span class="hljs-number">1</span>、保证高可用<span class="hljs-number">2</span>、监控各个节点<span class="hljs-number">3</span>、自动故障迁移缺点：主从模式，切换需要时间丢数据没有解决 <span class="hljs-keyword">master</span> <span class="hljs-title">写的压力</span></code></pre><h4 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h4><blockquote><p><img src="/2023/02/06/Redis%E7%AF%87/1481291-20180925142304757-1498788186.png" alt="img"></p><p>从redis 3.0之后版本支持redis-cluster集群，Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。</p><p>特点：</p><p>1、无中心架构（不存在哪个节点影响性能瓶颈），少了 proxy 层。</p><p>2、数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布。</p><p>3、可扩展性，可线性扩展到 1000 个节点，节点可动态添加或删除。</p><p>4、高可用性，部分节点不可用时，集群仍可用。通过增加 Slave 做备份数据副本</p><p>5、实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave到 Master 的角色提升。</p><p>缺点：</p><p>1、资源隔离性较差，容易出现相互影响的情况。</p><p>2、数据通过异步复制,不保证数据的强一致性</p></blockquote><h3 id="Q9-Redis集群-如何从海量数据里快速找到所需？"><a href="#Q9-Redis集群-如何从海量数据里快速找到所需？" class="headerlink" title="Q9:Redis集群-如何从海量数据里快速找到所需？"></a>Q9:Redis集群-如何从海量数据里快速找到所需？</h3><ul><li><h4 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h4><p>按照某种规则去划分数据，分散存储在多个节点上。通过将数据分到多个Redis服务器上，来减轻单个Redis服务器的压力。</p></li><li><h4 id="一致性Hash算法"><a href="#一致性Hash算法" class="headerlink" title="一致性Hash算法"></a>一致性Hash算法</h4><p>既然要将数据进行分片，那么通常的做法就是获取节点的Hash值，然后根据节点数求模，但这样的方法有明显的弊端，当Redis节点数需要动态增加或减少的时候，会造成大量的Key无法被命中。所以Redis中引入了<strong>一致性Hash算法</strong>。该算法<strong>对2^32 取模，将Hash值空间组成虚拟的圆环</strong>，整个圆环按<strong>顺时针</strong>方向组织，每个节点依次为0、1、2…2^32-1，之后将每个服务器进行Hash运算，确定服务器在这个Hash环上的地址，确定了服务器地址后，对数据使用同样的Hash算法，将数据定位到特定的Redis服务器上。如果定位到的地方没有Redis服务器实例，则继续顺时针寻找，找到的第一台服务器即该数据最终的服务器位置。 </p><p><img src="https://user-gold-cdn.xitu.io/2019/9/17/16d3e62113addc43?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="一致性Hash算法"></p></li></ul><h4 id="Hash环的数据倾斜问题"><a href="#Hash环的数据倾斜问题" class="headerlink" title="Hash环的数据倾斜问题"></a>Hash环的数据倾斜问题</h4><p>Hash环在服务器节点很少的时候，容易遇到服务器节点不均匀的问题，这会造成<strong>数据倾斜</strong>，数据倾斜指的是被缓存的对象大部分集中在Redis集群的其中一台或几台服务器上。 </p><p><img src="/2023/02/06/Redis%E7%AF%87/16d3e6243490f5e0" alt="数据倾斜"></p><p> 如上图，一致性Hash算法运算后的数据大部分被存放在A节点上，而B节点只存放了少量的数据，久而久之A节点将被撑爆。<br><strong>引入虚拟节点</strong></p><p><img src="/2023/02/06/Redis%E7%AF%87/16d3e627518a678e" alt="虚拟节点"></p><p> 例如上图：将NodeA和NodeB两个节点分为Node A#1-A#3 NodeB#1-B#3。</p><h3 id="Q10-什么是缓存穿透？如何避免？什么是缓存雪崩？如何避免？什么是缓存击穿？如何避免？"><a href="#Q10-什么是缓存穿透？如何避免？什么是缓存雪崩？如何避免？什么是缓存击穿？如何避免？" class="headerlink" title="Q10:什么是缓存穿透？如何避免？什么是缓存雪崩？如何避免？什么是缓存击穿？如何避免？"></a>Q10:什么是缓存穿透？如何避免？什么是缓存雪崩？如何避免？什么是缓存击穿？如何避免？</h3><blockquote><p>缓存穿透</p><p>一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。一些恶意的请求会故意查询不存在的key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。</p><p>如何避免？</p><p>1：对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。</p><p>2：对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤。</p><p>3：由于请求参数是不合法的（每次都请求不存在的参数），于是我们可以使用布隆过滤器（Bloomfilter）或压缩filter提前进行拦截，不合法就不让这个请求进入到数据库层</p><p>缓存雪崩</p><p>当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。</p><p>如何避免？</p><p>1：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p><p>2：做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期</p><p>3：不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p><p>4：启用限流策略，尽量避免数据库被干掉</p><p>缓存击穿</p><p>概念<br>一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。</p><p>解决方案<br>A. 在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key</p><p>B. 服务层处理 - 方法加锁 + 双重校验：</p><pre><code class="hljs java"><span class="hljs-comment">// 锁-实例</span><span class="hljs-keyword">private</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<span class="hljs-keyword">public</span> String <span class="hljs-title function_">getProductImgUrlById</span><span class="hljs-params">(String id)</span>&#123;    <span class="hljs-comment">// 获取缓存</span>    <span class="hljs-type">String</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> jedisClient.get(PRODUCT_KEY + id);    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == product) &#123;        <span class="hljs-comment">// 如果没有获取锁等待3秒，SECONDS代表：秒</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (lock.tryLock(<span class="hljs-number">3</span>, TimeUnit.SECONDS)) &#123;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-comment">// 获取锁后再查一次，查到了直接返回结果</span>                    product = jedisClient.get(PRODUCT_KEY + id);                    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == product) &#123;                        <span class="hljs-comment">// ....</span>                    &#125;                    <span class="hljs-keyword">return</span> product;                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                    product = jedisClient.get(PRODUCT_KEY + id);                &#125; <span class="hljs-keyword">finally</span> &#123;                    <span class="hljs-comment">// 释放锁（成功、失败都必须释放，如果是lock.tryLock()方法会一直阻塞在这）</span>                    lock.unlock();                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                product = jedisClient.get(PRODUCT_KEY + id);            &#125;        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            product = jedisClient.get(PRODUCT_KEY + id);        &#125;    &#125;    <span class="hljs-keyword">return</span> product;&#125;</code></pre></blockquote><p>|          | 解释                                                         | 基础解决方案                                                 |<br>| – |  |  |<br>| 缓存穿透 | 访问一个不存在的key，缓存不起作用，请求会穿透到DB，流量大时DB会挂掉 | 1.采用布隆过滤器，使用一个足够大的bitmap，用于存储可能访问的key，不存在的key直接被过滤； 2.访问key未在DB查询到值，也将空值写进缓存，但可以设置较短过期时间 |<br>| 缓存雪崩 | 大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩 | 可以给缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效 |<br>| 缓存击穿 | 一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增 | 在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key |</p><h3 id="Q11-缓存与数据库双写一致"><a href="#Q11-缓存与数据库双写一致" class="headerlink" title="Q11:缓存与数据库双写一致"></a>Q11:缓存与数据库双写一致</h3><blockquote><p>如果仅仅是读数据，没有此类问题</p><p>如果是新增数据，也没有此类问题</p><p>当数据需要更新时，如何保证缓存与数据库的双写一致性？</p><p>三种更新策略：</p><ol><li>先更新数据库，再更新缓存  -&gt;  </li><li>先删除缓存，再更新数据库</li><li>先更新数据库，再删除缓存</li></ol><p>方案一：并发的时候，执行顺序无法保证，可能A先更新数据库，但B后更新数据库但先更新缓存</p><p>​                加锁的话，确实可以避免，但这样吞吐量会下降，可以根据业务场景考虑</p><p>方案二：该方案会导致不一致的原因是。同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:<br>（1）请求A进行写操作，删除缓存<br>（2）请求B查询发现缓存不存在<br>（3）请求B去数据库查询得到旧值<br>（4）请求B将旧值写入缓存<br>（5）请求A将新值写入数据库</p><p>因此采用：<strong>采用延时双删策略</strong>   即进入逻辑就删除Key，执行完操作，延时再删除key</p><p>方案三：更新数据库 - 删除缓存  可能出现问题的场景：</p><p>（1）缓存刚好失效<br>（2）请求A查询数据库，得一个旧值<br>（3）请求B将新值写入数据库<br>（4）请求B删除缓存<br>（5）请求A将查到的旧值写入缓存</p><p>先天条件要求：请求第二步的读取操作耗时要大于更新操作，条件较为苛刻</p><p>但如果真的发生怎么处理？</p><p>A. 给键设置合理的过期时间</p><p>B. 异步延时删除key</p></blockquote><h3 id="Q12-何保证Redis中的数据都是热点数据"><a href="#Q12-何保证Redis中的数据都是热点数据" class="headerlink" title="Q12:何保证Redis中的数据都是热点数据"></a>Q12:何保证Redis中的数据都是热点数据</h3><blockquote><p>A. 可以通过手工或者主动方式，去加载热点数据</p><p>B. Redis有其自己的数据淘汰策略：</p><p>redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略（回收策略）。redis 提供 6种数据淘汰策略：</p><ol><li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</li><li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li>no-enviction（驱逐）：禁止驱逐数据</li></ol></blockquote><h3 id="Q13-Redis的并发竞争问题如何解决"><a href="#Q13-Redis的并发竞争问题如何解决" class="headerlink" title="Q13:Redis的并发竞争问题如何解决?"></a>Q13:Redis的并发竞争问题如何解决?</h3><pre><code class="hljs routeros">即多线程同时操作统一Key的解决办法：Redis为单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，但是在Jedis客户端对Redis进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成对此有多种解决方法：A：条件允许的情况下，请使用redis自带的incr命令,decr命令B：乐观锁方式watch price<span class="hljs-built_in">get</span> price <span class="hljs-variable">$price</span><span class="hljs-variable">$price</span> = <span class="hljs-variable">$price</span> + 10multi<span class="hljs-built_in">set</span> price <span class="hljs-variable">$price</span>execC：针对客户端，操作同一个key的时候，进行加锁处理D：场景允许的话，使用setnx 实现</code></pre><h3 id="Q14-Redis回收进程如何工作的-Redis回收使用的是什么算法"><a href="#Q14-Redis回收进程如何工作的-Redis回收使用的是什么算法" class="headerlink" title="Q14:Redis回收进程如何工作的? Redis回收使用的是什么算法?"></a>Q14:Redis回收进程如何工作的? Redis回收使用的是什么算法?</h3><blockquote><p>Q12 中提到过，当所需内存超过配置的最大内存时，redis会启用数据淘汰规则</p><p>默认规则是：# maxmemory-policy noeviction</p><p>即只允许读，无法继续添加key</p><p>因此常需要配置淘汰策略，比如LRU算法</p><p><img src="/2023/02/06/Redis%E7%AF%87/251954349742220-1569134965865.png" alt="img"></p><p><code>LRU算法最为精典的实现，就是HashMap+Double LinkedList，时间复杂度为O(1)</code></p></blockquote><h3 id="Q15-Redis大批量增加数据"><a href="#Q15-Redis大批量增加数据" class="headerlink" title="Q15:Redis大批量增加数据"></a>Q15:Redis大批量增加数据</h3><p>参考文章：<a href="https://www.cnblogs.com/PatrickLiu/p/8548580.html">https://www.cnblogs.com/PatrickLiu/p/8548580.html</a></p><blockquote><p>使用管道模式，运行的命令如下所示：</p><pre><code class="hljs haskell"><span class="hljs-title">cat</span> <span class="hljs-class"><span class="hljs-keyword">data</span>.txt | redis-cli <span class="hljs-comment">--pipe</span></span></code></pre><p>data.txt文本：</p><pre><code class="hljs java">SET Key0 Value0SET Key1 Value1...SET KeyN ValueN# 或者是 RESP协议内容 - 注意文件编码！！！*<span class="hljs-number">8</span>$<span class="hljs-number">5</span>HMSET$<span class="hljs-number">8</span>person:<span class="hljs-number">1</span>$<span class="hljs-number">2</span>id$<span class="hljs-number">1</span><span class="hljs-number">1</span></code></pre><p>这将产生类似于这样的输出：</p><pre><code class="hljs sql"><span class="hljs-keyword">All</span> data transferred. Waiting <span class="hljs-keyword">for</span> the <span class="hljs-keyword">last</span> reply...<span class="hljs-keyword">Last</span> reply received <span class="hljs-keyword">from</span> server.errors: <span class="hljs-number">0</span>, replies: <span class="hljs-number">1000000</span></code></pre><p>redis-cli实用程序还将确保只将从Redis实例收到的错误重定向到标准输出</p><p>演示：</p><pre><code class="hljs livecodeserver">cat redis_commands.txt | redis-cli -h <span class="hljs-number">192.168</span><span class="hljs-number">.127</span><span class="hljs-number">.130</span> -p <span class="hljs-number">6379</span> [-<span class="hljs-keyword">a</span> <span class="hljs-string">&quot;password&quot;</span>] -n <span class="hljs-number">0</span> <span class="hljs-comment">--pipe</span>All data transferred.Waiting <span class="hljs-keyword">for</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">last</span> reply...Last reply received <span class="hljs-built_in">from</span> server.errors:<span class="hljs-number">0</span>，replies：<span class="hljs-number">10000000</span></code></pre><pre><div class="caption"><span>实战：```  文件详情：可见Redis-通道实战</span></div><code class="hljs mysql数据快速导入到redis">博文：https://www.cnblogs.com/tommy-huang/p/4703514.html```sql# 1.准备一个tablecreate database  if not exists `test`;use `test`;CREATE TABLE `person` (  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,  `name` varchar(200) NOT NULL,  `age` varchar(200) NOT NULL,  PRIMARY KEY (`id`)) ENGINE=MyISAM AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;# 2.插入七八万条数据# 3.SQL查询，将其转化为 RESP协议命令   Linux 版本： -&gt; 不要在windows环境试，没啥意义SELECT CONCAT(   &quot;*8\r\n&quot;,   &#x27;$&#x27;,LENGTH(redis_cmd),&#x27;\r\n&#x27;,redis_cmd,&#x27;\r\n&#x27;,   &#x27;$&#x27;,LENGTH(redis_key),&#x27;\r\n&#x27;,redis_key,&#x27;\r\n&#x27;,   &#x27;$&#x27;,LENGTH(hkey1),&#x27;\r\n&#x27;,hkey1,&#x27;\r\n&#x27;,&#x27;$&#x27;,LENGTH(hval1),&#x27;\r\n&#x27;,hval1,&#x27;\r\n&#x27;,   &#x27;$&#x27;,LENGTH(hkey2),&#x27;\r\n&#x27;,hkey2,&#x27;\r\n&#x27;,&#x27;$&#x27;,LENGTH(hval2),&#x27;\r\n&#x27;,hval2,&#x27;\r\n&#x27;,   &#x27;$&#x27;,LENGTH(hkey3),&#x27;\r\n&#x27;,hkey3,&#x27;\r\n&#x27;,&#x27;$&#x27;,LENGTH(hval3),&#x27;\r\n&#x27;,hval3,&#x27;\r&#x27;)FROM(   SELECT &#x27;HMSET&#x27; AS redis_cmd,   concat_ws(&#x27;:&#x27;,&#x27;person&#x27;, id) AS redis_key,   &#x27;id&#x27; AS hkey1, id AS hval1,   &#x27;name&#x27; AS hkey2, name AS hval2,   &#x27;age&#x27; AS hkey3, age AS hval3   From person)AS t# 4.如果用的就是线上数据库+线上Linux -&gt; 把sql存到 order.sql，进行执行mysql -uroot -p123456 test --default-character-set=utf8 --skip-column-names --raw &lt; order.sql  |redis-cli -h 127.0.0.1 -p 6379 -a 123456 --pipe# 5.本地数据库+线上redis利用Navicat导出数据 -&gt; data.txt，清理格式（导出来的数据里面各种 &quot; 符号），全局替换即可cat data.txt | redis-cli -h 127.0.0.1 -p 6379 -a 123456  --pipe81921条数据 一瞬间导入完成注意事项： RESP协议要求，不要有莫名其妙的字符，注意文件类型是Unix编码类型</code></pre></blockquote><h3 id="Q16：延申：布隆过滤器"><a href="#Q16：延申：布隆过滤器" class="headerlink" title="Q16：延申：布隆过滤器"></a>Q16：延申：布隆过滤器</h3><blockquote><p>数据结构及算法篇 &#x2F; 布隆过滤器</p><p>Redis 实现</p><p>redis 4.X 以上 提供 布隆过滤器插件</p><p>centos中安装redis插件bloom-filter：<a href="https://blog.csdn.net/u013030276/article/details/88350641">https://blog.csdn.net/u013030276/article/details/88350641</a></p><p>语法：*[bf.add  key  options]*</p><p>语法：[bf.exists  key  options]</p><p>注意: <code>redis 布隆过滤器提供的是 最大内存512M，2亿数据，万分之一的误差率</code></p></blockquote><h3 id="Q17：Lua脚本相关"><a href="#Q17：Lua脚本相关" class="headerlink" title="Q17：Lua脚本相关"></a>Q17：Lua脚本相关</h3><p>使用Lua脚本的好处：</p><ul><li>减少网络开销。可以将多个请求通过脚本的形式一次发送，减少网络时延</li><li>原子操作，redis会将整个脚本作为一个整体执行，中间不会被其他命令插入。因此在编写脚本的过程中无需担心会出现竞态条件，无需使用事务</li><li>复用，客户端发送的脚本会永久存在redis中，这样，其他客户端可以复用这一脚本而不需要使用代码完成相同的逻辑</li></ul><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testLua&quot;)</span><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testLua</span> <span class="hljs-params">()</span> &#123;    <span class="hljs-type">String</span> <span class="hljs-variable">key</span>   <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mylock&quot;</span>;    <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;xxxxxxxxxxxxxxx&quot;</span>;    <span class="hljs-comment">//        if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1]</span>    <span class="hljs-comment">//            then</span>    <span class="hljs-comment">//                return redis.call(&#x27;del&#x27;, KEYS[1])</span>    <span class="hljs-comment">//        else</span>    <span class="hljs-comment">//            return 0</span>    <span class="hljs-comment">//        end</span>    <span class="hljs-comment">// lua脚本，用来释放分布式锁 - 如果使用的较多，可以封装到文件中, 再进行调用</span>    <span class="hljs-type">String</span> <span class="hljs-variable">luaScript</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;,KEYS[1]) else return 0 end&quot;</span>;    <span class="hljs-type">Object</span> <span class="hljs-variable">eval</span> <span class="hljs-operator">=</span> jedis.eval(luaScript, Collections.singletonList(key), Collections.singletonList(value));    <span class="hljs-keyword">return</span> eval.toString();&#125;</code></pre><h3 id="Q18：性能相关-Redis慢查询分析"><a href="#Q18：性能相关-Redis慢查询分析" class="headerlink" title="Q18：性能相关 - Redis慢查询分析"></a>Q18：性能相关 - Redis慢查询分析</h3><blockquote><p>redis 命令会放在redis内置队列中，然后主线程一个个执行，因此 其中一个 命令执行时间过长，会造成成批量的阻塞</p><pre><div class="caption"><span>get 获取慢查询记录</span></div><code class="hljs 命令：```slowlog">     slowlog len 获取慢查询记录量(慢查询队列是先进先出的，因此新的值在满载的时候，旧的会出去)Redis 慢查询 -&gt; 执行阶段耗时过长 ```conf文件设置： ```slowlog-low-slower-than 10000 -&gt; 10000微秒,10毫秒 (默认)                            0 -&gt; 记录所有命令                           -1 -&gt; 不记录命令slow-max-len 存放的最大条数```慢查询导致原因: value 值过大，解决办法:```数据分段（更细颗粒度存放数据） ### Q19：如何提高Redis处理效率? 基于Jedis 的批量操作 Pipelined```javaJedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);Pipeline pipelined = jedis.pipelined();for (String key : keys) &#123;   pipelined.del(key);&#125;pipelined.sync();jedis.close();// pipelined 实际是封装过一层的指令集 -&gt;  实际应用的还是单条指令，但是节省了网络传输开销（服务端到Redis环境的网络开销）</code></pre></blockquote>]]></content>
    
    
    <categories>
      
      <category>中间件篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL优化与诊断</title>
    <link href="/2023/02/06/SQL%E4%BC%98%E5%8C%96%E4%B8%8E%E8%AF%8A%E6%96%AD/"/>
    <url>/2023/02/06/SQL%E4%BC%98%E5%8C%96%E4%B8%8E%E8%AF%8A%E6%96%AD/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL优化与诊断"><a href="#SQL优化与诊断" class="headerlink" title="SQL优化与诊断"></a>SQL优化与诊断</h1><p>标签： #Share</p><h2 id="Explain诊断"><a href="#Explain诊断" class="headerlink" title="Explain诊断"></a>Explain诊断</h2><p>Explain各参数的含义如下：</p><p>| <strong>列名</strong>     | <strong>说明</strong>                                                     |<br>|  |  |<br>| id           | 执行编号，标识select所属的行。如果在语句中没有子查询或关联查询，只有唯一的select，每行都将显示1.否则，内层的select语句一般会顺序编号，对应于其在原始语句中的位置 |<br>| select_type  | 显示本行是简单或复杂select，如果查询有任何复杂的子查询，则最外层标记为PRIMARY（DERIVED、UNION、UNION RESUIT） |<br>| table        | 访问引用哪个表（引用某个查询，如“derived3”）                 |<br>| type         | 数据访问&#x2F;读取操作类型（All、index、range、ref、eq_ref、const&#x2F;system、NULL） |<br>| possible_key | 揭示哪一些索引可能有利于高效的查找                           |<br>| key          | 显示mysql实际决定采用哪个索引来优化查询                      |<br>| key_len      | 显示mysql在索引里使用的字节数                                |<br>| ref          | 显示了之前的表在key列记录的索引中查找值所用的列或常量        |<br>| rows         | 为了找到所需要的行而需要读取的行数，估算值                   |<br>| Extra        | 额外信息，如using index、filesort等                          |</p><h3 id="select-type-常见类型及其含义"><a href="#select-type-常见类型及其含义" class="headerlink" title="select_type 常见类型及其含义"></a>select_type 常见类型及其含义</h3><ul><li><strong>SIMPLE</strong>：不包含子查询或者 UNION 操作的查询</li><li><strong>PRIMARY</strong>：查询中如果包含任何子查询，那么最外层的查询则被标记为 PRIMARY </li><li><strong>SUBQUERY</strong>：子查询中第一个 SELECT</li><li><strong>DEPENDENT SUBQUERY</strong>：子查询中的第一个 SELECT，取决于外部查询</li><li><strong>UNION</strong>：UNION 操作的第二个或者之后的查询</li><li><strong>DEPENDENT UNION</strong>：UNION 操作的第二个或者之后的查询,取决于外部查询</li><li><strong>UNION RESULT</strong>：UNION 产生的结果集</li><li><strong>DERIVED</strong>：出现在 FROM 字句中的子查询</li></ul><h3 id="type常见类型及其含义"><a href="#type常见类型及其含义" class="headerlink" title="type常见类型及其含义"></a>type常见类型及其含义</h3><ul><li><strong>system</strong>：这是 const 类型的一个特例，只会出现在待查询的表只有一行数据的情况下 </li><li><code>consts</code>：常出现在主键或唯一索引与常量值进行比较的场景下，此时查询性能是最优的 </li><li><strong>eq_ref</strong>：当连接使用的是完整的索引并且是 PRIMARY KEY 或 UNIQUE NOT NULL INDEX 时使用它 </li><li><code>ref</code>：当连接使用的是前缀索引或连接条件不是 PRIMARY KEY 或 UNIQUE INDEX 时则使用它 </li><li><strong>ref_or_null</strong>：类似于 ref 类型的查询，但是附加了对 NULL 值列的查询 </li><li><strong>index_merge</strong>：该联接类型表示使用了索引进行合并优化 </li><li><code>range</code>：使用索引进行范围扫描，常见于 between、&gt; 、&lt; 这样的查询条件 </li><li><code>index</code>：索引连接类型与 ALL 相同，只是扫描的是索引树，通常出现在索引是该查询的覆盖索引的情况 </li><li><strong>ALL</strong>：全表扫描，效率最差的查找方式</li></ul><p>阿里编码规范要求：<code>至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好</code></p><h3 id="key列"><a href="#key列" class="headerlink" title="key列"></a>key列</h3><p>实际在查询中是否使用到索引的标志字段</p><h3 id="Extra列"><a href="#Extra列" class="headerlink" title="Extra列"></a>Extra列</h3><p>Extra 列主要用于显示额外的信息，常见信息及其含义如下：</p><ul><li><strong>Using where</strong> ：MySQL 服务器会在存储引擎检索行后再进行过滤</li><li><strong>Using filesort</strong>：通常出现在 GROUP BY 或 ORDER BY 语句中，且排序或分组没有基于索引，此时需要使用文件在内存中进行排序，因为使用索引排序的性能好于使用文件排序，所以出现这种情况可以考虑通过添加索引进行优化</li><li><strong>Using index</strong>：使用了覆盖索引进行查询，此时不需要访问表，从索引中就可以获取到所需的全部数据</li><li><strong>Using index condition：</strong>查找使用了索引，但是需要回表查询数据</li><li><strong>Using temporary</strong>：表示需要使用临时表来处理查询，常出现在 GROUP BY 或 ORDER BY 语句中</li></ul><h3 id="如何查看Mysql优化器优化之后的SQL"><a href="#如何查看Mysql优化器优化之后的SQL" class="headerlink" title="如何查看Mysql优化器优化之后的SQL"></a>如何查看Mysql优化器优化之后的SQL</h3><pre><code class="hljs mysql"># 仅在服务器环境下或通过Navicat进入命令列界面explain extended  SELECT * FROM `student` where `name` = 1 and `age` = 1;# 再执行show warnings;# 结果如下：/* select#1 */ select `mytest`.`student`.`age` AS `age`,`mytest`.`student`.`name` AS `name`,`mytest`.`student`.`year` AS `year` from `mytest`.`student` where ((`mytest`.`student`.`age` = 1) and (`mytest`.`student`.`name` = 1))</code></pre><p>为什么要做这个事呢？我们知道Mysql有一个最左匹配原则，那么如果我的索引建的是age，name，那我以name，age这样的顺序去查询能否使用到索引呢？实际上是可以的，就是因为Mysql查询优化器可以帮助我们自动对SQL的执行顺序等进行优化，以选取代价最低的方式进行查询（注意是代价最低，不是时间最短）</p><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><h3 id="超大分页场景解决方案"><a href="#超大分页场景解决方案" class="headerlink" title="超大分页场景解决方案"></a>超大分页场景解决方案</h3><p>如表中数据需要进行深度分页，如何提高效率？在阿里出品的Java编程规范中写道：</p><p><code>利用延迟关联或者子查询优化超多分页场景</code> </p><p>说明：MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写</p><pre><code class="hljs mysql"># 反例（耗时129.570s）select * from task_result LIMIT 20000000, 10;# 正例（耗时5.114s）SELECT a.* FROM task_result a, (select id from task_result LIMIT 20000000, 10) b where a.id = b.id;# 说明task_result表为生产环境的一个表，总数据量为3400万，id为主键，偏移量达到2000万</code></pre><h3 id="获取一条数据时的Limit-1"><a href="#获取一条数据时的Limit-1" class="headerlink" title="获取一条数据时的Limit 1"></a>获取一条数据时的Limit 1</h3><p>如果数据表的情况已知，某个业务需要获取符合某个Where条件下的一条数据，注意使用Limit</p><p>说明：在很多情况下我们已知数据仅存在一条，此时我们应该告知数据库只用查一条，否则将会转化为全表扫描</p><pre><code class="hljs mysql"># 反例（耗时2424.612s）select * from task_result where unique_key = &#x27;ebbf420b65d95573db7669f21fa3be3e_861414030800727_48&#x27;;# 正例（耗时1.036s）select * from task_result where unique_key = &#x27;ebbf420b65d95573db7669f21fa3be3e_861414030800727_48&#x27; LIMIT 1;# 说明task_result表为生产环境的一个表，总数据量为3400万，where条件非索引字段，数据所在行为第19486条记录</code></pre><h3 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h3><pre><code class="hljs mysql"># 反例INSERT into person(name,age) values(&#x27;A&#x27;,24)INSERT into person(name,age) values(&#x27;B&#x27;,24)INSERT into person(name,age) values(&#x27;C&#x27;,24)# 正例INSERT into person(name,age) values(&#x27;A&#x27;,24),(&#x27;B&#x27;,24),(&#x27;C&#x27;,24);# 说明比较常规，就不多做说明了</code></pre><h3 id="like语句的优化"><a href="#like语句的优化" class="headerlink" title="like语句的优化"></a>like语句的优化</h3><p>like语句一般业务要求都是 <code>&#39;%关键字%&#39;</code>这种形式，但是依然要思考能否考虑使用右模糊的方式去替代产品的要求，其中阿里的编码规范提到：</p><p><code>页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决</code></p><pre><code class="hljs mysql"># 反例（耗时78.843s）EXPLAIN select * from task_result where taskid LIKE &#x27;%tt600e6b601677b5cbfe516a013b8e46%&#x27; LIMIT 1;# 正例（耗时0.986s）select * from task_result where taskid LIKE &#x27;tt600e6b601677b5cbfe516a013b8e46%&#x27; LIMIT 1########################################################################### 对正例的Explain1SIMPLEtask_resultrangeadapt_idadapt_id9899100.00Using index condition# 对反例的Explain1SIMPLEtask_resultALL                    3362855411.11Using where# 说明task_result表为生产环境的一个表，总数据量为3400万，taskid是一个普通索引列，可见%%这种匹配方式完全无法使用索引，从而进行全表扫描导致效率极低，而正例通过索引查找数据只需要扫描99条数据即可</code></pre><h3 id="避免SQL中对where字段进行函数转换或表达式计算"><a href="#避免SQL中对where字段进行函数转换或表达式计算" class="headerlink" title="避免SQL中对where字段进行函数转换或表达式计算"></a>避免SQL中对where字段进行函数转换或表达式计算</h3><pre><code class="hljs mysql"># 反例select * from task_result where id + 1 = 15551;# 正例select * from task_result where id = 15550;########################################################################### 对正例的Explain1SIMPLEtask_resultconstPRIMARYPRIMARY8const1100.00# 对反例的Explain1SIMPLEtask_resultALL                33631512  100.00Using where# 说明其实在知道了有SQL优化器之后，我个人感觉这种普通的表达式转换应该可以提前进行处理再进行查询，这样一来就可以用到索引了，但是问题又来了，如果mysql优化器可以提前计算出结果，那么写sql语句的人也一定可以提前计算出结果，所以矛盾点在这个地方，导致5.7版本以前的此种情况都无法使用索引吧，未来可能会对其进行优化</code></pre><h3 id="使用-ISNULL-来判断是否为-NULL-值"><a href="#使用-ISNULL-来判断是否为-NULL-值" class="headerlink" title="使用 ISNULL()来判断是否为 NULL 值"></a>使用 ISNULL()来判断是否为 NULL 值</h3><p>说明：NULL 与任何值的直接比较都为 NULL</p><pre><code class="hljs mysql"># 1） NULL&lt;&gt;NULL 的返回结果是 NULL，而不是 false。 # 2） NULL=NULL 的返回结果是 NULL，而不是 true。 # 3） NULL&lt;&gt;1 的返回结果是 NULL，而不是 true。</code></pre><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p>我所在的公司基本禁止了多表查询，那如果必须使用到的话，我们可以一起参考一下阿里的编码规范</p><p>Eg：超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引</p><h3 id="明明有索引为什么还走全表扫描"><a href="#明明有索引为什么还走全表扫描" class="headerlink" title="明明有索引为什么还走全表扫描"></a>明明有索引为什么还走全表扫描</h3><p>之前回答一些面试问题的时候，对某一个点的理解出现了偏差，即我认为只要查询的列有索引则一定会使用索引去Push数据</p><p>然而实际上不仅仅是这样，真正应该是：<code>针对查询的数据行占总数据量过多时会转化成全表查询</code></p><p>那么这个过多指代的是多少呢？</p><p>我的测试结果是50%，但个人认为MySQL优化器不会完全纠结于行数区分是否全表，而是有很多其他因素综合考虑发现全表扫描的效率更高等等，所以充分认识到该问题即可</p><h3 id="count-还是-count-id"><a href="#count-还是-count-id" class="headerlink" title="count(*) 还是 count(id)"></a>count(*) 还是 count(id)</h3><p>阿里的Java编码规范中有以下内容：</p><p><code>【强制】不要使用 count(列名) 或 count(常量) 来替代 count(*)</code></p><p>count(*) 是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。 </p><p>说明：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行</p><h3 id="字段类型不同导致索引失效"><a href="#字段类型不同导致索引失效" class="headerlink" title="字段类型不同导致索引失效"></a>字段类型不同导致索引失效</h3><p>阿里的Java编码规范中有以下内容：</p><p><code>【推荐】防止因字段类型不同造成的隐式转换，导致索引失效</code></p><p>实际上数据库在查询的时候会作一层隐式的转换，比如 varchar 类型字段通过 数字去查询</p><pre><code class="hljs mysql"># 正例EXPLAIN SELECT * FROM `user_coll` where pid = &#x27;1&#x27;;type：refref：constrows:1Extra:Using index condition# 反例EXPLAIN SELECT * FROM `user_coll` where pid = 1;type：indexref：NULLrows:3(总记录数)Extra:Using where; Using index# 说明pid字段有相应索引，且格式为varchar</code></pre><h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>感谢以下博文及其作者：</p><p><a href="https://juejin.im/post/5e0f5eec5188253a9d4a436f#heading-4">干货！SQL性能优化，书写高质量SQL语句</a></p><p><a href="https://juejin.im/post/5e1eb8ebf265da3e4244e094">干货！SQL性能优化，书写高质量SQL语句（二）</a></p><p><a href="https://dev.mysql.com/doc/refman/5.6/en/optimize-overview.html">MySQL官方文档</a></p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>自建数据表进行测试</p><pre><code class="hljs mysql">CREATE TABLE `student` (  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;,  `name` varchar(255) NOT NULL,  `class` varchar(255) DEFAULT NULL,  `page` bigint(20) DEFAULT NULL,  `status` tinyint(3) unsigned NOT NULL COMMENT &#x27;状态：0 正常，1 冻结，2 删除&#x27;,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8mb4</code></pre><p>插入数据</p><pre><code class="hljs mysql">DELIMITER ;;    CREATE PROCEDURE insertData()    BEGIN        declare i int;        set i = 1 ;        WHILE (i &lt; 1000000) DO            INSERT INTO student(`name`,class,`page`,`status`)                VALUES(CONCAT(&#x27;class_&#x27;, i),                    CONCAT(&#x27;class_&#x27;, i),                i, (SELECT FLOOR(RAND() * 2)));            set i = i + 1;        END WHILE;        commit;END;;CALL insertData();</code></pre>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL优化与诊断</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring-xsd</title>
    <link href="/2023/02/06/Spring-xsd/"/>
    <url>/2023/02/06/Spring-xsd/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-XSD篇"><a href="#Spring-XSD篇" class="headerlink" title="Spring XSD篇"></a>Spring XSD篇</h1><p>标签： #Share</p><h2 id="错误描述"><a href="#错误描述" class="headerlink" title="错误描述"></a>错误描述</h2><p>有时候你会发现过去一直启动正常的系统，某天启动时会报出形如下面的错误： </p><pre><code class="hljs xquery">org.xml.sax.SAXParseException: schema_reference.<span class="hljs-number">4</span>: Failed <span class="hljs-keyword">to</span> read <span class="hljs-keyword">schema</span><span class="hljs-built_in"> document</span> <span class="hljs-string">&#x27;http://www.springframework.org/schema/beans/spring-beans-2.0.xsd&#x27;</span>, because <span class="hljs-number">1</span>) could<span class="hljs-built_in"> not</span> find the<span class="hljs-built_in"> document</span>; <span class="hljs-number">2</span>) the<span class="hljs-built_in"> document</span> could<span class="hljs-built_in"> not</span> be read; <span class="hljs-number">3</span>) the<span class="hljs-built_in"> root</span> <span class="hljs-keyword">element</span> of the <span class="hljs-keyword">document</span> is not &lt;xsd:schema&gt;.</code></pre><p> 很显然，spring xml配置文件中指定的xsd文件读取不到了，原因多是因为断网或spring的官网暂时无法连接导致的。 你可以通过在浏览器输入xsd文件的URL，如：<a href="http://www.springframework.org/schema/beans/spring-beans-2.0.xsd">http://www.springframework.org/schema/beans/spring-beans-2.0.xsd</a> 进行确认 </p><h2 id="XSD文件的作用"><a href="#XSD文件的作用" class="headerlink" title="XSD文件的作用"></a>XSD文件的作用</h2><p>xml文档要有格式，为了Spring的配置文件增加的节点(比如&lt;tx:advice)能符合要求、合法，必须通过引入校验该xml格式的文件，也就是xsd文件，Spring通过配置可以联网引入xsd文件，也可以在断网下使用本地xsd文件校验xml文件</p><p> xsi:schemaLocation 属性提供一种方法来查找在 XML 实例文档中定义的命名空间的 XML 架构定义。它的值是用空白分隔的统一资源标识符 (URI) 对的列表，其中的每一对 URI 都依次包含一个命名空间以及该命名空间的 XML 架构定义（通常为 .xsd 文件）的位置 </p><pre><div class="caption"><span>```:</span><a href="http://www.springframework.org/schema/tx">link</a></div><code class="hljs Spring在启动时默认要加载xsd文件来验证XML文件的">![image-20191209135859502](Spring-xsd/image-20191209135859502.png)## XSD引起的错误&gt; 前文讲到：XSD文件在Spring启动时起作用&gt;&gt; - 项目正式启动时&gt;&gt; - test测试时&gt;&gt; - Maven打包不跳过test测试（不跳过test测试即会启动项目）&gt;&gt;   &gt;&gt; Spring会默认从本地Jar中读取XSD文件，如果本地读取不到则会通过定义的url地址从网上进行下载示例：![image-20191209140226954](Spring-xsd/image-20191209140226954.png)Spring中：![image-20191209140357800](Spring-xsd/image-20191209140357800.png)上述的版本无法对应，因此就会从网络读取，如果恰好服务器断网或没有外网，则项目启动后会在几秒钟之后停止，报关于解析xml文件错误```javajava.lang.Throwable: org.springframework.beans.factory.xml.XmlBeanDefinitionStoreException: Line 1 in XML document from cn.testin.common.spring.pojo.DynamicResource@957e06 is invalid; nested exception is org.xml.sax.SAXParseException; lineNumber: 1; columnNumber: 1297; cvc-complex-type.2.4.c: The matching wildcard is strict, but no declaration can be found for element &#x27;mongo:mongo-client&#x27;.</code></pre><h2 id="XSD引用解决方案"><a href="#XSD引用解决方案" class="headerlink" title="XSD引用解决方案"></a>XSD引用解决方案</h2> <pre><code class="hljs 不要在Spring的配置文件中配置XSD的版本号```，因为没配置版本号时，默认取当前jar里的XSD文件，减少了各种风险">例子：```xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd       http://www.springframework.org/schema/aop       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;&lt;/beans&gt;</code></pre><p>其他方法：</p><p>思路一致，既然需要解决断网情况下无法启动的问题，则保证配置的能够生效即可</p><ul><li>将tx的某个版本的xsd文件拷贝到工程的source folder下，然后xml的配置改成如下形式：</li></ul><pre><code class="hljs xml">xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans         classpath:beans/spring-beans-4.1.xsd         http://www.springframework.org/schema/mvc         classpath:mvc/spring-mvc-4.1.xsd         http://www.springframework.org/schema/context         classpath:context/spring-context-4.1.xsd         http://www.springframework.org/schema/aop         classpath:aop/spring-aop-4.1.xsd         http://www.springframework.org/schema/tx           classpath:tx/spring-tx-4.1.xsd &quot;&gt;</code></pre><ul><li><strong>根据使用的Spring的相应jar包版本更改对应的版本</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>Tips篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring-xsd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-自定义starter</title>
    <link href="/2023/02/06/SpringBoot-%E8%87%AA%E5%AE%9A%E4%B9%89starter/"/>
    <url>/2023/02/06/SpringBoot-%E8%87%AA%E5%AE%9A%E4%B9%89starter/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-Boot-Starter简介"><a href="#Spring-Boot-Starter简介" class="headerlink" title="Spring Boot Starter简介"></a>Spring Boot Starter简介</h1><p>标签： #Share</p><p>Starter是Spring Boot中的一个非常重要的概念，Starter相当于模块，它能将模块所需的依赖整合起来并对模块内的Bean根据环境（ 条件）进行自动配置。使用者只需要依赖相应功能的Starter，无需做过多的配置和依赖，Spring Boot就能自动扫描并加载相应的模块。</p><p>例如在Maven的依赖中加入spring-boot-starter-web就能使项目支持Spring MVC，并且Spring Boot还为我们做了很多默认配置，无需再依赖spring-web、spring-webmvc等相关包及做相关配置就能够立即使用起来。</p><h2 id="Starter的开发步骤"><a href="#Starter的开发步骤" class="headerlink" title="Starter的开发步骤"></a>Starter的开发步骤</h2><p>编写Starter非常简单，与编写一个普通的Spring Boot应用没有太大区别，总结如下：</p><pre><code>1.新建Maven项目，在项目的POM文件中定义使用的依赖；2.新建配置类，写好配置项和默认的配置值，指明配置项前缀；3.新建自动装配类，使用@Configuration和@Bean来进行自动装配；4.新建spring.factories文件，指定Starter的自动装配类；</code></pre><h2 id="Starter的开发示例"><a href="#Starter的开发示例" class="headerlink" title="Starter的开发示例"></a>Starter的开发示例</h2><p>下面，我就以创建一个自动配置来讲一下各个步骤及细节。<br>1.新建Maven项目，在项目的POM文件中定义使用的依赖。</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre><p>2.新建配置类，写好配置项和默认的配置值，指明配置项前缀。</p><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(&quot;example.service&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StarterServiceProperties</span> &#123;    <span class="hljs-keyword">private</span> String config;    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> enabled;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setConfig</span><span class="hljs-params">(String config)</span> &#123;        <span class="hljs-built_in">this</span>.config = config;    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getConfig</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> config;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEnabled</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> enabled;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setEnabled</span><span class="hljs-params">(<span class="hljs-type">boolean</span> enabled)</span> &#123;        <span class="hljs-built_in">this</span>.enabled = enabled;    &#125;&#125;</code></pre><blockquote><p>指定配置项前缀为<code>example.service</code>，各配置项均有默认值，默认值可以通过模块使用者的配置文件进行覆盖。</p></blockquote><p>3.新建自动装配类，使用<code>@Configuration</code>和<code>@Bean</code>来进行自动装配。</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableConfigurationProperties(StarterServiceProperties.class)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StarterAutoConfigure</span> &#123;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 注意：构建SpringBoot项目时候会自动增加plugin 工具，starter 不需要boot启动类</span><span class="hljs-comment">     * 如果install 时报错和工具相关，需要删除plugin相关配置</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> StarterServiceProperties properties;    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@ConditionalOnMissingBean(StarterService.class)</span>    <span class="hljs-meta">@ConditionalOnProperty(prefix = &quot;example.service&quot;, value = &quot;enabled&quot;, havingValue = &quot;true&quot;)</span>    StarterService <span class="hljs-title function_">starterService</span> <span class="hljs-params">()</span>&#123;        <span class="hljs-type">StarterService</span> <span class="hljs-variable">starterService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StarterService</span>();        starterService.setConfig(properties.getConfig());        <span class="hljs-keyword">return</span> starterService;    &#125;&#125;</code></pre><p>4.新建spring.factories文件，指定Starter的自动装配类。</p><pre><code class="hljs ini"><span class="hljs-comment"># 配置自动注入的类</span><span class="hljs-attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=com.bootstarter.StarterAutoConfigure</code></pre><blockquote><p>spring.factories文件位于resources&#x2F;META-INF目录下，需要手动创建;<br><code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code>后面的类名说明了自动装配类，如果有多个 ，则用逗号分开;<br>使用者应用（SpringBoot）在启动的时候，会通过<code>org.springframework.core.io.support.SpringFactoriesLoader</code>读取classpath下每个Starter的spring.factories文件，加载自动装配类进行Bean的自动装配；</p></blockquote><p>至此，整个Starter开发完毕，Deploy到中央仓库或Install到本地仓库后即可使用</p><h2 id="Starter的使用"><a href="#Starter的使用" class="headerlink" title="Starter的使用"></a>Starter的使用</h2><p>1.创建Maven项目，依赖刚才发布的es-starter包。</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 依赖自定义starter --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre><blockquote><p>只需依赖刚才开发的es-starter即可</p></blockquote><p>2.根据要求进行配置</p><pre><code class="hljs ini"><span class="hljs-comment"># starter 配置文件</span><span class="hljs-attr">example.service.config</span>  = abc-des-dde,SSS-DRS-RE,SDR-SDFR-XXX<span class="hljs-attr">example.service.enabled</span> = <span class="hljs-literal">false</span></code></pre><p>3.编写应用程序启动类。</p><pre><code class="hljs java"><span class="hljs-comment">// 根据example.service.enabled 参数配置是否进行自动装配</span><span class="hljs-meta">@Component</span><span class="hljs-meta">@ConditionalOnExpression(&quot;$&#123;example.service.enabled:true&#125;&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationRunner</span> &#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> StarterService starterService;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(ApplicationArguments args)</span> <span class="hljs-keyword">throws</span> Exception &#123;        System.out.println(Arrays.toString(starterService.split(<span class="hljs-string">&quot;,&quot;</span>)));    &#125;&#125;</code></pre><p>5.运行程序测试</p><pre><code class="hljs gherkin">  .   ____          _            __ _ _ /\\ / ___&#x27;_ __ _ _(_)_ __  __ _ \ \ \ \( ( )\___ |<span class="hljs-string"> &#x27;_ </span>|<span class="hljs-string"> &#x27;_</span>|<span class="hljs-string"> </span>|<span class="hljs-string"> &#x27;_ \/ _` </span>|<span class="hljs-string"> \ \ \ \</span><span class="hljs-string"> \\/  ___)</span>|<span class="hljs-string"> </span>|<span class="hljs-string">_)</span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>||<span class="hljs-string"> (_</span>|<span class="hljs-string"> </span>|<span class="hljs-string">  ) ) ) )</span><span class="hljs-string">  &#x27;  </span>|<span class="hljs-string">____</span>|<span class="hljs-string"> .__</span>|<span class="hljs-string">_</span>|<span class="hljs-string"> </span>|<span class="hljs-string">_</span>|<span class="hljs-string">_</span>|<span class="hljs-string"> </span>|<span class="hljs-string">_\__, </span>|<span class="hljs-string"> / / / /</span><span class="hljs-string"> =========</span>|<span class="hljs-string">_</span>|<span class="hljs-string">==============</span>|<span class="hljs-string">___/=/_/_/_/</span><span class="hljs-string"> :: Spring Boot ::        (v2.1.7.RELEASE)</span><span class="hljs-string"></span><span class="hljs-string">2019-08-29 14:28:27.061  INFO 9844 --- [           main] com.demo.BootDemoApplication             : Starting BootDemoApplication on Kerwin with PID 9844 (C:\Users\Administrator\Desktop\Codes\KerwinBoots\boot-demo\target\classes started by Administrator in C:\Users\Administrator\Desktop\Codes\KerwinBoots)</span><span class="hljs-string">2019-08-29 14:28:27.064  INFO 9844 --- [           main] com.demo.BootDemoApplication             : No active profile set, falling back to default profiles: default</span><span class="hljs-string">2019-08-29 14:28:28.317  INFO 9844 --- [           main] com.demo.BootDemoApplication             : Started BootDemoApplication in 1.733 seconds (JVM running for 2.975)</span><span class="hljs-string">[abc-des-dde, SSS-DRS-RE,SDR-SDFR-XXX]</span></code></pre><blockquote><p>运行程序，观察控制台输出: 源码可见: <a href="https://github.com/kkzhilu/KerwinBoots">https://github.com/kkzhilu/KerwinBoots</a> | boot_starter 分支</p></blockquote><h2 id="注解说明"><a href="#注解说明" class="headerlink" title="注解说明"></a>注解说明</h2><p>| 注解                              | 说明                                                         |<br>| — |  |<br>| <code>@ConditionalOnSingleCandidate</code>   | 当给定类型的bean存在并且指定为Primary的给定类型存在时,返回true |<br>| <code>@ConditionalOnMissingBean</code>       | 当给定的类型、类名、注解、昵称在beanFactory中不存在时返回true.各类型间是or的关系 |<br>| <code>@ConditionalOnBean</code>              | 与上面相反，要求bean存在                                     |<br>| <code>@ConditionalOnMissingClass</code>      | 当给定的类名在类路径上不存在时返回true,各类型间是and的关系   |<br>| <code>@ConditionalOnClass</code>             | 与上面相反，要求类存在                                       |<br>| <code>@ConditionalOnCloudPlatform</code>     | 当所配置的CloudPlatform为激活时返回true                      |<br>| <code>@ConditionalOnExpression</code>        | spel表达式执行为true                                         |<br>| <code>@ConditionalOnJava</code>              | 运行时的java版本号是否包含给定的版本号.如果包含,返回匹配,否则,返回不匹配 |<br>| <code>@ConditionalOnProperty</code>          | 要求配置属性匹配条件                                         |<br>| <code>@ConditionalOnJndi</code>              | 给定的jndi的Location 必须存在一个.否则,返回不匹配            |<br>| <code>@ConditionalOnNotWebApplication</code> | web环境不存在时                                              |<br>| <code>@ConditionalOnWebApplication</code>    | web环境存在时                                                |<br>| <code>@ConditionalOnResource</code>          | 要求制定的资源存在                                           |</p>]]></content>
    
    
    <categories>
      
      <category>框架篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot-自定义starter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot代码生成器</title>
    <link href="/2023/02/06/SpringBoot%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <url>/2023/02/06/SpringBoot%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Code-Generate-代码生成器"><a href="#Code-Generate-代码生成器" class="headerlink" title="Code-Generate 代码生成器"></a><a href="https://github.com/kkzhilu/Code-Generate">Code-Generate</a> 代码生成器</h1><p>标签： #Share</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p> 🚀  Code-Generate是一个基于原生Mysql &amp; SpringBoot &amp; Mybatis 的代码生成器，建表之后即可完全解放双手，1秒钟构建CRUD接口以及漂亮的LayUi前端界面，同时支持<code>在不改动任何老代码的情况下拓展新的模板</code>，适合：</p><ul><li>规律性定制化开发</li><li>解放劳动力，一键完成固有代码</li><li>原生mybatis.xml以及SpringBoot，简单Demo的学习利器</li><li>允许开发者继承接口实现自定义文件内容，阅读简单开源项目的首选</li><li>测试同学的测试Demo案例，1秒钟造一个，就说快不快</li><li>学生党快速交作业（咳咳咳，如果你是该类，一定要关注加点赞啊！）</li></ul><h2 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a>效果演示</h2><p><img src="/2023/02/06/SpringBoot%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/code-generate.gif"></p><p>步骤说明：</p><ol><li>自行建立数据库及需要映射的数据表</li><li>打开Code-Generate，进行基础的配置，如项目名，作者名，输出地址，应用哪些模板等等</li><li>运行App.java核心类，即得到了最终的项目</li><li>运行生成的项目即可</li></ol><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><p>该项目为普通Java项目，依赖的环境有：</p><ul><li>JDK</li><li>MySQL</li><li>Maven</li><li>Lombok插件</li></ul><table><thead><tr><th align="center">可配置项</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">ip</td><td align="center">IP地址</td></tr><tr><td align="center">port</td><td align="center">端口号</td></tr><tr><td align="center">driver</td><td align="center">驱动</td></tr><tr><td align="center">dataBase</td><td align="center">数据库</td></tr><tr><td align="center">encoding</td><td align="center">编码</td></tr><tr><td align="center">loginName</td><td align="center">数据库用户名</td></tr><tr><td align="center">passWord</td><td align="center">数据库密码</td></tr><tr><td align="center">include</td><td align="center">包括哪些表，默认*; 全部</td></tr><tr><td align="center">projectName</td><td align="center">项目名称</td></tr><tr><td align="center">packageName</td><td align="center">自定义包名</td></tr><tr><td align="center">authorName</td><td align="center">作者名称（用作注释）</td></tr><tr><td align="center">rootPath</td><td align="center">输出路径</td></tr><tr><td align="center">customHandleInclude</td><td align="center">自定义模板，默认*;全部</td></tr></tbody></table><p><code>Main方法 @see App.java</code></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 执行 - 构建项目</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;        <span class="hljs-type">AbstractEngine</span> <span class="hljs-variable">engine</span> <span class="hljs-operator">=</span> AbstractEngine.init();        engine.execute();    &#125;&#125;</code></pre><blockquote><p>生成的结果是一个Maven项目，直接用IDE打开即可</p></blockquote><h2 id="现有模块"><a href="#现有模块" class="headerlink" title="现有模块"></a>现有模块</h2><ul><li>基础的接口访问</li><li>基于MD的数据库字段文档</li><li>基于LayUi的前端展示模块</li></ul><p>如下图所示：</p><p><strong>接口访问</strong></p><p><img src="/2023/02/06/SpringBoot%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/image-20200505000913778.png" alt="image-20200505000913778"></p><p><strong>MD的数据库字段文档</strong></p><p><img src="/2023/02/06/SpringBoot%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/image-20200505001007953.png" alt="image-20200505001007953"></p><p><strong>LayUi的前端展示模块</strong></p><p><img src="/2023/02/06/SpringBoot%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/image-20200505001023936.png" alt="image-20200505001023936"></p><h2 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h2><p><code>本项目主要的核心即两个通过mysql内置的表字段查询配合FreeMaker模板，构建具有一定规律性，通用的代码内容</code></p><ul><li>FreeMaker  DefaultEngine.java process方法</li><li>mybatis 原生XML，包含增，批量增，删，批量删，多条件分页查询，列表查询，单一查询，单一数据修改等</li><li>logback日志</li><li>SpringBoot</li><li>拔插式拦截器（基于org.reflections实现），支持扫描指定接口</li></ul><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><h3 id="GNU-General-Public-License-v3-0"><a href="#GNU-General-Public-License-v3-0" class="headerlink" title="GNU General Public License v3.0"></a>GNU General Public License v3.0</h3><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>该项目是从无到有一点点构建出来的，适合初学者和刚入门的人进行学习，更加适合大佬们直接快速构建简单Demo，把时间花在更有价值的事情上，欢迎各位Star &amp; Fork.</p><p>点我：<a href="https://github.com/kkzhilu/Code-Generate/tree/master">GitHub地址</a></p><p><img src="/2023/02/06/SpringBoot%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/%E5%BE%AE%E4%BF%A1%E4%BA%8C%E7%BB%B4%E7%A0%81.png" alt="微信二维码"></p>]]></content>
    
    
    <categories>
      
      <category>开源篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot代码生成器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot配置多数据源</title>
    <link href="/2023/02/06/SpringBoot%E9%85%8D%E7%BD%AE%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90/"/>
    <url>/2023/02/06/SpringBoot%E9%85%8D%E7%BD%AE%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot配置多数据源"><a href="#SpringBoot配置多数据源" class="headerlink" title="SpringBoot配置多数据源"></a>SpringBoot配置多数据源</h1><p>标签： #Share</p><h2 id="核心技术点"><a href="#核心技术点" class="headerlink" title="核心技术点"></a>核心技术点</h2><p>​        在Spring 2.x 中引入了AbstractRoutingDataSource, 该类充当了<strong>DataSource的路由中介</strong>, 能有在<strong>运行时</strong>, 根据某种key值来<strong>动态切换</strong>到真正的DataSource上。</p><p>​        Spring动态配置多数据源，即在大型应用中对数据进行切分，并且采用多个数据库实例进行管理，这样可以有效提高系统的水平伸缩性。而这样的方案就会不同于常见的单一数据实例的方案，这就要程序在运行时根据当时的请求及系统状态来动态的决定将数据存储在哪个数据库实例中，以及从哪个数据库提取数据。</p><p>​        Spring2.x的版本中采用Proxy模式，就是我们在方案中实现一个虚拟的数据源，并且用它来<strong>封装数据源选择逻辑</strong>，这样就可以有效地将数据源选择逻辑从Client中分离出来。Client<strong>提供选择所需的上下文</strong>（因为这是Client所知道的），由虚拟的DataSource根据Client提供的上下文来实现数据源的选择。 </p><p><code>具体的实现如下</code></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicRoutingDataSource</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractRoutingDataSource</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">determineCurrentLookupKey</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">// TODO</span>        <span class="hljs-comment">// 重写 determineCurrentLookupKey 方法</span>    &#125;&#125;</code></pre><p>原理:</p><pre><code class="hljs java"><span class="hljs-comment">// AbstractRoutingDataSource 类</span><span class="hljs-keyword">protected</span> DataSource <span class="hljs-title function_">determineTargetDataSource</span><span class="hljs-params">()</span> &#123;Assert.notNull(<span class="hljs-built_in">this</span>.resolvedDataSources, <span class="hljs-string">&quot;DataSource router not initialized&quot;</span>);<span class="hljs-type">Object</span> <span class="hljs-variable">lookupKey</span> <span class="hljs-operator">=</span> determineCurrentLookupKey();<span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.resolvedDataSources.get(lookupKey);<span class="hljs-keyword">if</span> (dataSource == <span class="hljs-literal">null</span> &amp;&amp; (<span class="hljs-built_in">this</span>.lenientFallback || lookupKey == <span class="hljs-literal">null</span>)) &#123;dataSource = <span class="hljs-built_in">this</span>.resolvedDefaultDataSource;&#125;<span class="hljs-keyword">if</span> (dataSource == <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Cannot determine target DataSource for lookup key [&quot;</span> + lookupKey + <span class="hljs-string">&quot;]&quot;</span>);&#125;<span class="hljs-keyword">return</span> dataSource;&#125;</code></pre><p>因此分析到，如果lookupKey 为null则会走默认配置，如果没有所谓的默认配置则会报错，如果指定了数据源，则会加载指定的配置数据源</p><h2 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h2><h3 id="去除默认数据源"><a href="#去除默认数据源" class="headerlink" title="去除默认数据源"></a>去除默认数据源</h3><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 1.配置数据库事务</span><span class="hljs-comment"> * 2.去除JDBC 自动配置数据源</span><span class="hljs-comment"> */</span><span class="hljs-meta">@EnableTransactionManagement</span><span class="hljs-meta">@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KerwinBootsApplication</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        SpringApplication.run(KerwinBootsApplication.class, args);    &#125;&#125;</code></pre><h3 id="多数据源配置"><a href="#多数据源配置" class="headerlink" title="多数据源配置"></a>多数据源配置</h3><pre><code class="hljs java"><span class="hljs-comment">// 多数据源配置</span># select 库spring.datasource.select.jdbc-url=jdbc:mysql:<span class="hljs-comment">//127.0.0.1:3306/test1</span>spring.datasource.select.driverClassName=com.mysql.jdbc.Driverspring.datasource.select.username=rootspring.datasource.select.password=# update 库spring.datasource.update.jdbc-url=jdbc:mysql:<span class="hljs-comment">//127.0.0.1:3306/test2</span>spring.datasource.update.driverClassName=com.mysql.jdbc.Driverspring.datasource.update.username=rootspring.datasource.update.password=</code></pre><h3 id="配置数据源Bean"><a href="#配置数据源Bean" class="headerlink" title="配置数据源Bean"></a>配置数据源Bean</h3><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataSourceConfig</span> &#123;    <span class="hljs-comment">// application.properteis中对应属性的前缀</span>    <span class="hljs-meta">@Bean(name = &quot;selectDataSource&quot;)</span>    <span class="hljs-meta">@ConfigurationProperties(prefix = &quot;spring.datasource.select&quot;)</span>    <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">selectDataSource</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> DataSourceBuilder.create().build();    &#125;    <span class="hljs-meta">@Bean(name = &quot;updateDataSource&quot;)</span>    <span class="hljs-meta">@ConfigurationProperties(prefix = &quot;spring.datasource.update&quot;)</span>    <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">updateDataSource</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> DataSourceBuilder.create().build();    &#125;&#125;</code></pre><h3 id="构造线程数据源持有者"><a href="#构造线程数据源持有者" class="headerlink" title="构造线程数据源持有者"></a>构造线程数据源持有者</h3><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataSourceContextHolder</span> &#123;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * ThreadLocal提供了线程内存储变量的能力，这些变量不同之处在于每一个线程读取的变量是对应的互相独立的</span><span class="hljs-comment">     * 通过get和set方法就可以得到当前线程对应的值</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;String&gt; CONTEXT_HOLDER = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDbType</span><span class="hljs-params">(String dbType)</span> &#123;        CONTEXT_HOLDER.set(dbType);    &#125;    <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getDbType</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> CONTEXT_HOLDER.get();    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123; CONTEXT_HOLDER.remove();&#125;&#125;</code></pre><h3 id="复写路由方法"><a href="#复写路由方法" class="headerlink" title="复写路由方法"></a>复写路由方法</h3><pre><code class="hljs java"><span class="hljs-comment">// 名字(dataSource)  Primary  Priority</span><span class="hljs-meta">@Component</span><span class="hljs-meta">@Primary</span> <span class="hljs-comment">// 多个DataSource Bean 因此@Primary 将作为首选者</span>         <span class="hljs-comment">// @Priority 优先级</span>         <span class="hljs-comment">// 多个按类型的dataSource 为了让它找到bean可以给当前bean修改 名称 -&gt; @Component(value = &quot;dataSource&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicRoutingDataSource</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractRoutingDataSource</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(DynamicRoutingDataSource.class);    <span class="hljs-meta">@Autowired</span>    <span class="hljs-meta">@Qualifier(&quot;selectDataSource&quot;)</span>    <span class="hljs-keyword">private</span> DataSource selectDataSource;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-meta">@Qualifier(&quot;updateDataSource&quot;)</span>    <span class="hljs-keyword">private</span> DataSource updateDataSource;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">determineCurrentLookupKey</span><span class="hljs-params">()</span> &#123;        logger.info(<span class="hljs-string">&quot;切换数据源: &quot;</span> + DataSourceContextHolder.getDbType());        <span class="hljs-keyword">return</span> DataSourceContextHolder.getDbType();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 重写after配置方法, 配置默认数据源</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> &#123;        Map&lt;Object,Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();        map.put(<span class="hljs-string">&quot;selectDataSource&quot;</span>, selectDataSource);        map.put(<span class="hljs-string">&quot;updateDataSource&quot;</span>, updateDataSource);        setTargetDataSources(map);        setDefaultTargetDataSource(updateDataSource);        <span class="hljs-built_in">super</span>.afterPropertiesSet();    &#125;&#125;</code></pre><h3 id="考虑自动切换数据源方案-AOP-（注解或依据方法名）"><a href="#考虑自动切换数据源方案-AOP-（注解或依据方法名）" class="headerlink" title="考虑自动切换数据源方案 - AOP （注解或依据方法名）"></a>考虑自动切换数据源方案 - AOP （注解或依据方法名）</h3><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><span class="hljs-meta">@Component</span><span class="hljs-meta">@Order(0)</span> <span class="hljs-comment">// Order设定AOP执行顺序 使之在数据库事务上先执行</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicDataSourceAspect</span> &#123;    <span class="hljs-meta">@Before(&quot;execution(* com.boot.service.*.*(..))&quot;)</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processMethodName</span> <span class="hljs-params">(JoinPoint joinPoint)</span> &#123;        String methodName=joinPoint.getSignature().getName();        <span class="hljs-keyword">if</span> (methodName.startsWith(<span class="hljs-string">&quot;get&quot;</span>)                ||methodName.startsWith(<span class="hljs-string">&quot;count&quot;</span>)                ||methodName.startsWith(<span class="hljs-string">&quot;find&quot;</span>)                ||methodName.startsWith(<span class="hljs-string">&quot;list&quot;</span>)                ||methodName.startsWith(<span class="hljs-string">&quot;select&quot;</span>)                ||methodName.startsWith(<span class="hljs-string">&quot;check&quot;</span>))&#123;            DataSourceContextHolder.setDbType(<span class="hljs-string">&quot;selectDataSource&quot;</span>);        &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//切换dataSource</span>            DataSourceContextHolder.setDbType(<span class="hljs-string">&quot;updateDataSource&quot;</span>);        &#125;    &#125;<span class="hljs-comment">//    @Before(&quot;execution(* com.boot.service.*.*(..))&quot;)</span><span class="hljs-comment">//    public void process(JoinPoint point) &#123;</span><span class="hljs-comment">//</span><span class="hljs-comment">//        //获得当前访问的class</span><span class="hljs-comment">//        Class&lt;?&gt; className = point.getTarget().getClass();</span><span class="hljs-comment">//</span><span class="hljs-comment">//        //获得访问的方法名</span><span class="hljs-comment">//        String methodName = point.getSignature().getName();</span><span class="hljs-comment">//</span><span class="hljs-comment">//        //得到方法的参数的类型</span><span class="hljs-comment">//        Class[] argClass = ((MethodSignature)point.getSignature()).getParameterTypes();</span><span class="hljs-comment">//</span><span class="hljs-comment">//        try &#123;</span><span class="hljs-comment">//            // 得到访问的方法对象</span><span class="hljs-comment">//            Method method = className.getMethod(methodName, argClass);</span><span class="hljs-comment">//</span><span class="hljs-comment">//            // 判断是否存在@DS注解</span><span class="hljs-comment">//            if (method.isAnnotationPresent(DS.class)) &#123;</span><span class="hljs-comment">//                DS annotation = method.getAnnotation(DS.class);</span><span class="hljs-comment">//</span><span class="hljs-comment">//                // 取出注解中的数据源名</span><span class="hljs-comment">//                String dataSource = annotation.value();</span><span class="hljs-comment">//</span><span class="hljs-comment">//                // 切换数据源</span><span class="hljs-comment">//                DataSourceContextHolder.setDbType(dataSource);</span><span class="hljs-comment">//            &#125;</span><span class="hljs-comment">//        &#125; catch (Exception e) &#123;</span><span class="hljs-comment">//            e.printStackTrace();</span><span class="hljs-comment">//            System.out.println(&quot;error.&quot;);</span><span class="hljs-comment">//        &#125;</span><span class="hljs-comment">//    &#125;</span>    <span class="hljs-meta">@After(&quot;execution(* com.boot.service.*.*(..))&quot;)</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterswitchDs</span> <span class="hljs-params">(JoinPoint point)</span>&#123;        DataSourceContextHolder.clear();    &#125;&#125;</code></pre><h2 id="遗留技术点"><a href="#遗留技术点" class="headerlink" title="遗留技术点"></a>遗留技术点</h2><h3 id="ThreadLocal-的作用，DataSourceContextHolder类的意义何在"><a href="#ThreadLocal-的作用，DataSourceContextHolder类的意义何在" class="headerlink" title="ThreadLocal 的作用，DataSourceContextHolder类的意义何在"></a>ThreadLocal 的作用，DataSourceContextHolder类的意义何在</h3><p>作用：建立一个获得和设置上下文环境的类，主要负责改变上下文数据源的名称</p><p>原因：ThreadLocal 与 Synchronized 作用不同 -》</p><p>Synchronized  -&gt; 保证多线程情况下变量一致性（数据共享）</p><p>ThreadLocal    -&gt; 保证多线程情况下变量私有性（数据隔离）</p><p>即每个线程的变量只对自己本线程负责 （不会存在A线程改了影响B的情况，要的就是数据隔离）</p><p>官方解释:</p><pre><code class="hljs oxygene">This <span class="hljs-keyword">class</span> provides thread-local variables. These variables differ <span class="hljs-keyword">from</span> their normal counterparts <span class="hljs-keyword">in</span> that <span class="hljs-keyword">each</span> thread that accesses one (via its <span class="hljs-comment">&#123;@code get&#125;</span> <span class="hljs-keyword">or</span> <span class="hljs-comment">&#123;@code set&#125;</span> <span class="hljs-keyword">method</span>) <span class="hljs-title function_">has</span> <span class="hljs-title function_">its</span> <span class="hljs-title function_">own</span>, <span class="hljs-title function_">independently</span> <span class="hljs-title function_">initialized</span> <span class="hljs-title function_">copy</span> <span class="hljs-title function_">of</span> <span class="hljs-title function_">the</span> <span class="hljs-title function_">variable</span>. <span class="hljs-comment">&#123;@code ThreadLocal&#125;</span> <span class="hljs-title function_">instances</span> <span class="hljs-title function_">are</span> <span class="hljs-title function_">typically</span> <span class="hljs-title function_">private</span> <span class="hljs-title function_">static</span> <span class="hljs-title function_">fields</span> <span class="hljs-title function_">in</span> <span class="hljs-title function_">classes</span> <span class="hljs-title function_">that</span> <span class="hljs-title function_">wish</span> <span class="hljs-title function_">to</span> <span class="hljs-title function_">associate</span> <span class="hljs-title function_">state</span> <span class="hljs-title function_">with</span> <span class="hljs-title function_">a</span> <span class="hljs-title function_">thread</span> <span class="hljs-params">(e.g., a user ID <span class="hljs-keyword">or</span> Transaction ID)</span>.</code></pre><p>总结:</p><blockquote><p>总结一下重点：</p><ul><li>ThreadLocal 提供了一种访问某个变量的特殊方式：访问到的变量属于当前线程，即保证每个线程的变量不一样，而同一个线程在任何地方拿到的变量都是当前这个线程私有的，这就是所谓的线程隔离。</li><li>如果要使用 ThreadLocal，通常定义为 private static 类型，最好是定义为 private static final 类型。</li></ul></blockquote><h3 id="2-为什么重写了-determineCurrentLookupKey-方法，SpringBoot真正在执行的时候就会调用我们重写的类呢？"><a href="#2-为什么重写了-determineCurrentLookupKey-方法，SpringBoot真正在执行的时候就会调用我们重写的类呢？" class="headerlink" title="2.为什么重写了 determineCurrentLookupKey 方法，SpringBoot真正在执行的时候就会调用我们重写的类呢？"></a>2.为什么重写了 determineCurrentLookupKey 方法，SpringBoot真正在执行的时候就会调用我们重写的类呢？</h3><pre><code class="hljs java"><span class="hljs-comment">// 多数据源方案二代码...核心如下： 此种方案有显示的放入事务数据源中</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * 配置<span class="hljs-doctag">@Transactional</span>注解</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Bean</span><span class="hljs-keyword">public</span> PlatformTransactionManager <span class="hljs-title function_">transactionManager</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataSourceTransactionManager</span>(dynamicDataSource());&#125;</code></pre><p>回顾方案一，跟踪断点发现如下代码:</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ConditionalOnClass(&#123; DataSource.class, JdbcTemplate.class &#125;)</span><span class="hljs-meta">@ConditionalOnSingleCandidate(DataSource.class)</span><span class="hljs-meta">@AutoConfigureAfter(DataSourceAutoConfiguration.class)</span><span class="hljs-meta">@EnableConfigurationProperties(JdbcProperties.class)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdbcTemplateAutoConfiguration</span> &#123;<span class="hljs-meta">@Configuration</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdbcTemplateConfiguration</span> &#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DataSource dataSource;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> JdbcProperties properties;JdbcTemplateConfiguration(DataSource dataSource, JdbcProperties properties) &#123;<span class="hljs-built_in">this</span>.dataSource = dataSource;<span class="hljs-built_in">this</span>.properties = properties;&#125;<span class="hljs-meta">@Bean</span><span class="hljs-meta">@Primary</span><span class="hljs-meta">@ConditionalOnMissingBean(JdbcOperations.class)</span><span class="hljs-keyword">public</span> JdbcTemplate <span class="hljs-title function_">jdbcTemplate</span><span class="hljs-params">()</span> &#123;<span class="hljs-type">JdbcTemplate</span> <span class="hljs-variable">jdbcTemplate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdbcTemplate</span>(<span class="hljs-built_in">this</span>.dataSource);JdbcProperties.<span class="hljs-type">Template</span> <span class="hljs-variable">template</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.properties.getTemplate();jdbcTemplate.setFetchSize(template.getFetchSize());jdbcTemplate.setMaxRows(template.getMaxRows());<span class="hljs-keyword">if</span> (template.getQueryTimeout() != <span class="hljs-literal">null</span>) &#123;jdbcTemplate.setQueryTimeout((<span class="hljs-type">int</span>) template.getQueryTimeout().getSeconds());&#125;<span class="hljs-keyword">return</span> jdbcTemplate;&#125;&#125;<span class="hljs-meta">@Configuration</span><span class="hljs-meta">@Import(JdbcTemplateConfiguration.class)</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NamedParameterJdbcTemplateConfiguration</span> &#123;<span class="hljs-meta">@Bean</span><span class="hljs-meta">@Primary</span><span class="hljs-meta">@ConditionalOnSingleCandidate(JdbcTemplate.class)</span><span class="hljs-meta">@ConditionalOnMissingBean(NamedParameterJdbcOperations.class)</span><span class="hljs-keyword">public</span> NamedParameterJdbcTemplate <span class="hljs-title function_">namedParameterJdbcTemplate</span><span class="hljs-params">(JdbcTemplate jdbcTemplate)</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NamedParameterJdbcTemplate</span>(jdbcTemplate);&#125;&#125;&#125;<span class="hljs-comment">//*********************************************</span><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ConditionalOnClass(&#123; JdbcTemplate.class, PlatformTransactionManager.class &#125;)</span><span class="hljs-meta">@AutoConfigureOrder(Ordered.LOWEST_PRECEDENCE)</span><span class="hljs-meta">@EnableConfigurationProperties(DataSourceProperties.class)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataSourceTransactionManagerAutoConfiguration</span> &#123;<span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ConditionalOnSingleCandidate(DataSource.class)</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataSourceTransactionManagerConfiguration</span> &#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DataSource dataSource;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TransactionManagerCustomizers transactionManagerCustomizers;DataSourceTransactionManagerConfiguration(DataSource dataSource,ObjectProvider&lt;TransactionManagerCustomizers&gt; transactionManagerCustomizers) &#123;<span class="hljs-built_in">this</span>.dataSource = dataSource;<span class="hljs-built_in">this</span>.transactionManagerCustomizers = transactionManagerCustomizers.getIfAvailable();&#125;<span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean(PlatformTransactionManager.class)</span><span class="hljs-keyword">public</span> DataSourceTransactionManager <span class="hljs-title function_">transactionManager</span><span class="hljs-params">(DataSourceProperties properties)</span> &#123;<span class="hljs-type">DataSourceTransactionManager</span> <span class="hljs-variable">transactionManager</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataSourceTransactionManager</span>(<span class="hljs-built_in">this</span>.dataSource);<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.transactionManagerCustomizers != <span class="hljs-literal">null</span>) &#123;<span class="hljs-built_in">this</span>.transactionManagerCustomizers.customize(transactionManager);&#125;<span class="hljs-keyword">return</span> transactionManager;&#125;&#125;&#125;</code></pre><p>我们发现SpringBoot，当注入了唯一DataSource Bean之后，会调用我们创建的指定数据源，将其放入boot核心代码中，之后事务数据源，JDBC数据源都会引用我们注入的Bean，因此我们重写之后，注入完成，SpringBoot真正在执行的时候就会调用我们重写的类</p><h3 id="3-为什么要使用-Primary-注解，有没有其他的方案"><a href="#3-为什么要使用-Primary-注解，有没有其他的方案" class="headerlink" title="3.为什么要使用@Primary 注解，有没有其他的方案"></a>3.为什么要使用@Primary 注解，有没有其他的方案</h3><p>DataSource Bean 需要被初始化，作为数据库连接所使用，但是在类 DataSourceConfig 中，有两个bean都是DataSource，且 DynamicRoutingDataSource的本质也是一个 DataSource</p><p>因此 Spring容器在真正调用DataSource时，会通过类型找到此Bean，但是由于有三个同类型的Bean，因此无法确定，所以又会按名称查找，但是还是找不到，所以如果无法确定到底哪个Bean 被用作数据源连接，则会抛出异常</p><p>解决方案有三种</p><pre><code class="hljs java"><span class="hljs-comment">// 多个DataSource Bean 因此@Primary 将作为首选者</span><span class="hljs-comment">// @Priority 优先级</span><span class="hljs-comment">// 多个按类型的dataSource 为了让它找到bean可以给当前bean修改 名称 -&gt; @Component(value = &quot;dataSource&quot;)</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>框架篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot配置多数据源</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Testin - JSP项目有感</title>
    <link href="/2023/02/06/Testin%20-%20JSP%E9%A1%B9%E7%9B%AE%E6%9C%89%E6%84%9F/"/>
    <url>/2023/02/06/Testin%20-%20JSP%E9%A1%B9%E7%9B%AE%E6%9C%89%E6%84%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="Testin-JSP项目有感"><a href="#Testin-JSP项目有感" class="headerlink" title="Testin - JSP项目有感"></a>Testin - JSP项目有感</h1><p>标签： #Share</p><p>最近被分配到Web自动化测试的项目开发任务，由于时间紧张，因此为求迅速，节约前端成本，把部分的前端开发任务挪给后端，通过JSP这种老掉牙的技术去做，但是在真正的制作当中，有很多以往没有想到，或者没有规范话的好经验值得我去深思和回顾，大致内容如下：</p><h2 id="公共分页展示JS"><a href="#公共分页展示JS" class="headerlink" title="公共分页展示JS"></a>公共分页展示JS</h2><p>真正的官网或者Web项目中，分页随处可见，且复杂的工程分页要求也比较麻烦，比如默认如何显示，比如还需要显示条数，查询窗口等等，代码非常复杂，但这往往具有通用性，回想实习时候，第一次真正做企业级开发，什么东西都自己写，根本没有意识到，这种代码是完全可以重用的，现在想来懊悔不已，给个例子如下：</p><pre><code class="hljs java"><span class="hljs-comment">// 全文请见: Testin-JSP项目有感</span>&lt;c:<span class="hljs-keyword">if</span> test=<span class="hljs-string">&quot;$&#123;pager.totalCount gt 0&#125;&quot;</span>&gt;    &lt;div class=<span class="hljs-string">&quot;pagination-panel&quot;</span>&gt;        &lt;c:choose&gt;            &lt;c:when test=<span class="hljs-string">&quot;$&#123;pager.startPageNo == 1&#125;&quot;</span>&gt;                &lt;c:<span class="hljs-keyword">if</span> test=<span class="hljs-string">&quot;$&#123;pager.totalCount &lt;= pager.pageSize&#125;&quot;</span>&gt;                    &lt;span&gt;&lt;fmt:message key=<span class="hljs-string">&#x27;common.page_txt1&#x27;</span>/&gt;<span class="hljs-number">1</span>-$&#123;pager.totalCount&#125;&lt;fmt:message key=<span class="hljs-string">&#x27;common.page_txt2&#x27;</span>/&gt;&lt;fmt:message key=<span class="hljs-string">&#x27;common.page_txt3&#x27;</span>/&gt;$&#123;pager.totalCount&#125;&lt;fmt:message key=<span class="hljs-string">&#x27;common.page_txt4&#x27;</span>/&gt;&lt;/span&gt;                &lt;/c:<span class="hljs-keyword">if</span>&gt;                &lt;c:<span class="hljs-keyword">if</span> test=<span class="hljs-string">&quot;$&#123;pager.totalCount &gt; pager.pageSize&#125;&quot;</span>&gt;                    &lt;span&gt;&lt;fmt:message key=<span class="hljs-string">&#x27;common.page_txt1&#x27;</span>/&gt;<span class="hljs-number">1</span>-$&#123;pager.pageSize&#125;&lt;fmt:message key=<span class="hljs-string">&#x27;common.page_txt2&#x27;</span>/&gt;&lt;fmt:message key=<span class="hljs-string">&#x27;common.page_txt3&#x27;</span>/&gt;$&#123;pager.totalCount&#125;&lt;fmt:message key=<span class="hljs-string">&#x27;common.page_txt4&#x27;</span>/&gt;&lt;/span&gt;                &lt;/c:<span class="hljs-keyword">if</span>&gt;            &lt;/c:when&gt;            &lt;c:when test=<span class="hljs-string">&quot;$&#123;pager.startPageNo == pager.totalPageCount&#125;&quot;</span>&gt;                &lt;span&gt;&lt;fmt:message key=<span class="hljs-string">&#x27;common.page_txt1&#x27;</span>/&gt;$&#123;(pager.startPageNo-<span class="hljs-number">1</span>)*pager.pageSize + <span class="hljs-number">1</span>&#125;-$&#123;pager.totalCount&#125;&lt;fmt:message key=<span class="hljs-string">&#x27;common.page_txt2&#x27;</span>/&gt;&lt;fmt:message key=<span class="hljs-string">&#x27;common.page_txt3&#x27;</span>/&gt;$&#123;pager.totalCount&#125;&lt;fmt:message key=<span class="hljs-string">&#x27;common.page_txt4&#x27;</span>/&gt;&lt;/span&gt;            &lt;/c:when&gt;            &lt;c:otherwise&gt;                &lt;span&gt;&lt;fmt:message key=<span class="hljs-string">&#x27;common.page_txt1&#x27;</span>/&gt;$&#123;(pager.startPageNo-<span class="hljs-number">1</span>)*pager.pageSize + <span class="hljs-number">1</span>&#125;-$&#123;pager.startPageNo*pager.pageSize&#125;&lt;fmt:message key=<span class="hljs-string">&#x27;common.page_txt2&#x27;</span>/&gt;&lt;fmt:message key=<span class="hljs-string">&#x27;common.page_txt3&#x27;</span>/&gt;$&#123;pager.totalCount&#125;&lt;fmt:message key=<span class="hljs-string">&#x27;common.page_txt4&#x27;</span>/&gt;&lt;/span&gt;            &lt;/c:otherwise&gt;        &lt;/c:choose&gt;        &lt;c:<span class="hljs-keyword">if</span> test=<span class="hljs-string">&quot;$&#123;sessionScope.deploy_target eq &#x27;PRIVATE CLOUDS&#x27; and isScriptSelectPage eq 1&#125;&quot;</span>&gt;&lt;span style=<span class="hljs-string">&quot;margin-left: 5px;&quot;</span>&gt;&lt;fmt:message key=<span class="hljs-string">&#x27;common.page_txt5&#x27;</span>/&gt;</code></pre><p>我们做过MVC开发的都知道可以给model增加属性，因此，重要属性名称一致，参数名保证一致，即可完全做到高效的重用，做后端开发的伙伴都知道工具类的重要性，但是经常会忽略，其实前端也有工具类的说法，至少我在学习期间几乎没有意识到这种问题，因为毕竟前端的需求针对性较强一些，也不复杂，但真正的面向对象的思考，是一个开发者应该一直坚持的事情。</p><h2 id="装饰模式-核心界面为其装饰头，尾，菜单的效果"><a href="#装饰模式-核心界面为其装饰头，尾，菜单的效果" class="headerlink" title="装饰模式 - 核心界面为其装饰头，尾，菜单的效果"></a>装饰模式 - 核心界面为其装饰头，尾，菜单的效果</h2><p>我们去看阿里云或者其他实用型官网项目，如果有复杂的头，尾，左侧导航等界面，难道我们都得在界面中去实现吗？在学习jsp的时候，有import这个说法，可以把界面引入到本界面来，实现上述的效果，但是总觉得每次写一堆代码怪怪的，而且头部，尾部，菜单还得分开引用，比较麻烦。那么可以考虑配置装饰的方式，通过配置给界面主动添加如头部，尾部，菜单的界面</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sitemesh</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 指明满足“/json/”的页面，将被排除，不被装饰 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/json/*&quot;</span> <span class="hljs-attr">exclue</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/ajax/*&quot;</span> <span class="hljs-attr">exclue</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/login*&quot;</span> <span class="hljs-attr">exclue</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/*/ajax/*&quot;</span> <span class="hljs-attr">exclue</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/*/*/ajax/*&quot;</span> <span class="hljs-attr">exclue</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span>    ....................................<span class="hljs-tag">&lt;/<span class="hljs-name">sitemesh</span>&gt;</span></code></pre><h2 id="合理的界面分层"><a href="#合理的界面分层" class="headerlink" title="合理的界面分层"></a>合理的界面分层</h2><p>刚开始做开发，没人教，或者有人教的时候，总是喜欢这么做，把所有东西堆到一个界面里去，然后传递参数到后端，后端把数据获取到，添加到model里，再展示到前端，顺便通过jquery把请求的界面节点的数据部分拿出来，再替换当前界面里的内容，以此完成一个完美的 “Ajax界面刷新的效果”，但是这么做有不好的地方</p><ol><li>想要这么做，在ajax请求时必须对返回的界面转化为jquery对象，然后通过find或者其他方法把数据节点位置找到再替换当前的内容，这里存在两个问题，一个是低版本的jq转换H5界面时候一直报错（换成高版本就OK）另外数据节点的寻找需要进行DOM的解析，会耗时</li><li>把参数什么的刷到后台，然后又从后台转到前台来，有点多此一举</li></ol><p>如果这么做呢？<br>查询条件界面 （留一个数据Div填充）- 数据界面（直接被Div包含，去掉多余的样式，body，html等无用的东西）</p><p>然后通过默认函数加载数据，通过分页跳转界面再加载数据等等…  完美解决了上面的需求，同时有以下的好处：</p><ul><li>界面分开后，代码会更加清晰。哪个部分干什么事一目了然</li><li>参数只用往后传，不用再往前传，完全解决了各种莫名其妙的回显问题</li><li>效率更高（由于不用再解析返回的界面了，直接通过jquery append到指定节点位置即可）</li></ul><h2 id="MVC-mapping-占位符的妙用"><a href="#MVC-mapping-占位符的妙用" class="headerlink" title="MVC mapping * 占位符的妙用"></a>MVC mapping * 占位符的妙用</h2><p>在MVC开发中，总有这样的需求前端三个界面不同，但是功能类似，此时映射三个mapping，到底写三个还是写一个然后把想法抽取？当然不可能写三个，但是写一个想法抽取的话，在语义上不明确，而且增加了额外的方法，让类变得更加复杂了，比较麻烦，那为何不利用 <code>*</code>去站位匹配呢？</p><pre><code class="hljs java"><span class="hljs-comment">// 此时匹配 list-任意内容 -&gt; 如 list-ajax  list-jsp等等</span><span class="hljs-meta">@RequestMapping(&quot;/list-*&quot;)</span></code></pre><p>这样做的好处，可以把代码减少的最少，同时语义稍微明确一点，再来看一个更加方便的用处把</p><p>在初期学习界面，写的界面比较简单，总会用到各种各样的不包含太多逻辑的index界面，或者包含非常简单的基本数据而已，但是利用MVC设计的话，需要映射mapping，怎么做可以让代码更加简洁而且通用呢？</p><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseController</span> &#123;    <span class="hljs-meta">@RequestMapping(&quot;/path/*&quot;)</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">jumpPath</span> <span class="hljs-params">(HttpServletRequest request)</span> &#123;        <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> request.getServletPath();        <span class="hljs-comment">// 截取path/ 之后的具体路径  如 finalPath</span>        <span class="hljs-type">String</span> <span class="hljs-variable">finalPath</span> <span class="hljs-operator">=</span> path.sub........        <span class="hljs-keyword">return</span> finalPath;    &#125;&#125;<span class="hljs-comment">// 前端页面</span>href = <span class="hljs-string">&quot;/path/task-list&quot;</span>href = <span class="hljs-string">&quot;/path/monkey-list&quot;</span>href = <span class="hljs-string">&quot;/path/money-list&quot;</span>此时不再需要给每一个不需要什么逻辑的界面单独写一个controller去映射界面，是不是方便了很多？</code></pre><h2 id="一行代码，10个BUG"><a href="#一行代码，10个BUG" class="headerlink" title="一行代码，10个BUG"></a>一行代码，10个BUG</h2><p>真正开始工作之后才知道，什么jsp。ssm都是老掉牙的东西，整个编程的风气如今都是高并发，高可用诸如此类的，但是有天看到一句笑话，一位程序员说，<em><strong>天天尼玛高并发，高可用，一行代码，10个BUG，玩NM的高并发</strong></em>，如此粗俗的话一下子击中了我，后来我渐渐发现，原来我也是整天想着高并发高可用，完全没有意识到真正基础的重要性，最近做一个大批量文件导入的模块，涉及文件上传，用户操作配置，文件解析，文件导入等几个步骤，刷刷刷，代码写完，自测没毛病，交给测试了，后来一堆隐患问题就来了，直接掠过过程说问题：</p><ol><li>耗时操作的部分按钮没有加上限制，即点击后仍然处于可操作状态 -&gt; 非常致命</li><li>代码设计上，想到哪里写到哪里，功能最后都实现了，但是总的来说不完美，虽然不擅长JS。但这也不应该是借口，比如弹窗，按钮等等的重置效果，成功或者失败的响应效果，就应该封装好，统一调用等等</li></ol><p>总结：做一个事情不难，想真正做好一件事情，难</p><blockquote><p>一切都是有可能的，甚至那些不可能的也是.</p></blockquote><p>实习加工作10个月了，突然回顾之前的知识，觉得太浅显，但是仍然从如此浅显的内容中提炼出了以前并没有意识到的技巧或者更好的设计方式等等，因此记录了此篇感触，用以醒悟自身，不要自傲。</p><p>​                                                                                                                                                                                             2019年 8月26日 Kerwin</p>]]></content>
    
    
    <categories>
      
      <category>程序人生篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Testin - JSP项目有感</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue初识</title>
    <link href="/2023/02/06/Vue%E5%88%9D%E8%AF%86/"/>
    <url>/2023/02/06/Vue%E5%88%9D%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue初始"><a href="#Vue初始" class="headerlink" title="Vue初始"></a>Vue初始</h1><p>标签： #Share</p><h2 id="本地构建Vue环境"><a href="#本地构建Vue环境" class="headerlink" title="本地构建Vue环境"></a>本地构建Vue环境</h2><ul><li>安装Node.js 并配置完成</li></ul><blockquote><p>配置方式：<a href="https://blog.csdn.net/tjj3027/article/details/84751321">https://blog.csdn.net/tjj3027/article/details/84751321</a> </p><p>​                     <a href="https://www.cnblogs.com/fighxp/p/7411608.html">https://www.cnblogs.com/fighxp/p/7411608.html</a> </p><p>卸载，安装，设置数据源，配置环境变量，配置全局存储目录（node.js，F:\Node.js\node_global）</p></blockquote><ul><li>修改Node.js 文件源（npm config set registry <a href="https://registry.npm.taobao.org)/">https://registry.npm.taobao.org）</a></li><li>Vue 相关配置</li></ul><blockquote><p>Vue 3.0： <a href="https://segmentfault.com/a/1190000017020755">https://segmentfault.com/a/1190000017020755</a> </p></blockquote><h2 id="Vue项目构建"><a href="#Vue项目构建" class="headerlink" title="Vue项目构建"></a>Vue项目构建</h2><blockquote><p>Vue 3.0： <a href="https://segmentfault.com/a/1190000017020755">https://segmentfault.com/a/1190000017020755</a> </p></blockquote><h2 id="Vue-3-0-项目结构"><a href="#Vue-3-0-项目结构" class="headerlink" title="Vue 3.0 项目结构"></a>Vue 3.0 项目结构</h2><p><img src="/2023/02/06/Vue%E5%88%9D%E8%AF%86/image-20200121165935771.png" alt="image-20200121165935771"></p><h2 id="Vue-集成ElementUI"><a href="#Vue-集成ElementUI" class="headerlink" title="Vue 集成ElementUI"></a>Vue 集成ElementUI</h2><pre><code class="hljs shell">npm i element-ui -S</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">/* main.js */</span><span class="hljs-comment">/* import  */</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><span class="hljs-comment">// 引入ElementUI</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">ElementUI</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">ElementUI</span>);<span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span>;<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;  <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>),&#125;).$mount(<span class="hljs-string">&#x27;#app&#x27;</span>);</code></pre><h2 id="Vue-集成axios"><a href="#Vue-集成axios" class="headerlink" title="Vue 集成axios"></a>Vue 集成axios</h2><pre><code class="hljs shell">npm install axios</code></pre><blockquote><p>在项目根目录创建文件 vue.config.js —&gt; 此举一来可以解决跨域问题，二来可以统一请求的域名统一性</p><pre><code class="hljs javascript"><span class="hljs-comment">// vue.config.js 基于服务端代理解决跨域问题</span><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123; <span class="hljs-attr">devServer</span>: &#123;     <span class="hljs-attr">proxy</span>: &#123;         <span class="hljs-comment">// /api前缀</span>         <span class="hljs-string">&quot;/api&quot;</span>: &#123;             <span class="hljs-comment">// 目标地址</span>             <span class="hljs-attr">target</span>: <span class="hljs-string">&quot;https://news-at.zhihu.com/api&quot;</span>,             <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,             <span class="hljs-attr">ws</span>: <span class="hljs-literal">true</span>,             <span class="hljs-attr">pathRewrite</span>: &#123;                 <span class="hljs-string">&quot;^/api&quot;</span>: <span class="hljs-string">&quot;&quot;</span>             &#125;         &#125;     &#125; &#125;&#125;</code></pre><p><code>main.js 同步修改</code></p><pre><code class="hljs javascript"><span class="hljs-comment">/* import */</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><span class="hljs-comment">// 引入axios</span><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">VueAxios</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-axios&#x27;</span><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">VueAxios</span>, axios);<span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span>;<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;  <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>),&#125;).$mount(<span class="hljs-string">&#x27;#app&#x27;</span>);</code></pre></blockquote><h2 id="Vue-集成Router"><a href="#Vue-集成Router" class="headerlink" title="Vue 集成Router"></a>Vue 集成Router</h2><pre><code class="hljs shell">npm i vue-router -S</code></pre><blockquote><p>建一个与main.js同级的 router.js文件，引入Router，配置各界面的路由</p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">Router</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><span class="hljs-comment">// 组件模块</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">News</span>          <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/News.vue&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">NewsContent</span>   <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/NewsContent.vue&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">Movies</span>        <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/Movies.vue&#x27;</span><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Router</span>)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>(&#123; <span class="hljs-attr">routes</span>: [     &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>             , <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;news&#x27;</span>           , <span class="hljs-attr">component</span>: <span class="hljs-title class_">News</span> &#125;,     &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/newsContent&#x27;</span>  , <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;newsContent&#x27;</span>    , <span class="hljs-attr">component</span>: <span class="hljs-title class_">NewsContent</span>&#125;,     &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/movies&#x27;</span>       , <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;movies&#x27;</span>         , <span class="hljs-attr">component</span>: <span class="hljs-title class_">Movies</span>&#125;, ]&#125;)</code></pre><p><code>main.js 同步修改</code></p><pre><code class="hljs javascript"><span class="hljs-comment">/* import */</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><span class="hljs-comment">// 引入router</span><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./router.js&quot;</span>;<span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span>;<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;  <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>),  <span class="hljs-comment">// 注册路由</span>  router,&#125;).$mount(<span class="hljs-string">&#x27;#app&#x27;</span>);</code></pre><p><code>界面中使用方式</code></p><pre><code class="hljs javascript">&lt;router-link to=<span class="hljs-string">&#x27;/home&#x27;</span>&gt;首页&lt;/router-link&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&#x27;/foods&#x27;</span>&gt;</span>美食<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span></span>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span></span><span class="hljs-comment">// JS 主动跳转</span><span class="hljs-comment">// GET方式</span><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(&#123;<span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/newsContent&#x27;</span>, <span class="hljs-attr">query</span>:&#123;<span class="hljs-attr">id</span>: id&#125;&#125;);<span class="hljs-comment">// POST方式</span><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;/newsContent&#x27;</span>, <span class="hljs-attr">params</span>:&#123;<span class="hljs-attr">id</span>: id&#125;&#125;);</code></pre></blockquote><p><code>简单项目DEMO：</code></p><p>GitHub：<a href="https://github.com/kkzhilu/Kerwin-Vue">https://github.com/kkzhilu/Kerwin-Vue</a> </p><p>分支   ： master</p><p>界面效果：</p><p><img src="/2023/02/06/Vue%E5%88%9D%E8%AF%86/image-20200121171607036.png" alt="image-20200121171607036"></p>]]></content>
    
    
    <categories>
      
      <category>前端篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue初识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「奇淫技巧」如何写最少的代码</title>
    <link href="/2023/02/06/%E3%80%8C%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7%E3%80%8D%E5%A6%82%E4%BD%95%E5%86%99%E6%9C%80%E5%B0%91%E7%9A%84%E4%BB%A3%E7%A0%81/"/>
    <url>/2023/02/06/%E3%80%8C%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7%E3%80%8D%E5%A6%82%E4%BD%95%E5%86%99%E6%9C%80%E5%B0%91%E7%9A%84%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p>标签： #Share</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于性格原因，笔者很难沉下心来进行严肃的系统学习，总是喜欢折腾一些奇淫技巧，非常喜欢代码设计，扣代码的细节，所以本次分享一下我所知道的<code>如何写最少的代码</code>的小技巧，如果你有更好的方案，欢迎在评论区留言，<code>方案很棒的话，加我微信，为你送上冬天的一杯奶茶~</code></p><h2 id="Java：我想返回多个返回值"><a href="#Java：我想返回多个返回值" class="headerlink" title="Java：我想返回多个返回值"></a>Java：我想返回多个返回值</h2><p>秀一下<code>Go</code>的多返回值：</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-comment">// 返回 X + Y 和 X * Y</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Computer</span><span class="hljs-params">(X, Y <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) &#123;    <span class="hljs-keyword">return</span> X + Y, X * Y&#125;</code></pre><p>众所周知，Java仅支持单一返回值，一般情况下如果需要返回多个对象，我们会根据代码语义选择容器或者新建一个新的类，把我们需要的数据包起来。</p><p><code>这样做有没有问题？</code>当然没有问题，但是瑕疵就在于：可能会产生没啥语义但又不得不存在的<code>中间类</code>，我个人非常讨论该类代码，那么该如何解决这种问题呢？</p><p>首先需要认识到，解决方案必须满足几个要求：</p><ul><li>代码可复用</li><li>语义要清晰</li><li>安全</li></ul><p>既然如此，我们可以采用<code>泛型</code>来满足复用、语义清晰的要求，用<code>中间类</code>来满足代码安全性的要求，代码如下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MultipleTwoReturn</span>&lt;A, B&gt; &#123;    <span class="hljs-comment">/** 第一个返回值 **/</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> A first;    <span class="hljs-comment">/** 第二个返回值 **/</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> B second;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MultipleTwoReturn</span><span class="hljs-params">(A first, B second)</span> &#123;        <span class="hljs-built_in">this</span>.first = first;        <span class="hljs-built_in">this</span>.second = second;    &#125;    <span class="hljs-comment">// 省略Get方法</span>&#125;</code></pre><p>同时，我们可以依赖于<code>继承</code>，让该工具类拓展更多的参数：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MultipleThreeReturn</span>&lt;A, B, C&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MultipleTwoReturn</span>&lt;A, B&gt; &#123;    <span class="hljs-comment">/** 第三个返回值 **/</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> C third;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MultipleThreeReturn</span><span class="hljs-params">(A first, B second, C third)</span> &#123;        <span class="hljs-built_in">super</span>(first, second);        <span class="hljs-built_in">this</span>.third = third;    &#125;&#125;</code></pre><p>测试类：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MultipleApp</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        MultipleTwoReturn&lt;Integer, String&gt; returnTest = MultipleApp.getReturnTest();        System.out.println(returnTest.getFirst());        System.out.println(returnTest.getSecond());    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> MultipleTwoReturn&lt;Integer, String&gt; <span class="hljs-title function_">getReturnTest</span><span class="hljs-params">()</span> &#123;        MultipleTwoReturn&lt;Integer, String&gt; demo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MultipleTwoReturn</span>&lt;&gt;(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;Kerwin Demo.&quot;</span>);        <span class="hljs-keyword">return</span> demo;    &#125;&#125;</code></pre><p>本质还是<code>普通对象</code>，但是加上<code>泛型</code>后威力剧增！由于在方法定义时就强制了<code>泛型约束</code>，语义非常清晰，同时可以完全杜绝上述的无语义中间类，当然一些必要的，有业务含义的组装类，不建议使用这种方式。</p><h2 id="泛型：我想new一个对象"><a href="#泛型：我想new一个对象" class="headerlink" title="泛型：我想new一个对象"></a>泛型：我想new一个对象</h2><p>大家在学Java泛型之初有没有这种想法？我想利用<T>作为泛型约束，却需要<code>new</code>一个<code>T</code>，但是Java它<code>new</code>不出来啊 😂</T></p><p>很久之前我在写一个通用的<code>Java爬虫接口</code>，里面有一个功能就是<code>传入目标网页的即可获取到针对不同网页设计的Bean</code>，大概如下所示：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SpiderBeansHandle</span>&lt;T&gt; &#123;    <span class="hljs-comment">/** 获取Url **/</span>    String <span class="hljs-title function_">getUrl</span><span class="hljs-params">()</span>;    <span class="hljs-comment">/** 获取Cookie **/</span>    String <span class="hljs-title function_">getCookie</span><span class="hljs-params">()</span>;    <span class="hljs-comment">/** 获取CSS selector **/</span>    String <span class="hljs-title function_">getSelector</span><span class="hljs-params">()</span>;        <span class="hljs-comment">// ....</span> &#125;</code></pre><p>中间关键的一点即如何获取到这个Bean，那个时候我只有一个想法：<code>new 一个 T</code></p><p>事实证明，我过于天真了 🙄</p><p>但是换种思路，既然<code>new</code>不出来，那我就返回一下吧，于是代码出炉了~</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SpiderBeansHandle</span>&lt;T&gt; &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取Url</span><span class="hljs-comment">     */</span>    String <span class="hljs-title function_">getUrl</span><span class="hljs-params">()</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取Cookie</span><span class="hljs-comment">     */</span>    String <span class="hljs-title function_">getCookie</span><span class="hljs-params">()</span>;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 获取CSS selector</span><span class="hljs-comment">     */</span>    String <span class="hljs-title function_">getSelector</span><span class="hljs-params">()</span>;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 解析Element</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> element  element</span><span class="hljs-comment">     */</span>    T <span class="hljs-title function_">parseElement</span><span class="hljs-params">(Element element)</span>;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * Get Beans</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> handle  Bean对象 | handle对象</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt;     Bean类型</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>        List&lt;Beans&gt;</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="hljs-title function_">getBeans</span><span class="hljs-params">(SpiderBeansHandle&lt;T&gt; handle)</span> &#123;        List&lt;T&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();        List&lt;Element&gt; elements = SpiderUtils.getElementWithCookie(handle.getUrl(), handle.getSelector(), handle.getCookie());        <span class="hljs-keyword">for</span> (Element element : elements) &#123;            <span class="hljs-type">T</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> handle.parseElement(element);            <span class="hljs-keyword">if</span> (bean != <span class="hljs-literal">null</span>) &#123;                list.add(bean);            &#125;        &#125;        <span class="hljs-keyword">return</span> list;    &#125;&#125;</code></pre><p>关键一步就在于：</p><pre><code class="hljs java"><span class="hljs-comment">/***</span><span class="hljs-comment"> * 解析Element</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> element  element</span><span class="hljs-comment"> */</span>T <span class="hljs-title function_">parseElement</span><span class="hljs-params">(Element element)</span>;</code></pre><p>那么这个小技巧有什么用呢？仔细看会不会觉得它像一种设计模式的变形体？没错！真相只有一个：<code>模板方法模式</code></p><p>我刚提到了我需要一个<code>处理爬虫的通用接口</code>，因为简单爬虫无非就是拿到url然后请求，解析细节封装到自身的Bean里，然后获取一个列表，那么在开发业务代码的时候类似，肯定有某些场景和需求具有高度的一致性，那么使用这种设计方案即可大大的减少重复代码~</p><h2 id="方法：你到底想干嘛？"><a href="#方法：你到底想干嘛？" class="headerlink" title="方法：你到底想干嘛？"></a>方法：你到底想干嘛？</h2><p>咱们在写代码的时候有没有遇到过这种问题？写了一个工具类方法，但是功能又过于单一，虽说单一原则好吧，但是一个小逻辑写一堆方法，总感觉不得劲，如何解决咧？</p><p>Java8提供的函数式编程即可帮我们一定程度上解决这种问题，如：</p><pre><code class="hljs java"><span class="hljs-comment">// 写一个获取文件列表，且判断是否为txt结尾的工具类方法，新手会这么写</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> File <span class="hljs-title function_">getFileWithTxt</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> IOException &#123;    <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path);    <span class="hljs-keyword">if</span> (!file.exists()) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;File is not exist.&quot;</span>);    &#125;    <span class="hljs-keyword">if</span> (file.getName().endsWith(<span class="hljs-string">&quot;.txt&quot;</span>)) &#123;        <span class="hljs-keyword">return</span> file;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;&#125;</code></pre><p>老手一般会把 <code>.txt</code> 作为参数传入，<code>但是某一天我需要判断文件大小，文件长度，甚至是文件内容的时候，我该咋办？再写N个？</code></p><p>最好的方案即传入 <code>Predicate</code> 谓词，让调用者<code>自定义处理逻辑</code>，然后再把最常用的逻辑基于该方法复写一下，拓展性Max！代码如下：</p><pre><code class="hljs java"><span class="hljs-comment">/***</span><span class="hljs-comment"> * 文件夹谓词匹配</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> file          文件</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> predicate     谓词匹配</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span>              List&lt;File&gt;</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IOException  IOException</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;File&gt; <span class="hljs-title function_">listFilesInDirWithFilter</span><span class="hljs-params">(File file, Predicate&lt;String&gt; predicate)</span> <span class="hljs-keyword">throws</span> IOException &#123;<span class="hljs-keyword">if</span> (!file.exists()) &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;File is not exist.&quot;</span>);     &#125;List&lt;File&gt; fileList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<span class="hljs-keyword">if</span> (file.isDirectory()) &#123;File[] files = file.listFiles();<span class="hljs-keyword">for</span> (File f : Objects.requireNonNull(files)) &#123;fileList.addAll(listFilesInDirWithFilter(f, predicate));         &#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> (predicate.test(file.getName())) &#123;fileList.add(file);&#125;&#125;<span class="hljs-keyword">return</span> fileList;&#125;</code></pre><p>类似的还比如说处理 <code>IO</code>，直接上代码：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readLine</span><span class="hljs-params">(BufferedReader br, Consumer&lt;String&gt; handle, <span class="hljs-type">boolean</span> close)</span> &#123;    String s;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">while</span> (((s = br.readLine()) != <span class="hljs-literal">null</span>)) &#123;            handle.accept(s);        &#125;    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;        e.printStackTrace();    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-keyword">if</span> (close &amp;&amp; br != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">try</span> &#123;                br.close();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre><p><code>方法</code>说你到底想干嘛？！算了，你想干嘛就干嘛吧，请随意😎~ </p><h2 id="重载：写的更多也是为了写的更少"><a href="#重载：写的更多也是为了写的更少" class="headerlink" title="重载：写的更多也是为了写的更少"></a>重载：写的更多也是为了写的更少</h2><p><code>写的更多也是为了写的更少</code>，这句话乍一听感觉非常矛盾，但是编程经验比较丰富的小伙伴应该能体会到<code>方法重载</code>的威力，尤其是在写工具类或者底层接口的时候，建议大家先写一个大而全的<code>内部方法</code>，然后一点点去根据需要重载它，会有意想不到的好处。</p><p>最简单的例子，如下：</p><pre><code class="hljs java"><span class="hljs-comment">// Root 方法</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readLine</span><span class="hljs-params">(BufferedReader br, Consumer&lt;String&gt; handle, <span class="hljs-type">boolean</span> close)</span> &#123;    String s;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">while</span> (((s = br.readLine()) != <span class="hljs-literal">null</span>)) &#123;            handle.accept(s);        &#125;    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;        e.printStackTrace();    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-keyword">if</span> (close &amp;&amp; br != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">try</span> &#123;                br.close();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;<span class="hljs-comment">// 重载方法一</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readLine</span><span class="hljs-params">(String path, Consumer&lt;String&gt; handle, <span class="hljs-type">boolean</span> close)</span> &#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(path));        readLine(br, handle, close);    &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;        e.printStackTrace();    &#125;&#125;<span class="hljs-comment">// 重载方法二</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readLine</span><span class="hljs-params">(String path, Consumer&lt;String&gt; handle)</span> &#123;readLine(path, handle, <span class="hljs-literal">true</span>);&#125;</code></pre><p><code>重载</code>可以让我们的方法调用方式变得丰富多彩，在语义明确的情况下，写代码有如神助，配合函数式编程，可以让工具类或者底层接口的能力大大增强。</p><p>同时，当我们需要调整某一个方法逻辑时，也可以使用<code>继续重载</code>的方式，将影响面降到最小，尽量不动其他模块的代码。</p><h2 id="终极：从设计模式到抽象"><a href="#终极：从设计模式到抽象" class="headerlink" title="终极：从设计模式到抽象"></a>终极：从设计模式到抽象</h2><p>与其说是<code>如何写最少的代码</code>，不如说是：<code>如何只写真正有价值的代码</code>。</p><p>面对这种问题的时候，我们第一反应肯定就是设计模式了，例如上文的泛型章节提到的<code>模板方法模式</code>，小小的推荐一下我之前的文章：</p><ul><li><a href="https://juejin.cn/post/6844904176653172749">【一起学系列】之模板方法：写SSO我只要5分钟</a></li><li><a href="https://juejin.cn/post/6846687591425638413">设计模式总篇：从为什么需要原则到实际落地</a></li></ul><p>通过良好的设计模式或者其变形体，我们可以得到高内聚低耦合的代码，这是一个非常好的思路。</p><p>另一个思路，所有人都认同一点：<code>程序 = 算法 + 数据结构</code>，选择好正确的数据结构可以事倍功半，比如说我们做<code>类似文件夹需求</code>的时候，会想到使用<code>链表</code>或者<code>树</code>结构，在做如：<code>如何高效的给用户发送生日短信</code>时会想到用<code>堆</code>结构（用当前时间对比堆中的最大值，满足则继续迭代，减少遍历）等等。</p><p>这其实都是抽象，或深或浅而已，我最开始学习Java的时候，老师会说一句话：万物皆为对象，我们来看看上面的技巧各自对应着什么？</p><ul><li>多返回值：封装对象 + 泛型约束</li><li>泛型：封装对象的公共接口，高度抽象</li><li>函数式方法：把方法当作一个对象</li><li>重载：对象方法（行为）的不断演化</li></ul><p>所以如何只写真正有价值的代码？官方一点的话就是：<code>把变化的抽象出来</code>，那么到底该怎么抽？</p><p>这就需要我们一点点的去探索了，毕竟<code>奇淫技巧</code>只是小道尔，不过我会一直探索下去。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>如果你觉得这篇内容对你有帮助的话：</p><ol><li>当然要点赞支持一下啦~</li><li>另外，搜索并关注公众号「<strong>是Kerwin啊</strong>」，一起在技术的路上走下去吧~ 😋</li></ol>]]></content>
    
    
    <categories>
      
      <category>编码及设计模式篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>「奇淫技巧」如何写最少的代码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>volatile和synchronized</title>
    <link href="/2023/02/06/volatile%E5%92%8Csynchronized/"/>
    <url>/2023/02/06/volatile%E5%92%8Csynchronized/</url>
    
    <content type="html"><![CDATA[<p>标签： #Share</p><h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>volatile关键字是在一般面试中经常问到的一个点，大家对它的回答莫过于两点：</p><ul><li>保证内存可见性</li><li>防止指令重排</li></ul><p>那为了更有底气，那咱们就来深入看看吧</p><h3 id="JMM内存模型"><a href="#JMM内存模型" class="headerlink" title="JMM内存模型"></a>JMM内存模型</h3><p>咱们在聊volatile关键字的时候，首先需要了解JMM内存模型，它本身是一种抽象的概念并不真实存在，草图如下：</p><p><img src="/2023/02/06/volatile%E5%92%8Csynchronized/JMM.png" alt="img"></p><p>JMM内存模型规定了线程的工作机理：<code>即所有的共享变量都存储在主内存，如果线程需要使用，则拿到主内存的副本，然后操作一番，再放到主内存里面去</code></p><p>这个可以引发一个思考，<strong>这是不是就是多线程并发情况下线程不安全的根源？</strong>假如所有线程都操作主内存的数据，是不是就不会有线程不安全的问题，随即引发下面的问题</p><h3 id="为什么需要JMM内存模型"><a href="#为什么需要JMM内存模型" class="headerlink" title="为什么需要JMM内存模型"></a>为什么需要JMM内存模型</h3><p>关于这个问题，我感觉过于硬核，我只能简单的想象<code>假如没有JMM，所有线程可以直接操作主内存的数据会怎么样</code></p><ul><li>上文说过，JMM模型并不是真实存在的，它只是一种规范，这种规范反而可以统一开发者的行为，如果没有规范，可能Java所提倡的一次编译，处处运行就凉凉了</li><li>另外我们都知道CPU 时间片轮转机制（就是在极短的时间切换进程，让用户无感知的享受多个进程运行的效果），线程在执行时候其实也是轮着来，假如A线程正在操作一个金钱数据，操作到一半，轮给B线程了，B线程把金额给改了，A线程最后又以错误的数据去入库等等，那问题不就大了去了？</li></ul><p>所以我想面对这样的场景，前辈们才模仿CPU解决缓存一致性的思路确定了JMM模型（能力不足，纯属猜测）</p><blockquote><p><em>在多处理器系统中，每个处理器都有自己的高速缓存，而他们又共享同一主存</em></p></blockquote><h3 id="volatile如何保证内存可见性"><a href="#volatile如何保证内存可见性" class="headerlink" title="volatile如何保证内存可见性"></a>volatile如何保证内存可见性</h3><p>我们来看一段代码：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileTest</span> &#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> String key;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;        key = <span class="hljs-string">&quot;Happy Birthday To Me!&quot;</span>;    &#125;&#125;</code></pre><p>通过对代码进行javap命令，获取其字节码，内容如下（可以忽略啦）：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">com</span>.mine.juc.lock.VolatileTest  minor version: <span class="hljs-number">0</span>  major version: <span class="hljs-number">52</span>  flags: ACC_PUBLIC, ACC_SUPERConstant pool:   #<span class="hljs-number">1</span> = Methodref          #<span class="hljs-number">5.</span>#<span class="hljs-number">21</span>         <span class="hljs-comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span>   #<span class="hljs-number">2</span> = String             #<span class="hljs-number">22</span>            <span class="hljs-comment">// Happy Birthday To Me!</span>   #<span class="hljs-number">3</span> = Fieldref           #<span class="hljs-number">4.</span>#<span class="hljs-number">23</span>         <span class="hljs-comment">// com/mine/juc/lock/VolatileTest.key:Ljava/lang/String;</span>   #<span class="hljs-number">4</span> = Class              #<span class="hljs-number">24</span>            <span class="hljs-comment">// com/mine/juc/lock/VolatileTest</span>   #<span class="hljs-number">5</span> = Class              #<span class="hljs-number">25</span>            <span class="hljs-comment">// java/lang/Object</span>   #<span class="hljs-number">6</span> = Utf8               key   #<span class="hljs-number">7</span> = Utf8               Ljava/lang/String;   #<span class="hljs-number">8</span> = Utf8               &lt;init&gt;   #<span class="hljs-number">9</span> = Utf8               ()V  #<span class="hljs-number">10</span> = Utf8               Code  #<span class="hljs-number">11</span> = Utf8               LineNumberTable  #<span class="hljs-number">12</span> = Utf8               LocalVariableTable  #<span class="hljs-number">13</span> = Utf8               <span class="hljs-built_in">this</span>  #<span class="hljs-number">14</span> = Utf8               Lcom/mine/juc/lock/VolatileTest;  #<span class="hljs-number">15</span> = Utf8               main  #<span class="hljs-number">16</span> = Utf8               ([Ljava/lang/String;)V  #<span class="hljs-number">17</span> = Utf8               args  #<span class="hljs-number">18</span> = Utf8               [Ljava/lang/String;  #<span class="hljs-number">19</span> = Utf8               SourceFile  #<span class="hljs-number">20</span> = Utf8               VolatileTest.java  #<span class="hljs-number">21</span> = NameAndType        #<span class="hljs-number">8</span>:#<span class="hljs-number">9</span>          <span class="hljs-comment">// &quot;&lt;init&gt;&quot;:()V</span>  #<span class="hljs-number">22</span> = Utf8               Happy Birthday To Me!  #<span class="hljs-number">23</span> = NameAndType        #<span class="hljs-number">6</span>:#<span class="hljs-number">7</span>          <span class="hljs-comment">// key:Ljava/lang/String;</span>  #<span class="hljs-number">24</span> = Utf8               com/mine/juc/lock/VolatileTest  #<span class="hljs-number">25</span> = Utf8               java/lang/Object&#123;  <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> java.lang.String key;    descriptor: Ljava/lang/String;    flags: ACC_STATIC, ACC_VOLATILE  <span class="hljs-keyword">public</span> com.mine.juc.lock.VolatileTest();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span>         <span class="hljs-number">0</span>: aload_0         <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span>                  <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span>         <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span>      LineNumberTable:        line <span class="hljs-number">11</span>: <span class="hljs-number">0</span>      LocalVariableTable:        Start  Length  Slot  Name   Signature            <span class="hljs-number">0</span>       <span class="hljs-number">5</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   Lcom/mine/juc/lock/VolatileTest;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(java.lang.String[])</span>;    descriptor: ([Ljava/lang/String;)V    flags: ACC_PUBLIC, ACC_STATIC    Code:      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span>         <span class="hljs-number">0</span>: ldc           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// String Happy Birthday To Me!</span>         <span class="hljs-number">2</span>: putstatic     #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field key:Ljava/lang/String;</span>         <span class="hljs-number">5</span>: <span class="hljs-keyword">return</span>      LineNumberTable:        line <span class="hljs-number">16</span>: <span class="hljs-number">0</span>        line <span class="hljs-number">17</span>: <span class="hljs-number">5</span>      LocalVariableTable:        Start  Length  Slot  Name   Signature            <span class="hljs-number">0</span>       <span class="hljs-number">6</span>     <span class="hljs-number">0</span>  args   [Ljava/lang/String;&#125;SourceFile: <span class="hljs-string">&quot;VolatileTest.java&quot;</span></code></pre><p>请大家注意这一段代码：</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> java.lang.String key;    descriptor: Ljava/lang/String;    flags: ACC_STATIC, ACC_VOLATILE</code></pre><p>可以看到，volatile关键字在编译的时候会主动为变量增加标识：<code>ACC_VOLATILE</code>，再研究下去就过于硬核了（汇编指令），我可能硬不起来（手动狗头），以后我会再对它进行深入的研究，我们只用了解到，Java关键字volatile，是在编译阶段主动为变量增加了ACC_VOLATILE标识，以此保证了它的<code>内存可见性</code></p><p>即然volatile可以保证内存可见性，那至少有一个场景我们是可以放心使用的，即：<code>一写多读场景</code></p><p>另外，大家在验证volatile内存可见性的时候，不要使用 System.out.println() ，原因如下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">println</span><span class="hljs-params">()</span> &#123;    newLine();&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 是不是赫然看到一个synchronized，具体原因见下文</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">newLine</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;            ensureOpen();            textOut.newLine();            textOut.flushBuffer();            charOut.flushBuffer();            <span class="hljs-keyword">if</span> (autoFlush)                out.flush();        &#125;    &#125;    <span class="hljs-keyword">catch</span> (InterruptedIOException x) &#123;        Thread.currentThread().interrupt();    &#125;    <span class="hljs-keyword">catch</span> (IOException x) &#123;        trouble = <span class="hljs-literal">true</span>;    &#125;&#125;</code></pre><h3 id="为什么会有指令重排"><a href="#为什么会有指令重排" class="headerlink" title="为什么会有指令重排"></a>为什么会有指令重排</h3><p>为了优化程序性能，编译器和处理器会对Java编译后的字节码和机器指令进行重排序，在单线程情况下不会影响结果，然而在多线程情况下，可能会出现莫名其妙的问题，案例见下文</p><h3 id="指令重排例子"><a href="#指令重排例子" class="headerlink" title="指令重排例子"></a>指令重排例子</h3><p><img src="/2023/02/06/volatile%E5%92%8Csynchronized/volatile.png" alt="img"></p><p>运行这段代码我们可能会得到一个匪夷所思的结果:我们获得的单例对象是未初始化的。为什么会出现这种情况？因为<code>指令重排</code></p><p>首先要明确一点，同步代码块中的代码也是能够被指令重排的。然后来看问题的关键</p><pre><code class="hljs java">INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();</code></pre><p>虽然在代码中只有一行,编译出的字节码指令可以用如下三行表示</p><ul><li>1.为对象分配内存空间</li><li>2.初始化对象</li><li>3.将INSTANCE变量指向刚分配的内存地址</li></ul><p>由于步骤2，3交换不会改变单线程环境下的执行结果，故而这种重排序是被允许的。也就是我们在初始化对象之前就把INSTANCE变量指向了该对象。而如果这时另一个线程刚好执行到代码所示的2处</p><pre><code class="hljs java"><span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>)</code></pre><p>那么这时候有意思的事情就发生了:虽然INSTANCE指向了一个未被初始化的对象，但是它确实不为null了，所以这个判断会返回false，之后它将return一个未被初始化的单例对象！</p><p>如下：</p><p><img src="/2023/02/06/volatile%E5%92%8Csynchronized/handle.png" alt="img"></p><p>由于重排序是编译器和CPU自动进行的，如何禁止指令重排？</p><p>INSTANCE变量加个volatile关键字就行，这样编译器就会根据一定的规则禁止对volatile变量的读写操作重排序了。而编译出的字节码，也会在合适的地方插入内存屏障，比如volatile写操作之前和之后会分别插入一个StoreStore屏障和StoreLoad屏障，禁止CPU对指令的重排序越过这些屏障</p><h3 id><a href="#" class="headerlink" title></a></h3><h3 id="即然保证了内存可见，为什么还是线程不安全？"><a href="#即然保证了内存可见，为什么还是线程不安全？" class="headerlink" title="即然保证了内存可见，为什么还是线程不安全？"></a>即然保证了内存可见，为什么还是线程不安全？</h3><p>volatile 关键字虽然保证了内存可见，但是问题来了，见代码：</p><pre><code class="hljs java">index += <span class="hljs-number">1</span>;</code></pre><p>这短短一行代码在字节码级别其实分为了多个步骤进行，如获取变量，赋值，计算等等，如CPU基本执行原理一般，真正执行的是一个个命令，分为很多步骤</p><p>volatile 关键字可以保证的是单个读取操作是具有原子性的（每次读取都是从主内存获取最新的值）</p><p>但是如 index +&#x3D; 1;  实质是三个步骤，三次行为，因此它无法保证整块代码的原子性</p><h2 id="synchronize关键字"><a href="#synchronize关键字" class="headerlink" title="synchronize关键字"></a>synchronize关键字</h2><h3 id="驳斥关于类锁的概念"><a href="#驳斥关于类锁的概念" class="headerlink" title="驳斥关于类锁的概念"></a>驳斥关于类锁的概念</h3><p>首先驳斥一个关于类锁的概念，synchronize就是对象锁，在普通方法，静态方法，同步块时锁的对象分别是：</p><p>|   类型   |                代码示例                 |        锁住的对象        |<br>| :: | :-: | :—-: |<br>| 普通方法 |      synchronized void test() { }       |         当前对象         |<br>| 静态方法 |   synchronized static void test() { }   | 锁的是当前类的Class 对象 |<br>|  同步块  | void fun () {  synchronized (this) {} } |    锁的是（）中的对象    |</p><p>大家都同意在同步代码块中，锁住的是括号里的对象，那么见以下代码：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynDemo</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;                <span class="hljs-keyword">synchronized</span> (SynDemo.class) &#123;                    System.out.println(<span class="hljs-string">&quot;真的有所谓的类锁？&quot;</span>);                    <span class="hljs-keyword">try</span> &#123;                        Thread.sleep(<span class="hljs-number">3000</span>);                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;        &#125;).start();        Thread.sleep(<span class="hljs-number">500</span>);        answer();    &#125;    <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">answer</span> <span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;答案清楚了吗&quot;</span>);    &#125;&#125;<span class="hljs-comment">// 输出结果</span><span class="hljs-comment">// 真的有所谓的类锁？</span><span class="hljs-comment">// 间隔2秒多左右</span><span class="hljs-comment">// 答案清楚了吗</span></code></pre><p>所以实际上所谓的类锁，完全就是当前类的Class对象，所以不要被误导，synchronize就是对象锁</p><h3 id="synchronize实现原理"><a href="#synchronize实现原理" class="headerlink" title="synchronize实现原理"></a>synchronize实现原理</h3><p><code>JVM</code> 是通过进入、退出对象监视器(<code>Monitor</code> 来实现对方法、同步块的同步的</p><p>具体实现是在编译之后在同步方法调用前加入一个 <code>monitor.enter</code> 指令，在退出方法和异常处插入 <code>monitor.exit</code> 的指令。</p><p>其本质就是对一个对象监视器 <code>Monitor</code> 进行获取，而这个获取过程具有排他性从而达到了同一时刻只能一个线程访问的目的</p><p>而对于没有获取到锁的线程将会阻塞到方法入口处，直到获取锁的线程 <code>monitor.exit</code> 之后才能尝试继续获取锁。</p><p>流程图如下：</p><p><img src="/2023/02/06/volatile%E5%92%8Csynchronized/exec.png" alt="1566131929317"></p><p>代码例子：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;    <span class="hljs-keyword">synchronized</span> (Synchronize.class)&#123;        System.out.println(<span class="hljs-string">&quot;Synchronize&quot;</span>);    &#125;&#125;</code></pre><p>字节码：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">com</span>.crossoverjie.synchronize.Synchronize &#123;  <span class="hljs-keyword">public</span> com.crossoverjie.synchronize.Synchronize();    Code:       <span class="hljs-number">0</span>: aload_0       <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span>                  <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span>       <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(java.lang.String[])</span>;    Code:       <span class="hljs-number">0</span>: ldc           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// class com/crossoverjie/synchronize/Synchronize</span>       <span class="hljs-number">2</span>: dup       <span class="hljs-number">3</span>: astore_1       **<span class="hljs-number">4</span>: monitorenter**       <span class="hljs-number">5</span>: getstatic     #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span>       <span class="hljs-number">8</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String Synchronize</span>      <span class="hljs-number">10</span>: invokevirtual #<span class="hljs-number">5</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span>      <span class="hljs-number">13</span>: aload_1      **<span class="hljs-number">14</span>: monitorexit**      <span class="hljs-number">15</span>: goto          <span class="hljs-number">23</span>      <span class="hljs-number">18</span>: astore_2      <span class="hljs-number">19</span>: aload_1      <span class="hljs-number">20</span>: monitorexit      <span class="hljs-number">21</span>: aload_2      <span class="hljs-number">22</span>: athrow      <span class="hljs-number">23</span>: <span class="hljs-keyword">return</span>    Exception table:       from    to  target type           <span class="hljs-number">5</span>    <span class="hljs-number">15</span>    <span class="hljs-number">18</span>   any          <span class="hljs-number">18</span>    <span class="hljs-number">21</span>    <span class="hljs-number">18</span>   any&#125;</code></pre><h3 id="为什么会有两次monitorexit"><a href="#为什么会有两次monitorexit" class="headerlink" title="为什么会有两次monitorexit"></a>为什么会有两次<code>monitorexit</code></h3><p>同步代码块添加了一个隐式的try-finally，在finally中会调用<code>monitorexit</code>命令释放锁，目的是为了避免异常情况就无法释放锁</p><h3 id="synchronized锁的几种形式"><a href="#synchronized锁的几种形式" class="headerlink" title="synchronized锁的几种形式"></a>synchronized锁的几种形式</h3><p>之前大家都说千万不要用synchronized，效率太差啦，但是Hotspot团队对synchronized进行许多优化，提供了三种状态的锁：偏向锁、轻量级锁、重量级锁，这样一来synchronized性能就有了极大的提高</p><p>偏向锁：就是锁偏向某一个线程。主要是为了处理同一个线程多次获取同一个锁的情况，比如锁重入或者一个线程频繁操作同一个线程安全的容器，但是一旦出现线程之间竞争同一个锁，偏向锁就会撤销，升级为轻量级锁</p><p>轻量级锁：是基于CAS操作实现的。线程使用CAS尝试获取锁失败后，进行一段时间的忙等，也就是所谓的自旋操作。尝试一段时间仍无法获取锁才会升级为重量级锁</p><p>重量级锁：是基于底层操作系统实现的，每次获取锁失败都会直接让线程挂起，这会带来<code>用户态</code>和<code>内核态</code>的切换，性能开销比较大</p><p>打一个比方：大家在排队打饭，你有一个专属通道，叫做帅哥美女专属通道，只有你一个人可以自由的同行，这就叫偏向锁</p><p>突然有一天，我来了，我也自诩帅哥，所以我盯上了你的通道，但是你还在打饭，然后我就抢过去和你一起打饭，但是这样效率比较低，所以阿姨没问我的时候，我就玩会手机等你，这就叫轻量级锁</p><p>突然还有一天，我饿到不行，什么帅哥美女统统滚蛋，就我一个人先打饭，所有阿姨为我服务，给我服务完了再轮到你们，这就叫重量级锁</p><h3 id="synchronized除了上锁还有什么作用"><a href="#synchronized除了上锁还有什么作用" class="headerlink" title="synchronized除了上锁还有什么作用"></a>synchronized除了上锁还有什么作用</h3><ul><li>获得同步锁</li><li>清空工作内存</li><li>从主内存中拷贝对象副本到本地内存</li><li>执行代码</li><li>刷新主内存数据</li><li>释放同步锁</li></ul><p>这也就是上文提到的System.out.println()为何会影响内存可见性的原因了</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>字节码获取方法：</p><pre><code class="hljs properties"><span class="hljs-attr">用法</span>: <span class="hljs-string">javap &lt;options&gt; &lt;classes&gt;</span><span class="hljs-attr">其中,</span> <span class="hljs-string">可能的选项包括:</span>  <span class="hljs-attr">-help</span>  <span class="hljs-string">--help  -?        输出此用法消息</span>  <span class="hljs-attr">-version</span>                 <span class="hljs-string">版本信息</span>  <span class="hljs-attr">-v</span>  <span class="hljs-string">-verbose             输出附加信息</span>  <span class="hljs-attr">-l</span>                       <span class="hljs-string">输出行号和本地变量表</span>  <span class="hljs-attr">-public</span>                  <span class="hljs-string">仅显示公共类和成员</span>  <span class="hljs-attr">-protected</span>               <span class="hljs-string">显示受保护的/公共类和成员</span>  <span class="hljs-attr">-package</span>                 <span class="hljs-string">显示程序包/受保护的/公共类</span>                           <span class="hljs-attr">和成员</span> <span class="hljs-string">(默认)</span>  <span class="hljs-attr">-p</span>  <span class="hljs-string">-private             显示所有类和成员</span>  <span class="hljs-attr">-c</span>                       <span class="hljs-string">对代码进行反汇编</span>  <span class="hljs-attr">-s</span>                       <span class="hljs-string">输出内部类型签名</span>  <span class="hljs-attr">-sysinfo</span>                 <span class="hljs-string">显示正在处理的类的</span>                           <span class="hljs-attr">系统信息</span> <span class="hljs-string">(路径, 大小, 日期, MD5 散列)</span>  <span class="hljs-attr">-constants</span>               <span class="hljs-string">显示最终常量</span>  <span class="hljs-attr">-classpath</span> <span class="hljs-string">&lt;path&gt;        指定查找用户类文件的位置</span>  <span class="hljs-attr">-cp</span> <span class="hljs-string">&lt;path&gt;               指定查找用户类文件的位置</span>  <span class="hljs-attr">-bootclasspath</span> <span class="hljs-string">&lt;path&gt;    覆盖引导类文件的位置</span></code></pre><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>感谢以下博文及其作者：</p><p><a href="https://juejin.im/post/5ea913d35188256d4576d199?utm_source=gold_browser_extension#heading-23">面试官没想到一个Volatile，我都能跟他扯半小时</a></p><p><a href="https://www.jianshu.com/p/e2054351bd95">死磕Synchronized底层实现–概论</a></p>]]></content>
    
    
    <categories>
      
      <category>多线程并发篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>volatile和synchronized</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「生产事故」MongoDB复合索引引发的灾难</title>
    <link href="/2023/02/06/%E3%80%8C%E7%94%9F%E4%BA%A7%E4%BA%8B%E6%95%85%E3%80%8DMongoDB%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95%E5%BC%95%E5%8F%91%E7%9A%84%E7%81%BE%E9%9A%BE/"/>
    <url>/2023/02/06/%E3%80%8C%E7%94%9F%E4%BA%A7%E4%BA%8B%E6%95%85%E3%80%8DMongoDB%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95%E5%BC%95%E5%8F%91%E7%9A%84%E7%81%BE%E9%9A%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="「生产事故」MongoDB复合索引引发的灾难"><a href="#「生产事故」MongoDB复合索引引发的灾难" class="headerlink" title="「生产事故」MongoDB复合索引引发的灾难"></a>「生产事故」MongoDB复合索引引发的灾难</h1><p>标签： #Share</p><h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><ol><li>11月末<code>我司商品服务</code>的<code>MongoDB主库</code>曾出现过严重抖动、频繁锁库等情况。</li><li>由于诸多业务存在插入<code>MongoDB</code>、然后立即查询等逻辑，因此项目并未开启读写分离。</li><li>最终定位问题是由于：服务器自身磁盘 + 大量<code>慢查询</code>导致</li><li>基于上述情况，运维同学后续着重增强了对<code>MongoDB慢查询</code>的监控和告警</li></ol><blockquote><p><strong>幸运的一点</strong>：在出事故之前刚好完成了缓存过期时间的升级且过期时间为一个月，<code>C端查询</code>都落在缓存上，因此没有造成<code>P0级</code>事故，仅仅阻塞了部分<code>B端逻辑</code></p></blockquote><br><h2 id="事故回放"><a href="#事故回放" class="headerlink" title="事故回放"></a>事故回放</h2><p>我司的各种监控做的比较到位，当天突然收到了数据库服务器负载较高的告警通知，于是我和同事们就赶紧登录了<code>Zabbix监控</code>，如下图所示，截图的时候是正常状态，当时事故期间忘记留图了，可以想象当时的数据曲线反正是该高的很低，该低的很高就是了。</p><blockquote><p>Zabbix 分布式监控系统官网:<a href="https://www.zabbix.com/">https://www.zabbix.com/</a></p></blockquote><p><img src="/2023/02/06/%E3%80%8C%E7%94%9F%E4%BA%A7%E4%BA%8B%E6%95%85%E3%80%8DMongoDB%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95%E5%BC%95%E5%8F%91%E7%9A%84%E7%81%BE%E9%9A%BE/image-20201209005754862.png" alt="image-20201209005754862"></p><br><h2 id="开始分析"><a href="#开始分析" class="headerlink" title="开始分析"></a>开始分析</h2><p>我们研发是没有操控服务器权限的，因此委托运维同学帮助我们抓取了部分查询记录，如下所示：</p><pre><code class="hljs bash">---+Op          | Duration | Query                                                                                                                   ---+query       | 5 s      | &#123;<span class="hljs-string">&quot;filter&quot;</span>: &#123;<span class="hljs-string">&quot;orgCode&quot;</span>: 350119, <span class="hljs-string">&quot;fixedStatus&quot;</span>: &#123;<span class="hljs-string">&quot;<span class="hljs-variable">$in</span>&quot;</span>: [1, 2]&#125;&#125;, <span class="hljs-string">&quot;sort&quot;</span>: &#123;<span class="hljs-string">&quot;_id&quot;</span>: -1&#125;, <span class="hljs-string">&quot;find&quot;</span>: <span class="hljs-string">&quot;sku_main&quot;</span>&#125;               query       | 5 s      | &#123;<span class="hljs-string">&quot;filter&quot;</span>: &#123;<span class="hljs-string">&quot;orgCode&quot;</span>: 350119, <span class="hljs-string">&quot;fixedStatus&quot;</span>: &#123;<span class="hljs-string">&quot;<span class="hljs-variable">$in</span>&quot;</span>: [1, 2]&#125;&#125;, <span class="hljs-string">&quot;sort&quot;</span>: &#123;<span class="hljs-string">&quot;_id&quot;</span>: -1&#125;, <span class="hljs-string">&quot;find&quot;</span>: <span class="hljs-string">&quot;sku_main&quot;</span>&#125;               query       | 4 s      | &#123;<span class="hljs-string">&quot;filter&quot;</span>: &#123;<span class="hljs-string">&quot;orgCode&quot;</span>: 346814, <span class="hljs-string">&quot;fixedStatus&quot;</span>: &#123;<span class="hljs-string">&quot;<span class="hljs-variable">$in</span>&quot;</span>: [1, 2]&#125;&#125;, <span class="hljs-string">&quot;sort&quot;</span>: &#123;<span class="hljs-string">&quot;_id&quot;</span>: -1&#125;, <span class="hljs-string">&quot;find&quot;</span>: <span class="hljs-string">&quot;sku_main&quot;</span>&#125;               query       | 4 s      | &#123;<span class="hljs-string">&quot;filter&quot;</span>: &#123;<span class="hljs-string">&quot;orgCode&quot;</span>: 346814, <span class="hljs-string">&quot;fixedStatus&quot;</span>: &#123;<span class="hljs-string">&quot;<span class="hljs-variable">$in</span>&quot;</span>: [1, 2]&#125;&#125;, <span class="hljs-string">&quot;sort&quot;</span>: &#123;<span class="hljs-string">&quot;_id&quot;</span>: -1&#125;, <span class="hljs-string">&quot;find&quot;</span>: <span class="hljs-string">&quot;sku_main&quot;</span>&#125;              query       | 4 s      | &#123;<span class="hljs-string">&quot;filter&quot;</span>: &#123;<span class="hljs-string">&quot;orgCode&quot;</span>: 346814, <span class="hljs-string">&quot;fixedStatus&quot;</span>: &#123;<span class="hljs-string">&quot;<span class="hljs-variable">$in</span>&quot;</span>: [1, 2]&#125;&#125;, <span class="hljs-string">&quot;sort&quot;</span>: &#123;<span class="hljs-string">&quot;_id&quot;</span>: -1&#125;, <span class="hljs-string">&quot;find&quot;</span>: <span class="hljs-string">&quot;sku_main&quot;</span>&#125;...</code></pre><p>查询很慢的话所有研发应该第一时间想到的就是<code>索引</code>的使用问题，所以立即检查了一遍索引，如下所示：</p><pre><code class="hljs bash"><span class="hljs-comment">### 当时的索引</span>db.sku_main.ensureIndex(&#123;<span class="hljs-string">&quot;_id&quot;</span>: -1&#125;,&#123;background:<span class="hljs-literal">true</span>&#125;);db.sku_main.ensureIndex(&#123;<span class="hljs-string">&quot;orgCode&quot;</span>: 1, <span class="hljs-string">&quot;_id&quot;</span>: -1&#125;,&#123;background:<span class="hljs-literal">true</span>&#125;);db.sku_main.ensureIndex(&#123;<span class="hljs-string">&quot;orgCode&quot;</span>: 1, <span class="hljs-string">&quot;upcCode&quot;</span>: 1&#125;,&#123;background:<span class="hljs-literal">true</span>&#125;);....</code></pre><p>我屏蔽了干扰项，反正能很明显的看出来，这个查询是完全可以命中索引的，所以就需要直面第一个问题：</p><p><strong><font color="red">上述查询记录中排首位的慢查询到底是不是出问题的根源？</font></strong></p><p>我的判断是：它应该不是数据库整体缓慢的根源，因为第一它的查询条件足够简单暴力，完全命中索引，在索引之上有一点其他的查询条件而已，第二在查询记录中也存在相同结构不同条件的查询，耗时非常短。</p><p>在运维同学继续排查查询日志时，发现了另一个比较惊爆的查询，如下：</p><pre><code class="hljs bash"><span class="hljs-comment">### 当时场景日志</span>query: &#123; <span class="hljs-variable">$query</span>: &#123; shopCategories.0: &#123; <span class="hljs-variable">$exists</span>: <span class="hljs-literal">false</span> &#125;, orgCode: 337451, fixedStatus: &#123; <span class="hljs-variable">$in</span>: [ 1, 2 ] &#125;, _id: &#123; <span class="hljs-variable">$lt</span>: 2038092587 &#125; &#125;, <span class="hljs-variable">$orderby</span>: &#123; _id: -1 &#125; &#125; planSummary: IXSCAN &#123; _id: 1 &#125; ntoreturn:1000 ntoskip:0 keysExamined:37567133 docsExamined:37567133 cursorExhausted:1 keyUpdates:0 writeConflicts:0 numYields:293501 nreturned:659 reslen:2469894 locks:&#123; Global: &#123; acquireCount: &#123; r: 587004 &#125; &#125;, Database: &#123; acquireCount: &#123; r: 293502 &#125; &#125;, Collection: &#123; acquireCount: &#123; r: 293502 &#125; &#125; &#125; <span class="hljs-comment"># 耗时</span>179530ms</code></pre><p>耗时180秒且基于查询的<code>执行计划</code>可以看出，它走的是<code>_id_</code>索引，进行了全表扫描，扫描的数据总量为：37567133，不慢才怪。</p><br><h2 id="迅速解决"><a href="#迅速解决" class="headerlink" title="迅速解决"></a>迅速解决</h2><p>定位到问题后，没办法立即修改，第一要务是：<code>止损</code></p><p>结合当时的时间也比较晚了，因此我们发了公告，禁止了上述查询的功能并短暂暂停了部分业务，，过了一会之后进行了<code>主从切换</code>，再去看<code>Zabbix监控</code>就一切安好了。</p><br><h2 id="分析根源"><a href="#分析根源" class="headerlink" title="分析根源"></a>分析根源</h2><p>我们回顾一下查询的语句和我们预期的索引，如下所示：</p><pre><code class="hljs bash"><span class="hljs-comment">### 原始Query</span>db.getCollection(<span class="hljs-string">&quot;sku_main&quot;</span>).find(&#123;         <span class="hljs-string">&quot;orgCode&quot;</span> : NumberLong(337451),         <span class="hljs-string">&quot;fixedStatus&quot;</span> : &#123;             <span class="hljs-string">&quot;<span class="hljs-variable">$in</span>&quot;</span> : [                1.0,                 2.0            ]        &#125;,         <span class="hljs-string">&quot;shopCategories&quot;</span> : &#123;             <span class="hljs-string">&quot;<span class="hljs-variable">$exists</span>&quot;</span> : <span class="hljs-literal">false</span>        &#125;,         <span class="hljs-string">&quot;_id&quot;</span> : &#123;             <span class="hljs-string">&quot;<span class="hljs-variable">$lt</span>&quot;</span> : NumberLong(2038092587)        &#125;    &#125;).<span class="hljs-built_in">sort</span>(    &#123;         <span class="hljs-string">&quot;_id&quot;</span> : -1.0    &#125;).skip(1000).<span class="hljs-built_in">limit</span>(1000);<span class="hljs-comment">### 期望的索引</span>db.sku_main.ensureIndex(&#123;<span class="hljs-string">&quot;orgCode&quot;</span>: 1, <span class="hljs-string">&quot;_id&quot;</span>: -1&#125;,&#123;background:<span class="hljs-literal">true</span>&#125;);</code></pre><p>乍一看，好像一切都很Nice啊，字段<code>orgCode</code>等值查询，字段<code>_id</code>按照创建索引的方向进行倒序排序，为啥会这么慢？</p><p>但是，关键的一点就在 <code>$lt</code> 上</p><h3 id="知识点一：索引、方向及排序"><a href="#知识点一：索引、方向及排序" class="headerlink" title="知识点一：索引、方向及排序"></a>知识点一：索引、方向及排序</h3><p>在MongoDB中，排序操作可以通过从索引中按照索引的顺序获取文档的方式，来保证结果的有序性。</p><p>如果MongoDB的查询计划器没法从索引中得到排序顺序，那么它就需要在内存中对结果排序。</p><blockquote><p><strong>注意</strong>：在内存排序时，默认最大限制是32M，超过即会抛出错误</p></blockquote><h3 id="知识点二：单列索引不在乎方向"><a href="#知识点二：单列索引不在乎方向" class="headerlink" title="知识点二：单列索引不在乎方向"></a>知识点二：单列索引不在乎方向</h3><p>无论是MongoDB还是MySQL都是用的树结构作为索引，如果<code>排序方向</code>和<code>索引方向</code>相反，只需要从另一头开始遍历即可，如下所示：</p><pre><code class="hljs bash"><span class="hljs-comment"># 索引</span>db.records.createIndex(&#123;a:1&#125;); <span class="hljs-comment"># 查询</span>db.records.find().<span class="hljs-built_in">sort</span>(&#123;a:-1&#125;);<span class="hljs-comment"># 索引为升序，但是我查询要按降序，我只需要从右端开始遍历即可满足需求，反之亦然</span>MIN 0 1 2 3 4 5 6 7 MAX</code></pre><h3 id="MongoDB的复合索引结构"><a href="#MongoDB的复合索引结构" class="headerlink" title="MongoDB的复合索引结构"></a>MongoDB的复合索引结构</h3><blockquote><p>官方介绍：MongoDB supports <em>compound indexes</em>, where a single index structure holds references to multiple fields within a collection’s documents. </p></blockquote><p>复合索引结构示意图如下所示：</p><p><img src="/2023/02/06/%E3%80%8C%E7%94%9F%E4%BA%A7%E4%BA%8B%E6%95%85%E3%80%8DMongoDB%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95%E5%BC%95%E5%8F%91%E7%9A%84%E7%81%BE%E9%9A%BE/image-20201209012242728.png" alt="image-20201209012242728"></p><p>该索引刚好和我们讨论的是一样的，<code>userid顺序</code>，<code>score倒序</code>，同时假设当前表存在单列索引: <code>&#123;&quot;score&quot;: -1&#125;</code></p><p>我们需要直面第二个问题：**<font color="red">复合索引在使用时需不需要在乎方向？</font>**</p><p>假设两个查询条件：</p><pre><code class="hljs bash"><span class="hljs-comment"># 查询 一</span>db.getCollection(<span class="hljs-string">&quot;records&quot;</span>).find(&#123;   <span class="hljs-string">&quot;userid&quot;</span> : <span class="hljs-string">&quot;ca2&quot;</span>&#125;).<span class="hljs-built_in">sort</span>(&#123;<span class="hljs-string">&quot;score&quot;</span> : -1.0&#125;);<span class="hljs-comment"># 使用索引</span>&#123;<span class="hljs-string">&quot;userid&quot;</span>:1, <span class="hljs-string">&quot;score&quot;</span>:-1&#125;<span class="hljs-comment"># 查询 二</span>db.getCollection(<span class="hljs-string">&quot;records&quot;</span>).find(&#123;   <span class="hljs-string">&quot;userid&quot;</span> : <span class="hljs-string">&quot;ca2&quot;</span>&#125;).<span class="hljs-built_in">sort</span>(&#123;<span class="hljs-string">&quot;score&quot;</span> : 1.0&#125;);<span class="hljs-comment"># 使用索引</span>&#123;<span class="hljs-string">&quot;userid&quot;</span>:1, <span class="hljs-string">&quot;score&quot;</span>:-1&#125;</code></pre><p>上述的查询没有任何问题，因为受到<code>score</code>字段排序的影响，只是数据从左侧还是从右侧遍历的问题，那么下面的一个查询呢？</p><pre><code class="hljs bash"><span class="hljs-comment"># 错误示范</span>db.getCollection(<span class="hljs-string">&quot;records&quot;</span>).find(&#123;   <span class="hljs-string">&quot;userid&quot;</span> : <span class="hljs-string">&quot;ca2&quot;</span>,  <span class="hljs-string">&quot;score&quot;</span> : &#123;     <span class="hljs-string">&quot;<span class="hljs-variable">$lt</span>&quot;</span> : NumberLong(2038092587)  &#125;&#125;).<span class="hljs-built_in">sort</span>(&#123;<span class="hljs-string">&quot;score&quot;</span> : -1.0&#125;);<span class="hljs-comment"># 使用索引</span>&#123;<span class="hljs-string">&quot;score&quot;</span>:-1&#125;</code></pre><p>错误原因如下：</p><ul><li><strong><font color="red">由于score字段按照倒序排序，因此为了使用该索引，所以需要从左侧开始遍历</font></strong></li><li><strong><font color="red">从倒序顺序中找小于某个值的数据，势必会扫描很多无用数据，然后丢弃，当前场景下找大于某个值才是最佳方案</font></strong></li><li><strong><font color="red">所以MongoDB为了更多场景考虑，在该种情况下，放弃了复合索引，选用其他的索引，如 score 的单列索引</font></strong></li></ul><h2 id="针对性修改"><a href="#针对性修改" class="headerlink" title="针对性修改"></a>针对性修改</h2><p>仔细阅读了根源之后，再回顾线上的查询语句，针对性修改，把 <code>$lt</code> 条件改为 <code>$gt</code> 观察优化结果:</p><pre><code class="hljs bash"><span class="hljs-comment"># 原始查询</span>[TEMP INDEX] =&gt; lt: &#123;<span class="hljs-string">&quot;limit&quot;</span>:1000,<span class="hljs-string">&quot;queryObject&quot;</span>:&#123;<span class="hljs-string">&quot;_id&quot;</span>:&#123;<span class="hljs-string">&quot;<span class="hljs-variable">$lt</span>&quot;</span>:2039180008&#125;,<span class="hljs-string">&quot;categoryId&quot;</span>:23372,<span class="hljs-string">&quot;orgCode&quot;</span>:351414,<span class="hljs-string">&quot;fixedStatus&quot;</span>:&#123;<span class="hljs-string">&quot;<span class="hljs-variable">$in</span>&quot;</span>:[1,2]&#125;&#125;,<span class="hljs-string">&quot;restrictedTypes&quot;</span>:[],<span class="hljs-string">&quot;skip&quot;</span>:0,<span class="hljs-string">&quot;sortObject&quot;</span>:&#123;<span class="hljs-string">&quot;_id&quot;</span>:-1&#125;&#125;<span class="hljs-comment"># 原始耗时</span>[TEMP LT] =&gt; 超时 （超时时间10s）<span class="hljs-comment"># 优化后查询</span>[TEMP INDEX] =&gt; gt: &#123;<span class="hljs-string">&quot;limit&quot;</span>:1000,<span class="hljs-string">&quot;queryObject&quot;</span>:&#123;<span class="hljs-string">&quot;_id&quot;</span>:&#123;<span class="hljs-string">&quot;<span class="hljs-variable">$gt</span>&quot;</span>:2039180008&#125;,<span class="hljs-string">&quot;categoryId&quot;</span>:23372,<span class="hljs-string">&quot;orgCode&quot;</span>:351414,<span class="hljs-string">&quot;fixedStatus&quot;</span>:&#123;<span class="hljs-string">&quot;<span class="hljs-variable">$in</span>&quot;</span>:[1,2]&#125;&#125;,<span class="hljs-string">&quot;restrictedTypes&quot;</span>:[],<span class="hljs-string">&quot;skip&quot;</span>:0,<span class="hljs-string">&quot;sortObject&quot;</span>:&#123;<span class="hljs-string">&quot;_id&quot;</span>:-1&#125;&#125;<span class="hljs-comment"># 优化后耗时</span>[TEMP GT] =&gt; 耗时: 383ms , List Size: 999</code></pre><h2 id="修改方案"><a href="#修改方案" class="headerlink" title="修改方案"></a>修改方案</h2><ol><li><p>反向排序条件即可</p><pre><code class="hljs bash"><span class="hljs-comment"># 上文提到了索引可以从左或者从右开始遍历，因此调整文档扫描方向即可</span><span class="hljs-comment"># 注: 需要主动申明首位(orgCode)字段查询方向，否则会按默认方向查找</span><span class="hljs-built_in">sort</span>(&#123; <span class="hljs-string">&quot;orgCode&quot;</span> : -1.0&#125;,&#123; <span class="hljs-string">&quot;_id&quot;</span> : 1.0&#125;)</code></pre></li><li><p>修改业务代码</p><ol><li>预先查出查询条件下<code>_id</code>最小值（完全利用索引，速度非常快）</li><li>将 <code>lt</code> 查询换成 <code>gt</code> 查询即可</li></ol></li></ol><h2 id="拓展场景：无其他索引干扰时的场景"><a href="#拓展场景：无其他索引干扰时的场景" class="headerlink" title="拓展场景：无其他索引干扰时的场景"></a>拓展场景：无其他索引干扰时的场景</h2><p>上文中为了模拟线上事故，所以我们假定了一个复合索引以及一个单列索引，即：</p><pre><code class="hljs bash">&#123;<span class="hljs-string">&quot;userid&quot;</span>: 1, <span class="hljs-string">&quot;score&quot;</span>: -1&#125;&#123;<span class="hljs-string">&quot;score&quot;</span>: -1&#125;</code></pre><p>当我们删除单列索引，按不符合方向的查询，会有什么现象呢？</p><pre><code class="hljs bash"><span class="hljs-comment"># 仅剩复合索引时</span>db.getCollection(<span class="hljs-string">&quot;records&quot;</span>).find(&#123;   <span class="hljs-string">&quot;userid&quot;</span> : <span class="hljs-string">&quot;ca2&quot;</span>,  <span class="hljs-string">&quot;score&quot;</span> : &#123;     <span class="hljs-string">&quot;<span class="hljs-variable">$lt</span>&quot;</span> : NumberLong(2038092587)  &#125;&#125;).<span class="hljs-built_in">sort</span>(&#123;<span class="hljs-string">&quot;score&quot;</span> : -1.0&#125;);<span class="hljs-comment"># 使用索引</span>&#123;<span class="hljs-string">&quot;userid&quot;</span>:1, <span class="hljs-string">&quot;score&quot;</span>:-1&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>分析了小2000字，其实改动就是两个字符而已，当然真正的改动需要考虑业务的需要，但是问题既然已经定位，修改什么的就不难了，回顾上述内容总结如下：</p><ul><li>学习数据库知识的时候可以用类比的方式，但是需要额外注意其不同的地方（MySQL、MongoDB索引、索引的方向）</li><li>MongoDB单列索引可以不在乎方向</li><li>MongoDB无法通过索引排序时会在内存中进行排序，超过默认大小（32M）限制后悔报错</li><li><code>MongoDB数据库复合索引在使用中一定要注意其方向</code>，要完全理解其逻辑，<code>要么完全相同，要么完全相反</code>，避免索引失效</li><li>针对上一条：<code>但当索引选择器没有更优解时，即使查询方向不符合索引方向，也会使用目标索引</code></li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>如果你觉得这篇内容对你挺有帮助的话：</p><ol><li>当然要点赞支持一下啦~</li><li>搜索并关注公众号「<strong>是Kerwin啊</strong>」，一起唠唠嗑~</li><li>再来看看最近几篇的「<strong>查漏补缺</strong>」系列吧，该系列会持续输出~<ul><li><a href="https://juejin.cn/post/6870264679063617550">「查缺补漏」巩固你的Nginx知识体系</a></li><li><a href="https://juejin.cn/post/6862865811137101837">「查缺补漏」巩固你的RocketMQ知识体系</a></li><li><a href="https://juejin.cn/post/6857667542652190728">「查缺补漏」巩固你的Redis知识体系（笑）</a></li><li><a href="https://juejin.cn/post/6860262796618268680">悄咪咪提高团队幸福感 &amp; Surprise！</a></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>MongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>「生产事故」MongoDB复合索引引发的灾难</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一文入门DNS？从访问GitHub开始</title>
    <link href="/2023/02/06/%E4%B8%80%E6%96%87%E5%85%A5%E9%97%A8DNS%EF%BC%9F%E4%BB%8E%E8%AE%BF%E9%97%AEGitHub%E5%BC%80%E5%A7%8B/"/>
    <url>/2023/02/06/%E4%B8%80%E6%96%87%E5%85%A5%E9%97%A8DNS%EF%BC%9F%E4%BB%8E%E8%AE%BF%E9%97%AEGitHub%E5%BC%80%E5%A7%8B/</url>
    
    <content type="html"><![CDATA[<p>标签： #Share</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大家都是做开发的，都有<code>GitHub</code>的账号，在日常使用中肯定会遇到这种情况，在不修改任何配置的情况下，有时可以正常访问GitHub，有时又直接未响应，来一起捋捋到底是为啥。</p><h2 id="GitHub访问的千层套路"><a href="#GitHub访问的千层套路" class="headerlink" title="GitHub访问的千层套路"></a>GitHub访问的千层套路</h2><p>以我家里的电脑为例，在不修改任何配置，不启用什么代理工具的情况下，访问<code>GitHub</code>会得到以下结果：</p><p><img src="/2023/02/06/%E4%B8%80%E6%96%87%E5%85%A5%E9%97%A8DNS%EF%BC%9F%E4%BB%8E%E8%AE%BF%E9%97%AEGitHub%E5%BC%80%E5%A7%8B/%E9%94%99%E4%B9%B1.png"></p><p>😂😂😂</p><p>虽然很戳心，但好歹能展示一部分。</p><p>从网上搜了一堆乱七八糟的攻略，知道了可以通过修改电脑的<code>Hosts</code>文件达到正常访问的能力，于是胡搜了一通，</p><p>步骤：<a href="https://jingyan.baidu.com/article/9113f81b49ed2f2b3214c7fa.html">百度经验</a></p><p>效果如下：</p><p><img src="/2023/02/06/%E4%B8%80%E6%96%87%E5%85%A5%E9%97%A8DNS%EF%BC%9F%E4%BB%8E%E8%AE%BF%E9%97%AEGitHub%E5%BC%80%E5%A7%8B/%E4%BC%98%E5%8C%96-1.png"></p><p>访问效果依然很感人，最近活动数据不显示，整个界面加载都快接近2分钟了，有什么办法没有咧~</p><h3 id="站长工具-PING-PING-PING"><a href="#站长工具-PING-PING-PING" class="headerlink" title="站长工具 PING PING PING"></a>站长工具 PING PING PING</h3><p>都是搞开发的，都会用F12看看网络或者资源请求的地址是什么，以上面耗时最慢的地址为例，域名为：<code>github.githu.com</code></p><p>打开站长工具的PING功能，地址为：<a href="http://ping.chinaz.com/github.githu.com">http://ping.chinaz.com/github.githu.com</a></p><p>结果如下：</p><p><img src="/2023/02/06/%E4%B8%80%E6%96%87%E5%85%A5%E9%97%A8DNS%EF%BC%9F%E4%BB%8E%E8%AE%BF%E9%97%AEGitHub%E5%BC%80%E5%A7%8B/image-20200722010132371.png" alt="image-20200722010132371"></p><p>我发现 <code>185.199.108.154</code> 这个IP地址速度快的一批，于是立马更换 <code>Hosts</code>中该域名对应的IP地址</p><p>再次访问，效果如下：</p><p><img src="/2023/02/06/%E4%B8%80%E6%96%87%E5%85%A5%E9%97%A8DNS%EF%BC%9F%E4%BB%8E%E8%AE%BF%E9%97%AEGitHub%E5%BC%80%E5%A7%8B/%E4%BC%98%E5%8C%96-2.png"></p><p>那句话怎么说的来着？如什么什么般丝滑，我感觉这就非常丝滑~  🤪</p><h3 id="GitHub项目定时发布最新Hosts"><a href="#GitHub项目定时发布最新Hosts" class="headerlink" title="GitHub项目定时发布最新Hosts"></a>GitHub项目定时发布最新Hosts</h3><p>当然了，如果每次访问都得折腾一次，那滋味，简直不要太难受，所以网上已经有人开源了相关的项目，会定时发布最新的 <code>GitHub</code> IP地址，链接：<a href="https://github.com/521xueweihan/GitHub520">https://github.com/521xueweihan/GitHub520</a></p><p>本文撰写时的Hosts</p><pre><code class="hljs bash"><span class="hljs-comment"># github</span>185.199.108.154               github.githu.com199.232.68.133                camo.githubusercontent.com52.168.24.190                 github.map.fastly.net199.232.69.194                github.global.ssl.fastly.net140.82.112.4                  github.com140.82.112.5                  api.github.com199.232.68.133                raw.githubusercontent.com199.232.68.133                user-images.githubusercontent.com199.232.68.133                favicons.githubusercontent.com199.232.68.133                avatars5.githubusercontent.com199.232.68.133                avatars4.githubusercontent.com199.232.68.133                avatars3.githubusercontent.com199.232.68.133                avatars2.githubusercontent.com199.232.68.133                avatars1.githubusercontent.com199.232.68.133                avatars0.githubusercontent.com</code></pre><p>该项目会自动发布在指定的地址上，结合软件使用，可以完全自动化，无需持续更新</p><p>当然也可以自行手动更改</p><h2 id="为什么改了Hosts就能访问GitHub"><a href="#为什么改了Hosts就能访问GitHub" class="headerlink" title="为什么改了Hosts就能访问GitHub"></a>为什么改了Hosts就能访问GitHub</h2><p>平常都是百度 + 谷歌，今天非要探究一下原理！咱们一步一步来，首先大家都需要明确一点，在网络的世界中 <code>域名</code> 只是为了便于记忆和识别而存在的一个唯一地址，真正工作的仍然是 <code>IP</code></p><h3 id="Hosts文件是干吗的"><a href="#Hosts文件是干吗的" class="headerlink" title="Hosts文件是干吗的"></a>Hosts文件是干吗的</h3><p>简单来说，Hosts文件是存储本机网址域名与其对应的IP地址的一个文件，在网络请求阶段发挥作用</p><h3 id="为什么改了Hosts就能生效"><a href="#为什么改了Hosts就能生效" class="headerlink" title="为什么改了Hosts就能生效"></a>为什么改了Hosts就能生效</h3><p>这就涉及到了域名解析，因为Hosts文件存放的就是 <code>域名</code> 和 <code>IP</code> 的对应关系，因此它可以在域名解析阶段发挥作用，为什么呢？因为在域名解析的流程中 <code>本机Hosts</code> 解析处于顺序二</p><p>即：浏览器解析 -》<code>本机解析</code> -》XXXX（后面的稍后再提）</p><p>所以有时候我们白嫖软件，都会改一下 <code>Hosts</code>，因为需要把它在线验证的域名指向错误的地址去，另外可能存在一定的浏览器缓存或者本机缓存，可以通过重开浏览器或者 <code>PING</code> 域名来检查更改是否生效。</p><h3 id="DNS解析到底是什么玩意？"><a href="#DNS解析到底是什么玩意？" class="headerlink" title="DNS解析到底是什么玩意？"></a>DNS解析到底是什么玩意？</h3><p>上文中多次提到<code>解析</code>，其实说的就是 <code>DNS解析</code> </p><p>同时上文也提到过，在网络世界中真正发挥作用的是 <code>IP</code>，而一般情况下我们访问的都是 <code>域名</code>，为什么能实现这种效果，就是因为域名与IP地址的对应关系存储在一个叫做 <code>DNS（Domain Name System）</code> 的系统里。DNS是一个全球化的分布式数据库，它所提供的服务就是将域名转换为互联网IP地址。</p><h3 id="DNS解析的全部流程"><a href="#DNS解析的全部流程" class="headerlink" title="DNS解析的全部流程"></a>DNS解析的全部流程</h3><p>网上的关于流程的图很多，我从中借鉴了一副，如下所示：</p><p><img src="/2023/02/06/%E4%B8%80%E6%96%87%E5%85%A5%E9%97%A8DNS%EF%BC%9F%E4%BB%8E%E8%AE%BF%E9%97%AEGitHub%E5%BC%80%E5%A7%8B/385704-20190108192401036-1125761048.png" alt="img"></p><ol><li><p>浏览器缓存：一次请求会首先通过浏览器缓存信息寻找域名映射的IP地址，这也是为什么有时候我们改了本机hosts，需要关闭再打开浏览器才能正常使用，如果找到则返回，没找到则继续到下一级</p></li><li><p>本机系统缓存：即上文中提到的，通过 <code>hosts</code> 文件来映射域名和IP，在上古时期有很多垃圾软件会悄咪咪的修改系统的 hosts文件，达到 <code>DNS劫持</code> 的目的，即把淘宝域名指向另一个 <code>IP</code>，然后部署一个高仿的淘宝商城，静静等你输入账号，密码，然后凉凉…</p></li><li><p>本地域名解析服务系统：本地域名系统LDNS一般都是本地区的域名服务器。离你的位置都比较近，Windows系统使用命令<code>ipconfig</code> 就可以查看，在Linux和Mac系统下，直接使用命令 <code>cat /etc/resolv.conf</code> 来查看LDNS服务地址。<br>LDNS一般都缓存了大部分的域名解析的结果，大部分的解析工作到这里就差不多已经结束了</p><p>以下即是所谓的 <code>递归解析</code></p></li><li><p>根域名解析：本地域名解析服务系统无法解析时，会向 <code>13根</code> 发起域名解析请求</p><p><font color="red">说明：</font> 所谓的 13根，指的是根域名服务器，是架构因特网所必须的基础设施。根服务器主要用来管理互联网的主目录，由于DNS解析中采用的是UDP协议，仅能传递512字节的有效报文，因此只能构建出A-M 13个根服务器，而真正工作运行肯定不止13台服务器，而是包含很多服务器镜像的</p></li><li><p>根域名解析服务器返回  <code>gTLD (Generic top-level domain)</code> 给本地解析服务器，即该域名所属的顶级域及其所在的服务器，顶级域名即如：.com .cn等等</p></li><li><p>本地解析服务器已知顶级域名服务器地址后，发起解析请求</p></li><li><p>顶级域名解析服务器返回 <code>权限域名服务器</code> 信息给本地解析服务器，<code>权限域名服务器</code> 即如：taobao.com</p></li><li><p>本地解析服务器已知权限域名服务器地址后，发起解析请求</p></li><li><p>权限域名服务器返回域名对应的IP地址给本地解析服务器</p></li><li><p>本地解析服务器缓存相关信息，并返回给用户</p></li></ol><p>是不是有点绕？咱们来整个图吧，<code>递归解析</code> 如下所示：</p><p><img src="/2023/02/06/%E4%B8%80%E6%96%87%E5%85%A5%E9%97%A8DNS%EF%BC%9F%E4%BB%8E%E8%AE%BF%E9%97%AEGitHub%E5%BC%80%E5%A7%8B/image-20200722233231460.png" alt="image-20200722233231460"></p><h3 id="再问一遍为什么改Hosts就可以访问GitHub"><a href="#再问一遍为什么改Hosts就可以访问GitHub" class="headerlink" title="再问一遍为什么改Hosts就可以访问GitHub"></a>再问一遍为什么改Hosts就可以访问GitHub</h3><p>了解了上文之后，对于这个问题就更好回答了，因为GitHub毕竟为外国的网站，咱们访问时有一层 <code>DNS污染</code>，即把对应的域名指向了不可达的IP上，或者禁止访问的IP上，因此很多时候无法使用</p><p>修改Hosts文件后即避免了DNS污染，直达目标IP，即可正常访问了，当然了，这种方法是全部通用吗？</p><p>答案：肯定不是，因为刚才也提到了，网关层是可以控制某些IP禁止访问的</p><p>整一个工具来验证一下猜想，顺便看看我们的整个请求流程：</p><p>软件名：BestTrace</p><p><img src="/2023/02/06/%E4%B8%80%E6%96%87%E5%85%A5%E9%97%A8DNS%EF%BC%9F%E4%BB%8E%E8%AE%BF%E9%97%AEGitHub%E5%BC%80%E5%A7%8B/trans.png"></p><p>我请求的域名是 <code>github.githu.com</code>，最终请求接收方IP和我Hosts配置的IP一致，那我换一个  facebook.com </p><p><img src="/2023/02/06/%E4%B8%80%E6%96%87%E5%85%A5%E9%97%A8DNS%EF%BC%9F%E4%BB%8E%E8%AE%BF%E9%97%AEGitHub%E5%BC%80%E5%A7%8B/image-20200722234214751.png" alt="image-20200722234214751"></p><p>可以看到，当请求到达 221.183.46.249 这个IP时，整个请求就被拦截下来了，因此这并不是万能的办法</p><p>除了访问GitHub，还有什么时候可能用到呢？</p><p>比如下载 <code>IDEA插件</code>时，如果发现老是刷新不出来插件库，或者下载失败，就可以通过PING工具去配置最佳IP，方便下载~</p><h2 id="DNS除了解析还能做什么"><a href="#DNS除了解析还能做什么" class="headerlink" title="DNS除了解析还能做什么"></a>DNS除了解析还能做什么</h2><h3 id="智能DNS"><a href="#智能DNS" class="headerlink" title="智能DNS"></a>智能DNS</h3><p>网络请求交由域名解析服务器来处理，分配到最佳的服务器IP上</p><p>例如：请求的源头是电信还是联通等，如果是电信则将解析的IP分流到电信对应的IP上，或者返回距离最近的服务器IP地址</p><h3 id="反向代理水平扩展"><a href="#反向代理水平扩展" class="headerlink" title="反向代理水平扩展"></a>反向代理水平扩展</h3><p>典型的互联网架构中，可以通过增加<code>web-server</code>来扩充web层的性能，但反向代理nginx仍是整个系统的唯一入口</p><p><strong>如果系统吞吐超过nginx的性能极限</strong>，那么将难以扩容，此时就需要<code>dns-server</code>来配合水平扩展。</p><p>即DNS解析服务器有序的把域名解析到不同的网关层，每次DNS解析请求，轮询返回不同的ip，这样就能实现nginx的水平扩展，这个方法叫 “<strong>DNS轮询</strong>”</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>参考资料：</p><p><a href="https://www.cnblogs.com/kongtongshu/p/11069559.html">博客园  DNS解析全过程分析</a></p><p><a href="https://blog.csdn.net/shenjian58/article/details/107273629/">除了解析域名，DNS还能干吗</a></p><p>如果觉得对你有用的话，不要忘记点个赞啊~    也可以扫描二维码关注我，一起朝着技术人的顶峰前进！</p><p><img src="/2023/02/06/%E4%B8%80%E6%96%87%E5%85%A5%E9%97%A8DNS%EF%BC%9F%E4%BB%8E%E8%AE%BF%E9%97%AEGitHub%E5%BC%80%E5%A7%8B/1734e416a4d04ce4"></p>]]></content>
    
    
    <categories>
      
      <category>网络篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>一文入门DNS？从访问GitHub开始</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>享元模式</title>
    <link href="/2023/02/06/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/02/06/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="享元模式篇"><a href="#享元模式篇" class="headerlink" title="享元模式篇"></a>享元模式篇</h1><p>标签： #Share</p><h3 id="官方解释"><a href="#官方解释" class="headerlink" title="官方解释"></a>官方解释</h3><p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能，这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式</p><h3 id="享元模式的使用"><a href="#享元模式的使用" class="headerlink" title="享元模式的使用"></a>享元模式的使用</h3><p> 1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面<br> 2、数据库的数据池</p><h3 id="官方示例"><a href="#官方示例" class="headerlink" title="官方示例"></a>官方示例</h3><p>Head First：<a href="https://www.cnblogs.com/adamjwh/p/9070107.html">https://www.cnblogs.com/adamjwh/p/9070107.html</a><br>菜鸟教程：<a href="https://www.runoob.com/design-pattern/flyweight-pattern.html">https://www.runoob.com/design-pattern/flyweight-pattern.html</a></p><h3 id="工作举例"><a href="#工作举例" class="headerlink" title="工作举例"></a>工作举例</h3><pre><code class="hljs awk">详情见：https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/kkzhilu/</span>KerwinTools<span class="hljs-regexp">/tree/m</span>aster<span class="hljs-regexp">/src/m</span>ain<span class="hljs-regexp">/java/</span>design/pattern享元模式相关</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><pre><code class="hljs java"><span class="hljs-comment">/***</span><span class="hljs-comment"> * 享元模式</span><span class="hljs-comment"> *     主要解决：在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 关键代码</span><span class="hljs-comment"> *     1.构建产品类</span><span class="hljs-comment"> *     2.构建享元工厂, 通过唯一的key进行判断，是否重复创建对象</span><span class="hljs-comment"> *     3.通过key拿到对象后，根据set方法变化数据，达到想要的目的</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 值得注意</span><span class="hljs-comment"> *     外部状态和内部状态的变化</span><span class="hljs-comment"> */</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>编码及设计模式篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>享元模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代理模式</title>
    <link href="/2023/02/06/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/02/06/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="代理模式篇"><a href="#代理模式篇" class="headerlink" title="代理模式篇"></a>代理模式篇</h1><p>标签： #Share</p><h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>为其他对象提供一种代理以控制对这个对象的访问</p><h2 id="代理模式的诞生"><a href="#代理模式的诞生" class="headerlink" title="代理模式的诞生"></a>代理模式的诞生</h2><p>【<font color="orange">产品</font>】：Kerwin，我记得你是在通州租房住吧？</p><p>【<font color="blue">开发</font>】：是啊，怎么了？</p><p>【<font color="orange">产品</font>】：你是房东直租还是中介啊？我最近真是特别烦中介，收费都好黑！</p><p>【<font color="blue">开发</font>】：我啊，我租的房子名义上倒是房东直租，但估计还是中介，你知道吗，中介的扩张是一个必然。</p><p>【<font color="orange">产品</font>】：扩张？你指的是全北京的房子都是中介的意思吗？</p><p>【<font color="blue">开发</font>】：现在肯定不至于全部都是，但也是大部分了，为什么会这样呢，因为中介需要控制租户，控制租金市场，如果租户直租房东，房东钱多人好，就很有可能很便宜，这就会打乱市场价格，所以拿下所有房老板，<font color="red">不仅为了赚钱，也是为了控制这种市场关系</font>。</p><p>【<font color="orange">产品</font>】：我看你们程序员平常“傻傻的”，怎么对这个这么了解？莫非有计算机相关的故事？</p><p>【<font color="blue">开发</font>】：被你说中了，这个就是代理模式！它的诞生就是为了控制对象的访问，<font color="red">不过我们一般是用来增强其功能</font>，不像XXX🤪</p><p><img src="/2023/02/06/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/image-20200622004018317.png" alt="image-20200622004018317"></p><h2 id="HeadFirst-核心代码"><a href="#HeadFirst-核心代码" class="headerlink" title="HeadFirst 核心代码"></a>HeadFirst 核心代码</h2><p><em><strong>定义正常业务类接口</strong></em></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PhoneInterface</span> &#123;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 更新电话号码</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> phoneNum    电话号码</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception  可能抛出Exception 异常</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">updatePhone</span><span class="hljs-params">(Long phoneNum)</span>;&#125;</code></pre><p><em><strong>实现正常业务类</strong></em></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PhoneServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PhoneInterface</span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updatePhone</span><span class="hljs-params">(Long phoneNum)</span> &#123;        System.out.println(<span class="hljs-string">&quot;update phoneNum is: -&gt; &quot;</span> + phoneNum);    &#125;&#125;</code></pre><p><em><strong>静态代理业务类</strong></em></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PhoneServiceProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PhoneInterface</span> &#123;    <span class="hljs-comment">/** 代理模式一般自行New对象, 反观装饰器模式则是传入对象 **/</span>    <span class="hljs-keyword">private</span> PhoneInterface phoneInterface;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PhoneServiceProxy</span><span class="hljs-params">()</span> &#123;        <span class="hljs-built_in">this</span>.phoneInterface = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhoneServiceImpl</span>();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updatePhone</span><span class="hljs-params">(Long phoneNum)</span> &#123;        before(phoneNum);        phoneInterface.updatePhone(phoneNum);        after();    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">(Long phoneNum)</span> &#123;        System.out.println(MessageFormat.format(<span class="hljs-string">&quot;log start time:&#123;0&#125; , phoneNum is: &#123;1&#125;&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(), phoneNum));        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == phoneNum || String.valueOf(phoneNum).length() != <span class="hljs-number">11</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Update phoneNum fail, phoneNum is wrong.&quot;</span>);        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">after</span><span class="hljs-params">()</span> &#123;        System.out.println(MessageFormat.format(<span class="hljs-string">&quot;log end time:&#123;0&#125;&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()));    &#125;&#125;</code></pre><p><font color="red">静态代理模式的设计思路：</font></p><ul><li>Proxy  代理类</li><li>RealSubject  定义被代理的实体</li><li>Subject  定义RealSubject和Proxy共用接口</li></ul><p>简单来说，</p><ol><li>需要一个普通接口及其普通实现类</li><li>代理类同时实现该接口，自行new出对应实现类对象，对接口方法的前后增加额外操作</li></ol><blockquote><p>如果看着有点模棱两可，建议看完本文后，访问专题设计模式开源项目，里面有具体的代码示例，链接在最下面</p></blockquote><h2 id="装饰器模式和代理模式的区别"><a href="#装饰器模式和代理模式的区别" class="headerlink" title="装饰器模式和代理模式的区别"></a>装饰器模式和代理模式的区别</h2><ul><li>持有对象方式：代理模式一般是New，装饰器模式则是传入同一接口对象</li><li>意图：装饰器模式意在增强方法功能，代理模式意在控制对象的访问（例如代码中增加校验）</li></ul><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>刚才 HeadFirst核心代码 章节展示的是其静态代码的书写方式，如果所有的类都基于这样实现，那势必发生类膨胀的无解问题，因此真正常用的还是动态代理，分为两种 CGLIB | JDK动态代理</p><h3 id="JDK-动态代理之MyBatis"><a href="#JDK-动态代理之MyBatis" class="headerlink" title="JDK 动态代理之MyBatis"></a>JDK 动态代理之MyBatis</h3><p><em><strong>注意事项：</strong></em></p><ol><li>JDK动态代理的本质是创造一个实现了同一个接口的Proxy代理类，去进行真正的调用</li><li>JDK动态代理在实现中的本质是反射技术</li><li>由于所有的代理类都实现了Proxy.class -&gt; 包括帮我们创造的代理类也是，因此由于JAVA单继承的特点，只能想要实现代理必须实现某一个接口</li></ol><p><em><strong>JDK 动态代理必不可少的三要素：InvocationHandler，newProxyInstance，invoke</strong></em></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisInvocation</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 代理指定的接口</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> tClass 接口class</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt;    接口类型</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  &lt;T&gt; T <span class="hljs-title function_">newProxyInstance</span><span class="hljs-params">(Class&lt;T&gt; tClass)</span> &#123;        <span class="hljs-keyword">return</span> (T) Proxy.newProxyInstance(tClass.getClassLoader(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;tClass&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MybatisInvocation</span>());    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;        <span class="hljs-keyword">if</span> (method.isAnnotationPresent(Select.class)) &#123;            <span class="hljs-type">Select</span> <span class="hljs-variable">select</span> <span class="hljs-operator">=</span> method.getAnnotation(Select.class);            System.out.println(MessageFormat.format(<span class="hljs-string">&quot;Method Name: &#123;0&#125; , Annotation Value is: &#123;1&#125;&quot;</span>, method.getName(), select.value()));        &#125;        <span class="hljs-comment">// 获取到SQL及参数, 即可通过JDBC进行数据库操作查询数据, MyBatis不再神秘</span>        <span class="hljs-keyword">return</span> Arrays.asList(<span class="hljs-string">&quot;I&quot;</span>, <span class="hljs-string">&quot; am&quot;</span>, <span class="hljs-string">&quot; Kerwin~&quot;</span>);    &#125;&#125;</code></pre><p><em><strong>被代理的接口</strong></em></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyBatis</span> &#123;    <span class="hljs-meta">@Select(&quot;select * from demo&quot;)</span>    List&lt;String&gt; <span class="hljs-title function_">select</span><span class="hljs-params">()</span>;&#125;</code></pre><p><em><strong>测试调用</strong></em></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-comment">// JDK动态代理：模拟 MyBatis 核心代理阶段</span>        <span class="hljs-type">MyBatis</span> <span class="hljs-variable">batis</span> <span class="hljs-operator">=</span> MybatisInvocation.newProxyInstance(MyBatis.class);        System.out.println(<span class="hljs-string">&quot;Result:&quot;</span> + batis.select());    &#125;&#125;</code></pre><p><em><strong>输出结果</strong></em></p><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Method Name: <span class="hljs-keyword">select</span> , Annotation Value is: <span class="hljs-keyword">select</span> * from demo</span><span class="hljs-meta prompt_"># </span><span class="language-bash">Result:[I,  am,  Kerwin~]</span></code></pre><p><font color="red">MyBatis中的JDK 动态代理：</font>我们在使用MyaBtis的时候，肯定想过，它凭什么一个接口就可以输出结果，利用JDK 动态代理，可以非常方便的构建接口的代理，我们便可以在 <code>Invoke</code> 方法中大做文章，解析方法注解的值，解析其方法返回值，然后利用JDBC即可实现数据库查询实现一个简单ORM框架，推荐大家自行尝试一下</p><h3 id="CGLIB-动态代理之AOP"><a href="#CGLIB-动态代理之AOP" class="headerlink" title="CGLIB 动态代理之AOP"></a>CGLIB 动态代理之AOP</h3><p><em><strong>基础使用</strong></em></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PhoneCglibProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;    Object target;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PhoneCglibProxy</span><span class="hljs-params">(Object o)</span> &#123;        <span class="hljs-built_in">this</span>.target = o;    &#125;    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">newProxyInstance</span><span class="hljs-params">()</span>&#123;        <span class="hljs-type">Enhancer</span> <span class="hljs-variable">en</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();        <span class="hljs-comment">// 设置要代理的目标类</span>        en.setSuperclass(target.getClass());        <span class="hljs-comment">// 设置要代理的拦截器</span>        en.setCallback(<span class="hljs-built_in">this</span>);        <span class="hljs-comment">// 生成代理类的实例</span>        <span class="hljs-keyword">return</span> en.create();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;        System.out.println(MessageFormat.format(<span class="hljs-string">&quot;Method Name is: &#123;0&#125; Params is: &#123;1&#125;&quot;</span>, method.getName(), Arrays.toString(objects)));        <span class="hljs-keyword">return</span> methodProxy.invokeSuper(o, objects);    &#125;&#125;</code></pre><p><em><strong>测试调用</strong></em></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * CGLIB动态代理</span><span class="hljs-comment">     *      如果类是final的，则无法生成代理对象，报错</span><span class="hljs-comment">     *      如果方法是final的，代理无效</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * 关键代码：</span><span class="hljs-comment">     *     1.PhoneCglibProxy 实现 MethodInterceptor 方法拦截器接口  同时实现其 newProxyInstance方法 -&gt; 该方法内容比较固定</span><span class="hljs-comment">     *     2.通过代理工厂构建, 创建对象, 使用即可</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * Spring 3.2之后默认包含了cglib依赖</span><span class="hljs-comment">     * 普通项目 CGLIB依赖如下:</span><span class="hljs-comment">     *</span><span class="hljs-comment">     *     &lt;dependency&gt;</span><span class="hljs-comment">     *        &lt;groupId&gt;cglib&lt;/groupId&gt;</span><span class="hljs-comment">     *        &lt;artifactId&gt;cglib-nodep&lt;/artifactId&gt;</span><span class="hljs-comment">     *        &lt;version&gt;2.2.2&lt;/version&gt;</span><span class="hljs-comment">     *     &lt;/dependency&gt;</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * 推荐代码阅读顺序：</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> PhoneServiceImpl</span><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> PhoneCglibProxy</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;        <span class="hljs-type">PhoneServiceImpl</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhoneServiceImpl</span>();        <span class="hljs-type">PhoneCglibProxy</span> <span class="hljs-variable">proxyFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhoneCglibProxy</span>(phone);        <span class="hljs-type">PhoneServiceImpl</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> (PhoneServiceImpl) proxyFactory.newProxyInstance();        service.updatePhone(<span class="hljs-number">15186564812L</span>);    &#125;&#125;</code></pre><p><font color="red">CGLIB 动态代理：</font>Spring 3.2之后默认包含了cglib依赖，在使用中也要注意 final 关键字会使CGLIB代理失效，另外<font color="red">Spring AOP 默认采用JDK 动态代理，同时配合CGLIB代理一起实现的</font>。</p><h3 id="两种动态代理总结"><a href="#两种动态代理总结" class="headerlink" title="两种动态代理总结"></a>两种动态代理总结</h3><ul><li>JDK 动态代理只能针对实现了接口的类的接口方法进行代理</li><li>CgLib 动态代理基于继承来实现代理，所以无法对final类、private方法和static方法实现代理</li></ul><p><em><strong>Spring AOP</strong></em>：</p><ul><li>如果目标对象实现了接口，则默认采用JDK 动态代理</li><li>如果目标对象没有实现接口，则采用CgLib 动态代理</li><li>如果目标对象实现了接口，且强制CgLib 代理，则采用CgLib进行动态代理</li></ul><blockquote><p>关于两种动态原理的实现原理可以查查其他的文章~</p></blockquote><h2 id="遵循的设计原则"><a href="#遵循的设计原则" class="headerlink" title="遵循的设计原则"></a>遵循的设计原则</h2><ul><li>封装变化：在父级接口中提供 default 方法，子类实现其对应的状态方法即可</li><li>多用组合，少用继承：代理模式经常和策略模式做对比，它们都是利用组合而非继承增强其变化和能力</li></ul><h2 id="什么场景适合使用代理模式"><a href="#什么场景适合使用代理模式" class="headerlink" title="什么场景适合使用代理模式"></a>什么场景适合使用代理模式</h2><p>当我们需要为额外控制对象方法的执行时，比如历史项目的接口都没有记录日志，在Spring环境下，我们可以对所有的Bean方法增加日志功能，又或是多数据源时，通过注解标明对应的数据源，解耦代码等等</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p><strong>附上GOF一书中对于代理模式的UML图：</strong></p><p><img src="/2023/02/06/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/image-20200622012022768.png" alt="image-20200622012022768"></p><h2 id="相关代码链接"><a href="#相关代码链接" class="headerlink" title="相关代码链接"></a>相关代码链接</h2><p><a href="https://github.com/kkzhilu/Kerwin-DesignPattern">GitHub地址</a></p><ul><li>兼顾了《HeadFirst》以及《GOF》两本经典书籍中的案例</li><li>提供了友好的阅读指导</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/5/18/172284a1c8caf324?w=487&h=185&f=png&s=17561"></p>]]></content>
    
    
    <categories>
      
      <category>编码及设计模式篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代理模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式</title>
    <link href="/2023/02/06/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/02/06/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="单例模式篇"><a href="#单例模式篇" class="headerlink" title="单例模式篇"></a>单例模式篇</h1><p>标签： #Share</p><h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p><font color="red">别名：单件模式</font></p><h2 id="单例模式的诞生"><a href="#单例模式的诞生" class="headerlink" title="单例模式的诞生"></a>单例模式的诞生</h2><p>【<font color="blue">开发</font>】：老大，为什么我保存配置信息，每次都和我预期的不一样啊，总是会覆盖？</p><p>【<font color="red">BOSS</font>】：哈？我来看看。</p><p>【<font color="red">BOSS</font>】：你每次使用的时候都会new一个新的配置对象吗？</p><p>【<font color="blue">开发</font>】：对啊，有什么问题？</p><p>【<font color="red">BOSS</font>】：那肯定不对啊，像这种配置信息，全局只应该有一个，不然会互相影响！</p><p><img src="/2023/02/06/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/image-20200524135834920.png" alt="image-20200524135834920"></p><h2 id="HeadFirst-核心代码"><a href="#HeadFirst-核心代码" class="headerlink" title="HeadFirst 核心代码"></a>HeadFirst 核心代码</h2><h3 id="饿汉型-（不推荐）"><a href="#饿汉型-（不推荐）" class="headerlink" title="饿汉型 （不推荐）"></a>饿汉型 （不推荐）</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HazardousTypeSingleton</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">App</span> <span class="hljs-variable">APP</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">App</span>();    <span class="hljs-comment">// 私有构造方法</span>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">HazardousTypeSingleton</span> <span class="hljs-params">()</span> &#123;&#125;    <span class="hljs-comment">// 类加载时已初始化，不会有多线程的问题</span>    <span class="hljs-keyword">static</span> App <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;APP - 饿汉型模式&quot;</span>);        <span class="hljs-keyword">return</span> APP;    &#125;&#125;</code></pre><blockquote><p>名字由来：因为随着类加载而加载，显得很“急迫”，所以称之为饿汉型</p></blockquote><p><strong>评价：</strong>这样的写法和全局变量没有本质的区别，不推荐</p><h3 id="懒汉型-（不推荐）"><a href="#懒汉型-（不推荐）" class="headerlink" title="懒汉型 （不推荐）"></a>懒汉型 （不推荐）</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LazyTypeSingleton</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-title function_">LazyTypeSingleton</span> <span class="hljs-params">()</span> &#123;&#125;    <span class="hljs-comment">// 静态私用成员，没有初始化</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">App</span> <span class="hljs-variable">intance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 直接加synchronized关键字</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">synchronized</span>  <span class="hljs-keyword">static</span> App <span class="hljs-title function_">getIntance</span> <span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;APP - 懒汉型模式&quot;</span>);        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == intance) &#123;            intance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">App</span>();            <span class="hljs-keyword">return</span> intance;        &#125;        <span class="hljs-keyword">return</span> intance;    &#125;&#125;</code></pre><blockquote><p>名字由来：调用时才加载，因此称之为懒汉型</p></blockquote><p><strong>评价：</strong>这样写有延迟加载的功能，但是加了一个synchronized大锁，因此多线程环境下效率较低</p><h3 id="懒汉型之双重锁校验-🧡"><a href="#懒汉型之双重锁校验-🧡" class="headerlink" title="懒汉型之双重锁校验 🧡"></a>懒汉型之双重锁校验 🧡</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LazyTypeSingleton</span> &#123;    <span class="hljs-comment">// volatile关键字修饰，防止指令重排</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-type">App</span> <span class="hljs-variable">app</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * Double Check Lock（DCL） 双重锁校验</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">static</span> App <span class="hljs-title function_">getInstanceByDCL</span> <span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == app) &#123;            <span class="hljs-keyword">synchronized</span> (LazyTypeSingleton.class) &#123;                <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == app) &#123;                    System.out.println(<span class="hljs-string">&quot;APP - 饿汉模式DCL 双重锁校验&quot;</span>);                    app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">App</span>();                    <span class="hljs-keyword">return</span> app;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> app;    &#125;&#125;</code></pre><blockquote><p>注意volatile关键字起到的作用，详情请见：<a href="https://juejin.im/post/5ebadd9df265da7bda414c20">https://juejin.im/post/5ebadd9df265da7bda414c20</a></p></blockquote><p><strong>评价：</strong>比较推荐的写法，可以保证线程安全，同时具备延时加载的效果</p><h3 id="静态内部类方式🧡"><a href="#静态内部类方式🧡" class="headerlink" title="静态内部类方式🧡"></a>静态内部类方式🧡</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnterTypeSingleton</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-title function_">InnterTypeSingleton</span><span class="hljs-params">()</span>&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();    &#125;    <span class="hljs-comment">// 静态内部类方式，类似饿汉保证天然的线程安全</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHolder</span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">App</span> <span class="hljs-variable">app</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">App</span>();    &#125;    <span class="hljs-keyword">static</span> App <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;        System.out.println(<span class="hljs-string">&quot;APP - 静态内部类方式(Holder)&quot;</span>);        <span class="hljs-keyword">return</span> SingletonHolder.app;    &#125;&#125;</code></pre><p><strong>评价：</strong>线程安全，调用效率高，可以延时加载</p><h3 id="静态内部类之神奇的报错"><a href="#静态内部类之神奇的报错" class="headerlink" title="静态内部类之神奇的报错"></a>静态内部类之神奇的报错</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnterTypeSingletonError</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-title function_">InnterTypeSingletonError</span><span class="hljs-params">()</span>&#123;        System.out.println(<span class="hljs-number">5</span> / <span class="hljs-number">0</span>);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHolder</span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">InnterTypeSingletonError</span> <span class="hljs-variable">app</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InnterTypeSingletonError</span>();    &#125;    <span class="hljs-keyword">static</span> InnterTypeSingletonError <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;        System.out.println(<span class="hljs-string">&quot;APP - 静态内部类方式(Holder)&quot;</span>);        <span class="hljs-keyword">return</span> SingletonHolder.app;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;        <span class="hljs-keyword">try</span> &#123;            InnterTypeSingletonError.getInstance();        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;            t.printStackTrace();        &#125;        <span class="hljs-keyword">try</span> &#123;            InnterTypeSingletonError.getInstance();        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;            t.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>注意看上文中代码块：</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-title function_">InnterTypeSingletonError</span><span class="hljs-params">()</span>&#123;System.out.println(<span class="hljs-number">5</span> / <span class="hljs-number">0</span>);&#125;</code></pre><p>这样一定会出错，运行结果报错信息如下：</p><pre><code class="hljs properties"><span class="hljs-attr">APP</span> <span class="hljs-string">- 静态内部类方式(Holder)</span><span class="hljs-attr">APP</span> <span class="hljs-string">- 静态内部类方式(Holder)</span><span class="hljs-attr">java.lang.ExceptionInInitializerError</span><span class="hljs-attr">at</span> <span class="hljs-string">com.design.singleton.InnterTypeSingletonError.getInstance(InnterTypeSingletonError.java:23)</span><span class="hljs-attr">at</span> <span class="hljs-string">com.design.singleton.InnterTypeSingletonError.main(InnterTypeSingletonError.java:28)</span><span class="hljs-attr">Caused</span> <span class="hljs-string">by: java.lang.ArithmeticException: / by zero</span><span class="hljs-attr">at</span> <span class="hljs-string">com.design.singleton.InnterTypeSingletonError.&lt;init&gt;(InnterTypeSingletonError.java:14)</span><span class="hljs-attr">at</span> <span class="hljs-string">com.design.singleton.InnterTypeSingletonError.&lt;init&gt;(InnterTypeSingletonError.java:11)</span><span class="hljs-attr">at</span> <span class="hljs-string">com.design.singleton.InnterTypeSingletonError$SingletonHolder.&lt;clinit&gt;(InnterTypeSingletonError.java:18)</span><span class="hljs-attr">...</span> <span class="hljs-string">2 more</span><span class="hljs-attr">java.lang.NoClassDefFoundError</span>: <span class="hljs-string">Could not initialize class com.design.singleton.InnterTypeSingletonError$SingletonHolder</span><span class="hljs-attr">at</span> <span class="hljs-string">com.design.singleton.InnterTypeSingletonError.getInstance(InnterTypeSingletonError.java:23)</span><span class="hljs-attr">at</span> <span class="hljs-string">com.design.singleton.InnterTypeSingletonError.main(InnterTypeSingletonError.java:34)</span></code></pre><p>可以发现它第一次报错是正常的异常，第二次如果再报错就是<font color="blue">Could not initialize class </font>，为什么呢？</p><p>因为：<strong>类加载时静态变量只会在第一次加载时，进行初始化，此后不管成不成功，都不会进行第二次初始化了</strong></p><p>所以使用的时候需要注意</p><h3 id="枚举方式🧡"><a href="#枚举方式🧡" class="headerlink" title="枚举方式🧡"></a>枚举方式🧡</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span>  <span class="hljs-title class_">EnumSingleton</span> &#123;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * APP对象</span><span class="hljs-comment">     */</span>    APP;    <span class="hljs-keyword">private</span> App app;    EnumSingleton() &#123;        app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">App</span>();    &#125;    <span class="hljs-keyword">public</span> App <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;**************************&quot;</span>);        System.out.println(<span class="hljs-string">&quot;APP - 枚举方式&quot;</span>);        <span class="hljs-keyword">return</span> app;    &#125;&#125;</code></pre><p><strong>评价：</strong>线程安全，调用效率高，不能延时加载，可以天然的防止反射和反序列化调用</p><h3 id="什么场景适用"><a href="#什么场景适用" class="headerlink" title="什么场景适用"></a>什么场景适用</h3><p>在以下情况可以使用单例模式：</p><ul><li>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时</li><li>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时</li></ul><h3 id="Code-生活中的实际应用"><a href="#Code-生活中的实际应用" class="headerlink" title="Code&#x2F;生活中的实际应用"></a>Code&#x2F;生活中的实际应用</h3><p>在很多项目中的数据库连接池，亦或是配置中心，配置文件对象等等，非常常见~</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>感谢Java3Y的文章：<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247487997&idx=1&sn=49c53a5cd66a6abf6cdf261de501206a&chksm=ebd750fcdca0d9eab476e21dfae06a4a81da4732fdc8698536e6466a7c8843ab6d9dcfa3a003&scene=126&sessionid=1590301045&key=b1bca8bd86b0ad8c164b148788862fa06cb138632b5964ec6f43017e86abb318e4ae4ace123f10a8a5cddff82896564cc9aaf68ba9a06e75a7c15da859f29061a6ca6b313fc185edf422dd6fd48b1778&ascene=1&uin=MjMxMjY2NTAwMw==&devicetype=Windows+10+x64&version=62090070&lang=zh_CN&exportkey=Ac5DfHaLdHapqlkgTQV/0uY=&pass_ticket=52XHEG2v/3jbLNsGB58V0iQlGTQCZcBqIQ64EdwtExoOuAs8XSGQBjaGtniIitaV">三歪写Bug写哭了</a>，从中学习到了内部类使用时的神器报错</p><p>单例模式使用的场景其实固化，任何需要单一对象工作时的场景都可以使用单例模式，同时只推荐以下三种写法：</p><ul><li>基于双重锁校验的懒汉型</li><li>静态内部类方式</li><li>枚举方式</li></ul><h2 id="相关代码链接"><a href="#相关代码链接" class="headerlink" title="相关代码链接"></a>相关代码链接</h2><p><a href="https://github.com/kkzhilu/Kerwin-DesignPattern">GitHub地址</a></p><ul><li>兼顾了《HeadFirst》以及《GOF》两本经典书籍中的案例</li><li>提供了友好的阅读指导</li></ul><p><img src="/2023/02/06/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/%E5%BE%AE%E4%BF%A1%E4%BA%8C%E7%BB%B4%E7%A0%81.png"></p>]]></content>
    
    
    <categories>
      
      <category>编码及设计模式篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单例模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原型模式</title>
    <link href="/2023/02/06/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/02/06/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="原型模式篇"><a href="#原型模式篇" class="headerlink" title="原型模式篇"></a>原型模式篇</h1><p>标签： #Share</p><h3 id="官方解释"><a href="#官方解释" class="headerlink" title="官方解释"></a>官方解释</h3><p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。</p><h3 id="命令模式生活中使用"><a href="#命令模式生活中使用" class="headerlink" title="命令模式生活中使用"></a>命令模式生活中使用</h3><p>用原型模式实现细胞分裂</p><p>分析：所有细胞的构造，构造都相同，无需重新从无到有的创建，而是以类似克隆的方式即可</p><h3 id="官方示例"><a href="#官方示例" class="headerlink" title="官方示例"></a>官方示例</h3><p>Head First：<a href="https://www.cnblogs.com/xcsn/p/7352136.html">https://www.cnblogs.com/xcsn/p/7352136.html</a></p><p>菜鸟教程：<a href="https://www.runoob.com/design-pattern/prototype-pattern.html">https://www.runoob.com/design-pattern/prototype-pattern.html</a></p><p>简书：<a href="https://www.jianshu.com/p/1e41ee3ac4b5">https://www.jianshu.com/p/1e41ee3ac4b5</a></p><h3 id="工作举例"><a href="#工作举例" class="headerlink" title="工作举例"></a>工作举例</h3><pre><code class="hljs awk">详情见：https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/kkzhilu/</span>KerwinTools<span class="hljs-regexp">/tree/m</span>aster<span class="hljs-regexp">/src/m</span>ain<span class="hljs-regexp">/java/</span>design/pattern原型模式相关</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 总结</span><span class="hljs-comment"> *    原型模式分为：</span><span class="hljs-comment"> *        Shallow cloning 浅克隆</span><span class="hljs-comment"> *        Deep cloning    深克隆</span><span class="hljs-comment"> *       （实质是Java中关于引用传递的问题）</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 特点</span><span class="hljs-comment"> *    A. 原型模式克隆,不会克隆final关键字的对象，两者不可兼容，另外克隆不会执行构造方法（内存操作，无视构造方法和访问权限）</span><span class="hljs-comment"> *    B. 原型模式是在内存二进制流的拷贝，要比直接new一个对象性能好很多，特别是在一个循环体内产生大量的对象时，原型模式可以更好地体现其优点</span><span class="hljs-comment"> *    C. 从工厂方法到模板...到原型模式  创建对象的方式慢慢从编码过度到基于内存</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 浅度克隆：当被克隆的类中有引用对象（String或Integer等包装类型除外）时，</span><span class="hljs-comment"> *    克隆出来的类中的引用变量存储的还是之前的内存地址，也就是说克隆与被克隆的对象是同一个</span><span class="hljs-comment"> *    这样的话两个对象共享了一个私有变量，所有人都可以改，是一个种非常不安全的方式，在实际项目中使用还是比较少的</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 深度拷贝：final 类型修饰的成员变量不能进行深度拷贝</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 使用场景：</span><span class="hljs-comment"> *     1、在创建对象的时候，我们不只是希望被创建的对象继承其基类的基本结构，还希望继承原型对象的数据。</span><span class="hljs-comment"> * 　　2、希望对目标对象的修改不影响既有的原型对象（深度克隆的时候可以完全互不影响）。</span><span class="hljs-comment"> * 　　3、隐藏克隆操作的细节，很多时候，对对象本身的克隆需要涉及到类本身的数据细节。</span><span class="hljs-comment"> * 　　4、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等；</span><span class="hljs-comment"> * 　　5、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式；</span><span class="hljs-comment"> * 　　6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用</span><span class="hljs-comment"> *    在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone的方法创建一个对象，</span><span class="hljs-comment"> *    然后由工厂方法提供给调用者。</span><span class="hljs-comment"> */</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>编码及设计模式篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原型模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>命令模式</title>
    <link href="/2023/02/06/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/02/06/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="命令模式篇"><a href="#命令模式篇" class="headerlink" title="命令模式篇"></a>命令模式篇</h1><p>标签： #Share</p><h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p><font color="red">将一个请求封装为一个对象</font>，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。</p><h2 id="命令模式的诞生"><a href="#命令模式的诞生" class="headerlink" title="命令模式的诞生"></a>命令模式的诞生</h2><p>【<font color="orange">产品</font>】：开发小哥，来活啦，咱们需要设计一款遥控器，核心功能就是几个按键，但是可能要控制很多不同品牌的设备，你们构思构思吧~</p><p>【<font color="blue">开发</font>】：按键？不存在的，对我来说就是请求罢了，Boss，帮我想一下怎么适配不同的品牌的设备啊？</p><p>【<font color="red">BOSS</font>】：适配设备这个事，仅仅靠我们是不行的，这都是配合的结果，你既然也说了什么按钮只不过是请求而已，那可以考虑使用命令模式，把请求封装为对象，由我们主动去绑定不同品牌对应的执行者，懂了吗？</p><p>【<font color="blue">开发</font>】：哈？哦，懂了懂了（我懂个鬼！）</p><p><img src="/2023/02/06/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/image-20200601010620507.png" alt="image-20200601010620507"></p><h2 id="HeadFirst-核心代码"><a href="#HeadFirst-核心代码" class="headerlink" title="HeadFirst 核心代码"></a>HeadFirst 核心代码</h2><p><strong>父级接口</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Command</span> &#123;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span>;&#125;</code></pre><p><strong>封装请求为一个对象</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LightOnCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> &#123;    Light light;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LightOnCommand</span><span class="hljs-params">(Light light)</span> &#123;        <span class="hljs-built_in">this</span>.light = light;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;        light.on();    &#125;&#125;</code></pre><p><strong>请求响应的Api</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Light</span> &#123;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * on方法</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">on</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;On...&quot;</span>);    &#125;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * off方法</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">off</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;Off...&quot;</span>);    &#125;&#125;</code></pre><p><strong>调用方代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleRemoteControl</span> &#123;    Command slot;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SimpleRemoteControl</span><span class="hljs-params">()</span> &#123;&#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCommand</span><span class="hljs-params">(Command command)</span> &#123;        slot = command;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buttonWasPressed</span><span class="hljs-params">()</span> &#123;        slot.execute();    &#125;&#125;<span class="hljs-comment">//******************************************</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;    <span class="hljs-type">SimpleRemoteControl</span> <span class="hljs-variable">remote</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleRemoteControl</span>();    <span class="hljs-type">Light</span> <span class="hljs-variable">light</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Light</span>();    <span class="hljs-type">LightOnCommand</span> <span class="hljs-variable">lightOn</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LightOnCommand</span>(light);    remote.setCommand(lightOn);    remote.buttonWasPressed();    <span class="hljs-type">LightOffCommand</span> <span class="hljs-variable">lightOff</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LightOffCommand</span>(light);    remote.setCommand(lightOff);    remote.buttonWasPressed();&#125;</code></pre><p><font color="red">命令模式的设计思路</font>：</p><ul><li>Command                   声明命令的接口</li><li>ConcreteCommand   具体的动作 | 命令</li><li>Client                          客户端请求</li><li>Invoker                       绑定命令与接收者</li><li>Receiver                     接收者  知道如何实施与执行一个请求相关的操作，任何类都可以是接收者</li></ul><p>代码的核心即：把请求抽象为一个命令，把执行命令的接收者和命令本身分离，交由第三方类（Invoker）去管理，达到解耦的目的</p><h2 id="试试用命令模式封装简单Jedis"><a href="#试试用命令模式封装简单Jedis" class="headerlink" title="试试用命令模式封装简单Jedis"></a>试试用命令模式封装简单Jedis</h2><h3 id="Redis协议Tips"><a href="#Redis协议Tips" class="headerlink" title="Redis协议Tips"></a>Redis协议Tips</h3><p>Redis 即 REmote Dictionary Server (远程字典服务)；</p><p>而Redis的协议规范是 Redis Serialization Protocol (Redis序列化协议)</p><p>RESP 是redis客户端和服务端之前使用的一种通讯协议；</p><p>RESP 的特点：实现简单、快速解析、可读性好</p><p>协议如下：</p><p>客户端以规定格式的形式发送命令给服务器</p><pre><code class="hljs java"><span class="hljs-comment">/***</span><span class="hljs-comment"> * set key value 协议翻译如下：</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * * 3    -&gt;  表示以下有几组命令</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * $ 3    -&gt;  表示命令长度是3</span><span class="hljs-comment"> * SET</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * $6     -&gt;  表示长度是6</span><span class="hljs-comment"> * keykey</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * $5     -&gt;  表示长度是5</span><span class="hljs-comment"> * value</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 完整即：</span><span class="hljs-comment"> * * 3</span><span class="hljs-comment"> * $ 3</span><span class="hljs-comment"> * SET</span><span class="hljs-comment"> * $6</span><span class="hljs-comment"> * keykey</span><span class="hljs-comment"> * $5 </span><span class="hljs-comment"> * value</span><span class="hljs-comment">*/</span></code></pre><blockquote><p>关于Redis相关的RESP协议，我在之后的文章会专门出一篇讲解~</p></blockquote><h3 id="封装Get命令"><a href="#封装Get命令" class="headerlink" title="封装Get命令"></a>封装Get命令</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GetCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> &#123;    <span class="hljs-keyword">private</span> GetReceiver receiver;    <span class="hljs-keyword">private</span> String arg;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;        receiver.doCommand(<span class="hljs-built_in">this</span>.arg);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">GetCommand</span><span class="hljs-params">(GetReceiver receiver, String arg)</span> &#123;        <span class="hljs-built_in">this</span>.receiver = receiver;        <span class="hljs-built_in">this</span>.arg = arg;    &#125;&#125;</code></pre><h3 id="封装Get接收者"><a href="#封装Get接收者" class="headerlink" title="封装Get接收者"></a>封装Get接收者</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GetReceiver</span> &#123;    OutputStream write;    InputStream read;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doCommand</span> <span class="hljs-params">(String arg)</span> &#123;        String[] strings = arg.split(<span class="hljs-string">&quot; &quot;</span>);        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> strings[<span class="hljs-number">0</span>];        <span class="hljs-type">byte</span>[] bytes;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-type">String</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;*2&quot;</span> + SPILT +                    <span class="hljs-string">&quot;$3&quot;</span> + SPILT +                    <span class="hljs-string">&quot;GET&quot;</span> + SPILT +                    <span class="hljs-string">&quot;$&quot;</span> + key.getBytes().length + SPILT +                    key + SPILT;            write.write(sb.getBytes());            bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];            read.read(bytes);            System.out.println(<span class="hljs-string">&quot;Result: &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes));        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">GetReceiver</span><span class="hljs-params">(OutputStream write, InputStream read)</span> &#123;        <span class="hljs-built_in">this</span>.write = write;        <span class="hljs-built_in">this</span>.read = read;    &#125;    <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SPILT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;\r\n&quot;</span>;&#125;</code></pre><h3 id="封装Invoker"><a href="#封装Invoker" class="headerlink" title="封装Invoker"></a>封装Invoker</h3><p>利用栈存储命令，可以很好的控制命令的变化等等</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Invoker</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Stack&lt;Command&gt; commands;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Invoker</span><span class="hljs-params">()</span> &#123;        commands = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCommand</span><span class="hljs-params">(Command command)</span> &#123;        commands.push(command);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">undoCommand</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (!commands.empty()) &#123;            commands.pop();        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">while</span> (!commands.empty()) &#123;            <span class="hljs-type">Command</span> <span class="hljs-variable">command</span> <span class="hljs-operator">=</span> commands.pop();            command.execute();        &#125;    &#125;&#125;</code></pre><h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><pre><code class="hljs java"><span class="hljs-comment">/***</span><span class="hljs-comment">    * 简易Jedis代码, 利用栈存储命令(可根据需求更改数据结构)</span><span class="hljs-comment">    *</span><span class="hljs-comment">    * 推荐阅读顺序：</span><span class="hljs-comment">    * <span class="hljs-doctag">@see</span> Command</span><span class="hljs-comment">    * <span class="hljs-doctag">@see</span> GetCommand | SetCommand</span><span class="hljs-comment">    * <span class="hljs-doctag">@see</span> GetReceiver | SetReceiver</span><span class="hljs-comment">    * <span class="hljs-doctag">@see</span> Invoker</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;       <span class="hljs-comment">// 初始化Socket流</span>       <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>);       <span class="hljs-type">OutputStream</span> <span class="hljs-variable">write</span> <span class="hljs-operator">=</span> socket.getOutputStream();       <span class="hljs-type">InputStream</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> socket.getInputStream();       <span class="hljs-type">Invoker</span> <span class="hljs-variable">invoker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Invoker</span>();       <span class="hljs-comment">// 初始化Get | Set任务执行者</span>       <span class="hljs-type">GetReceiver</span> <span class="hljs-variable">getReceiver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GetReceiver</span>(write, read);       <span class="hljs-type">SetReceiver</span> <span class="hljs-variable">setReceiver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SetReceiver</span>(write, read);       <span class="hljs-comment">// 测试get命令</span>       invoker.addCommand(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GetCommand</span>(getReceiver, <span class="hljs-string">&quot;key&quot;</span>));       <span class="hljs-comment">// 测试set命令</span>       invoker.addCommand(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SetCommand</span>(setReceiver, <span class="hljs-string">&quot;key xixixi&quot;</span>));       <span class="hljs-comment">// 测试get命令</span>       invoker.addCommand(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GetCommand</span>(getReceiver, <span class="hljs-string">&quot;key&quot;</span>));       <span class="hljs-comment">// 测试get命令</span>       invoker.addCommand(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GetCommand</span>(getReceiver, <span class="hljs-string">&quot;key&quot;</span>));       <span class="hljs-comment">// 测试撤销上一个命令 -&gt; 输出四次则测试失败，三次则成功</span>       invoker.undoCommand();       invoker.execute();   &#125;</code></pre><p>输出结果：</p><pre><code class="hljs java"><span class="hljs-comment">/***</span><span class="hljs-comment"> * Result: $4</span><span class="hljs-comment"> * test</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Result: +OK</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Result: $6</span><span class="hljs-comment"> * xixixi</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * // 测试成功~</span><span class="hljs-comment"> */</span></code></pre><blockquote><p>代码量有点小多，需要看详情的话，请跳转到最下面的相关代码链接吧~</p></blockquote><h2 id="什么场景适用"><a href="#什么场景适用" class="headerlink" title="什么场景适用"></a>什么场景适用</h2><p>在下列情况下可以使用 Command Method模式：</p><ul><li>需要抽象出待执行的动作以参数化某对象</li><li>在不同的时刻指定，排列和执行请求</li><li>支持取消操作</li></ul><h2 id="Code-生活中的实际应用"><a href="#Code-生活中的实际应用" class="headerlink" title="Code&#x2F;生活中的实际应用"></a>Code&#x2F;生活中的实际应用</h2><p>在日常生活中都有订单的概念，为什么我们下订单，服务员或者其他工作人员完全明白我们的意图呢？就是因为我们按照他们制定的规则构建起了一个命令，那么在交互过程就不需要层层沟通，方便解耦。</p><h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><p><img src="/2023/02/06/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/image-20200601232728451.png" alt="image-20200601232728451"></p><h2 id="遵循的设计原则"><a href="#遵循的设计原则" class="headerlink" title="遵循的设计原则"></a>遵循的设计原则</h2><ul><li>针对接口编程，不针对实现编程</li><li>为交互对象松耦合设计而努力</li><li>类应该对拓展开放，对修改关闭</li></ul><h2 id="相关代码链接"><a href="#相关代码链接" class="headerlink" title="相关代码链接"></a>相关代码链接</h2><p><a href="https://github.com/kkzhilu/Kerwin-DesignPattern">GitHub地址</a></p><ul><li>兼顾了《HeadFirst》以及《GOF》两本经典书籍中的案例</li><li>提供了友好的阅读指导</li></ul><p><img src="/2023/02/06/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/%E5%BE%AE%E4%BF%A1%E4%BA%8C%E7%BB%B4%E7%A0%81.png"></p>]]></content>
    
    
    <categories>
      
      <category>编码及设计模式篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>命令模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>商品治理</title>
    <link href="/2023/02/06/%E5%95%86%E5%93%81%E6%B2%BB%E7%90%86/"/>
    <url>/2023/02/06/%E5%95%86%E5%93%81%E6%B2%BB%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="京东到家商品治理体系的建设"><a href="#京东到家商品治理体系的建设" class="headerlink" title="京东到家商品治理体系的建设"></a>京东到家商品治理体系的建设</h1><p>标签： #Share</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>京东到家作为一个即时零售的电商平台，在提供1小时送达极致服务的同时也力求将万千好物送到消费者的手中。为了不断提高平台露出商品的价值，提高用户的满意度，我们设计并投入使用了京东到家商品治理系统，其主要职责是对商品新建、修改、呈现的全链路流程进行干预及核验，旨在<code>发现</code>并<code>解决</code>商品信息中如：敏感词、虚假宣传、错误信息等不符合平台规范和质量要求的问题，保证商品与实物的匹配度，信息的正确性等。</p><h2 id="系统架构介绍"><a href="#系统架构介绍" class="headerlink" title="系统架构介绍"></a>系统架构介绍</h2><p>京东到家各业务线采用的是标准化的微服务架构设计，各个系统在迭代过程中只用按需申请对应的组件即可，下图为治理系统所用到的技术组件：</p><ul><li>消息中间件：使用京东的MQ中间件，实现业务解耦。</li><li>存储：Redis集群、MySQL集群等。</li><li>Worker：基于TBSchedule分布式调度引擎框架构建的服务，进行定时任务的执行和分发。</li><li>服务监控：采用统一监控与告警服务平台，可以达到秒级监控、多方位监控、服务告警、全链路追踪等能力。</li><li>服务间调用：使用京东的JSF平台，实现服务间注册、服务间调用，服务治理等能力，支持请求超时自动阻断。</li><li>日志服务：日志采集与查询服务。</li></ul><p><img src="/2023/02/06/%E5%95%86%E5%93%81%E6%B2%BB%E7%90%86/image-20220518072116799.png" alt="image-20220518072116799"></p><h2 id="早期的治理系统"><a href="#早期的治理系统" class="headerlink" title="早期的治理系统"></a>早期的治理系统</h2><p>治理系统的第一个需求与大多数业务系统类似，是基于数据的增删改查，构建一套敏感词管理模块，同时为商品主系统提供敏感词的校验能力。</p><p>它的第二个需求是为运营同学提供一个核验结果的报表，其主要逻辑是通过上传Excel，内部解析完成后调用接口得到相应的数据结果，基于MySQL进行存储，然后提供查询及展示的能力，以便运营使用。</p><p>但由于缺乏设计和长远的思考，因此当时的治理系统与商品主系统耦合严重，图示如下：</p><p><img src="/2023/02/06/%E5%95%86%E5%93%81%E6%B2%BB%E7%90%86/image-20220518064404134.png" alt="image-20220518064404134"></p><p>而随着平台对商品信息合规性的要求越来越严格，针对商品分类、毛重、图片等等诸多的治理需求也就接踵而来。但在上图的设计之中，我们不难发现，治理系统是以具体的业务来构建对外接口的，那随着业务需求的不断增加，两个系统之间交互的接口个数也会出现暴涨，这是我们不希望看到的。</p><p>另外，治理的最终目的是期望商品上的问题能够得到<code>解决</code>，而不仅仅只是<code>发现</code>，因此将问题暴露给运营或者商家，是势在必行的，但当下存在两个问题：</p><ol><li><p><strong>商品系统在自身的主流程中强依赖治理的核验能力，且随着业务的增加，依赖会越来越多。</strong></p></li><li><p><strong>商品系统只能将前置拦截的核验结果告知商家，业务覆盖面不全。</strong></p></li></ol><p>再加上有诸多问题是属于弱合规性（不需要强制拦截但又需要解决），<strong>因此我们决定将商品治理业务的核心由商品系统转为治理系统</strong>。</p><p>为了实现高效率的商品治理，我们对治理系统的设计要求和定位作出了一点变更，提出了两项基本原则：</p><ul><li><code>治理系统需要完成整个治理业务的闭环，作为商品问题发现及解决的总入口和总出口</code></li><li><code>治理系统需要具备高拓展性，当增加特定化治理需求时能够迅速响应</code></li></ul><h2 id="业务架构升级"><a href="#业务架构升级" class="headerlink" title="业务架构升级"></a>业务架构升级</h2><h3 id="抽象思维显神威"><a href="#抽象思维显神威" class="headerlink" title="抽象思维显神威"></a>抽象思维显神威</h3><p>在理清治理系统的业务架构升级思路之后，我们首先需要确定的一个问题就是：<strong>治理系统最基础的原子能力是什么？</strong></p><p>以各个主系统为例，商品系统最基础的原子能力即：商品的创建、修改和提供查询能力、库存系统最基础的原子能力即：商品库存信息的维护及查询能力。根据治理业务的发展规划，我们也基本确定出治理系统的原子能力，即：<strong>发现商品存在的合规问题，并向外提供查询和辅助解决的能力</strong>。</p><p>对于<code>合规问题</code>的定义，我们做出了如下解释，即：<code>不符合电商平台商品展示规范的如敏感词、虚假渲传等问题。</code></p><p>例如商品名称中包含敏感词，会映射为敏感词问题，另外需要说明的是：在编码阶段中，一种可量化的具体规则可以确定对应的一种合规问题，且同一个商品可能同时存在多个不同的合规问题。</p><p>目前到家治理系统所涉猎的合规问题主要有：</p><p>| 合规问题大类         | 对外描述                       | 问题细节                                               |<br>| – |  |  |<br>| 商品毛重问题         | 商品毛重不准确                 | 商品毛重与实际商品不符、商品毛重超过最大运力限制等     |<br>| 商品信息不正确       | 商品信息不正确，请检查具体内容 | 商品名称包含敏感词、商品分类与实际商品不符、虚假宣传等 |<br>| 商家商品经营范围问题 | 当前售卖商品超出商家经营范围   | 当前售卖商品超出商家经营范围等                         |<br>| 图片信息问题         | 商品图片信息存在问题           | 商品无主图、商品主图为默认图、商品主图为黑底图等       |<br>|                      |                                |                                                        |<br>| <strong>未来计划</strong>         |                                |                                                        |<br>| <code>商品价格问题</code>       | –                             | –                                                     |<br>| <code>商品画像问题</code>       | –                             | –                                                     |<br>| <code>...</code>                |                                |                                                        |</p><p>为了方便理解，我们可以将每一种<strong>合规问题看作是一种策略</strong>，而针对策略的顶层接口又定义了四个核心方法：</p><ul><li>映射关联的枚举：每一个问题都需要关联具体的问题原因</li><li>问题关联的字段：每一个问题都需要关联具体的影响字段或被影响字段</li><li>自定义过滤能力：根据业务特点，减少无用处理</li><li>核验方法：根据业务规则实现的具体核验逻辑</li></ul><p>具体的实现逻辑如下图所示：</p><p><img src="/2023/02/06/%E5%95%86%E5%93%81%E6%B2%BB%E7%90%86/image-20220520113616054.png" alt="image-20220520113616054"></p><p>下图为<strong>商品毛重信息填写错误</strong>问题处理前后的展示结果：</p><p><img src="/2023/02/06/%E5%95%86%E5%93%81%E6%B2%BB%E7%90%86/image-20220516144949447.png" alt="image-20220516144949447"></p><p><img src="/2023/02/06/%E5%95%86%E5%93%81%E6%B2%BB%E7%90%86/image-20220516144715540.png" alt="image-20220516144715540"></p><p>毛重问题有其对应的关联枚举及文案映射，即：商品毛重不准确（问题类型），推荐毛重为 XXX（文案映射），所关联的字段为：商品重量及商品名称，再配合一定的过滤逻辑及核验算法，那么毛重问题的抽象实体也就完成了，以此类推，我们后续在增加新的治理问题时，采用类似的方式即可。</p><p>如果是对设计模式涉猎较多的读者应该已经判断出来，这种设计方案其实就是策略模式及模板方法模式的变种罢了，在编码阶段也肯定少不了工厂的使用，在编码层面整体的变化如下图所示：</p><p><img src="/2023/02/06/%E5%95%86%E5%93%81%E6%B2%BB%E7%90%86/image-20220518082356305.png" alt="image-20220518082356305"></p><p>上述方案落地之后，产研侧对于治理业务的后续发展达成了基本共识，同时需求的实现也变得简单起来，我们不用再关注其他系统的逻辑，而是着眼于具体合规问题的业务规则实现上。</p><p>业务方和产品可以更好的通过数据分析来确定未来的治理重点和需求规划，研发人员也以优雅的方式解决了系统间耦合、业务代码重复的问题。</p><h3 id="难点问题巧手破"><a href="#难点问题巧手破" class="headerlink" title="难点问题巧手破"></a>难点问题巧手破</h3><p>初步定义好治理系统的业务架构设计后，在后续迭代的过程中，我们遇到了两个较为棘手的问题，一个是业务问题，一个是技术问题。</p><h4 id="业务问题"><a href="#业务问题" class="headerlink" title="业务问题"></a>业务问题</h4><p>业务方要求APP展示的商品主图不能与默认图（例如空白图、品牌商标图等不能体现商品信息的图片）一致，然而商品图片的核验逻辑一直由图片核验系统承接。</p><p>这就引起了一个问题：<strong>治理系统是否需要集成图片核验逻辑，如果不集成，那又该如何将其图片违规问题纳入至治理体系中？</strong></p><p>如果是经验丰富的开发者一定会提出使用MQ的方式由图片核验系统发送核验结果至治理系统，来解决这个问题。实际上我们也是这么做的，只不过做的更彻底一些。</p><p>在设计模式当中，我们通常会将一系列类似业务整合成一个公共接口向外提供能力，我们将它称之为：门面模式或者外观模式。</p><p>对于上述的类似问题，我们找到了公共的处理思路，即：<code>将治理系统作为门面，其他系统作为组件，各系统都可以主动的向治理系统提供需要治理的内容</code>。</p><p>该方案确定之后，各种令人头痛的业务场景也就变得简单起来，而且此举还扩大了治理系统的边界，例如商品无图合规问题，商品差评率高的问题，只需要对应系统将相关数据&#x2F;结果以MQ的形式发送至治理系统，然后由治理系统为其绑定具体的合规问题即可。</p><p>在编码层面我们采用的是最简单的MQ解耦的方式实现，示意图如下：</p><p><img src="/2023/02/06/%E5%95%86%E5%93%81%E6%B2%BB%E7%90%86/image-20220518084104202.png" alt="image-20220518084104202"></p><h4 id="技术问题"><a href="#技术问题" class="headerlink" title="技术问题"></a>技术问题</h4><p>在治理迭代的过程中，有一系列的需求是针对平台商品的图片进行治理，以破损图逻辑为例。</p><p>在最开始的处理逻辑中，大家查询资料整合信息，发现平台偶尔出现的破损图是由于图片在下载过程中未下载完整后流中断，触发上传引起的。因此在第一版的逻辑中，我们查阅资料作出了如下逻辑判断：当图片下载完成触发上传前，对比请求体中的<code>ContentLength</code>与实际图片字节大小，问题初步解决。</p><p>但是过了不久问题再次爆发，此时我们发现事情没有那么简单。</p><p>由于到家平台对接众多的商家系统，各个系统的图片服务器与后台逻辑不一，导致我们无法对所有图片都使用文件大小比对的方式，因此我们重新调研并实现了针对破损图的核验能力。</p><p><img src="/2023/02/06/%E5%95%86%E5%93%81%E6%B2%BB%E7%90%86/0.png" alt="img"></p><p>即通过下载后的图片内容进行处理和分析，利用算法与目标问题的业务特征来进行识别，至此，问题基本解决。</p><p>同时，基于该思路我们也衍生出针对<strong>黑底图</strong>、<strong>默认图</strong>的处理方式，在图片问题的治理上更进一步。</p><h3 id="治理触达终落地"><a href="#治理触达终落地" class="headerlink" title="治理触达终落地"></a>治理触达终落地</h3><p>基于上述的方案和设计，治理系统在<code>问题发现</code>的流程上已经趋于完善，接下来，产品提出了新的要求，即：<code>部分问题实现自动治理及问题触达商家</code>。</p><p>笔者在之前了解机器学习方面的知识时，注意到这样一个特点，在机器学习中，模型可以分为两种：判别模型和生成模型。忽略掉其具体含义，吸收其设计思想，我们也可以将治理系统分为两个阶段，即：<code>发现</code>和<code>解决</code>。</p><p>上述的业务抽象以及技术问题、业务问题都是在用以<code>发现</code>问题，当我们将<code>解决</code>问题的目标纳入到整个治理体系时，只需要对现有结构进行一定程度的拓展即可满足。</p><p>仍然以商品毛重信息填写错误问题举例，我们只需要在上文的抽象中增加两个待实现方法：</p><ul><li>是否需要自动处理：毛重问题需要自动处理</li><li>自动处理的具体实现规则：当实际毛重大于某一阈值时，将商品系统下架处理（依托于商品对外接口能力）</li></ul><p>在核验结果入库前，根据具体的实现逻辑以及数据反馈结果来判断需要人工处理还是系统处理即可。</p><p>而对于触达需求，其实现就更简单了，因为我们在最初就定义好了治理业务沟通的基本要素是一个个具体的治理问题，我们只需要将存储好的数据以接口亦或是MQ的形式露出即可。</p><p>至此，整个治理体系从编码层面也就建设完成，其核心逻辑在三个环节：</p><ol><li>商品变动MQ&#x2F;其他系统治理内容通知触发具体合规问题核验。</li><li>针对核验结果进行判断：人工处理或系统自动处理（处理的能力需借助于商品对外接口）。</li><li>核验结果对外露出。</li></ol><p>下图为治理系统当前整体业务结构图：</p><p><img src="/2023/02/06/%E5%95%86%E5%93%81%E6%B2%BB%E7%90%86/image-20220516163306748.png" alt="image-20220516163306748"></p><h2 id="治理业务全景图"><a href="#治理业务全景图" class="headerlink" title="治理业务全景图"></a>治理业务全景图</h2><p>从治理平台业务架构升级至今，已经稳定运行9个多月，在业务发展过程当中，已经累计治理平台商品480W+，构建出了8种识别能力，3种处理方式及两种触达方式。同时立足于商品、标品系统为商品的快速建品、基础信息建设、治理审核等保驾护航，下图为到家治理全景图：</p><p><img src="/2023/02/06/%E5%95%86%E5%93%81%E6%B2%BB%E7%90%86/image-20220516181111121.png" alt="image-20220516181111121"></p><h2 id="未来规划"><a href="#未来规划" class="headerlink" title="未来规划"></a>未来规划</h2><p>目前的治理体系是围绕商品系统的主环节来设计和搭建的，其影响范围较窄，我们完全可以将商品治理的成果运用于商品体系之外的其他系统。</p><p>例如下图中的各个业务场景：</p><p><img src="/2023/02/06/%E5%95%86%E5%93%81%E6%B2%BB%E7%90%86/image-20220321091329235.png" alt="image-20220321091329235"></p><p>以搜索推荐为例，我们可以为各个合规问题制定相应的扣减分数，搜索侧在构建数据时将当前商品的合规分数纳入至自身体系中，在满足搜索条件后按分值大小进行排序。</p><p>另外，也有很多用算法无法识别的问题需要纳入至治理体系中，例如：商品差评率高、退货率高等等。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>随着业务的不断发展，对于商品信息的质量要求也会越来越高，到家治理系统还需要和各个上下游系统一起联动，提供更精细化的商品管控能力，期待未来我们的治理能力越来越出色，为用户提供更加真实、贴合实际的商品数据以及更加优质的服务。</p>]]></content>
    
    
    <categories>
      
      <category>编码及设计模式篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>商品治理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工厂模式</title>
    <link href="/2023/02/06/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/02/06/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="工厂模式篇"><a href="#工厂模式篇" class="headerlink" title="工厂模式篇"></a>工厂模式篇</h1><p>标签： #Share</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在设计模式中关于工厂模式有一点特殊，就标准意义而言我们一般提到的工厂模式一般包括三种：</p><ul><li>简单工厂</li><li>工厂方法模式</li><li>抽象工厂模式</li></ul><blockquote><p><em><strong>其实简单工厂不属于设计模式，由于它的使用场景还是比较多的，因此本篇将会一起介绍一下~</strong></em></p></blockquote><h2 id="工厂模式意图"><a href="#工厂模式意图" class="headerlink" title="工厂模式意图"></a>工厂模式意图</h2><p>工厂模式属于对象创建型模式，无论是上述三种的哪一种都是为了同一个设计原则即<font color="red">依赖抽象，不要依赖具体</font></p><p>简单来说就是把<font color="blue">复杂对象创建（初始化）的细节</font>或者<font color="blue">依赖关系经常可能发生变化的细节</font>交给一个第三方类（工厂类），避免在业务逻辑中书写不必要的内容</p><h2 id="简单工厂模式的简单写法"><a href="#简单工厂模式的简单写法" class="headerlink" title="简单工厂模式的简单写法"></a>简单工厂模式的简单写法</h2><p>简单工厂在实际应用中非常的频繁，假设我们现在需要生产Intel和AMD相关的产品，来看看代码</p><h3 id="静态方法无脑IF-Switch"><a href="#静态方法无脑IF-Switch" class="headerlink" title="静态方法无脑IF | Switch"></a>静态方法无脑IF | Switch</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleFactory</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AbstractCPU <span class="hljs-title function_">createCpu</span> <span class="hljs-params">(String type)</span> &#123;        <span class="hljs-keyword">switch</span> (type) &#123;            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;INTEL&quot;</span>:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntelCpu</span>();            <span class="hljs-keyword">default</span>:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AMDCpu</span>();        &#125;       <span class="hljs-comment">/* if (&quot;INTEL&quot;.equals(type)) &#123;</span><span class="hljs-comment">            return new IntelCpu();</span><span class="hljs-comment">        &#125; else if (&quot;AMD&quot;.equals(type))&#123;</span><span class="hljs-comment">            return new AMDCpu();</span><span class="hljs-comment">        &#125;</span><span class="hljs-comment">        return null;*/</span>    &#125;&#125;</code></pre><blockquote><p><em><strong>此种方式适合非常单一的场景，快速构建工厂代码，不用过多的思考</strong></em></p></blockquote><p>值得注意的是静态方法和普通方法的区别，静态工厂让它不具备继承性，在某些场合可能导致无法扩展的问题，在代码优化层面可以配合枚举，Map等方式继续让代码变得更清爽一些</p><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类，Factory Mehod使一个类的实例化延迟到其子类</p><h3 id="工厂方法模式的诞生"><a href="#工厂方法模式的诞生" class="headerlink" title="工厂方法模式的诞生"></a>工厂方法模式的诞生</h3><p>工厂方法用来处理对象的创建，并将这样的行为封装在子类中，这样，客户程序中关于超类的代码就和子类对象创建代码解耦了。</p><p>咱们还是一样，说说人话：</p><p>【<font color="orange">产品</font>】：最近我们有<font color="red">英特尔和AMD的CPU</font>产品订购方案，您看能不能实现一下相关的代码？</p><p>【<font color="red">BOSS</font>】：它们的装配啊，生产啊等等的<font color="red">细节一样</font>吗？</p><p>【<font color="orange">产品</font>】：嗯嗯，细节流程都是一样的！</p><p>【<font color="red">BOSS</font>】：那个谁，小柯啊，工厂方法模式懂吗，去做吧，给你半天时间，好好设计设计。</p><p><img src="/2023/02/06/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/image-20200524105721242.png" alt="image-20200524105721242"></p><p>【<font color="blue">开发</font>】：好的！（内心OS：我不会啊！！！）</p><h3 id="HeadFirst-核心代码"><a href="#HeadFirst-核心代码" class="headerlink" title="HeadFirst 核心代码"></a>HeadFirst 核心代码</h3><p>不会的话，只能看书学习啦~</p><p><strong>父级接口</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Factory</span> &#123;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 产品订购方案</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> AbstractCPU <span class="hljs-title function_">orderCpu</span> <span class="hljs-params">()</span> &#123;        <span class="hljs-type">AbstractCPU</span> <span class="hljs-variable">cpu</span> <span class="hljs-operator">=</span> generateCpu();        cpu.show();        cpu.prepare();        cpu.box();        <span class="hljs-comment">// 假设有相同的业务处理逻辑...</span>        <span class="hljs-keyword">return</span> cpu;    &#125;    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> AbstractCPU <span class="hljs-title function_">generateCpu</span><span class="hljs-params">()</span>;&#125;</code></pre><p><strong>具体实现</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntelCpuFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Factory</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> AbstractCPU <span class="hljs-title function_">generateCpu</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntelCpu</span>();    &#125;&#125;<span class="hljs-comment">// ****************************************************************</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AMDCpuFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Factory</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> AbstractCPU <span class="hljs-title function_">generateCpu</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AMDCpu</span>();    &#125;&#125;</code></pre><p><font color="red">工厂方法模式的设计思路</font>：</p><ul><li>Product（Document） 定义工厂方法所创建对象的接口</li><li>ConcreteProduct（MyDocument）实现Product接口</li><li>Creator（Factory）声明工厂方法</li><li>ConcreteCreator（MyFactory）具体的工厂类</li></ul><h3 id="什么场景适用"><a href="#什么场景适用" class="headerlink" title="什么场景适用"></a>什么场景适用</h3><p>在下列情况下可以使用 Factory Method模式：</p><ul><li>当一个类不知道它所必须创建的对象的类的时候</li><li>当一个类希望由它的子类来指定它所创建的对象的时候</li><li>当类将创建对象的职责委托给多个子类中的某一个，并且你希望控制哪一个子类实现的时候</li></ul><h3 id="Code-生活中的实际应用"><a href="#Code-生活中的实际应用" class="headerlink" title="Code&#x2F;生活中的实际应用"></a>Code&#x2F;生活中的实际应用</h3><p>例如在工厂生产电池时，对于电池的保管，订货，输送的方式可能完全一致，但是仅型号不一致，因此分别交给A流水线，B流水线进行生产，但是后续的其他流程又是重合的</p><h3 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h3><p><img src="/2023/02/06/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/image-20200524112807802.png" alt="image-20200524112807802"></p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><h3 id="意图-1"><a href="#意图-1" class="headerlink" title="意图"></a>意图</h3><p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类</p><h3 id="抽象工厂模式的诞生"><a href="#抽象工厂模式的诞生" class="headerlink" title="抽象工厂模式的诞生"></a>抽象工厂模式的诞生</h3><p>PS：故事内容承接工厂方法模式的诞生~</p><p>【<font color="orange">产品</font>】：我…  我好像搞错需求了…</p><p>【<font color="red">BOSS</font>】：什么意思？？？</p><p>【<font color="orange">产品</font>】：咱们的订单不是仅仅只生成CPU产品，而是要生成<font color="red">英特尔还有AMD的全系列产品…</font></p><p><img src="/2023/02/06/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/image-20200524113603606.png" alt="image-20200524113603606"></p><p>【<font color="red">BOSS</font>】：你你你你…   之前的功夫都白费了啊！</p><p>【<font color="orange">产品</font>】：不就是生产东西嘛，反正都是生产，我不管，你要给我实现！</p><p>【<font color="red">BOSS</font>】：小柯，委屈你了。</p><p>【<font color="blue">开发</font>】：好吧，那我能问一个问题吗？<font color="red">未来是不是还有可能要生产华为的，联想的？</font></p><p>【<font color="orange">产品</font>】：对！很有可能！如果我们生意做大了！</p><h3 id="HeadFirst-核心代码-1"><a href="#HeadFirst-核心代码-1" class="headerlink" title="HeadFirst 核心代码"></a>HeadFirst 核心代码</h3><p>抽象工厂模式着重点在<font color="red">产品族</font>上，开始撸代码吧~</p><p><strong>父级抽象类</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractFactory</span> &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 创建CPU对象</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> CPU对象</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> AbstractCPU <span class="hljs-title function_">createCpu</span><span class="hljs-params">()</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 创建主板对象</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 主板对象</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> AbstractMotherboard <span class="hljs-title function_">createMainboard</span><span class="hljs-params">()</span>;&#125;</code></pre><p><strong>子类实现</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntelFactory</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">AbstractFactory</span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> AbstractCPU <span class="hljs-title function_">createCpu</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntelCpu</span>();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> AbstractMotherboard <span class="hljs-title function_">createMainboard</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntelMotherboard</span>();    &#125;&#125;<span class="hljs-comment">// *************************************************************</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AMDFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractFactory</span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> AbstractCPU <span class="hljs-title function_">createCpu</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AMDCpu</span>();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> AbstractMotherboard <span class="hljs-title function_">createMainboard</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AMDMotherboard</span>();    &#125;&#125;</code></pre><p><font color="red">抽象工厂模式的设计思路</font>：</p><ul><li>AbstractProduct    为一类产品对象声明一个接口</li><li>ConcreteProduct   具体对象</li><li>AbstractFactory     声明一个创建抽象产品对象的接口</li><li>ConcreteFactory   具体的产品族工厂</li></ul><p><font color="red">思路示意图</font>：</p><p><img src="/2023/02/06/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/image-20191223174111618.png" alt="image-20191223174111618"></p><h3 id="工厂方法是不是潜伏在抽象工厂中？"><a href="#工厂方法是不是潜伏在抽象工厂中？" class="headerlink" title="工厂方法是不是潜伏在抽象工厂中？"></a>工厂方法是不是潜伏在抽象工厂中？</h3><p>没错，抽象工厂的方法经常以工厂方法的方式实现，因为抽象工厂的任务通常是定义一个负责创建一组产品的接口，在这个接口内的每个方法都负责创建一个具体的产品，<em><strong>而这种某一个具体的产品的实质就是工厂方法模式的实践</strong></em></p><h3 id="什么场景适用-1"><a href="#什么场景适用-1" class="headerlink" title="什么场景适用"></a>什么场景适用</h3><p>在以下情况可以使用 Abstract Factory 模式：</p><ul><li>系统要独立于它的产品的创建、组合和表示时</li><li>系统要由多个产品系列中的一个来配置时</li><li>当你要强调一系列相关的产品对象的设计以便进行联合使用时</li><li>当你提供一个产品类库，而只想显示它们的接口而不是实现时</li></ul><h3 id="Code-生活中的实际应用-1"><a href="#Code-生活中的实际应用-1" class="headerlink" title="Code&#x2F;生活中的实际应用"></a>Code&#x2F;生活中的实际应用</h3><p>比如上述的情况，观察代码我们可以发现我们其实是把一个产品族进行了封装，如果这个时候要引入华为系列产品，我们完全不用动任何代码，只需要增加一个类即可，非常符合开闭原则</p><h3 id="UML图-1"><a href="#UML图-1" class="headerlink" title="UML图"></a>UML图</h3><p><img src="/2023/02/06/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/image-20200524114955227.png" alt="image-20200524114955227"></p><h2 id="遵循的设计原则"><a href="#遵循的设计原则" class="headerlink" title="遵循的设计原则"></a>遵循的设计原则</h2><p><strong>依赖抽象，而不是依赖具体</strong></p><ul><li>无论是简单工厂还是工厂方法，亦或是抽象工厂，都是强调解耦，依赖抽象，不依赖具体</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>相同点：</strong></p><ul><li>所有的工厂都是用来封装对象的创建</li><li>简单工厂，虽然不是真正的设计模式，但仍不失为一个简单的方法，可以进行解耦</li><li>所有工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合</li><li>依赖倒置原则，指导我们避免依赖具体类型，而要尽量依赖抽象</li><li>工厂是很有威力的技巧，帮助我们针对抽象编程，而不是具体类编程</li></ul><p><strong>工厂方法：</strong></p><ul><li>工厂方法利用继承：把对象的创建委托给子类，子类实现工厂方法来创建对象</li><li>工厂方法允许类将实例化延迟到子类实现</li></ul><p><strong>抽象工厂：</strong></p><ul><li>抽象工厂使用对象组合：对象的创建被实现在工厂接口所暴露出来的方法中</li><li>抽象工厂创建相关的<font color="red">对象家族</font>，而不需要依赖它们的具体类</li></ul><h2 id="相关代码链接"><a href="#相关代码链接" class="headerlink" title="相关代码链接"></a>相关代码链接</h2><p><a href="https://github.com/kkzhilu/Kerwin-DesignPattern">GitHub地址</a></p><ul><li>兼顾了《HeadFirst》以及《GOF》两本经典书籍中的案例</li><li>提供了友好的阅读指导</li></ul><p><img src="/2023/02/06/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/%E5%BE%AE%E4%BF%A1%E4%BA%8C%E7%BB%B4%E7%A0%81.png"></p>]]></content>
    
    
    <categories>
      
      <category>编码及设计模式篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工厂模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>布隆过滤器</title>
    <link href="/2023/02/06/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <url>/2023/02/06/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><p>标签： #Share</p><h2 id="什么是布隆过滤器"><a href="#什么是布隆过滤器" class="headerlink" title="什么是布隆过滤器"></a>什么是布隆过滤器</h2><p>本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。</p><p>相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的</p><h2 id="布隆过滤器数据结构"><a href="#布隆过滤器数据结构" class="headerlink" title="布隆过滤器数据结构"></a>布隆过滤器数据结构</h2><p>布隆过滤器是一个 bit 向量或者说 bit 数组，长这样：</p><p><img src="/2023/02/06/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/image-20210418134922226.png" alt="image-20210418134922226"></p><p>如果我们要映射一个值到布隆过滤器中，我们需要使用多个不同的哈希函数生成多个哈希值，并对每个生成的哈希值指向的 bit 位置 1，例如针对值 “baidu” 和三个不同的哈希函数分别生成了哈希值 1、4、7，则上图转变为：</p><p><img src="/2023/02/06/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/image-20210418134953198.png" alt="image-20210418134953198"></p><p>Ok，我们现在再存一个值 “tencent”，如果哈希函数返回 3、4、8 的话，图继续变为：</p><p><img src="/2023/02/06/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/image-20210418135011510.png" alt="image-20210418135011510"></p><p>值得注意的是，4 这个 bit 位由于两个值的哈希函数都返回了这个 bit 位，因此它被覆盖了。现在我们如果想查询 “dianping” 这个值是否存在，哈希函数返回了 1、5、8三个值，结果我们发现 5 这个 bit 位上的值为 0，说明没有任何一个值映射到这个 bit 位上，因此我们可以很确定地说 “dianping” 这个值不存在。而当我们需要查询 “baidu” 这个值是否存在的话，那么哈希函数必然会返回 1、4、7，然后我们检查发现这三个 bit 位上的值均为 1，那么我们可以说 “baidu” 存在了么？答案是不可以，只能是 “baidu” 这个值可能存在。</p><p>这是为什么呢？答案跟简单，因为随着增加的值越来越多，被置为 1 的 bit 位也会越来越多，这样某个值 “taobao” 即使没有被存储过，但是万一哈希函数返回的三个 bit 位都被其他值置位了 1 ，那么程序还是会判断 “taobao” 这个值存在</p><h2 id="支持删除么"><a href="#支持删除么" class="headerlink" title="支持删除么"></a>支持删除么</h2><p>目前我们知道布隆过滤器可以支持 add 和 isExist 操作，那么 delete 操作可以么，答案是不可以，例如上图中的 bit 位 4 被两个值共同覆盖的话，一旦你删除其中一个值例如 “tencent” 而将其置位 0，那么下次判断另一个值例如 “baidu” 是否存在的话，会直接返回 false，而实际上你并没有删除它。</p><p>如何解决这个问题，答案是计数删除。但是计数删除需要存储一个数值，而不是原先的 bit 位，会增大占用的内存大小。这样的话，增加一个值就是将对应索引槽上存储的值加一，删除则是减一，判断是否存在则是看值是否大于0</p><h2 id="快速集成BloomFilter"><a href="#快速集成BloomFilter" class="headerlink" title="快速集成BloomFilter"></a>快速集成BloomFilter</h2><p>关于布隆过滤器，我们不需要自己实现，谷歌已经帮我们实现好了。</p><ul><li>pom引入依赖</li></ul><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.google.guava/guava --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>25.1-jre<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><ul><li>核心api</li></ul><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">   * Creates a &#123;<span class="hljs-doctag">@link</span> BloomFilter BloomFilter&lt;T&gt;&#125; with the expected number of</span><span class="hljs-comment">   * insertions and expected false positive probability.</span><span class="hljs-comment">   *</span><span class="hljs-comment">   * &lt;p&gt;Note that overflowing a &#123;<span class="hljs-doctag">@code</span> BloomFilter&#125; with significantly more elements</span><span class="hljs-comment">   * than specified, will result in its saturation, and a sharp deterioration of its</span><span class="hljs-comment">   * false positive probability.</span><span class="hljs-comment">   *</span><span class="hljs-comment">   * &lt;p&gt;The constructed &#123;<span class="hljs-doctag">@code</span> BloomFilter&lt;T&gt;&#125; will be serializable if the provided</span><span class="hljs-comment">   * &#123;<span class="hljs-doctag">@code</span> Funnel&lt;T&gt;&#125; is.</span><span class="hljs-comment">   *</span><span class="hljs-comment">   * &lt;p&gt;It is recommended that the funnel be implemented as a Java enum. This has the</span><span class="hljs-comment">   * benefit of ensuring proper serialization and deserialization, which is important</span><span class="hljs-comment">   * since &#123;<span class="hljs-doctag">@link</span> #equals&#125; also relies on object identity of funnels.</span><span class="hljs-comment">   *</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> funnel the funnel of T&#x27;s that the constructed &#123;<span class="hljs-doctag">@code</span> BloomFilter&lt;T&gt;&#125; will use</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> expectedInsertions the number of expected insertions to the constructed</span><span class="hljs-comment">   *     &#123;<span class="hljs-doctag">@code</span> BloomFilter&lt;T&gt;&#125;; must be positive</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> fpp the desired false positive probability (must be positive and less than 1.0)</span><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> a &#123;<span class="hljs-doctag">@code</span> BloomFilter&#125;</span><span class="hljs-comment">   */</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; BloomFilter&lt;T&gt; <span class="hljs-title function_">create</span><span class="hljs-params">(</span><span class="hljs-params">      Funnel&lt;T&gt; funnel, <span class="hljs-type">int</span> expectedInsertions <span class="hljs-comment">/* n */</span>, <span class="hljs-type">double</span> fpp)</span> &#123;    checkNotNull(funnel);    checkArgument(expectedInsertions &gt;= <span class="hljs-number">0</span>, <span class="hljs-string">&quot;Expected insertions (%s) must be &gt;= 0&quot;</span>,        expectedInsertions);    checkArgument(fpp &gt; <span class="hljs-number">0.0</span>, <span class="hljs-string">&quot;False positive probability (%s) must be &gt; 0.0&quot;</span>, fpp);    checkArgument(fpp &lt; <span class="hljs-number">1.0</span>, <span class="hljs-string">&quot;False positive probability (%s) must be &lt; 1.0&quot;</span>, fpp);    <span class="hljs-keyword">if</span> (expectedInsertions == <span class="hljs-number">0</span>) &#123;      expectedInsertions = <span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">/*</span><span class="hljs-comment">     * TODO(user): Put a warning in the javadoc about tiny fpp values,</span><span class="hljs-comment">     * since the resulting size is proportional to -log(p), but there is not</span><span class="hljs-comment">     * much of a point after all, e.g. optimalM(1000, 0.0000000000000001) = 76680</span><span class="hljs-comment">     * which is less than 10kb. Who cares!</span><span class="hljs-comment">     */</span>    <span class="hljs-type">long</span> <span class="hljs-variable">numBits</span> <span class="hljs-operator">=</span> optimalNumOfBits(expectedInsertions, fpp);    <span class="hljs-type">int</span> <span class="hljs-variable">numHashFunctions</span> <span class="hljs-operator">=</span> optimalNumOfHashFunctions(expectedInsertions, numBits);    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BloomFilter</span>&lt;T&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BitArray</span>(numBits), numHashFunctions, funnel,          BloomFilterStrategies.MURMUR128_MITZ_32);    &#125; <span class="hljs-keyword">catch</span> (IllegalArgumentException e) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Could not create BloomFilter of &quot;</span> + numBits + <span class="hljs-string">&quot; bits&quot;</span>, e);    &#125;  &#125;<span class="hljs-comment">/**</span><span class="hljs-comment">   * Returns &#123;<span class="hljs-doctag">@code</span> true&#125; if the element &lt;i&gt;might&lt;/i&gt; have been put in this Bloom filter,</span><span class="hljs-comment">   * &#123;<span class="hljs-doctag">@code</span> false&#125; if this is &lt;i&gt;definitely&lt;/i&gt; not the case.</span><span class="hljs-comment">   */</span>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">mightContain</span><span class="hljs-params">(T object)</span> &#123;    <span class="hljs-keyword">return</span> strategy.mightContain(object, funnel, numHashFunctions, bits);  &#125;</code></pre><ul><li>一个小例子</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String... args)</span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 创建一个插入对象为一亿，误报率为0.01%的布隆过滤器</span><span class="hljs-comment">     */</span>    BloomFilter&lt;CharSequence&gt; bloomFilter = BloomFilter.create(Funnels.stringFunnel(Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>)), <span class="hljs-number">100000000</span>, <span class="hljs-number">0.0001</span>);    bloomFilter.put(<span class="hljs-string">&quot;121&quot;</span>);    bloomFilter.put(<span class="hljs-string">&quot;122&quot;</span>);    bloomFilter.put(<span class="hljs-string">&quot;123&quot;</span>);    System.out.println(bloomFilter.mightContain(<span class="hljs-string">&quot;121&quot;</span>));&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构及算法篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>布隆过滤器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>建造者&amp;责任链&amp;备忘录</title>
    <link href="/2023/02/06/%E5%BB%BA%E9%80%A0%E8%80%85&amp;%E8%B4%A3%E4%BB%BB%E9%93%BE&amp;%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    <url>/2023/02/06/%E5%BB%BA%E9%80%A0%E8%80%85&amp;%E8%B4%A3%E4%BB%BB%E9%93%BE&amp;%E5%A4%87%E5%BF%98%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="建造者-责任链-备忘录三连"><a href="#建造者-责任链-备忘录三连" class="headerlink" title="建造者 + 责任链 + 备忘录三连"></a>建造者 + 责任链 + 备忘录三连</h1><p>标签： #Share</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>【<font color="blue">开发</font>】：老大，你教了我挺多设计模式的，已经全部教完了吗？</p><p>【<font color="red">BOSS</font>】：没呢，还有好几个设计模式没说过呢，今天再传授你三个吧，分别是建造者模式，责任链模式，备忘录模式，如何？</p><p>【<font color="blue">开发</font>】：好啊，我最喜欢学习了！</p><p><img src="/2023/02/06/%E5%BB%BA%E9%80%A0%E8%80%85&%E8%B4%A3%E4%BB%BB%E9%93%BE&%E5%A4%87%E5%BF%98%E5%BD%95/de80a5abgy1gg081efphlg208c02xq8z.gif" alt="抖音猫咪摇头 GIF 动图"></p><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p><h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><p><em><strong>定义建造接口</strong></em></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Builder</span> &#123;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildPartOne</span><span class="hljs-params">()</span>;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildPartTwo</span><span class="hljs-params">()</span>;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildPartThr</span><span class="hljs-params">()</span>;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 一般情况肯定是一个复杂的对象</span><span class="hljs-comment">     */</span>    String <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span>;&#125;</code></pre><p><em><strong>定义实际建造工人</strong></em></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteBuilder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Builder</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildPartOne</span><span class="hljs-params">()</span> &#123;        buffer.append(<span class="hljs-string">&quot;i am part one\n&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildPartTwo</span><span class="hljs-params">()</span> &#123;        buffer.append(<span class="hljs-string">&quot;i am part two\n&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildPartThr</span><span class="hljs-params">()</span> &#123;        buffer.append(<span class="hljs-string">&quot;i am part Thr\n&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> buffer.toString();    &#125;&#125;</code></pre><h3 id="如何创建不同的表示？"><a href="#如何创建不同的表示？" class="headerlink" title="如何创建不同的表示？"></a>如何创建不同的表示？</h3><p><em><strong>定义督公</strong></em></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Director</span> &#123;    <span class="hljs-keyword">private</span> Builder builder;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Director</span><span class="hljs-params">(Builder builder)</span> &#123;        <span class="hljs-built_in">this</span>.builder = builder;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBuilder</span><span class="hljs-params">(Builder builder)</span> &#123;        <span class="hljs-built_in">this</span>.builder = builder;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">construct</span><span class="hljs-params">()</span> &#123;        builder.buildPartOne();        builder.buildPartTwo();        builder.buildPartThr();    &#125;&#125;</code></pre><p><em><strong>模拟调用</strong></em></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 建造者模式</span><span class="hljs-comment">     *     建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象，这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * 主要解决</span><span class="hljs-comment">     *     主要解决在软件系统中，有时候面临着&quot;一个复杂对象&quot;的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * 何时使用</span><span class="hljs-comment">     *      一些基本部件不会变，而其组合经常变化的时候。</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * 如何解决</span><span class="hljs-comment">     *     将变与不变分离开。</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * 关键代码</span><span class="hljs-comment">     *     建造者：创建和提供实例</span><span class="hljs-comment">     *     建造者接口：依赖接口编程</span><span class="hljs-comment">     *     指导者：管理建造出来的实例的依赖关系</span><span class="hljs-comment">     *     产品：建造者所生产的产品</span><span class="hljs-comment">     * 建造者作为参数进入指导者构造方法，通过特定普遍的构造顺序或算法执行，得到产品</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * 应用实例：</span><span class="hljs-comment">     *     1.去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的&quot;套餐&quot;</span><span class="hljs-comment">     *     2.StringBuilder</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;        <span class="hljs-comment">// 创建建造者接口并指向具体建造者 - 包含最终产品</span>        <span class="hljs-type">Builder</span> <span class="hljs-variable">concreteBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteBuilder</span>();        <span class="hljs-comment">// 创建指导者, 把具体建造者即工人作为参数传入, 通过统一方法执行相应的构建命令</span>        <span class="hljs-type">Director</span> <span class="hljs-variable">director</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Director</span>(concreteBuilder);        director.construct();        <span class="hljs-comment">// 从工人即具体建造者获取产品</span>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> concreteBuilder.getResult();        System.out.println(result);    &#125;&#125;</code></pre><h3 id="建造者的延展思考：链式调用"><a href="#建造者的延展思考：链式调用" class="headerlink" title="建造者的延展思考：链式调用"></a>建造者的延展思考：链式调用</h3><p>链式调用让代码更优雅~</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBuilder</span> &#123;    <span class="hljs-comment">// 省略不必要的代码</span>    MyBuilder <span class="hljs-title function_">withName</span><span class="hljs-params">(String name)</span> &#123;        <span class="hljs-built_in">this</span>.setName(name);        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;    &#125;    MyBuilder <span class="hljs-title function_">withYear</span><span class="hljs-params">(String year)</span> &#123;        <span class="hljs-built_in">this</span>.setYear(year);        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;    &#125;    MyBuilder <span class="hljs-title function_">withSex</span><span class="hljs-params">(String sex)</span> &#123;        <span class="hljs-built_in">this</span>.setSex(sex);        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;    &#125;&#125;</code></pre><h3 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h3><p><img src="/2023/02/06/%E5%BB%BA%E9%80%A0%E8%80%85&%E8%B4%A3%E4%BB%BB%E9%93%BE&%E5%A4%87%E5%BF%98%E5%BD%95/image-20200702233606240.png" alt="image-20200702233606240"></p><blockquote><p>代码见下方~</p></blockquote><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><h3 id="意图-1"><a href="#意图-1" class="headerlink" title="意图"></a>意图</h3><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连城一条链，并沿着这条链传递该请求，直到有一个对象处理它为止</p><h3 id="典型应用"><a href="#典型应用" class="headerlink" title="典型应用"></a>典型应用</h3><p>Log4J 日志系统即是使用了责任链的思想，通过不同日志级别的传递，按级别处理日志</p><h3 id="简单实现一个Log等级系统"><a href="#简单实现一个Log等级系统" class="headerlink" title="简单实现一个Log等级系统"></a>简单实现一个Log等级系统</h3><p><em><strong>抽象类</strong></em></p><p>定义日志等级，设置下一个处理器，抽象出写入方法</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractLogger</span> &#123;    <span class="hljs-comment">// 责任级别</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">INFO</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEBUG</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">ERROR</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;    <span class="hljs-comment">// 当前级别</span>    <span class="hljs-type">int</span> level;    <span class="hljs-comment">//责任链中的下一个元素</span>    AbstractLogger nextLogger;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNextLogger</span><span class="hljs-params">(AbstractLogger nextLogger)</span>&#123;        <span class="hljs-built_in">this</span>.nextLogger = nextLogger;    &#125;    <span class="hljs-comment">// 记录日志</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logMessage</span><span class="hljs-params">(<span class="hljs-type">int</span> level, String message)</span>&#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.level &lt;= level)&#123;            write(message);        &#125;        <span class="hljs-keyword">if</span>(nextLogger != <span class="hljs-literal">null</span>)&#123;            nextLogger.logMessage(level, message);        &#125;    &#125;    <span class="hljs-comment">// 抽象方法 -&gt; 重写具体日志输出类型</span>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(String message)</span>;&#125;</code></pre><p><em><strong>具体日志类</strong></em></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InfoLoger</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractLogger</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">InfoLoger</span><span class="hljs-params">(<span class="hljs-type">int</span> level)</span>&#123;        <span class="hljs-built_in">this</span>.level = level;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(String message)</span> &#123;        System.out.println(<span class="hljs-string">&quot;InfoLoger Console::Logger: &quot;</span> + message);    &#125;&#125;</code></pre><blockquote><p>为了避免重复，只展示一个类</p></blockquote><p><em><strong>实际调用</strong></em></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;        <span class="hljs-type">AbstractLogger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> getChainOfLoggers();        log.logMessage(AbstractLogger.INFO, <span class="hljs-string">&quot;i am info&quot;</span>);        log.logMessage(AbstractLogger.DEBUG, <span class="hljs-string">&quot;i am debug&quot;</span>);        log.logMessage(AbstractLogger.ERROR, <span class="hljs-string">&quot;i am error&quot;</span>);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AbstractLogger <span class="hljs-title function_">getChainOfLoggers</span><span class="hljs-params">()</span>&#123;        <span class="hljs-type">AbstractLogger</span> <span class="hljs-variable">error</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ErrorLoger</span>(AbstractLogger.ERROR);        <span class="hljs-type">AbstractLogger</span> <span class="hljs-variable">debug</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DebugLoger</span>(AbstractLogger.DEBUG);        <span class="hljs-type">AbstractLogger</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InfoLoger</span>(AbstractLogger.INFO);        error.setNextLogger(debug);        debug.setNextLogger(info);        <span class="hljs-keyword">return</span> error;    &#125;&#125;<span class="hljs-comment">// 输出结果：</span><span class="hljs-comment">// InfoLoger Console::Logger: i am info</span><span class="hljs-comment">//</span><span class="hljs-comment">// </span><span class="hljs-comment">//</span><span class="hljs-comment">// DebugLoger Console::Logger: i am debug</span><span class="hljs-comment">// InfoLoger Console::Logger: i am debug</span><span class="hljs-comment">//</span><span class="hljs-comment">// </span><span class="hljs-comment">//</span><span class="hljs-comment">// ErrorLoger Console::Logger: i am error</span><span class="hljs-comment">// DebugLoger Console::Logger: i am error</span><span class="hljs-comment">// InfoLoger Console::Logger: i am error</span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="多种形式"><a href="#多种形式" class="headerlink" title="多种形式"></a>多种形式</h4><ul><li>当前pattern下类似日志级别形式, 只要等级比A大，那B,C都会处理</li><li>如A-&gt;B-&gt;C 由低到高级别执行，只要执行就返回等</li><li>最高级形式: 低级发起请求后, 高级任一处理后，请求反馈即可(涉及到异步相关,线程通信)</li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>降低耦合度。它将请求的发送者和接收者解耦</li><li>简化了对象。使得对象不需要知道链的结构</li><li>增强给对象指派职责的灵活性，通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任</li><li>增加新的请求处理类很方便</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>不能保证请求一定被接收</li><li>系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用</li><li>可能不容易观察运行时的特征，有碍于除错</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定</li><li>在不明确指定接收者的情况下，向多个对象中的一个提交一个请求</li><li>可动态指定一组对象处理请求</li></ul><h3 id="UML图-1"><a href="#UML图-1" class="headerlink" title="UML图"></a>UML图</h3><p><img src="/2023/02/06/%E5%BB%BA%E9%80%A0%E8%80%85&%E8%B4%A3%E4%BB%BB%E9%93%BE&%E5%A4%87%E5%BF%98%E5%BD%95/image-20200702234746444.png" alt="image-20200702234746444"></p><blockquote><p>代码见下方~</p></blockquote><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><h3 id="意图-2"><a href="#意图-2" class="headerlink" title="意图"></a>意图</h3><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后可将对象恢复到原先保存的状态</p><h3 id="核心代码-1"><a href="#核心代码-1" class="headerlink" title="核心代码"></a>核心代码</h3><p><em><strong>备忘录</strong></em></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * ******************************</span><span class="hljs-comment"> * description:  备忘录，确定数据结构即可</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Memento</span> &#123;    Map&lt;String, String&gt; data;&#125;</code></pre><p><em><strong>模拟短信场景</strong></em></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * ******************************</span><span class="hljs-comment"> * description:  模拟短信场景</span><span class="hljs-comment"> * ******************************</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageData</span> &#123;    <span class="hljs-keyword">private</span> String time;    <span class="hljs-keyword">private</span> String message;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 存储数据</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> Memento <span class="hljs-title function_">saveMemento</span> <span class="hljs-params">()</span> &#123;        Map&lt;String, String&gt; map = Maps.newHashMap();        map.put(<span class="hljs-string">&quot;TIME&quot;</span>,    time);        map.put(<span class="hljs-string">&quot;MESSAGE&quot;</span>, message);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Memento</span>(map);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 取出数据</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getFromMemento</span><span class="hljs-params">(Memento memento)</span>&#123;        time    = memento.getData().get(<span class="hljs-string">&quot;TIME&quot;</span>);        message = memento.getData().get(<span class="hljs-string">&quot;MESSAGE&quot;</span>);    &#125;    <span class="hljs-comment">// 省略部分代码</span>&#125;</code></pre><p><em><strong>备忘录存储容器</strong></em></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MementoTaker</span> &#123;    <span class="hljs-keyword">private</span> List&lt;Memento&gt; mementoList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Memento state)</span>&#123;        mementoList.add(state);    &#125;    <span class="hljs-keyword">public</span> Memento <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;        <span class="hljs-keyword">return</span> mementoList.get(index);    &#125;&#125;</code></pre><p><em><strong>核心调用代码</strong></em></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;        <span class="hljs-comment">// 创建备忘录管理者</span>        <span class="hljs-type">MementoTaker</span> <span class="hljs-variable">mementoTaker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MementoTaker</span>();        <span class="hljs-type">MessageData</span> <span class="hljs-variable">messageData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageData</span>();        messageData.setTime(System.currentTimeMillis() + <span class="hljs-string">&quot;&quot;</span>);        messageData.setMessage(<span class="hljs-string">&quot;This is messgae first.&quot;</span>);        mementoTaker.add(messageData.saveMemento());        System.out.println(<span class="hljs-string">&quot;First: -&gt; &quot;</span> + messageData);        Thread.sleep(<span class="hljs-number">2000</span>);        messageData.setTime(System.currentTimeMillis() + <span class="hljs-string">&quot;&quot;</span>);        messageData.setMessage(<span class="hljs-string">&quot;This is messgae second.&quot;</span>);        mementoTaker.add(messageData.saveMemento());        System.out.println(<span class="hljs-string">&quot;Second: -&gt; &quot;</span> + messageData);        Thread.sleep(<span class="hljs-number">2000</span>);        <span class="hljs-comment">// 回复初次状态</span>        messageData.getFromMemento(mementoTaker.get(<span class="hljs-number">0</span>));        System.out.println(<span class="hljs-string">&quot;********************检测数据是否回到初始状态******************&quot;</span>);        System.out.println(messageData);    &#125;&#125;</code></pre><p>模式总结：<font color="red">其实该模式非常简单，即确定好数据结构在容器中存储一份，以便后续恢复，或者重新使用等等</font></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><h4 id="主要解决"><a href="#主要解决" class="headerlink" title="主要解决"></a>主要解决</h4><p>所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态</p><h4 id="备忘录思想的实践"><a href="#备忘录思想的实践" class="headerlink" title="备忘录思想的实践"></a>备忘录思想的实践</h4><ul><li>打游戏时的存档</li><li>Windows 里的 ctri + z</li><li>数据库的事务管理</li></ul><h3 id="UML图-2"><a href="#UML图-2" class="headerlink" title="UML图"></a>UML图</h3><p><img src="/2023/02/06/%E5%BB%BA%E9%80%A0%E8%80%85&%E8%B4%A3%E4%BB%BB%E9%93%BE&%E5%A4%87%E5%BF%98%E5%BD%95/image-20200702235930286.png" alt="image-20200702235930286"></p><h2 id="相关代码链接"><a href="#相关代码链接" class="headerlink" title="相关代码链接"></a>相关代码链接</h2><p><a href="https://github.com/kkzhilu/Kerwin-DesignPattern">GitHub地址</a></p><ul><li>兼顾了《HeadFirst》以及《GOF》两本经典书籍中的案例</li><li>提供了友好的阅读指导</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/5/18/172284a1c8caf324?w=487&h=185&f=png&s=17561"></p>]]></content>
    
    
    <categories>
      
      <category>编码及设计模式篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>建造者&amp;责任链&amp;备忘录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>悄咪咪提高团队幸福感 &amp; Surprise！</title>
    <link href="/2023/02/06/%E6%82%84%E5%92%AA%E5%92%AA%E6%8F%90%E9%AB%98%E5%9B%A2%E9%98%9F%E5%B9%B8%E7%A6%8F%E6%84%9F%20&amp;%20Surprise%EF%BC%81/"/>
    <url>/2023/02/06/%E6%82%84%E5%92%AA%E5%92%AA%E6%8F%90%E9%AB%98%E5%9B%A2%E9%98%9F%E5%B9%B8%E7%A6%8F%E6%84%9F%20&amp;%20Surprise%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p>标签： #Share</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文的灵感是在几个月以前工作不忙（摸鱼）时想到的，老是自己一个人往前冲冲冲也没啥意思，需要想一点办法，来提高团队的效率，提高团队的幸福感（效率起来了，单位时间内代码写的更多，那不就幸福啦 😜），经过几个月的摸索，总结出了几个小点，如果大家有更好的方式，欢迎一起讨论~</p><br><h2 id="永久解决不知道是什么版本"><a href="#永久解决不知道是什么版本" class="headerlink" title="永久解决不知道是什么版本"></a>永久解决不知道是什么版本</h2><p>我司的产品主要分为Saas端和私有平台，分别部署在公网和客户的私有环境，先来说说私有环境的问题：<code>不知道真正部署的项目版本</code>，说来很可笑，运维同学在部署的时候肯定是记录过各个客户的代码版本的，但也就是这么可笑，有时候就是会弄错，可能是由于升级流程不够完善，或者工作失误等等，总之，想个办法解决。</p><br><p>人靠不住，但还有代码。<code>Git</code>已经成为代码管理的事实标准，这就不多说了，即然人管理不好版本，那还是从<code>Git</code>本身入手吧，悄咪咪的给所有项目依赖（<code>POM.XML</code>）增加一个插件：</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Git Version插件 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>pl.project13.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>git-commit-id-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>get-the-git-infos<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>initialize<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>revision<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dotGitDirectory</span>&gt;</span>$&#123;project.basedir&#125;/.git<span class="hljs-tag">&lt;/<span class="hljs-name">dotGitDirectory</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">verbose</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">verbose</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dateFormat</span>&gt;</span>yyyy-MM-dd HH:mm:ss<span class="hljs-tag">&lt;/<span class="hljs-name">dateFormat</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">prefix</span>&gt;</span>git<span class="hljs-tag">&lt;/<span class="hljs-name">prefix</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">generateGitPropertiesFile</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">generateGitPropertiesFile</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">generateGitPropertiesFilename</span>&gt;</span>$&#123;project.build.outputDirectory&#125;/$&#123;project.name&#125;.build.json<span class="hljs-tag">&lt;/<span class="hljs-name">generateGitPropertiesFilename</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">format</span>&gt;</span>json<span class="hljs-tag">&lt;/<span class="hljs-name">format</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">gitDescribe</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">skip</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">skip</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">always</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">always</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">dirty</span>&gt;</span>-dirty<span class="hljs-tag">&lt;/<span class="hljs-name">dirty</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">gitDescribe</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></code></pre><p>插件将会在每次构建时生成一个版本相关文件，内容如下：</p><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>  <span class="hljs-attr">&quot;git.branch&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;master&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;git.build.host&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Kerwin&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;git.build.time&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2020-08-12 23:24:59&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;git.build.user.email&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;34807944+kkzhilu@users.noreply.github.com&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;git.build.user.name&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;kkzhilu&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;git.build.version&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0.0-SNAPSHOT&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;git.closest.tag.commit.count&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;git.closest.tag.name&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;git.commit.id&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;4981afb5dfeee6f835dcf9a7a135083d8e973090&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;git.commit.id.abbrev&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;4981afb&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;git.commit.id.describe&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;4981afb&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;git.commit.id.describe-short&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;4981afb&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;git.commit.message.full&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Commit git-version&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;git.commit.message.short&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Commit git-version&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;git.commit.time&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2020-08-04 18:18:47&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;git.commit.user.email&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;34807944+kkzhilu@users.noreply.github.com&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;git.commit.user.name&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;kexianming&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;git.dirty&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;false&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;git.local.branch.ahead&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;git.local.branch.behind&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;git.remote.origin.url&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://github.com/kkzhilu/KerwinBoots.git&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;git.tags&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;git.total.commit.count&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;9&quot;</span><span class="hljs-punctuation">&#125;</span></code></pre><p>插件名字叫：<code>git-commit-id-plugin</code>，至于细节使用就自己去搜索啦，它可以实现的效果即在每次打包时生成相应的Git相关信息，这样无论运维同学是否把代码升错，我们都可以知道<code>代码到底是什么版本</code></p><p>以后终于听不到同事之间因为代码版本扯皮的事情了🤪</p><br><h2 id="永久解决没打日志怎么办的问题"><a href="#永久解决没打日志怎么办的问题" class="headerlink" title="永久解决没打日志怎么办的问题"></a>永久解决没打日志怎么办的问题</h2><p>回到刚刚说的Saas端生产环境，由于各种原因，我们团队经常需要维护不是自己写的项目，很多时候一些细节逻辑完全摸不着头脑，而且没有日志，最要命的是在测试环境还不复现，肿么办？</p><br><p>以前的解决方案是各种喊人，然后硬看代码寻找上下文，尽可能的找到蛛丝马迹，总之效率非常感人，处理的慢了就是一个事故，全员挨批评，咋办呢？我就一直在寻找这种问题的解决办法，终于我发现了一个神器：<code>Arthas</code></p><br><p>用过这个工具的人就知道它有多强大，阿里出品，官方文档链接：<a href="https://arthas.gitee.io/commands.html">https://arthas.gitee.io/commands.html</a></p><p>我们可以通过其提供的部分命令，如：<code>tt</code>，<strong>获取方法执行数据的时空隧道，它可以记录下指定方法每次调用的入参和返回信息</strong>，想想它的帮助有多大，<code>记录每一个方法的入参和出参</code>，如果真遇上没日志的情况，知道这些信息其实配合代码就可以很快定位问题了，所以，听过没用过的朋友，都去试试吧，真的很无敌。</p><p>下次同事有难时，你就用这个工具去帮他，他说不定会请你吃顿饭🍗</p><br><h2 id="永久解决哪里耗时这么长的问题"><a href="#永久解决哪里耗时这么长的问题" class="headerlink" title="永久解决哪里耗时这么长的问题"></a>永久解决哪里耗时这么长的问题</h2><p>这个问题是由于之前同事重写了一块业务逻辑，结果线上展现层耗时大概30s，oh，天哪！在测试环境明明是一瞬间的，咋办？</p><p>造成这种问题的原因，肯定是SQL写的不好，或者业务处理哪里做了很多不必要的动作（我们没有灰度测试），但是生产环境又不能随便动，也不能断点调试，从日志也只能看到耗时很长，但是慢在哪里不知道。</p><br><p>当一个方法里面经过了N个内部方法后，你不知道到底是哪一个导致这么长的耗时，当无法复现的时候怎么办呢？其实还是利用上面的那个工具<code>Arthas</code>，还是一样的命令<code>tt</code>，它不仅可以记录入参和出参信息，<strong>还可以记录每一个方法的耗时</strong>，多么的强大。</p><br><p>所以我是为了再次提醒，这些功能只是<code>Arthas</code>的一点皮毛，咱们要学会合理使用开源工具</p><br><h2 id="注释无法表达流程图效果的解决方案"><a href="#注释无法表达流程图效果的解决方案" class="headerlink" title="注释无法表达流程图效果的解决方案"></a>注释无法表达流程图效果的解决方案</h2><p>注释是文字，难以表达如流程图一般的效果，所以该怎么办呢？我找到了两种解决方案，目前在项目中使用效果非常之好，第一种是利用<code>ASCII注释工具</code>，该工具的地址：<a href="http://asciiflow.com/">http://asciiflow.com/</a></p><p>效果如下：</p><p>![image-20200813002015129](悄咪咪提高团队幸福感 &amp; Surprise！&#x2F;image-20200813002015129.png)</p><p>注释如下：</p><pre><code class="hljs bash">+-+|                               ||  +-+  ||  |                         |  ||  |           Demo          |  ||  |                         |  ||  |                         |  ||  +++  ||               |               ||               |               ||               |               ||               |               ||               |               ||               |               ||               |               ||               |               ||               |               ||               +&gt; False  ||               |               ||               |               ||    True   &lt;---+               ||                               |+-+</code></pre><p>这玩意画出来的图是可以直接复制成文本的，控制好尺寸就可以解决大部分情况，也可以想象之前网上有一些很奇葩的注释是不是就是用这个工具或者同样的原理画出来的，附上一副之前文章缺的一张图：</p><p><strong>上亿数据怎么玩深度分页？兼容MySQL + ES + MongoDB：</strong><a href="https://juejin.im/post/6850037275456339975">https://juejin.im/post/6850037275456339975</a></p><p>这篇文章写完的时候，我自己方案的图还没画好，所以很多朋友问我用id实现不了什么的，这次就顺便展示一下我的方案</p><p>![](悄咪咪提高团队幸福感 &amp; Surprise！&#x2F;image-20200723163317073.png)</p><p>解决方案之二，利用<code>MarkDown</code>的原生画图功能，我不知道要发布文章的平台支不支持，所以用截图来代替了（<code>Typora支持</code>）</p><p>![image-20200813002527878](悄咪咪提高团队幸福感 &amp; Surprise！&#x2F;image-20200813002527878.png)</p><p>不知道的同学搜一下，<code>MarkDown</code>绘图语法，拿一个适合的改就好了，没必要专门去学，放到代码里看看效果：</p><p>![image-20200813002708209](悄咪咪提高团队幸福感 &amp; Surprise！&#x2F;image-20200813002708209.png)</p><p>有一个小<code>Tips</code>，使用IDEA的时候，<strong>利用鼠标滚动键可以按块复制，这样一来可以直接复制到指定的注释内容</strong>，然后把它复制到任何一个正常的<code>MarkDown</code>工具里，就可以展示流程图了，简直不要太完美，想测试的朋友可以复制以下代码去一些工具里试试，需要设置代码种类为：<code>mermaid</code></p><pre><code class="hljs bash">sequenceDiagram   Note over Boot: 启动类   Note over PDFThread: 线程类   Note over PDFWorker: 执行类 Boot-&gt;&gt;PDFThread: Boot类启动线程   PDFThread-&gt;&gt;PDFWorker: 线程类调用真正工作Worker   loop 队列处理       PDFThread-&gt;PDFThread: 考虑成功与失败情况处理方案   end      PDFWorker--&gt;&gt;PDFThread: Worker响应执行结果Note right of PDFWorker: 注意参数校验 &lt;br/&gt;文件格式校验</code></pre><p>你未来的同事维护代码的时候会爱上你，如果是女生，可能还会嫁给你🧡</p><p>幻想有一天你老大跑过来问你，你这写的注释都是些什么玩意，然后你一复制一粘贴，一张图就出来了！下次涨薪会没有你？</p><p>（反正我涨了，还不少😎）</p><br><p>PS：我考虑写一个支持直接复制然后渲染成流程图的<code>IDEA插件</code>，如果有现成的请联系我，就省的我去写了，嘿嘿✌</p><br><h2 id="垃圾SQL的解决方案"><a href="#垃圾SQL的解决方案" class="headerlink" title="垃圾SQL的解决方案"></a>垃圾SQL的解决方案</h2><p>我们公司没有专门的<code>DBA</code>，所以<code>SQL</code>语句的质量只掌握在开发和开发组长的手上，有时候事情多，或者不细心，或者模块不是很重要就容易粗心，到了生产环境出大问题，针对这种情况的解决方案依然是寻找工具，比如，我盯上了<code>小米</code>的<code>Soar</code></p><p>项目地址：<a href="https://github.com/XiaoMi/soar">https://github.com/XiaoMi/soar</a></p><p>官方的介绍：</p><ul><li>跨平台支持</li><li>目前只支持 MySQL 语法族协议的 SQL 优化</li><li>支持基于启发式算法的语句优化</li><li>支持复杂查询的多列索引优化（UPDATE、INSERT、DELETE、SELECT）</li></ul><p>贴个图片展示一下效果：</p><p>![](悄咪咪提高团队幸福感 &amp; Surprise！&#x2F;Soar-Web效果图.jpg)</p><p>这款工具可以进行对<code>SQL</code>进行打分，同时提供一些建议，它的能力上限我们还没有摸索出来，但是下限还是可以肯定的，因此之后只需要关注<code>索引</code>是否正确使用，其他的就交给这个工具吧，低于90分，就改！</p><p>PS：这个开源项目推荐使用<code>docker</code>安装，简单粗暴无脑省时间，命令如下：</p><pre><code class="hljs bash"><span class="hljs-comment"># 安装镜像</span>docker pull becivells/soar-web<span class="hljs-comment"># 运行</span>docker run -d --name Soar-web -p 5077:5077 becivells/soar-web</code></pre><p>想着有个工具会检查SQL质量了，是不是写的时候也认真多啦，幸福感提示满满，哈哈~😁</p><br><h2 id="懒得写文档的解决方案"><a href="#懒得写文档的解决方案" class="headerlink" title="懒得写文档的解决方案"></a>懒得写文档的解决方案</h2><p>方案设计的文档不可能由工具去写，但是简单的数据库字段映射，或者接口文档总不需要开发去写吧？也是一样摸索摸索，找到了几个不太适合但是靠边的开源项目，如：</p><p><strong>apidoc：</strong><a href="https://github.com/apidoc/apidoc">https://github.com/apidoc/apidoc</a></p><blockquote><p>RESTful web API Documentation Generator.</p></blockquote><p><strong>JApiDocs：</strong><a href="https://github.com/YeDaxia/JApiDocs">https://github.com/YeDaxia/JApiDocs</a></p><blockquote><p>A magical api documentation generator without annotation for springboot.</p></blockquote><p><strong>APIAuto：</strong><a href="https://github.com/TommyLemon/APIAuto">https://github.com/TommyLemon/APIAuto</a></p><blockquote><p>机器学习测试、自动生成代码、自动静态检查、自动生成文档与注释等，做最先进的接口管理工具</p></blockquote><p>因为每个项目的情况不同，但是我又不想做大的改动，所以只能说是靠边，不能百分百适合，但有了这些开源项目，我就可以改写其中的代码，让它适应当前项目的注释方案等等，总是，能节省相当一部分的编写文档的时间</p><br><h2 id="重复性代码的解决方案"><a href="#重复性代码的解决方案" class="headerlink" title="重复性代码的解决方案"></a>重复性代码的解决方案</h2><p>这个的确是个大坑，谁让咱们是CRUD程序员呢，经常需要写重复性相当高，但是又有一点不同的代码，这里我的解决方案是利用模板 + 更合适的工具解决，如果只是数据库操作层重复代码多，我们完全可以利用<code>mybatis-plus</code>工具减少重复代码，又或者写出<code>公共的操作层</code>减少重复代码。</p><br><p>当用工具完不成的时候，我就会用上模板了，比如直接我写过一个简单的开源项目：</p><p><strong>好像很厉害的生成器！一秒钟搞定一个项目：</strong><a href="https://juejin.im/post/6844904148417118215">https://juejin.im/post/6844904148417118215</a></p><p>核心思路和要求如下：</p><ul><li>基于数据库获取原始数据</li><li>基于模板 + 原始数据生成可运行的SpringBoot项目，支持界面 + 基本增删改查</li><li>提供拓展式接口，可以实现不修改代码生成全新的文件</li></ul><br><p>那利用这种思路，其实完全可以写一套更开放的代码生成模板，比如根据传递的<code>JSON</code>报文去解析数据，根据传递的<code>模板</code>去生成数据，这样的话又可以解决相当大一部分的重复工具，你，值得拥有。</p><p>PS：同理，其实数据库字段映射文档也可以用这种方式，只需要一秒钟，简直不要太舒服🤷‍♂️</p><br><h2 id="重复性的操作用脚本代码"><a href="#重复性的操作用脚本代码" class="headerlink" title="重复性的操作用脚本代码"></a>重复性的操作用脚本代码</h2><p>这个其实大家都有意识，但是有时候就是感觉可能用的不多，真要用起来的时候又没功夫去写脚本，比如进入一个<code>docker</code>容器，如果用命令行的话，至少要经历两步代码，十几秒的时间，如果写一个脚本呢，以后进入容器只需要一秒钟，所以我给团队写了不少这种脚本，其实我一开始也不会，反正就复制来一个改一改就行，如下是进入<code>docker容器</code>的</p><pre><code class="hljs bash"><span class="hljs-comment">#使用说明，用来提示输入参数</span><span class="hljs-function"><span class="hljs-title">usage</span></span>() &#123;    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Usage: sh 执行脚本.sh [rpcapp|tomcat|nginx|mysql]&quot;</span>    <span class="hljs-built_in">exit</span> 1&#125;<span class="hljs-function"><span class="hljs-title">rpcapp</span></span>()&#123;  DOCKER_ID=$(docker ps | grep <span class="hljs-string">&quot;rpcapp&quot;</span> | awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span>)  docker <span class="hljs-built_in">exec</span> -it <span class="hljs-variable">$DOCKER_ID</span> bash&#125;<span class="hljs-function"><span class="hljs-title">tomcat</span></span>()&#123;  DOCKER_ID=$(docker ps | grep <span class="hljs-string">&quot;tomcat&quot;</span> | awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span>)  docker <span class="hljs-built_in">exec</span> -it <span class="hljs-variable">$DOCKER_ID</span> bash&#125;<span class="hljs-function"><span class="hljs-title">nginx</span></span>()&#123;  DOCKER_ID=$(docker ps | grep <span class="hljs-string">&quot;nginx&quot;</span> | awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span>)  docker <span class="hljs-built_in">exec</span> -it <span class="hljs-variable">$DOCKER_ID</span> bash&#125;<span class="hljs-function"><span class="hljs-title">mysql</span></span>()&#123;  DOCKER_ID=$(docker ps | grep <span class="hljs-string">&quot;mysql&quot;</span> | awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span>)  docker <span class="hljs-built_in">exec</span> -it <span class="hljs-variable">$DOCKER_ID</span> bash&#125;<span class="hljs-comment">#根据输入参数，选择执行对应方法，不输入则执行使用说明</span><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> <span class="hljs-keyword">in</span>  <span class="hljs-string">&quot;rpcapp&quot;</span>)    rpcapp    ;;  <span class="hljs-string">&quot;tomcat&quot;</span>)    tomcat    ;;  <span class="hljs-string">&quot;nginx&quot;</span>)    nginx    ;;  <span class="hljs-string">&quot;mysql&quot;</span>)    mysql    ;;  *)    usage    ;;<span class="hljs-keyword">esac</span></code></pre><br><p>从网上找了找，又找到一个开源项目用以记录常用的脚本</p><p><strong>useful-scripts：</strong><a href="https://github.com/oldratlee/useful-scripts">https://github.com/oldratlee/useful-scripts</a></p><p>![image-20200813003842859](悄咪咪提高团队幸福感 &amp; Surprise！&#x2F;image-20200813003842859.png)</p><p>能自动的就不要每次都手写啦，节约时间去摸鱼不快乐吗👏</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这可是我这么久以来总结的时间管理神器，节省的时间拿去摸鱼学习，循环促进效率和能力，形成良性正反馈</p><p>这还不值得<code>来个赞</code>👍👍👍吗？嘿嘿~</p><blockquote><p>另外可以搜索公众号「<strong>是Kerwin啊</strong>」，一起进步！</p><p>也可以查看<a href="https://github.com/kkzhilu">Kerwin的GitHub主页</a>，关注一个小白程序员的进步，这货最近在折腾Go~</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>杂文篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>悄咪咪提高团队幸福感 &amp; Surprise！</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写一个本地缓存</title>
    <link href="/2023/02/06/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98/"/>
    <url>/2023/02/06/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h1 id="基于ConcurrentHashMap的本地缓存"><a href="#基于ConcurrentHashMap的本地缓存" class="headerlink" title="基于ConcurrentHashMap的本地缓存"></a>基于ConcurrentHashMap的本地缓存</h1><p>标签： #Share</p><p>在系统中，有些数据，数据量小，但是访问十分频繁（例如国家标准行政区域数据），针对这种场景，需要将数据搞到应用的本地缓存中，以提升系统的访问效率，减少无谓的数据库访问（数据库访问占用数据库连接，同时网络消耗比较大），但是有一点需要注意，就是缓存的占用空间以及缓存的失效策略</p><p>博文：<a href="https://www.jianshu.com/p/4194483127fe">https://www.jianshu.com/p/4194483127fe</a></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mine.localcache;<span class="hljs-keyword">import</span> java.util.Date;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">import</span> java.util.Timer;<span class="hljs-keyword">import</span> java.util.TimerTask;<span class="hljs-keyword">import</span> java.util.concurrent.ConcurrentHashMap;<span class="hljs-comment">/**</span><span class="hljs-comment"> * ******************************</span><span class="hljs-comment"> * author：      柯贤铭</span><span class="hljs-comment"> * createTime:   2019/7/15 9:56</span><span class="hljs-comment"> * description:  基于ConcurrentHashMap的本地缓存解决方案</span><span class="hljs-comment"> *               博文：https://www.jianshu.com/p/4194483127fe</span><span class="hljs-comment"> * version:      V1.0</span><span class="hljs-comment"> * ******************************</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalCache</span> &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 默认有效时长,单位:秒</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFUALT_TIMEOUT</span> <span class="hljs-operator">=</span> <span class="hljs-number">3600</span> * <span class="hljs-number">1000</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">SECOND_TIME</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; map;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Timer timer;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 初始化</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">static</span> &#123;        timer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>();        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 私有构造函数,工具类不允许实例化</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">LocalCache</span><span class="hljs-params">()</span> &#123;&#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 清除缓存任务类</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CleanWorkerTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TimerTask</span> &#123;        <span class="hljs-keyword">private</span> String key;        <span class="hljs-keyword">public</span> <span class="hljs-title function_">CleanWorkerTask</span><span class="hljs-params">(String key)</span> &#123;            <span class="hljs-built_in">this</span>.key = key;        &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;            LocalCache.remove(key);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 增加缓存</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(String key, Object value)</span> &#123;        map.put(key, value);        timer.schedule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CleanWorkerTask</span>(key), DEFUALT_TIMEOUT);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 增加缓存</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> timeout 有效时长</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(String key, Object value, <span class="hljs-type">int</span> timeout)</span> &#123;        map.put(key, value);        timer.schedule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CleanWorkerTask</span>(key), timeout * SECOND_TIME);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 增加缓存</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> expireTime 过期时间</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(String key, Object value, Date expireTime)</span> &#123;        map.put(key, value);        timer.schedule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CleanWorkerTask</span>(key), expireTime);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 批量增加缓存</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> m</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putAll</span><span class="hljs-params">(Map&lt;String, Object&gt; m)</span> &#123;        map.putAll(m);        <span class="hljs-keyword">for</span> (String key : m.keySet()) &#123;            timer.schedule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CleanWorkerTask</span>(key), DEFUALT_TIMEOUT);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 批量增加缓存</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> m</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putAll</span><span class="hljs-params">(Map&lt;String, Object&gt; m, <span class="hljs-type">int</span> timeout)</span> &#123;        map.putAll(m);        <span class="hljs-keyword">for</span> (String key : m.keySet()) &#123;            timer.schedule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CleanWorkerTask</span>(key), timeout * SECOND_TIME);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 批量增加缓存</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> m</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putAll</span><span class="hljs-params">(Map&lt;String, Object&gt; m, Date expireTime)</span> &#123;        map.putAll(m);        <span class="hljs-keyword">for</span> (String key : m.keySet()) &#123;            timer.schedule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CleanWorkerTask</span>(key), expireTime);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取缓存</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(String key)</span> &#123;        <span class="hljs-keyword">return</span> map.get(key);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 查询缓存是否包含key</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsKey</span><span class="hljs-params">(String key)</span> &#123;        <span class="hljs-keyword">return</span> map.containsKey(key);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 删除缓存</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(String key)</span> &#123;        map.remove(key);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 删除缓存</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> o</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123;        map.remove(o);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 返回缓存大小</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> map.size();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 清除所有缓存</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (size() &gt; <span class="hljs-number">0</span>) &#123;            map.clear();        &#125;        <span class="hljs-comment">// 取消延时任务,重新创建Timer</span>        timer.cancel();        timer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>();    &#125;&#125;</code></pre><h2 id="测试Demo"><a href="#测试Demo" class="headerlink" title="测试Demo"></a>测试Demo</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDemo</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20000</span>; i++) &#123;            LocalCache.put(i + <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;test for &quot;</span> + i , <span class="hljs-number">20</span>);        &#125;        System.out.println(<span class="hljs-string">&quot;ok&quot;</span>);        Thread.sleep(<span class="hljs-number">10</span> * <span class="hljs-number">1000</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20000</span>; i++) &#123;            System.out.println(LocalCache.get(i + <span class="hljs-string">&quot;&quot;</span>));        &#125;        Thread.sleep(<span class="hljs-number">15</span> * <span class="hljs-number">1000</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20000</span>; i++) &#123;            System.out.println(LocalCache.get(i + <span class="hljs-string">&quot;&quot;</span>));        &#125;    &#125;&#125;</code></pre><h2 id="总结分析"><a href="#总结分析" class="headerlink" title="总结分析"></a>总结分析</h2><pre><code class="hljs lasso">该缓存是基于ConcurrentHashMap配合Timer实现的本地缓存策略，但是它有其瓶颈，比如：LRU：Least Recently Used，最近最少使用 算法实现等都均未实现，不过可以用作学习和参考使用生产级别推荐使用：Guava <span class="hljs-keyword">cache</span>构建本地缓存</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>手写一个本地缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写简易SpringMVC</title>
    <link href="/2023/02/06/%E6%89%8B%E5%86%99%E7%AE%80%E6%98%93SpringMVC/"/>
    <url>/2023/02/06/%E6%89%8B%E5%86%99%E7%AE%80%E6%98%93SpringMVC/</url>
    
    <content type="html"><![CDATA[<h1 id="手写简易SpringMVC"><a href="#手写简易SpringMVC" class="headerlink" title="手写简易SpringMVC"></a>手写简易SpringMVC</h1><p>标签： #Share</p><blockquote><p>手写系列框架代码基于普通Maven构建，因此在手写SpringMVC的过程中，需要手动的集成Tomcat容器</p><p>必备知识：<br>Servlet相关理解和使用，Maven，Java 反射，Java自定义注解</p></blockquote><h2 id="配置Web类型结构"><a href="#配置Web类型结构" class="headerlink" title="配置Web类型结构"></a>配置Web类型结构</h2><p><code>结构如图所示：</code></p><p><img src="/2023/02/06/%E6%89%8B%E5%86%99%E7%AE%80%E6%98%93SpringMVC/1567700174356.png" alt="1567700174356"></p><p>注意 要设置 webapp为web moudle -&gt; IDEA 有蓝色小圈圈为准，resource 配置为资源文件</p><h2 id="配置Web-xml，配置Artifacts，配置文件"><a href="#配置Web-xml，配置Artifacts，配置文件" class="headerlink" title="配置Web.xml，配置Artifacts，配置文件"></a>配置Web.xml，配置Artifacts，配置文件</h2><p><img src="/2023/02/06/%E6%89%8B%E5%86%99%E7%AE%80%E6%98%93SpringMVC/1567700286694.png" alt="1567700286694"></p><p><img src="/2023/02/06/%E6%89%8B%E5%86%99%E7%AE%80%E6%98%93SpringMVC/1567700301717.png" alt="1567700301717"></p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span> <span class="hljs-attr">xmlns:web</span>=<span class="hljs-string">&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span></span><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;3.0&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>KerwinCodes<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.mycode.servlet.MyDispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>application.properties<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>KerwinCodes<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span></code></pre><pre><code class="hljs properties"><span class="hljs-attr">//</span> <span class="hljs-string">配置包扫描的路径</span><span class="hljs-attr">scanPackage</span>=<span class="hljs-string">com.mycode</span></code></pre><h2 id="编码阶段"><a href="#编码阶段" class="headerlink" title="编码阶段"></a>编码阶段</h2><ol><li>第一步毋庸置疑，我们需要创建必要的注解，如MyController,MyRequestMapping等等</li></ol><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-meta">@Documented</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyController &#123;    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;&#125;<span class="hljs-meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-meta">@Documented</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyRequestMapping &#123;    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;&#125;<span class="hljs-meta">@Target(ElementType.PARAMETER)</span><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-meta">@Documented</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyRequestParam &#123;    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;&#125;</code></pre><ol start="2"><li>需要思考我们如何才能实现SpringMVC</li></ol><pre><code class="hljs java">A.参考真正的SpringMVC， 它是基于Spring的基础上，因此我们需要自行实现IOC容器B.想要实现IOC容易，管理Bean，我们就需要根据包扫描的路径进行全项目扫描C.全项目扫描后，利用反射，同时根据注解判断是否是Bean，然后注入到Map容器中即可D.遍历容器，获取存储的Bean中的方法，配合RequestMapping注解，得到 url - method映射，同时得到 url - object映射，存储到新的Map集合总，便于后续反射调用E.页面请求时候，判断request.url 映射的到底是哪一个bean，哪一个方法 同时获取方法的参数，解析request的参数，即可匹配路径调用方法F.万事俱备，到底如何运行？Servlet -&gt; init方法，doGet方法，doPost方法  实质就是Servlet生命周期中初始化和真正执行策略的方法，我们只需要重写方法，然后让doGet，doPost 都调用我们的方法即可</code></pre><ol start="3"><li>核心代码如下：</li></ol><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mycode.servlet;<span class="hljs-keyword">import</span> com.mycode.annotation.MyController;<span class="hljs-keyword">import</span> com.mycode.annotation.MyRequestMapping;<span class="hljs-keyword">import</span> javax.servlet.ServletConfig;<span class="hljs-keyword">import</span> javax.servlet.ServletException;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServlet;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<span class="hljs-keyword">import</span> java.io.*;<span class="hljs-keyword">import</span> java.lang.reflect.Member;<span class="hljs-keyword">import</span> java.lang.reflect.Method;<span class="hljs-keyword">import</span> java.net.URL;<span class="hljs-keyword">import</span> java.util.*;<span class="hljs-comment">/**</span><span class="hljs-comment"> * ******************************</span><span class="hljs-comment"> * author：      柯贤铭</span><span class="hljs-comment"> * createTime:   2019/9/5 11:53</span><span class="hljs-comment"> * description:  MyDispatcherServlet</span><span class="hljs-comment"> * version:      V1.0</span><span class="hljs-comment"> * ******************************</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDispatcherServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span>&#123;    <span class="hljs-comment">/** 配置信息 **/</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();    <span class="hljs-comment">/** 所有类的Class地址 **/</span>    <span class="hljs-keyword">private</span> List&lt;String&gt; classNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    <span class="hljs-comment">/** Bean容器 **/</span>    <span class="hljs-keyword">private</span> Map&lt;String, Object&gt; iocFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();    <span class="hljs-comment">/** HandlerMapping - 方法**/</span>    <span class="hljs-keyword">private</span> Map&lt;String, Method&gt; handleMapping = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();    <span class="hljs-comment">/** HandlerMapping - 对象**/</span>    <span class="hljs-keyword">private</span> Map&lt;String, Object&gt; controllers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ServletConfig config)</span> <span class="hljs-keyword">throws</span> ServletException &#123;        <span class="hljs-comment">// 1.加载配置文件</span>        doLoadConfig(config.getInitParameter(<span class="hljs-string">&quot;contextConfigLocation&quot;</span>));        <span class="hljs-comment">// 2.初始化所有相关联的类,扫描用户设定的包下面所有的类</span>        doScanner(properties.getProperty(<span class="hljs-string">&quot;scanPackage&quot;</span>));        <span class="hljs-comment">// 3.拿到扫描到的类,通过反射机制,实例化,并且放到ioc容器中(k-v  beanName-bean)</span>        doInstance();        <span class="hljs-comment">// 4.初始化HandlerMapping(将url和method对应上)</span>        initHandlerMapping();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;        <span class="hljs-built_in">this</span>.doPost(req,resp);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;        <span class="hljs-keyword">try</span> &#123;            doDispatch(req, resp);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-comment">// 加载配置文件索取包扫描路径</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doLoadConfig</span> <span class="hljs-params">(String fileUrl)</span>  &#123;        <span class="hljs-keyword">try</span> &#123;            properties.load(<span class="hljs-built_in">this</span>.getClass().getClassLoader().getResourceAsStream(fileUrl));        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-comment">// 扫描目录下所有的类</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doScanner</span> <span class="hljs-params">(String rootPath)</span> <span class="hljs-keyword">throws</span> ServletException &#123;        <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getClass().getClassLoader().getResource( <span class="hljs-string">&quot;/&quot;</span> + rootPath.replaceAll(<span class="hljs-string">&quot;\\.&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>));        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(Objects.requireNonNull(url).getFile());        <span class="hljs-keyword">if</span> (!file.isDirectory()) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletException</span>(<span class="hljs-string">&quot;Base Package is wrong.&quot;</span>);        &#125;        <span class="hljs-keyword">for</span> (File current : Objects.requireNonNull(file.listFiles())) &#123;            <span class="hljs-keyword">if</span> (current.isDirectory()) &#123;                doScanner(rootPath + <span class="hljs-string">&quot;.&quot;</span> + current.getName());            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> rootPath + <span class="hljs-string">&quot;.&quot;</span> + current.getName().replace(<span class="hljs-string">&quot;.class&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);                classNames.add(className);            &#125;        &#125;    &#125;    <span class="hljs-comment">// 拿到所有的classNames 通过反射创建其对象 - 放入ioc容器中</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doInstance</span> <span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (classNames.isEmpty()) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">for</span> (String className : classNames) &#123;                Class&lt;?&gt; clazz = Class.forName(className);                <span class="hljs-keyword">if</span> (clazz.isAnnotationPresent(MyController.class)) &#123;                    iocFactory.put(clazz.getSimpleName(), clazz.newInstance());                &#125;            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-comment">// 初始化HandlerMapping(将url和method对应上)</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initHandlerMapping</span> <span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (iocFactory.isEmpty()) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (String key : iocFactory.keySet()) &#123;            Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Object</span>&gt; clazz = iocFactory.get(key).getClass();            <span class="hljs-keyword">if</span> (!clazz.isAnnotationPresent(MyController.class)) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">// 类 url</span>            <span class="hljs-type">MyRequestMapping</span> <span class="hljs-variable">annotation</span> <span class="hljs-operator">=</span> clazz.getAnnotation(MyRequestMapping.class);            <span class="hljs-type">String</span> <span class="hljs-variable">baseUrl</span> <span class="hljs-operator">=</span> annotation.value();            Method[] methods = clazz.getMethods();            <span class="hljs-keyword">for</span> (Method method : methods) &#123;                <span class="hljs-keyword">if</span> (method.isAnnotationPresent(MyRequestMapping.class)) &#123;                    <span class="hljs-type">String</span> <span class="hljs-variable">mappingUrl</span> <span class="hljs-operator">=</span> method.getAnnotation(MyRequestMapping.class).value();                    <span class="hljs-comment">// 获取匹配方法及对象 方便之后通过反射调用</span>                    handleMapping.put(baseUrl + mappingUrl, method);                    controllers.put(baseUrl + mappingUrl, iocFactory.get(key));                &#125;            &#125;        &#125;    &#125;    <span class="hljs-comment">// 中央处理器</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doDispatch</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-keyword">if</span> (iocFactory.isEmpty() || handleMapping.isEmpty() || controllers.isEmpty()) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> request.getRequestURI();        <span class="hljs-comment">// 如果不存在url</span>        <span class="hljs-keyword">if</span> (!handleMapping.containsKey(url)) &#123;            response.getWriter().write(<span class="hljs-string">&quot;Do Not Get Url : 404 ERROR&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// HandleMapping 的方法</span>        <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> handleMapping.get(url);        <span class="hljs-comment">// 获取方法的参数列表</span>        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();        <span class="hljs-comment">//获取请求的参数</span>        Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();        <span class="hljs-comment">//保存参数值</span>        Object [] paramValues= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[parameterTypes.length];        <span class="hljs-comment">// 方法的参数列表</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i&lt; parameterTypes.length; i++)&#123;            <span class="hljs-comment">//根据参数名称，做某些处理</span>            <span class="hljs-type">String</span> <span class="hljs-variable">requestParam</span> <span class="hljs-operator">=</span> parameterTypes[i].getSimpleName();            <span class="hljs-keyword">if</span> (requestParam.equals(<span class="hljs-string">&quot;HttpServletRequest&quot;</span>))&#123;                <span class="hljs-comment">//参数类型已明确，这边强转类型</span>                paramValues[i] = request;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">if</span> (requestParam.equals(<span class="hljs-string">&quot;HttpServletResponse&quot;</span>))&#123;                paramValues[i] = response;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">if</span>(requestParam.equals(<span class="hljs-string">&quot;String&quot;</span>))&#123;                <span class="hljs-keyword">for</span> (Map.Entry&lt;String, String[]&gt; param : parameterMap.entrySet()) &#123;                    <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> Arrays.toString(param.getValue()).replaceAll(<span class="hljs-string">&quot;\\[|\\]&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).replaceAll(<span class="hljs-string">&quot;,\\s&quot;</span>, <span class="hljs-string">&quot;,&quot;</span>);                    paramValues[i] = value;                &#125;            &#125;        &#125;        method.invoke(controllers.get(url), paramValues);    &#125;&#125;</code></pre><ol start="4"><li>测试代码：</li></ol><pre><code class="hljs java"><span class="hljs-meta">@MyController</span><span class="hljs-meta">@MyRequestMapping(&quot;/test&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestController</span> &#123;    <span class="hljs-meta">@MyRequestMapping(&quot;/doTest&quot;)</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span> <span class="hljs-params">( HttpServletRequest request, HttpServletResponse response,</span><span class="hljs-params">                        <span class="hljs-meta">@MyRequestParam(&quot;param&quot;)</span> String param)</span>&#123;        System.out.println(param);        <span class="hljs-keyword">try</span> &#123;            response.getWriter().write( <span class="hljs-string">&quot;doTest method success! param:&quot;</span>+param);        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-meta">@MyRequestMapping(&quot;/doTest2&quot;)</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span>&#123;        <span class="hljs-keyword">try</span> &#123;            response.getWriter().println(<span class="hljs-string">&quot;doTest2 method success!&quot;</span>);        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>测试结果：</p><p><a href="http://localhost:8080/">http://localhost:8080/</a>                                                   -&gt; Do Not Get Url : 404 ERROR</p><p><a href="http://localhost:8080/test/doTest2">http://localhost:8080/test/doTest2</a>                              -&gt; doTest2 method success!</p><p><a href="http://localhost:8080/test/doTest?param=asdasdad">http://localhost:8080/test/doTest?param=asdasdad</a> -&gt; doTest method success! param:asdasdad</p><blockquote><p>源码地址：<a href="https://github.com/kkzhilu/KerwinCodes">https://github.com/kkzhilu/KerwinCodes</a>  code_springmvc分支</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>框架篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>手写简易SpringMVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日志套餐篇</title>
    <link href="/2023/02/06/%E6%97%A5%E5%BF%97%E5%A5%97%E9%A4%90%E7%AF%87/"/>
    <url>/2023/02/06/%E6%97%A5%E5%BF%97%E5%A5%97%E9%A4%90%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="日志套餐篇-log4j2-logback全量套餐"><a href="#日志套餐篇-log4j2-logback全量套餐" class="headerlink" title="日志套餐篇 - log4j2 logback全量套餐"></a>日志套餐篇 - log4j2 logback全量套餐</h1><p>标签： #Share</p><blockquote><p>前情提要：</p><p>Log4j  Log4j2  logback是当下主流的日志框架</p><p>slf4j则是新一代的日志框架接口，logback直接实现了slf4j接口，另外logback是SpringBoot最新的默认日志框架</p><p>综合来看性能上依然推荐：log4j2（拥有logback全部特性）</p></blockquote><p><strong>注：</strong>鉴于log4j已经跟不上时代的要求，因此不做特别的介绍，其实log4j的配置，完全可以在log4j2上使用</p><h2 id="普通工程-建议集成log4j2"><a href="#普通工程-建议集成log4j2" class="headerlink" title="普通工程 - 建议集成log4j2"></a>普通工程 - 建议集成log4j2</h2><p>普通工程即：普通的java项目, 如个人的代码Demo或者准备打成jar使用的，推荐使用log4j2</p><p>必要依赖如下：</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- log4j2 必要依赖 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.12.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- log4j2 必要依赖 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.12.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- slf4j核心包 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- log4j-异步日志依赖 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.lmax<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>disruptor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--用于与slf4j保持桥接--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-slf4j-impl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.12.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>配置如下：</p><blockquote><p>Maven项目只需要在resource里面加入log4j2.xml配置文件即可</p></blockquote><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><span class="hljs-comment">&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;</span><span class="hljs-comment">&lt;!--Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，你会看到log4j2内部各种详细输出--&gt;</span><span class="hljs-comment">&lt;!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Configuration</span> <span class="hljs-attr">status</span>=<span class="hljs-string">&quot;WARN&quot;</span> <span class="hljs-attr">monitorInterval</span>=<span class="hljs-string">&quot;30&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!--全局属性--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">Properties</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;APP_NAME&quot;</span>&gt;</span>kerwinTools<span class="hljs-tag">&lt;/<span class="hljs-name">Property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;LOG_FILE_PATH&quot;</span>&gt;</span>/log/$&#123;APP_NAME&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">Property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;PATTERN_FORMAT&quot;</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %-5level [%t] %class&#123;36&#125; (%L) %M - %msg%xEx%n<span class="hljs-tag">&lt;/<span class="hljs-name">Property</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">Properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">Appenders</span>&gt;</span>        <span class="hljs-comment">&lt;!--输出到控制台--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Console</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Console&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;SYSTEM_OUT&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;$&#123;PATTERN_FORMAT&#125;&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">Console</span>&gt;</span>        <span class="hljs-comment">&lt;!-- INFO_LOG --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">RollingFile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;INFO_LOG&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;$&#123;LOG_FILE_PATH&#125;/info.log&quot;</span> <span class="hljs-attr">filePattern</span>=<span class="hljs-string">&quot;$&#123;LOG_HOME&#125;/info.log_%d&#123;yyyy-MM-dd&#125;.log&quot;</span>&gt;</span>            <span class="hljs-comment">&lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">Filters</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">ThresholdFilter</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;warn&quot;</span> <span class="hljs-attr">onMatch</span>=<span class="hljs-string">&quot;DENY&quot;</span> <span class="hljs-attr">onMismatch</span>=<span class="hljs-string">&quot;NEUTRAL&quot;</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">ThresholdFilter</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span> <span class="hljs-attr">onMatch</span>=<span class="hljs-string">&quot;ACCEPT&quot;</span> <span class="hljs-attr">onMismatch</span>=<span class="hljs-string">&quot;DENY&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">Filters</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;PATTERN_FORMAT&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">PatternLayout</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">Policies</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">TimeBasedTriggeringPolicy</span> <span class="hljs-attr">interval</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">modulate</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">Policies</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">DefaultRolloverStrategy</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">Delete</span> <span class="hljs-attr">basePath</span>=<span class="hljs-string">&quot;$&#123;LOG_FILE_PATH&#125;&quot;</span> <span class="hljs-attr">maxDepth</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">IfFileName</span> <span class="hljs-attr">glob</span>=<span class="hljs-string">&quot;info.log_*&quot;</span> /&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">IfLastModified</span> <span class="hljs-attr">age</span>=<span class="hljs-string">&quot;5d&quot;</span> /&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">Delete</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">DefaultRolloverStrategy</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">RollingFile</span>&gt;</span>        <span class="hljs-comment">&lt;!-- DEBUG_LOG --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">RollingFile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;DEBUG_LOG&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;$&#123;LOG_FILE_PATH&#125;/debug.log&quot;</span> <span class="hljs-attr">filePattern</span>=<span class="hljs-string">&quot;$&#123;LOG_HOME&#125;/debug.log_%d&#123;yyyy-MM-dd&#125;.log&quot;</span>&gt;</span>            <span class="hljs-comment">&lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">Filters</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">ThresholdFilter</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;error&quot;</span> <span class="hljs-attr">onMatch</span>=<span class="hljs-string">&quot;DENY&quot;</span> <span class="hljs-attr">onMismatch</span>=<span class="hljs-string">&quot;NEUTRAL&quot;</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">ThresholdFilter</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;debug&quot;</span> <span class="hljs-attr">onMatch</span>=<span class="hljs-string">&quot;ACCEPT&quot;</span> <span class="hljs-attr">onMismatch</span>=<span class="hljs-string">&quot;DENY&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">Filters</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;PATTERN_FORMAT&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">PatternLayout</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">Policies</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">TimeBasedTriggeringPolicy</span> <span class="hljs-attr">interval</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">modulate</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">Policies</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">DefaultRolloverStrategy</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">Delete</span> <span class="hljs-attr">basePath</span>=<span class="hljs-string">&quot;$&#123;LOG_FILE_PATH&#125;&quot;</span> <span class="hljs-attr">maxDepth</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">IfFileName</span> <span class="hljs-attr">glob</span>=<span class="hljs-string">&quot;debug.log_*&quot;</span> /&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">IfLastModified</span> <span class="hljs-attr">age</span>=<span class="hljs-string">&quot;5d&quot;</span> /&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">Delete</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">DefaultRolloverStrategy</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">RollingFile</span>&gt;</span>        <span class="hljs-comment">&lt;!-- ERROR_LOG --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">RollingFile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ERROR_LOG&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;$&#123;LOG_FILE_PATH&#125;/error.log&quot;</span> <span class="hljs-attr">filePattern</span>=<span class="hljs-string">&quot;$&#123;LOG_HOME&#125;/error.log_%d&#123;yyyy-MM-dd&#125;.log&quot;</span>&gt;</span>            <span class="hljs-comment">&lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">ThresholdFilter</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;error&quot;</span> <span class="hljs-attr">onMatch</span>=<span class="hljs-string">&quot;ACCEPT&quot;</span> <span class="hljs-attr">onMismatch</span>=<span class="hljs-string">&quot;DENY&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;PATTERN_FORMAT&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">PatternLayout</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">Policies</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">TimeBasedTriggeringPolicy</span> <span class="hljs-attr">interval</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">modulate</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">Policies</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">DefaultRolloverStrategy</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">Delete</span> <span class="hljs-attr">basePath</span>=<span class="hljs-string">&quot;$&#123;LOG_FILE_PATH&#125;&quot;</span> <span class="hljs-attr">maxDepth</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">IfFileName</span> <span class="hljs-attr">glob</span>=<span class="hljs-string">&quot;error.log_*&quot;</span> /&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">IfLastModified</span> <span class="hljs-attr">age</span>=<span class="hljs-string">&quot;5d&quot;</span> /&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">Delete</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">DefaultRolloverStrategy</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">RollingFile</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">Appenders</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">Loggers</span>&gt;</span>        <span class="hljs-comment">&lt;!-- LOG everything at DEBUG level includeLocation 处理日志所在行号 --&gt;</span>        <span class="hljs-comment">&lt;!-- Root 同步日志 AsyncRoot 异步日志 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">AsyncRoot</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;DEBUG&quot;</span> <span class="hljs-attr">includeLocation</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span>            <span class="hljs-comment">&lt;!-- Console 日志, 注释即不打印到控制台 --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;Console&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;INFO_LOG&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;DEBUG_LOG&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;ERROR_LOG&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">AsyncRoot</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">Loggers</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Configuration</span>&gt;</span></code></pre><p><strong>注：</strong>日志打印的位置我并没用做特别的约束，所以它会在项目所存储的盘符自动建立${APP_NAME} 文件夹</p><p>效果如图所示：</p><p><img src="/2023/02/06/%E6%97%A5%E5%BF%97%E5%A5%97%E9%A4%90%E7%AF%87/1565711360530.png" alt="1565711360530"></p><h2 id="如何验证Lo4j2开启异步日志"><a href="#如何验证Lo4j2开启异步日志" class="headerlink" title="如何验证Lo4j2开启异步日志"></a>如何验证Lo4j2开启异步日志</h2><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Configuration</span> <span class="hljs-attr">status</span>=<span class="hljs-string">&quot;WARN&quot;</span> <span class="hljs-attr">monitorInterval</span>=<span class="hljs-string">&quot;30&quot;</span>&gt;</span></code></pre><blockquote><p>注意Lo4j2的<code>Configuration</code>设置中<code>status=&quot;WARN&quot;</code>, 设置为 <code>TRACE</code>，即可让log4j打印内部日志，即可判断日志的细节</p></blockquote><h2 id="SpringBoot项目-个人练习建议集成logback"><a href="#SpringBoot项目-个人练习建议集成logback" class="headerlink" title="SpringBoot项目  - 个人练习建议集成logback"></a>SpringBoot项目  - 个人练习建议集成logback</h2><pre><code class="hljs java"><span class="hljs-comment">// 由于springboot默认支持logbak  因此无需任何依赖即可使用,当然需要一些默认的必备依赖 如 web等...</span></code></pre><p>application配置如下：</p><pre><code class="hljs properties"><span class="hljs-comment"># 约束mybis-dao级别为dao层</span><span class="hljs-attr">logging.level.com.cat.dao</span>=<span class="hljs-string">DEBUG</span><span class="hljs-attr">logging.config</span>=<span class="hljs-string">classpath:logback-spring.xml</span><span class="hljs-comment"></span><span class="hljs-comment"># 文件输出位置即文件夹名称</span><span class="hljs-attr">logging.file</span>=<span class="hljs-string">/log/volcat-server</span></code></pre><p>配置文件如下：</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><span class="hljs-comment">&lt;!-- 日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，如果设置为WARN，则低于WARN的信息都不会输出 --&gt;</span><span class="hljs-comment">&lt;!-- scan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true --&gt;</span><span class="hljs-comment">&lt;!-- scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 --&gt;</span><span class="hljs-comment">&lt;!-- de<span class="hljs-doctag">bug:</span>当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>  <span class="hljs-attr">scan</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">scanPeriod</span>=<span class="hljs-string">&quot;10 seconds&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">contextName</span>&gt;</span>logback<span class="hljs-tag">&lt;/<span class="hljs-name">contextName</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 命名为logback-spring 可以读取spring中的配置信息, 以下即为读取spring的日志输出地址 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">springProperty</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;context&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;log.path&quot;</span> <span class="hljs-attr">source</span>=<span class="hljs-string">&quot;logging.file&quot;</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 在当前文件中约束配置地址 --&gt;</span>    <span class="hljs-comment">&lt;!--&lt;property name=&quot;log.path&quot; value=&quot;/log/demo_test_nginx&quot; /&gt;--&gt;</span>    <span class="hljs-comment">&lt;!--</span><span class="hljs-comment">       &lt;logger&gt;用来设置某一个包或者具体的某一个类的日志打印级别、</span><span class="hljs-comment">       以及指定&lt;appender&gt;。&lt;logger&gt;仅有一个name属性，</span><span class="hljs-comment">       一个可选的level和一个可选的addtivity属性。</span><span class="hljs-comment">       name:用来指定受此logger约束的某一个包或者具体的某一个类。</span><span class="hljs-comment">       level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，</span><span class="hljs-comment">             还有一个特俗值INHERITED或者同义词NULL，代表强制执行上级的级别。</span><span class="hljs-comment">             如果未设置此属性，那么当前logger将会继承上级的级别。</span><span class="hljs-comment">       addtivity:是否向上级logger传递打印信息。默认是true</span><span class="hljs-comment">   --&gt;</span>    <span class="hljs-comment">&lt;!-- 彩色日志 --&gt;</span>    <span class="hljs-comment">&lt;!-- 彩色日志依赖的渲染类 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">conversionRule</span> <span class="hljs-attr">conversionWord</span>=<span class="hljs-string">&quot;clr&quot;</span> <span class="hljs-attr">converterClass</span>=<span class="hljs-string">&quot;org.springframework.boot.logging.logback.ColorConverter&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">conversionRule</span> <span class="hljs-attr">conversionWord</span>=<span class="hljs-string">&quot;wex&quot;</span> <span class="hljs-attr">converterClass</span>=<span class="hljs-string">&quot;org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">conversionRule</span> <span class="hljs-attr">conversionWord</span>=<span class="hljs-string">&quot;wEx&quot;</span> <span class="hljs-attr">converterClass</span>=<span class="hljs-string">&quot;org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter&quot;</span> /&gt;</span>    <span class="hljs-comment">&lt;!-- 彩色日志格式 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;CONSOLE_LOG_PATTERN&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;CONSOLE_LOG_PATTERN:-%clr(%d&#123;yyyy-MM-dd HH:mm:ss&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125; %line)&#123;cyan&#125; %clr(:) %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;&quot;</span>/&gt;</span>    <span class="hljs-comment">&lt;!--输出到控制台--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span>        <span class="hljs-comment">&lt;!--此日志appender是为开发使用，配置为DEBUG级别, 控制台输出的日志级别是大于或等于此级别的日志信息--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>debug<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">Pattern</span>&gt;</span>$&#123;CONSOLE_LOG_PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">Pattern</span>&gt;</span>            <span class="hljs-comment">&lt;!-- 设置字符集 --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>    <span class="hljs-comment">&lt;!--输出到文件--&gt;</span>    <span class="hljs-comment">&lt;!-- 时间滚动输出 level为 DEBUG 日志 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;DEBUG_FILE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 正在记录的日志文件的路径及文件名 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>$&#123;log.path&#125;/debug.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span>        <span class="hljs-comment">&lt;!--日志文件输出格式--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span> <span class="hljs-comment">&lt;!-- 设置字符集 --&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span>            <span class="hljs-comment">&lt;!-- 日志归档 --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/debug/debug-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">maxFileSize</span>&gt;</span>100MB<span class="hljs-tag">&lt;/<span class="hljs-name">maxFileSize</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span>            <span class="hljs-comment">&lt;!--日志文件保留天数--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>15<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 此日志文件只记录debug级别的 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>debug<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>DENY<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 时间滚动输出 level为 INFO 日志 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;INFO_FILE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 正在记录的日志文件的路径及文件名 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>$&#123;log.path&#125;/info.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span>        <span class="hljs-comment">&lt;!--日志文件输出格式--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span>            <span class="hljs-comment">&lt;!-- 每天日志归档路径以及格式 --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/info/info-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">maxFileSize</span>&gt;</span>100MB<span class="hljs-tag">&lt;/<span class="hljs-name">maxFileSize</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span>            <span class="hljs-comment">&lt;!--日志文件保留天数--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>15<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 此日志文件只记录info级别的 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>info<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>DENY<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 时间滚动输出 level为 WARN 日志 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;WARN_FILE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 正在记录的日志文件的路径及文件名 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>$&#123;log.path&#125;/warn.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span>        <span class="hljs-comment">&lt;!--日志文件输出格式--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span> <span class="hljs-comment">&lt;!-- 此处设置字符集 --&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/warn/warn-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">maxFileSize</span>&gt;</span>100MB<span class="hljs-tag">&lt;/<span class="hljs-name">maxFileSize</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span>            <span class="hljs-comment">&lt;!--日志文件保留天数--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>15<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 此日志文件只记录warn级别的 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>warn<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>DENY<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 时间滚动输出 level为 ERROR 日志 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ERROR_FILE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 正在记录的日志文件的路径及文件名 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>$&#123;log.path&#125;/error.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span>        <span class="hljs-comment">&lt;!--日志文件输出格式--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span> <span class="hljs-comment">&lt;!-- 此处设置字符集 --&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/error/error-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">maxFileSize</span>&gt;</span>100MB<span class="hljs-tag">&lt;/<span class="hljs-name">maxFileSize</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span>            <span class="hljs-comment">&lt;!--日志文件保留天数--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>15<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 此日志文件只记录ERROR级别的 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>ERROR<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>DENY<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>    <span class="hljs-comment">&lt;!--</span><span class="hljs-comment">        root节点是必选节点，用来指定最基础的日志输出级别，只有一个level属性</span><span class="hljs-comment">        level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，</span><span class="hljs-comment">        不能设置为INHERITED或者同义词NULL。默认是DEBUG</span><span class="hljs-comment">        可以包含零个或多个元素，标识这个appender将会添加到这个logger。</span><span class="hljs-comment">    --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;DEBUG_FILE&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;INFO_FILE&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;WARN_FILE&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;ERROR_FILE&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre><h2 id="SpringBoot项目-集成log4j2"><a href="#SpringBoot项目-集成log4j2" class="headerlink" title="SpringBoot项目  - 集成log4j2"></a>SpringBoot项目  - 集成log4j2</h2><p>必备依赖  - 既然是SpringBoot项目,那用官方的starter是最好的，版本什么的都不用管</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 去除logback日志依赖 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- 导入log4j2-starter --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- log4j2 异步打印必要依赖 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.lmax<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>disruptor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>applications配置</p><pre><code class="hljs ini"><span class="hljs-comment"># mybatis-dao相关的操作为DEBUG级别, 数据库日志会打印到debug文件中</span><span class="hljs-attr">logging.level.com.cat.dao</span>=DEBUG<span class="hljs-attr">logging.config</span>=classpath:log4j2.xml</code></pre><p>配置文件 - 沿用上面的配置文件即可，必要情况可以修改打印的日志级别，如</p><pre><code class="hljs xml">.....<span class="hljs-tag">&lt;<span class="hljs-name">Loggers</span>&gt;</span>    <span class="hljs-comment">&lt;!--过滤掉spring和mybatis的一些无用的DEBUG信息--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">Logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.springframework&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">Logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.mybatis&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- LOG everything at INFO level --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">Root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;Console&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;INFO_LOG&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;DEBUG_LOG&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;ERROR_LOG&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">Root</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Loggers</span>&gt;</span></code></pre><h2 id="SpringBoot-log4j2-企业级方案"><a href="#SpringBoot-log4j2-企业级方案" class="headerlink" title="SpringBoot - log4j2 企业级方案"></a>SpringBoot - log4j2 企业级方案</h2><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">Configuration</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;LOG_HOME&quot;</span>&gt;</span>/log/volcat-server<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">Appenders</span>&gt;</span>          <span class="hljs-comment">&lt;!-- 輸出到監視器 --&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">Console</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Console&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;SYSTEM_OUT&quot;</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;%date&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; [%thread][%level] - %msg%n&quot;</span> /&gt;</span>          <span class="hljs-tag">&lt;/<span class="hljs-name">Console</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">RollingFile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;error.log&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;$&#123;LOG_HOME&#125;/error.log&quot;</span> <span class="hljs-attr">filePattern</span>=<span class="hljs-string">&quot;$&#123;LOG_HOME&#125;/error.log_%d&#123;yyyy-MM-dd&#125;.log&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;%date&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; [%thread][%level] - %msg%n&quot;</span> /&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">Policies</span>&gt;</span>                  <span class="hljs-tag">&lt;<span class="hljs-name">TimeBasedTriggeringPolicy</span> <span class="hljs-attr">interval</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">modulate</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span>              <span class="hljs-tag">&lt;/<span class="hljs-name">Policies</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">DefaultRolloverStrategy</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">Delete</span> <span class="hljs-attr">basePath</span>=<span class="hljs-string">&quot;$&#123;LOG_HOME&#125;&quot;</span> <span class="hljs-attr">maxDepth</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>                       <span class="hljs-tag">&lt;<span class="hljs-name">IfFileName</span> <span class="hljs-attr">glob</span>=<span class="hljs-string">&quot;error.log_*&quot;</span> /&gt;</span>                       <span class="hljs-tag">&lt;<span class="hljs-name">IfLastModified</span> <span class="hljs-attr">age</span>=<span class="hljs-string">&quot;5d&quot;</span> /&gt;</span>              <span class="hljs-tag">&lt;/<span class="hljs-name">Delete</span>&gt;</span>              <span class="hljs-tag">&lt;/<span class="hljs-name">DefaultRolloverStrategy</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">RollingFile</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">RollingFile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;debug.log&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;$&#123;LOG_HOME&#125;/debug.log&quot;</span> <span class="hljs-attr">filePattern</span>=<span class="hljs-string">&quot;$&#123;LOG_HOME&#125;/debug.log_%d&#123;yyyy-MM-dd&#125;.log&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;%date&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; [%thread][%level] - %msg%n&quot;</span> /&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">Policies</span>&gt;</span>                  <span class="hljs-tag">&lt;<span class="hljs-name">TimeBasedTriggeringPolicy</span> <span class="hljs-attr">interval</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">modulate</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span>              <span class="hljs-tag">&lt;/<span class="hljs-name">Policies</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">DefaultRolloverStrategy</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">Delete</span> <span class="hljs-attr">basePath</span>=<span class="hljs-string">&quot;$&#123;LOG_HOME&#125;&quot;</span> <span class="hljs-attr">maxDepth</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>                       <span class="hljs-tag">&lt;<span class="hljs-name">IfFileName</span> <span class="hljs-attr">glob</span>=<span class="hljs-string">&quot;debug.log_*&quot;</span> /&gt;</span>                       <span class="hljs-tag">&lt;<span class="hljs-name">IfLastModified</span> <span class="hljs-attr">age</span>=<span class="hljs-string">&quot;5d&quot;</span> /&gt;</span>              <span class="hljs-tag">&lt;/<span class="hljs-name">Delete</span>&gt;</span>              <span class="hljs-tag">&lt;/<span class="hljs-name">DefaultRolloverStrategy</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">RollingFile</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">RollingFile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;message.log&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;$&#123;LOG_HOME&#125;/message.log&quot;</span> <span class="hljs-attr">filePattern</span>=<span class="hljs-string">&quot;$&#123;LOG_HOME&#125;/message.log_%d&#123;yyyy-MM-dd&#125;.log&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;%date&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; [%thread][%level] - %msg%n&quot;</span> /&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">Policies</span>&gt;</span>                  <span class="hljs-tag">&lt;<span class="hljs-name">TimeBasedTriggeringPolicy</span> <span class="hljs-attr">interval</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">modulate</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span>              <span class="hljs-tag">&lt;/<span class="hljs-name">Policies</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">DefaultRolloverStrategy</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">Delete</span> <span class="hljs-attr">basePath</span>=<span class="hljs-string">&quot;$&#123;LOG_HOME&#125;&quot;</span> <span class="hljs-attr">maxDepth</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>                       <span class="hljs-tag">&lt;<span class="hljs-name">IfFileName</span> <span class="hljs-attr">glob</span>=<span class="hljs-string">&quot;message.log_*&quot;</span> /&gt;</span>                       <span class="hljs-tag">&lt;<span class="hljs-name">IfLastModified</span> <span class="hljs-attr">age</span>=<span class="hljs-string">&quot;5d&quot;</span> /&gt;</span>              <span class="hljs-tag">&lt;/<span class="hljs-name">Delete</span>&gt;</span>              <span class="hljs-tag">&lt;/<span class="hljs-name">DefaultRolloverStrategy</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">RollingFile</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">RollingFile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;access.log&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;$&#123;LOG_HOME&#125;/access.log&quot;</span> <span class="hljs-attr">filePattern</span>=<span class="hljs-string">&quot;$&#123;LOG_HOME&#125;/access.log_%d&#123;yyyy-MM-dd&#125;.log&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;%date&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; [%thread][%level] - %msg%n&quot;</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">Policies</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">TimeBasedTriggeringPolicy</span> <span class="hljs-attr">interval</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">modulate</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">Policies</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">DefaultRolloverStrategy</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">Delete</span> <span class="hljs-attr">basePath</span>=<span class="hljs-string">&quot;$&#123;LOG_HOME&#125;&quot;</span> <span class="hljs-attr">maxDepth</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">IfFileName</span> <span class="hljs-attr">glob</span>=<span class="hljs-string">&quot;access.log_*&quot;</span> /&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">IfLastModified</span> <span class="hljs-attr">age</span>=<span class="hljs-string">&quot;5d&quot;</span> /&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">Delete</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">DefaultRolloverStrategy</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">RollingFile</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">Appenders</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">Loggers</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">Logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sys.error&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;ERROR&quot;</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;error.log&quot;</span> /&gt;</span>          <span class="hljs-tag">&lt;/<span class="hljs-name">Logger</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sys.debug&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;DEBUG&quot;</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;debug.log&quot;</span> /&gt;</span>          <span class="hljs-tag">&lt;/<span class="hljs-name">Logger</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sys.message&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;message.log&quot;</span> /&gt;</span>          <span class="hljs-tag">&lt;/<span class="hljs-name">Logger</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sys.access&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;access.log&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">Logger</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">Loggers</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">Configuration</span>&gt;</span></code></pre><p><strong>Logit工具类</strong></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mine.log;<span class="hljs-keyword">import</span> org.slf4j.Logger;<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Logit</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">DEBUG_LOG</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(<span class="hljs-string">&quot;sys.debug&quot;</span>);    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">WARN_LOG</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(<span class="hljs-string">&quot;sys.warn&quot;</span>);    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">MESSAGE_LOG</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(<span class="hljs-string">&quot;sys.message&quot;</span>);    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">ACCESS_LOG</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(<span class="hljs-string">&quot;sys.access&quot;</span>);    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">ERROR_LOG</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(<span class="hljs-string">&quot;sys.error&quot;</span>);    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">DB_LOG</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(<span class="hljs-string">&quot;db.sql&quot;</span>);    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Logit</span><span class="hljs-params">()</span> &#123;&#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accessLog</span><span class="hljs-params">(String log)</span> &#123;        ACCESS_LOG.info(log);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">messageLog</span><span class="hljs-params">(String log)</span> &#123;        StackTraceElement[] stacks = (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Throwable</span>()).getStackTrace();        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(stacks[<span class="hljs-number">1</span>].getClassName());        sb.append(<span class="hljs-string">&quot;.&quot;</span>);        sb.append(stacks[<span class="hljs-number">1</span>].getMethodName());        sb.append(<span class="hljs-string">&quot;---&quot;</span>);        sb.append(log);        MESSAGE_LOG.info(sb.toString());    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">messageLog</span><span class="hljs-params">(String log, String loglevel)</span> &#123;        StackTraceElement[] stacks = (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Throwable</span>()).getStackTrace();        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(stacks[<span class="hljs-number">1</span>].getClassName());        sb.append(<span class="hljs-string">&quot;.&quot;</span>);        sb.append(stacks[<span class="hljs-number">1</span>].getMethodName());        sb.append(<span class="hljs-string">&quot;---&quot;</span>);        sb.append(log);        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;debug&quot;</span>.equalsIgnoreCase(loglevel)) &#123;            MESSAGE_LOG.debug(log);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;info&quot;</span>.equalsIgnoreCase(loglevel)) &#123;            MESSAGE_LOG.info(log);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;warn&quot;</span>.equalsIgnoreCase(loglevel)) &#123;            MESSAGE_LOG.warn(log);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;error&quot;</span>.equalsIgnoreCase(loglevel)) &#123;            MESSAGE_LOG.error(log);        &#125; <span class="hljs-keyword">else</span> &#123;            MESSAGE_LOG.info(log);        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debugLog</span><span class="hljs-params">(String log)</span> &#123;        StackTraceElement[] stacks = (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Throwable</span>()).getStackTrace();        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(stacks[<span class="hljs-number">1</span>].getClassName());        sb.append(<span class="hljs-string">&quot;.&quot;</span>);        sb.append(stacks[<span class="hljs-number">1</span>].getMethodName());        sb.append(<span class="hljs-string">&quot;---&quot;</span>);        sb.append(log);        debugPlog(sb.toString(), <span class="hljs-string">&quot;debug&quot;</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debugLog</span><span class="hljs-params">(String log, String loglevel)</span> &#123;        StackTraceElement[] stacks = (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Throwable</span>()).getStackTrace();        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(stacks[<span class="hljs-number">1</span>].getClassName());        sb.append(<span class="hljs-string">&quot;.&quot;</span>);        sb.append(stacks[<span class="hljs-number">1</span>].getMethodName());        sb.append(<span class="hljs-string">&quot;---&quot;</span>);        sb.append(log);        debugPlog(sb.toString(), loglevel);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debugPlog</span><span class="hljs-params">(String log, String loglevel)</span> &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;debug&quot;</span>.equalsIgnoreCase(loglevel)) &#123;            DEBUG_LOG.debug(log);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;info&quot;</span>.equalsIgnoreCase(loglevel)) &#123;            DEBUG_LOG.info(log);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;warn&quot;</span>.equalsIgnoreCase(loglevel)) &#123;            DEBUG_LOG.warn(log);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;error&quot;</span>.equalsIgnoreCase(loglevel)) &#123;            DEBUG_LOG.error(log);        &#125; <span class="hljs-keyword">else</span> &#123;            DEBUG_LOG.debug(log);        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">warnLog</span><span class="hljs-params">(String log)</span> &#123;        StackTraceElement[] stacks = (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Throwable</span>()).getStackTrace();        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(stacks[<span class="hljs-number">1</span>].getClassName());        sb.append(<span class="hljs-string">&quot;.&quot;</span>);        sb.append(stacks[<span class="hljs-number">1</span>].getMethodName());        sb.append(<span class="hljs-string">&quot;---&quot;</span>);        sb.append(log);        WARN_LOG.error(sb.toString());    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">errorLog</span><span class="hljs-params">(String log)</span> &#123;        StackTraceElement[] stacks = (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Throwable</span>()).getStackTrace();        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(stacks[<span class="hljs-number">1</span>].getClassName());        sb.append(<span class="hljs-string">&quot;.&quot;</span>);        sb.append(stacks[<span class="hljs-number">1</span>].getMethodName());        sb.append(<span class="hljs-string">&quot;---&quot;</span>);        sb.append(log);        errorPLog(sb.toString(), (Throwable)<span class="hljs-literal">null</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">errorLog</span><span class="hljs-params">(String log, Throwable throwable)</span> &#123;        StackTraceElement[] stacks = (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Throwable</span>()).getStackTrace();        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(stacks[<span class="hljs-number">1</span>].getClassName());        sb.append(<span class="hljs-string">&quot;.&quot;</span>);        sb.append(stacks[<span class="hljs-number">1</span>].getMethodName());        sb.append(<span class="hljs-string">&quot;---&quot;</span>);        sb.append(log);        errorPLog(sb.toString(), throwable);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dbLog</span><span class="hljs-params">(String log, Object... objects)</span> &#123;        StackTraceElement[] stacks = (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Throwable</span>()).getStackTrace();        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(stacks[<span class="hljs-number">1</span>].getClassName());        sb.append(<span class="hljs-string">&quot;.&quot;</span>);        sb.append(stacks[<span class="hljs-number">1</span>].getMethodName());        sb.append(<span class="hljs-string">&quot;---&quot;</span>);        sb.append(log);        <span class="hljs-keyword">if</span> (objects != <span class="hljs-literal">null</span> &amp;&amp; objects.length &gt; <span class="hljs-number">0</span>) &#123;            sb.append(<span class="hljs-string">&quot;; parameter[&quot;</span>);            Object[] var4 = objects;            <span class="hljs-type">int</span> <span class="hljs-variable">var5</span> <span class="hljs-operator">=</span> objects.length;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">var6</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; var6 &lt; var5; ++var6) &#123;                <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> var4[var6];                sb.append(obj);                sb.append(<span class="hljs-string">&quot;,&quot;</span>);            &#125;            sb.delete(sb.length() - <span class="hljs-number">1</span>, sb.length());            sb.append(<span class="hljs-string">&quot;]&quot;</span>);        &#125;        DB_LOG.debug(sb.toString());    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">errorPLog</span><span class="hljs-params">(String log, Throwable throwable)</span> &#123;        <span class="hljs-keyword">if</span> (throwable == <span class="hljs-literal">null</span>) &#123;            ERROR_LOG.error(log);        &#125; <span class="hljs-keyword">else</span> &#123;            ERROR_LOG.error(log, throwable);        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String name, String log)</span> &#123;        StackTraceElement[] stacks = (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Throwable</span>()).getStackTrace();        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(stacks[<span class="hljs-number">1</span>].getClassName());        sb.append(<span class="hljs-string">&quot;.&quot;</span>);        sb.append(stacks[<span class="hljs-number">1</span>].getMethodName());        sb.append(<span class="hljs-string">&quot;---&quot;</span>);        sb.append(log);        logByName(name, sb.toString(), <span class="hljs-string">&quot;debug&quot;</span>, (Throwable)<span class="hljs-literal">null</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String name, String log, String loglevel)</span> &#123;        StackTraceElement[] stacks = (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Throwable</span>()).getStackTrace();        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(stacks[<span class="hljs-number">1</span>].getClassName());        sb.append(<span class="hljs-string">&quot;.&quot;</span>);        sb.append(stacks[<span class="hljs-number">1</span>].getMethodName());        sb.append(<span class="hljs-string">&quot;---&quot;</span>);        sb.append(log);        logByName(name, sb.toString(), loglevel, (Throwable)<span class="hljs-literal">null</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String name, String log, String loglevel, Throwable throwable)</span> &#123;        StackTraceElement[] stacks = (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Throwable</span>()).getStackTrace();        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(stacks[<span class="hljs-number">1</span>].getClassName());        sb.append(<span class="hljs-string">&quot;.&quot;</span>);        sb.append(stacks[<span class="hljs-number">1</span>].getMethodName());        sb.append(<span class="hljs-string">&quot;---&quot;</span>);        sb.append(log);        logByName(name, sb.toString(), loglevel, throwable);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logByName</span><span class="hljs-params">(String name, String log, String loglevel, Throwable throwable)</span> &#123;        <span class="hljs-keyword">if</span> (name != <span class="hljs-literal">null</span>) &#123;            StackTraceElement[] stacks = (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Throwable</span>()).getStackTrace();            <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(stacks[<span class="hljs-number">1</span>].getClassName());            sb.append(<span class="hljs-string">&quot;.&quot;</span>);            sb.append(stacks[<span class="hljs-number">1</span>].getMethodName());            sb.append(<span class="hljs-string">&quot;---&quot;</span>);            sb.append(log);            <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(name);            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">if</span> (throwable == <span class="hljs-literal">null</span>) &#123;                    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;debug&quot;</span>.equalsIgnoreCase(loglevel)) &#123;                        logger.debug(log);                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;info&quot;</span>.equalsIgnoreCase(loglevel)) &#123;                        logger.info(log);                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;warn&quot;</span>.equalsIgnoreCase(loglevel)) &#123;                        logger.warn(log);                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;error&quot;</span>.equalsIgnoreCase(loglevel)) &#123;                        logger.error(log);                    &#125; <span class="hljs-keyword">else</span> &#123;                        logger.debug(log);                    &#125;                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;debug&quot;</span>.equalsIgnoreCase(loglevel)) &#123;                    logger.debug(log, throwable);                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;info&quot;</span>.equalsIgnoreCase(loglevel)) &#123;                    logger.info(log, throwable);                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;warn&quot;</span>.equalsIgnoreCase(loglevel)) &#123;                    logger.warn(log, throwable);                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;error&quot;</span>.equalsIgnoreCase(loglevel)) &#123;                    logger.error(log, throwable);                &#125; <span class="hljs-keyword">else</span> &#123;                    logger.debug(log, throwable);                &#125;            &#125; <span class="hljs-keyword">catch</span> (Exception var8) &#123;                ;            &#125;        &#125;    &#125;&#125;</code></pre><p>使用说明 : </p><pre><code class="hljs java"><span class="hljs-comment">// 由于该方案配置的Logger 为 sys.error...等开头，因此  直接使用loger的方式会在控制台输出，但不会被记录到日志文件之中,有且仅有通过Logit打印的日志才会被记录到文件中，此方案减少了每个类都创建loger的尴尬，非常方便</span>Logit.errorLog(<span class="hljs-string">&quot;在线用户插入失败&quot;</span> + <span class="hljs-string">&quot; parms: &quot;</span> + userOnline, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Throwable</span>(e));</code></pre><p>GITHUB链接：<a href="https://github.com/kkzhilu/volcat-server">https://github.com/kkzhilu/volcat-server</a> (不同分支即对应不同日志框架)</p><p>项目暂时为私有, 如果需要参考请联系我</p>]]></content>
    
    
    <categories>
      
      <category>Java篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日志套餐篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板方法模式</title>
    <link href="/2023/02/06/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/02/06/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="模板方法模式篇"><a href="#模板方法模式篇" class="headerlink" title="模板方法模式篇"></a>模板方法模式篇</h1><p>标签： #Share</p><h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>定义一个操作中的算法的骨架，将一些步骤延迟到子类中。 Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤</p><h2 id="模板方法模式的诞生"><a href="#模板方法模式的诞生" class="headerlink" title="模板方法模式的诞生"></a>模板方法模式的诞生</h2><p>模板方法模式为我们提供了一种代码复用的重要技巧，它定义了算法的步骤，把这些步骤的实现延迟到子类</p><p>说人话就是：</p><p>【<font color="orange">产品</font>】：开发小哥，你会做饭吗？</p><p>【<font color="blue">开发</font>】：不会啊，怎么了？难道你要做给我吃？</p><p>【<font color="orange">产品</font>】：你想太多了，我就准备教你做一道炒包菜~，用你们写代码思路，我也来试试写写伪代码</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cookie</span><span class="hljs-params">()</span>&#123;    <span class="hljs-comment">// 第一步：倒油</span>    <span class="hljs-built_in">this</span>.pourOil();    <span class="hljs-comment">// 第二步：热油</span>    <span class="hljs-built_in">this</span>.HeatOil();    <span class="hljs-comment">// 第三步：倒入包菜</span>    <span class="hljs-built_in">this</span>.pourVegetable();    <span class="hljs-comment">// 第四步：倒入调味料</span>    <span class="hljs-built_in">this</span>.pourSauce();    <span class="hljs-comment">// 第五步：翻炒</span>    <span class="hljs-built_in">this</span>.fry();&#125;</code></pre><p>【<font color="blue">开发</font>】：我懂了，小姐姐，你要不来我家？我给你做一道炒蒜蓉~</p><p>【<font color="orange">产品</font>】：？？？你不是说你不会做饭吗？</p><p><img src="/2023/02/06/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/image-20200608234717306.png" alt="image-20200608234717306"></p><p>【<font color="blue">开发</font>】：你不是写出来步骤了嘛，我已经会了，嘿嘿嘿~</p><blockquote><p>你要是还没会，那咱们就一起看看核心代码吧~<br>你如果会了，那直接跳到SSO实战吧~</p></blockquote><h2 id="HeadFirst-核心代码"><a href="#HeadFirst-核心代码" class="headerlink" title="HeadFirst 核心代码"></a>HeadFirst 核心代码</h2><p><em><strong>抽象类</strong></em></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TemplateClass</span> &#123;<span class="hljs-comment">/***</span><span class="hljs-comment"> * 模板方法，用来控制炒菜的流程 （炒菜的流程是一样的-复用）</span><span class="hljs-comment"> * 可根据需求申明为final，防止子类覆盖这个方法，导致流程的执行顺序</span><span class="hljs-comment"> */</span><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cookProcess</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">// 第一步：倒油</span><span class="hljs-built_in">this</span>.pourOil();<span class="hljs-comment">// 第二步：热油</span><span class="hljs-built_in">this</span>.heatOil();<span class="hljs-comment">// 第三步：倒蔬菜</span><span class="hljs-built_in">this</span>.pourVegetable();<span class="hljs-comment">// 配合钩子函数, 确定是否需要倒调味料</span><span class="hljs-keyword">if</span> (needSauce()) &#123;<span class="hljs-built_in">this</span>.pourSauce();&#125;<span class="hljs-comment">// 第五步：翻炒</span><span class="hljs-built_in">this</span>.fry();&#125;<span class="hljs-keyword">void</span> <span class="hljs-title function_">pourOil</span><span class="hljs-params">()</span> &#123;System.out.println(<span class="hljs-string">&quot;倒油&quot;</span>);&#125;<span class="hljs-keyword">void</span> <span class="hljs-title function_">heatOil</span><span class="hljs-params">()</span> &#123;System.out.println(<span class="hljs-string">&quot;热油&quot;</span>);&#125;<span class="hljs-comment">/***</span><span class="hljs-comment"> * 需要变化的部分就定义为抽象</span><span class="hljs-comment"> */</span><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pourVegetable</span><span class="hljs-params">()</span>;<span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pourSauce</span><span class="hljs-params">()</span>;<span class="hljs-comment">/***</span><span class="hljs-comment"> * 钩子函数, 影响方法调用逻辑</span><span class="hljs-comment"> */</span><span class="hljs-type">boolean</span> <span class="hljs-title function_">needSauce</span><span class="hljs-params">()</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">void</span> <span class="hljs-title function_">fry</span><span class="hljs-params">()</span> &#123;System.out.println(<span class="hljs-string">&quot;炒啊炒啊炒到熟啊&quot;</span>);&#125;&#125;</code></pre><p><em><strong>子类实现</strong></em></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SuanRong</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TemplateClass</span> &#123;<span class="hljs-meta">@Override</span><span class="hljs-type">boolean</span> <span class="hljs-title function_">needSauce</span><span class="hljs-params">()</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-meta">@Override</span><span class="hljs-keyword">void</span> <span class="hljs-title function_">pourVegetable</span><span class="hljs-params">()</span> &#123;System.out.println(<span class="hljs-string">&quot;下锅的蔬菜是菜心&quot;</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-keyword">void</span> <span class="hljs-title function_">pourSauce</span><span class="hljs-params">()</span> &#123;System.out.println(<span class="hljs-string">&quot;下锅的酱料是蒜蓉&quot;</span>);&#125;&#125;</code></pre><p><font color="red">模板方法模式的设计思路：</font></p><ul><li>AbstractClass（抽象类）抽象基类，定义抽象方法，方法调用顺序等等</li><li>ConcreteClass（实现类）继承抽象基类，实现预先定义的方法</li></ul><p>简单来说，</p><ol><li>我们需要一个抽象类或者接口（Java8之后接口也可以提供具体的方法），定义需要实现的方法和方法执行逻辑</li><li>根据业务情况继承抽象类或接口，实现特定方法，使多种情况互相隔离</li><li>配合如策略或其他的方式合理的构建需要的实现类即可</li></ol><blockquote><p>如果看着有点模棱两可，建议看完本文后，访问专题设计模式开源项目，里面有具体的代码示例，链接在最下面</p></blockquote><h2 id="模板的力量：5分钟一个SSO"><a href="#模板的力量：5分钟一个SSO" class="headerlink" title="模板的力量：5分钟一个SSO"></a>模板的力量：5分钟一个SSO</h2><p>要说到用模板方法模式去使用SSO时，咱们先需要知道<font color="blue">什么是SSO</font>（知道的同学直接略过啦~）</p><h3 id="SSO"><a href="#SSO" class="headerlink" title="SSO"></a>SSO</h3><p>SSO即<font color="blue">单点登录</font>，即<strong>在多个系统中，用户只需一次登录，各个系统即可感知该用户已经登录</strong></p><h3 id="用户鉴权的几种常见方式"><a href="#用户鉴权的几种常见方式" class="headerlink" title="用户鉴权的几种常见方式"></a>用户鉴权的几种常见方式</h3><p>本文主要还是侧重设计模式的实战，所以就简单说几句，常见方式如：</p><ul><li>oauth 2.0</li><li>cookie</li><li>………..</li></ul><h3 id="第一个SSO"><a href="#第一个SSO" class="headerlink" title="第一个SSO"></a>第一个SSO</h3><p>我们在编写第一个SSO的时候，还是有那么一点费劲的，需要考虑各种流程，细节等等</p><p><font color="blue">（这里指的是我们集成其他公司的鉴权系统）</font></p><p>我所在的公司客户技术水平五花八门，技术栈也是五花八门，所以不是标准的oauth2.0结构，大致抽象出以下核心环节，如：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SSOContextAnalysis</span> &#123;    <span class="hljs-comment">/** 跳转登录*/</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">toLogin</span><span class="hljs-params">(SSOConfig ssoConfig, HttpServletResponse httpServletResponse)</span>;    <span class="hljs-comment">/** 获取token */</span>    Object <span class="hljs-title function_">getToken</span><span class="hljs-params">(SSOConfig ssoConfig, HttpServletRequest httpServletRequest)</span>;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 获取用户信息</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ssoConfig 配置</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 用户信息加密串</span><span class="hljs-comment">     */</span>    String <span class="hljs-title function_">getUserInfo</span><span class="hljs-params">(SSOConfig ssoConfig, Object arg)</span>;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 解析sso context</span><span class="hljs-comment">     */</span>    String <span class="hljs-title function_">getAccount</span><span class="hljs-params">(SSOConfig ssoConfig, Object userInfo)</span>;    <span class="hljs-comment">/** 进行退出 */</span>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">tologout</span><span class="hljs-params">(SSOConfig ssoConfig, UserOnline userOnline, HttpServletResponse httpServletResponse)</span>;&#125;</code></pre><p><em><strong>龙图SSO Demo</strong></em></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LongTuSSOHandle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SSOContextAnalysis</span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">toLogin</span><span class="hljs-params">(SSOConfig ssoConfig)</span> &#123;        <span class="hljs-comment">// 跳转SSO鉴权地址, 配置回调地址</span>    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getToken</span><span class="hljs-params">(SSOConfig ssoConfig)</span> &#123;        <span class="hljs-comment">// 根据客户的加密算法等获取Token信息</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getUserInfo</span><span class="hljs-params">(SSOConfig ssoConfig, Object arg)</span> &#123;        <span class="hljs-comment">// 组装报文, 发起用户请求, 获取用户数据</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAccount</span><span class="hljs-params">(SSOConfig ssoConfig, Object userInfo)</span> &#123;        <span class="hljs-comment">// 基于用户数据, 获取本平台用户数据, 完成SSO流程</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tologout</span><span class="hljs-params">(SSOConfig ssoConfig)</span> &#123;        <span class="hljs-comment">// 根据退出地址进行退出操作等等</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;</code></pre><p><font color="red">我们在编写业务代码的时候，完全依赖于顶层抽象类，彼时再动态的更改具体的实现类即可</font></p><h3 id="如何动态指定实现类"><a href="#如何动态指定实现类" class="headerlink" title="如何动态指定实现类"></a>如何动态指定实现类</h3><p>动态指定实现类的最好方式无非这么几种，大家可以根据需求选择：</p><ul><li>配置文件 + 反射构建实现类</li><li>配置文件 + 预先加载所有实现类，根据配置动态选择</li><li>数据库配置 + 反射（可以使用CGLIB代理）</li><li>数据库配置 + 预先加载所有实现类，根据配置动态选择</li></ul><h3 id="第二个SSO要多久？"><a href="#第二个SSO要多久？" class="headerlink" title="第二个SSO要多久？"></a>第二个SSO要多久？</h3><p>当我们使用模板方法模式，对整个SSO的流程已经梳理完成之后，第二个SSO只需要实现相应接口，然后根据客户的要求构建不同的加密协议，同时改一下配置即可，反正我只花了5分钟~</p><p><img src="/2023/02/06/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/image-20200609003245682.png" alt="image-20200609003245682"></p><h2 id="遵循的设计原则"><a href="#遵循的设计原则" class="headerlink" title="遵循的设计原则"></a>遵循的设计原则</h2><ol><li><strong>封装变化</strong><ul><li>在抽象基类中，我们可以有已经实现的方法供子类调用</li><li>在抽象基类中，对于必然不同的方法逻辑，定义为抽象的，供子类自行实现</li></ul></li><li><strong>好莱坞原则</strong><ul><li>别找我，我会找你   指的是底层代码（具体的实现类）不依赖于高层代码，我们在本次的SSO实战中也体现了，直接依赖接口，实现类只是作为真正的执行者而已</li></ul></li></ol><h2 id="什么场景适合使用"><a href="#什么场景适合使用" class="headerlink" title="什么场景适合使用"></a>什么场景适合使用</h2><ul><li>一次性实现一个算法不变的部分，并将可变的行为留给子类来实现</li><li>各子类中公共的行为应该被提取出来并集中到一个公共父类中以避免代码重复</li><li>控制子类扩展（文中提到的钩子方法，控制方法的执行与否）</li></ul><h2 id="Code-生活中的实际应用"><a href="#Code-生活中的实际应用" class="headerlink" title="Code&#x2F;生活中的实际应用"></a>Code&#x2F;生活中的实际应用</h2><p>比如我们使用的所有APP，在进行支付的时候大多都可以选择支付宝或者微信支付，其实整个支付步骤中，只有具体支付的步骤是分为多种情况（微信，支付宝，银行卡等）剩下的订单推送，数据扭转等很有可能是一样的，此时我们就可以使用模板方法模式来约束行为，同时减少重复代码</p><p><font color="blue">PS：此种情况也可能使用策略模式处理，需要视情况而定</font></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p><strong>附上GOF一书中对于模板方法模式的UML图：</strong></p><p><img src="/2023/02/06/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/image-20200609004140373.png" alt="image-20200609004140373"></p><h2 id="相关代码链接"><a href="#相关代码链接" class="headerlink" title="相关代码链接"></a>相关代码链接</h2><p><a href="https://github.com/kkzhilu/Kerwin-DesignPattern">GitHub地址</a></p><ul><li>兼顾了《HeadFirst》以及《GOF》两本经典书籍中的案例</li><li>提供了友好的阅读指导</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/5/18/172284a1c8caf324?w=487&h=185&f=png&s=17561"></p>]]></content>
    
    
    <categories>
      
      <category>编码及设计模式篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模板方法模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度分页通用解决方案</title>
    <link href="/2023/02/06/%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2023/02/06/%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p>标签： #Share</p><h2 id="面试题-真实经历"><a href="#面试题-真实经历" class="headerlink" title="面试题 &amp; 真实经历"></a>面试题 &amp; 真实经历</h2><blockquote><p>面试题：在数据量很大的情况下，怎么实现深度分页？</p></blockquote><p>大家在面试时，或者准备面试中可能会遇到上述的问题，大多的回答基本上是<code>分库分表建索引</code>，这是一种很<code>标准的正确回答</code>，但现实总是很骨感，所以面试官一般会追问你一句，<font color="red">现在工期不足，人员不足，该怎么实现深度分页？</font></p><p>这个时候没有实际经验的同学基本麻爪，So，请听我娓娓道来。</p><h2 id="惨痛的教训"><a href="#惨痛的教训" class="headerlink" title="惨痛的教训"></a>惨痛的教训</h2><p><em><strong>首先必须明确一点：</strong></em>深度分页可以做，但是<font color="red">深度随机跳页绝对需要禁止。</font></p><p>上一张图：</p><p><img src="/2023/02/06/%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20200714233120650.png" alt="image-20200714233120650"></p><p>你们猜，我点一下第<code>142360</code>页，服务会不会爆炸？</p><p>像<code>MySQL</code>，<code>MongoDB</code>数据库还好，本身就是专业的数据库，处理的不好，最多就是慢，但如果涉及到<code>ES</code>，性质就不一样了，我们不得不利用 <code>SearchAfter</code> Api，去循环获取数据，这就牵扯到内存占用的问题，如果当时代码写的不优雅，直接就可能导致内存溢出。</p><h2 id="为什么不能允许随机深度跳页"><a href="#为什么不能允许随机深度跳页" class="headerlink" title="为什么不能允许随机深度跳页"></a>为什么不能允许随机深度跳页</h2><p>从技术的角度浅显的聊一聊为什么不能允许随机深度跳页，或者说为什么不建议深度分页</p><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p>分页的基本原理：</p><pre><code class="hljs mysql">SELECT * FROM test ORDER BY id DESC LIMIT 10000, 20;</code></pre><p>LIMIT 10000 , 20的意思扫描满足条件的10020行，扔掉前面的10000行，返回最后的20行。如果是LIMIT 1000000 , 100，需要扫描1000100 行，在一个高并发的应用里，每次查询需要扫描超过100W行，不炸才怪。</p><h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><p>分页的基本原理：</p><pre><code class="hljs mysql">db.t_data.find().limit(5).skip(5);</code></pre><p>同样的，随着页码的增大，skip 跳过的条目也会随之变大，而这个操作是通过 cursor 的迭代器来实现的，对于cpu的消耗会非常明显，当页码非常大时且频繁时，必然爆炸。</p><h3 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h3><p>从业务的角度来说，<code>ElasticSearch</code>不是典型的数据库，它是一个搜索引擎，如果在筛选条件下没有搜索出想要的数据，继续深度分页也不会找到想要的数据，退一步讲，假如我们把<code>ES</code>作为数据库来使用进行查询，在进行分页的时候一定会遇到<code>max_result_window </code>的限制，看到没，官方都告诉你最大偏移量限制是一万。</p><p>查询流程：</p><ol><li>如查询第501页，每页10条，客户端发送请求到某节点</li><li>此节点将数据广播到各个分片，各分片各自查询前 5010 条数据</li><li>查询结果返回至该节点，然后对数据进行整合，取出前 5010 条数据</li><li>返回给客户端</li></ol><p>由此可以看出为什么要限制偏移量，另外，如果使用 <code>Search After</code> 这种滚动式API进行深度跳页查询，也是一样需要每次滚动几千条，可能一共需要滚动上百万，千万条数据，就为了最后的20条数据，效率可想而知。</p><h2 id="再次和产品对线"><a href="#再次和产品对线" class="headerlink" title="再次和产品对线"></a>再次和产品对线</h2><p><font color="red">俗话说的好，技术解决不了的问题，就由业务来解决！</font></p><p>在实习的时候信了产品的邪，必须实现深度分页 + 跳页，如今必须<code>拨乱反正</code>，业务上必须有如下更改：</p><ul><li><font color="red">尽可能的增加默认的筛选条件，如：时间周期</font>，目的是为了减少数据量的展示</li><li><font color="red">修改跳页的展现方式，改为滚动显示，或小范围跳页</font></li></ul><p>滚动显示参考图：</p><p><img src="/2023/02/06/%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20200715001921905.png" alt="image-20200715001921905"></p><p>小规模跳页参考图：</p><p><img src="/2023/02/06/%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20200715001959027.png" alt="image-20200715001959027"></p><h2 id="通用解决方案"><a href="#通用解决方案" class="headerlink" title="通用解决方案"></a>通用解决方案</h2><p>短时间内快速解决的方案主要是以下几点：</p><ul><li>必备：对排序字段，筛选条件务必设置好索引</li><li>核心：<font color="red">利用小范围页码的已知数据，或者滚动加载的已知数据，减少偏移量</font></li><li>额外：如果遇到不好处理的情况，也可以获取多余的数据，进行一定的截取，性能影响并不大</li></ul><h3 id="MySQL-1"><a href="#MySQL-1" class="headerlink" title="MySQL"></a>MySQL</h3><p>原分页SQL：</p><pre><code class="hljs mysql"># 第一页SELECT * FROM `year_score` where `year` = 2017 ORDER BY id limit 0, 20;# 第N页SELECT * FROM `year_score` where `year` = 2017 ORDER BY id limit (N - 1) * 20, 20;</code></pre><p>通过上下文关系，改写为：</p><pre><code class="hljs mysql"># XXXX 代表已知的数据SELECT * FROM `year_score` where `year` = 2017 and id &gt; XXXX ORDER BY id limit 20;</code></pre><p>在 <a href="https://juejin.im/post/5ea16dede51d45470b4ffc5b#heading-9">没内鬼，来点干货！SQL优化和诊断</a> 一文中提到过，LIMIT会在满足条件下停止查询，因此该方案的扫描总量会急剧减少，效率提升Max！</p><h3 id="ES"><a href="#ES" class="headerlink" title="ES"></a>ES</h3><p>方案和<code>MySQL</code>相同，此时我们就可以随用所欲的使用 <code>FROM-TO</code> Api，而且不用考虑最大限制的问题。</p><h3 id="MongoDB-1"><a href="#MongoDB-1" class="headerlink" title="MongoDB"></a>MongoDB</h3><p>方案基本类似，基本代码如下：</p><p><img src="/2023/02/06/%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/6635252.png" alt="img"></p><p>相关性能测试：</p><p><img src="/2023/02/06/%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/5698435.png" alt="img"></p><h2 id="我的方案：基于时间分割"><a href="#我的方案：基于时间分割" class="headerlink" title="我的方案：基于时间分割"></a>我的方案：基于时间分割</h2><p>我这次的数据展现方案，最终定的是时间分割策略，因为我们的数据展现都会有时间排序，示意图如下：</p><p><img src="/2023/02/06/%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20200723163317073.png"></p><h2 id="如果非要深度随机跳页"><a href="#如果非要深度随机跳页" class="headerlink" title="如果非要深度随机跳页"></a>如果非要深度随机跳页</h2><p>如果你没有杠过产品经理，又该怎么办呢，没关系，还有一丝丝的机会。</p><p>在 <a href="https://juejin.im/post/5ea16dede51d45470b4ffc5b#heading-8">SQL优化</a> 一文中还提到过<code>MySQL</code>深度分页的处理技巧，代码如下：</p><pre><code class="hljs mysql"># 反例（耗时129.570s）select * from task_result LIMIT 20000000, 10;# 正例（耗时5.114s）SELECT a.* FROM task_result a, (select id from task_result LIMIT 20000000, 10) b where a.id = b.id;# 说明# task_result表为生产环境的一个表，总数据量为3400万，id为主键，偏移量达到2000万</code></pre><p>该方案的核心逻辑即基于<code>聚簇索引</code>，在不通过<code>回表</code>的情况下，快速拿到指定偏移量数据的主键ID，然后利用<code>聚簇索引</code>进行回表查询，此时总量仅为10条，效率很高。</p><p>因此我们在处理<code>MySQL</code>，<code>ES</code>，<code>MongoDB</code>时，也可以采用一样的办法：</p><ol><li>限制获取的字段，只通过筛选条件，深度分页获取主键ID</li><li>通过主键ID定向查询需要的数据</li></ol><p>瑕疵：当偏移量非常大时，耗时较长，如文中的 5s</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>参考文章：<a href="https://mongoing.com/archives/25469">MongoDB中文社区</a></p><p>参考文章：<a href="https://mongoing.com/archives/25469">https://mongoing.com/archives/25469</a></p><p>参考文章：<a href="https://my.oschina.net/u/1787735/blog/3024051">https://my.oschina.net/u/1787735/blog/3024051</a></p><p>参考文章：<a href="https://www.cnblogs.com/kebibuluan/p/12987290.html">https://www.cnblogs.com/kebibuluan/p/12987290.html</a></p><p>感谢 @程大设计师 为我倾情设计的二维码😜</p><p>如果觉得对你有用的话，不要忘记点个赞啊~</p><p><img src="/2023/02/06/%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/LOGO-1594745448393.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度分页通用解决方案</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>状态模式</title>
    <link href="/2023/02/06/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/02/06/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="状态模式篇"><a href="#状态模式篇" class="headerlink" title="状态模式篇"></a>状态模式篇</h1><p>标签： #Share</p><h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>允许一个对象在其内部状态改变时改变它的行为</p><p>说人话：<font color="red">允许对象在改变自身状态时候，更改绑定的特定方法</font></p><h2 id="状态模式的诞生"><a href="#状态模式的诞生" class="headerlink" title="状态模式的诞生"></a>状态模式的诞生</h2><p>【<font color="orange">产品</font>】：Hello，开发小哥，我们需要开发一款 <code>娃娃机</code> ，你可以提前想想怎么设计它啦。</p><p>【<font color="blue">开发</font>】：娃娃机？我想想奥，它需要投币，用户移动，确认抓取，结束这几个动作，好像很好做欸，用一个变量维护它当前的阶段，然后写四个 if 语句就好啦。</p><p>【<font color="red">BOSS</font>】：你准备用一个主方法，四个子方法配合 if 语句外加一个状态变量去做吗？</p><pre><code class="hljs java"><span class="hljs-comment">// 伪代码</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">if</span> (flag == A) &#123;        a();    &#125;    <span class="hljs-keyword">if</span> (flag == B) &#123;        b();    &#125;&#125;</code></pre><p>【<font color="blue">开发</font>】：对啊，老大，你真是我肚子里的蛔虫！</p><p>【<font color="red">BOSS</font>】：蛔你个头，这样做<font color="red">  大错特错！ </font>，你难道想对 <font color="red">投币口，按钮，摇杆都绑定同一个方法吗？</font></p><p>【<font color="blue">开发</font>】：对哦，它们应该是<font color="red"> 不同的方法，同时暴露给用户，我再思考思考 </font></p><p><img src="/2023/02/06/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/image-20200617004054501.png" alt="image-20200617004054501"></p><h2 id="HeadFirst-核心代码"><a href="#HeadFirst-核心代码" class="headerlink" title="HeadFirst 核心代码"></a>HeadFirst 核心代码</h2><p><em><strong>定义状态接口，同时封装变化，利用default关键字封装默认方法</strong></em></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">State</span> &#123;    <span class="hljs-comment">/** 投币 **/</span>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">giveMoney</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;无法投币&quot;</span>);    &#125;    <span class="hljs-comment">/** 移动滑杆 **/</span>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;无法移动滑杆&quot;</span>);    &#125;    <span class="hljs-comment">/** 抓取 **/</span>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grab</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;无法抓取&quot;</span>);    &#125;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">changeState</span><span class="hljs-params">()</span>;&#125;</code></pre><p><em><strong>投币状态  状态的其中之一</strong></em></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MoneyState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">State</span>&#123;    Context context;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MoneyState</span><span class="hljs-params">(Context context)</span> &#123;        <span class="hljs-built_in">this</span>.context = context;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">giveMoney</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;已投币!&quot;</span>);        changeState();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">changeState</span><span class="hljs-params">()</span> &#123;        context.setExecute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MoveState</span>(context));    &#125;&#125;</code></pre><p>为了尽量减少代码，只展示了其中一种状态，我们可以看到在 <font color="blue">MoneyState</font> 状态类执行所属的业务方法时，更改了上下文持有的状态类，这就产生了  <font color="red">状态的变更</font> ，同时上下文更加清晰，即：<font color="red">我只用考虑我下一个状态是什么</font></p><p><font color="red">状态模式的设计思路：</font></p><ul><li>Context  上下文环境，持有状态</li><li>State   状态顶层接口</li><li>ConcreteState   具体的状态</li></ul><p>简单来说，</p><ol><li>必须清晰的认识到共有多少种不同的状态，并通过接口定义其核心方法，封装变化</li><li>状态类持有 <font color="blue">Context</font> 上下文，在核心方法处理后更改其状态</li></ol><blockquote><p>如果看着有点模棱两可，建议看完本文后，访问专题设计模式开源项目，里面有具体的代码示例，链接在最下面</p></blockquote><h2 id="状态模式的关键"><a href="#状态模式的关键" class="headerlink" title="状态模式的关键"></a>状态模式的关键</h2><ul><li>明确所有可能发生的状态，及其转换关系</li><li>明确状态模式中的各个状态是有可能同时暴露给用户的</li></ul><blockquote><p>就好像娃娃机运作的多种状态，<font color="red">  投币，移动摇杆，按下确认按钮等等可能不按先后顺序触发</font></p></blockquote><h2 id="整一个-“流程”-模式"><a href="#整一个-“流程”-模式" class="headerlink" title="整一个 “流程” 模式"></a>整一个 “流程” 模式</h2><h3 id="每个状态的方法名都一样会如何？"><a href="#每个状态的方法名都一样会如何？" class="headerlink" title="每个状态的方法名都一样会如何？"></a>每个状态的方法名都一样会如何？</h3><p>上文中我们大概知道了状态模式的特点，把状态封装成类，在调用状态-核心方法时候更改其状态本身，<font color="red">此时考虑的多种状态方法名可能各不相同，假设我们都起一样的名字会如何？</font></p><p>我们会首先遇到一个问题，我们无法得知它需要调用几次方法（因为可能有重复性 A - B 的情况），但如果无限循环，在适当的地方控制其结束点，和是否继续执行的标识，好像就可以解决了。</p><h3 id="来一个流程案例"><a href="#来一个流程案例" class="headerlink" title="来一个流程案例"></a>来一个流程案例</h3><p><img src="/2023/02/06/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/image-20200617001746490.png" alt="image-20200617001746490"></p><p>简单描述下即：开始处理订单</p><ul><li>正常则进入成功状态，入库，结束执行</li><li>失败则进入失败状态，检测是否重新执行，扭转状态为处理订单</li></ul><h3 id="上代码"><a href="#上代码" class="headerlink" title="上代码"></a>上代码</h3><p><em><strong>Context 上下文</strong></em></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span> &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 最大执行次数</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">FAIL_NUM</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 失败次数</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> failNum;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 是否继续执行的标识</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> isAbandon;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 当前状态</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> StateInterface stateInterface;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Context</span><span class="hljs-params">()</span> &#123;        <span class="hljs-built_in">this</span>.stateInterface = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandleOrder</span>();        <span class="hljs-built_in">this</span>.failNum = <span class="hljs-number">1</span>;        <span class="hljs-built_in">this</span>.isAbandon = <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 处理方法</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span> <span class="hljs-params">()</span> &#123;        stateInterface.doAction(<span class="hljs-built_in">this</span>);    &#125;        <span class="hljs-comment">// 省略无用代码...</span>&#125;</code></pre><p><em><strong>处理订单状态</strong></em></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandleOrder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">StateInterface</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAction</span><span class="hljs-params">(Context context)</span> &#123;        printCurrentState();        <span class="hljs-comment">// do somethings</span>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (Math.random() * <span class="hljs-number">11</span>);        <span class="hljs-keyword">if</span> (num &gt;= <span class="hljs-number">8</span>) &#123;            System.out.println(<span class="hljs-string">&quot;处理订单完成, 进入成功状态...&quot;</span>);            context.setStateInterface(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SuccessOrder</span>());        &#125; <span class="hljs-keyword">else</span> &#123;            System.out.println(<span class="hljs-string">&quot;处理订单失败, 进入失败状态...&quot;</span>);            context.setStateInterface(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FailOrder</span>());        &#125;        CodeUtils.spilt();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> StateEnums <span class="hljs-title function_">getCurrentState</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> StateEnums.HANDLE_ORDER;    &#125;&#125;</code></pre><p><em><strong>客户端调用方法</strong></em></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-comment">// 模拟从队列中取任务按流程循环执行</span>        <span class="hljs-type">Context</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Context</span>();        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;            <span class="hljs-comment">// 校验是否为废弃 | 已完成任务</span>            <span class="hljs-keyword">if</span> (context.isAbandon()) &#123;                System.out.println(<span class="hljs-string">&quot;此条任务不再执行... &quot;</span>);                <span class="hljs-keyword">break</span>;            &#125;                        context.handle();        &#125;    &#125;&#125;</code></pre><p>测试结果输出：</p><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">当前状态：订单处理</span><span class="hljs-meta prompt_"># </span><span class="language-bash">处理订单失败, 进入失败状态...</span><span class="hljs-meta prompt_"># </span><span class="language-bash"></span><span class="language-bash"></span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_"># </span><span class="language-bash">当前状态：处理订单失败</span><span class="hljs-meta prompt_"># </span><span class="language-bash">订单处理失败... 当前执行次数: 1</span><span class="hljs-meta prompt_"># </span><span class="language-bash"></span><span class="language-bash"></span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_"># </span><span class="language-bash">当前状态：订单处理</span><span class="hljs-meta prompt_"># </span><span class="language-bash">处理订单失败, 进入失败状态...</span><span class="hljs-meta prompt_"># </span><span class="language-bash"></span><span class="language-bash"></span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_"># </span><span class="language-bash">当前状态：处理订单失败</span><span class="hljs-meta prompt_"># </span><span class="language-bash">订单处理失败... 当前执行次数: 2</span><span class="hljs-meta prompt_"># </span><span class="language-bash"></span><span class="language-bash"></span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_"># </span><span class="language-bash">当前状态：订单处理</span><span class="hljs-meta prompt_"># </span><span class="language-bash">处理订单完成, 进入成功状态...</span><span class="hljs-meta prompt_"># </span><span class="language-bash"></span><span class="language-bash"></span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_"># </span><span class="language-bash">当前状态：处理订单成功</span><span class="hljs-meta prompt_"># </span><span class="language-bash">订单处理完成 -&gt; 进入入库逻辑...</span><span class="hljs-meta prompt_"># </span><span class="language-bash">入库处理完成</span><span class="hljs-meta prompt_"># </span><span class="language-bash"></span><span class="language-bash"></span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_"># </span><span class="language-bash">此条任务不再执行...</span></code></pre><blockquote><p>如果看着有点模棱两可，建议看完本文后，访问专题设计模式开源项目，里面有具体的代码示例，链接在最下面</p></blockquote><h3 id="“流程”-模式适用的场景"><a href="#“流程”-模式适用的场景" class="headerlink" title="“流程” 模式适用的场景"></a>“流程” 模式适用的场景</h3><p>在这样的设计中，与其说是状态的变更，不如说是 “流程” 的变更更为贴切，因此它可以作为诸多后台任务的解决方案，尤其是面临很多业务流程场景时，可以极大的提高代码的可维护性： <font color="red">我只用考虑和我有关的 “流程”</font></p><h2 id="遵循的设计原则"><a href="#遵循的设计原则" class="headerlink" title="遵循的设计原则"></a>遵循的设计原则</h2><ul><li>封装变化：在父级接口中提供 default 方法，子类实现其对应的状态方法即可</li><li>多用组合，少用继承：状态模式经常和策略模式做对比，它们都是利用组合而非继承增强其变化和能力</li></ul><h2 id="什么场景适合使用状态模式"><a href="#什么场景适合使用状态模式" class="headerlink" title="什么场景适合使用状态模式"></a>什么场景适合使用状态模式</h2><ul><li>一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变其行为</li><li>一个操作中含有庞大的多分支条件语句，且这些分支依赖于该对象的状态</li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p><strong>附上GOF一书中对于状态模式的UML图：</strong></p><p><img src="/2023/02/06/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/image-20200617003230665.png" alt="image-20200617003230665"></p><h2 id="相关代码链接"><a href="#相关代码链接" class="headerlink" title="相关代码链接"></a>相关代码链接</h2><p><a href="https://github.com/kkzhilu/Kerwin-DesignPattern">GitHub地址</a></p><ul><li>兼顾了《HeadFirst》以及《GOF》两本经典书籍中的案例</li><li>提供了友好的阅读指导</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/5/18/172284a1c8caf324?w=487&h=185&f=png&s=17561"></p>]]></content>
    
    
    <categories>
      
      <category>编码及设计模式篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>状态模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法实战篇</title>
    <link href="/2023/02/06/%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98%E7%AF%87/"/>
    <url>/2023/02/06/%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="算法实战篇-大数据量问题解决方案"><a href="#算法实战篇-大数据量问题解决方案" class="headerlink" title="算法实战篇 - 大数据量问题解决方案"></a>算法实战篇 - 大数据量问题解决方案</h1><p>标签： #Share</p><h2 id="1-如何从大量的-URL-中找出相同的-URL？"><a href="#1-如何从大量的-URL-中找出相同的-URL？" class="headerlink" title="1. 如何从大量的 URL 中找出相同的 URL？"></a>1. 如何从大量的 URL 中找出相同的 URL？</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定 a、b 两个文件，各存放 50 亿个 URL，每个 URL 各占 64B，内存限制是 4G。请找出 a、b 两个文件共同的 URL。</p><h3 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h3><p>每个 URL 占 64B，那么 50 亿个 URL占用的空间大小约为 320GB。</p><blockquote><p>5,000,000,000 * 64B ≈ 5GB * 64 &#x3D; 320GB</p></blockquote><p>由于内存大小只有 4G，因此，我们不可能一次性把所有 URL 加载到内存中处理。对于这种类型的题目，一般采用<strong>分治策略</strong>，即：把一个文件中的 URL 按照某个特征划分为多个小文件，使得每个小文件大小不超过 4G，这样就可以把这个小文件读到内存中进行处理了。</p><p><strong>思路如下</strong>：</p><p>首先遍历文件 a，对遍历到的 URL 求 <code>hash(URL) % 1000</code>，根据计算结果把遍历到的 URL 存储到 a0, a1, a2, …, a999，这样每个大小约为 300MB。使用同样的方法遍历文件 b，把文件 b 中的 URL 分别存储到文件 b0, b1, b2, …, b999 中。这样处理过后，所有可能相同的 URL 都在对应的小文件中，即 a0 对应 b0, …, a999 对应 b999，不对应的小文件不可能有相同的 URL。那么接下来，我们只需要求出这 1000 对小文件中相同的 URL 就好了。</p><p>接着遍历 ai( <code>i∈[0,999]</code>)，把 URL 存储到一个 HashSet  集合中。然后遍历 bi 中每个 URL，看在 HashSet 集合中是否存在，若存在，说明这就是共同的 URL，可以把这个 URL 保存到一个单独的文件中。</p><h3 id="方法总结"><a href="#方法总结" class="headerlink" title="方法总结"></a>方法总结</h3><ol><li>分而治之，进行哈希取余；</li><li>对每个子文件进行 HashSet 统计。</li></ol><h2 id="2-如何从大量数据中找出高频词？"><a href="#2-如何从大量数据中找出高频词？" class="headerlink" title="2. 如何从大量数据中找出高频词？"></a>2. 如何从大量数据中找出高频词？</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>有一个 1GB 大小的文件，文件里每一行是一个词，每个词的大小不超过 16B，内存大小限制是 1MB，要求返回频数最高的 100 个词(Top 100)。</p><h3 id="解答思路-1"><a href="#解答思路-1" class="headerlink" title="解答思路"></a>解答思路</h3><p>由于内存限制，我们依然无法直接将大文件的所有词一次读到内存中。因此，同样可以采用<strong>分治策略</strong>，把一个大文件分解成多个小文件，保证每个文件的大小小于 1MB，进而直接将单个小文件读取到内存中进行处理。</p><p><strong>思路如下</strong>：</p><p>首先遍历大文件，对遍历到的每个词x，执行 <code>hash(x) % 5000</code>，将结果为 i 的词存放到文件 ai 中。遍历结束后，我们可以得到 5000 个小文件。每个小文件的大小为 200KB 左右。如果有的小文件大小仍然超过 1MB，则采用同样的方式继续进行分解。</p><p>接着统计每个小文件中出现频数最高的 100 个词。最简单的方式是使用 HashMap 来实现。其中 key 为词，value 为该词出现的频率。具体方法是：对于遍历到的词 x，如果在 map 中不存在，则执行 <code>map.put(x, 1)</code>；若存在，则执行 <code>map.put(x, map.get(x)+1)</code>，将该词频数加 1。</p><p>上面我们统计了每个小文件单词出现的频数。接下来，我们可以通过维护一个<strong>小顶堆</strong>来找出所有词中出现频数最高的 100 个。具体方法是：依次遍历每个小文件，构建一个<strong>小顶堆</strong>，堆大小为 100。如果遍历到的词的出现次数大于堆顶词的出现次数，则用新词替换堆顶的词，然后重新调整为<strong>小顶堆</strong>，遍历结束后，小顶堆上的词就是出现频数最高的 100 个词。</p><h3 id="方法总结-1"><a href="#方法总结-1" class="headerlink" title="方法总结"></a>方法总结</h3><ol><li>分而治之，进行哈希取余；</li><li>使用 HashMap 统计频数；</li><li>求解<strong>最大</strong>的 TopN 个，用<strong>小顶堆</strong>；求解<strong>最小</strong>的 TopN 个，用<strong>大顶堆</strong>。</li></ol><h2 id="3-如何找出某一天访问百度网站最多的-IP？"><a href="#3-如何找出某一天访问百度网站最多的-IP？" class="headerlink" title="3. 如何找出某一天访问百度网站最多的 IP？"></a>3. 如何找出某一天访问百度网站最多的 IP？</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>现有海量日志数据保存在一个超大文件中，该文件无法直接读入内存，要求从中提取某天访问百度次数最多的那个 IP。</p><h3 id="解答思路-2"><a href="#解答思路-2" class="headerlink" title="解答思路"></a>解答思路</h3><p>这道题只关心某一天访问百度最多的 IP，因此，可以首先对文件进行一次遍历，把这一天访问百度 IP 的相关信息记录到一个单独的大文件中。接下来采用的方法与上一题一样，大致就是先对 IP 进行哈希映射，接着使用 HashMap 统计重复 IP 的次数，最后计算出重复次数最多的 IP。</p><blockquote><p>注：这里只需要找出出现次数最多的 IP，可以不必使用堆，直接用一个变量 max 即可。</p></blockquote><h3 id="方法总结-2"><a href="#方法总结-2" class="headerlink" title="方法总结"></a>方法总结</h3><ol><li>分而治之，进行哈希取余；</li><li>使用 HashMap 统计频数；</li><li>求解<strong>最大</strong>的 TopN 个，用<strong>小顶堆</strong>；求解<strong>最小</strong>的 TopN 个，用<strong>大顶堆</strong>。</li></ol><h2 id="4-如何在大量的数据中找出不重复的整数？"><a href="#4-如何在大量的数据中找出不重复的整数？" class="headerlink" title="4. 如何在大量的数据中找出不重复的整数？"></a>4. 如何在大量的数据中找出不重复的整数？</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>在 2.5 亿个整数中找出不重复的整数。注意：内存不足以容纳这 2.5 亿个整数。</p><h3 id="解答思路-3"><a href="#解答思路-3" class="headerlink" title="解答思路"></a>解答思路</h3><h4 id="方法一：分治法"><a href="#方法一：分治法" class="headerlink" title="方法一：分治法"></a>方法一：分治法</h4><p>与前面的题目方法类似，先将 2.5 亿个数划分到多个小文件，用 HashSet&#x2F;HashMap 找出每个小文件中不重复的整数，再合并每个子结果，即为最终结果。</p><h4 id="方法二：位图法"><a href="#方法二：位图法" class="headerlink" title="方法二：位图法"></a>方法二：位图法</h4><p><strong>位图</strong>，就是用一个或多个 bit 来标记某个元素对应的值，而键就是该元素。采用位作为单位来存储数据，可以大大节省存储空间。</p><p>位图通过使用位数组来表示某些元素是否存在。它可以用于快速查找，判重，排序等。不是很清楚？我先举个小例子。</p><p>假设我们要对 <code>[0,7]</code> 中的 5 个元素 (6, 4, 2, 1, 5) 进行排序，可以采用位图法。0~7 范围总共有 8 个数，只需要 8bit，即 1 个字节。首先将每个位都置 0：</p><pre><code class="hljs tap">0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0 0复制代码</code></pre><p>然后遍历 5 个元素，首先遇到 6，那么将下标为 6 的位的 0 置为 1；接着遇到 4，把下标为 4 的位 的 0 置为 1：</p><pre><code class="hljs tap">0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>1<span class="hljs-number"> 0 </span>1 0复制代码</code></pre><p>依次遍历，结束后，位数组是这样的：</p><pre><code class="hljs tap">0<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 0 </span>1<span class="hljs-number"> 1 </span>1 0复制代码</code></pre><p>每个为 1 的位，它的下标都表示了一个数：</p><pre><code class="hljs stylus"><span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>):    <span class="hljs-keyword">if</span> bits<span class="hljs-selector-attr">[i]</span> == <span class="hljs-number">1</span>:        <span class="hljs-built_in">print</span>(i)复制代码</code></pre><p>这样我们其实就已经实现了排序。</p><p>对于整数相关的算法的求解，<strong>位图法</strong>是一种非常实用的算法。假设 int 整数占用 4B，即 32bit，那么我们可以表示的整数的个数为 232。</p><p><strong>那么对于这道题</strong>，我们用 2 个 bit 来表示各个数字的状态：</p><ul><li>00 表示这个数字没出现过；</li><li>01 表示这个数字出现过一次（即为题目所找的不重复整数）；</li><li>10 表示这个数字出现了多次。</li></ul><p>那么这 232 个整数，总共所需内存为 232*2b&#x3D;1GB。因此，当可用内存超过 1GB 时，可以采用位图法。假设内存满足位图法需求，进行下面的操作：</p><p>遍历 2.5 亿个整数，查看位图中对应的位，如果是 00，则变为 01，如果是 01 则变为 10，如果是 10 则保持不变。遍历结束后，查看位图，把对应位是 01 的整数输出即可。</p><h3 id="方法总结-3"><a href="#方法总结-3" class="headerlink" title="方法总结"></a>方法总结</h3><p><strong>判断数字是否重复的问题</strong>，位图法是一种非常高效的方法。</p><h2 id="5-如何在大量的数据中判断一个数是否存在？"><a href="#5-如何在大量的数据中判断一个数是否存在？" class="headerlink" title="5. 如何在大量的数据中判断一个数是否存在？"></a>5. 如何在大量的数据中判断一个数是否存在？</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定 40 亿个不重复的没排过序的 unsigned int 型整数，然后再给定一个数，如何快速判断这个数是否在这 40 亿个整数当中？</p><h3 id="解答思路-4"><a href="#解答思路-4" class="headerlink" title="解答思路"></a>解答思路</h3><h4 id="方法一：分治法-1"><a href="#方法一：分治法-1" class="headerlink" title="方法一：分治法"></a>方法一：分治法</h4><p>依然可以用分治法解决，方法与前面类似，就不再次赘述了。</p><h4 id="方法二：位图法-1"><a href="#方法二：位图法-1" class="headerlink" title="方法二：位图法"></a>方法二：位图法</h4><p>40 亿个不重复整数，我们用 40 亿个 bit 来表示，初始位均为 0，那么总共需要内存：4,000,000,000b≈512M。</p><p>我们读取这 40 亿个整数，将对应的 bit 设置为 1。接着读取要查询的数，查看相应位是否为 1，如果为 1 表示存在，如果为 0 表示不存在。</p><h3 id="方法总结-4"><a href="#方法总结-4" class="headerlink" title="方法总结"></a>方法总结</h3><p><strong>判断数字是否存在、判断数字是否重复的问题</strong>，位图法是一种非常高效的方法。</p><h2 id="6-如何查询最热门的查询串？"><a href="#6-如何查询最热门的查询串？" class="headerlink" title="6. 如何查询最热门的查询串？"></a>6. 如何查询最热门的查询串？</h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>搜索引擎会通过日志文件把用户每次检索使用的所有查询串都记录下来，每个查询床的长度不超过 255 字节。</p><p>假设目前有 1000w 个记录（这些查询串的重复度比较高，虽然总数是 1000w，但如果除去重复后，则不超过 300w 个）。请统计最热门的 10 个查询串，要求使用的内存不能超过 1G。（一个查询串的重复度越高，说明查询它的用户越多，也就越热门。）</p><h3 id="解答思路-5"><a href="#解答思路-5" class="headerlink" title="解答思路"></a>解答思路</h3><p>每个查询串最长为 255B，1000w 个串需要占用 约 2.55G 内存，因此，我们无法将所有字符串全部读入到内存中处理。</p><h4 id="方法一：分治法-2"><a href="#方法一：分治法-2" class="headerlink" title="方法一：分治法"></a>方法一：分治法</h4><p>分治法依然是一个非常实用的方法。</p><p>划分为多个小文件，保证单个小文件中的字符串能被直接加载到内存中处理，然后求出每个文件中出现次数最多的 10 个字符串；最后通过一个小顶堆统计出所有文件中出现最多的 10 个字符串。</p><p>方法可行，但不是最好，下面介绍其他方法。</p><h4 id="方法二：HashMap-法"><a href="#方法二：HashMap-法" class="headerlink" title="方法二：HashMap 法"></a>方法二：HashMap 法</h4><p>虽然字符串总数比较多，但去重后不超过 300w，因此，可以考虑把所有字符串及出现次数保存在一个 HashMap 中，所占用的空间为 300w*(255+4)≈777M（其中，4表示整数占用的4个字节）。由此可见，1G 的内存空间完全够用。</p><p><strong>思路如下</strong>：</p><p>首先，遍历字符串，若不在 map 中，直接存入 map，value 记为 1；若在 map 中，则把对应的 value 加 1，这一步时间复杂度 <code>O(N)</code>。</p><p>接着遍历 map，构建一个 10 个元素的小顶堆，若遍历到的字符串的出现次数大于堆顶字符串的出现次数，则进行替换，并将堆调整为小顶堆。</p><p>遍历结束后，堆中 10 个字符串就是出现次数最多的字符串。这一步时间复杂度 <code>O(Nlog10)</code>。</p><h4 id="方法三：前缀树法"><a href="#方法三：前缀树法" class="headerlink" title="方法三：前缀树法"></a>方法三：前缀树法</h4><p>方法二使用了 HashMap 来统计次数，当这些字符串有大量相同前缀时，可以考虑使用前缀树来统计字符串出现的次数，树的结点保存字符串出现次数，0 表示没有出现。</p><p><strong>思路如下</strong>：</p><p>在遍历字符串时，在前缀树中查找，如果找到，则把结点中保存的字符串次数加 1，否则为这个字符串构建新结点，构建完成后把叶子结点中字符串的出现次数置为 1。</p><p>最后依然使用小顶堆来对字符串的出现次数进行排序。</p><h3 id="方法总结-5"><a href="#方法总结-5" class="headerlink" title="方法总结"></a>方法总结</h3><p>前缀树经常被用来统计字符串的出现次数。它的另外一个大的用途是字符串查找，判断是否有重复的字符串等。</p><h2 id="7-如何统计不同电话号码的个数？"><a href="#7-如何统计不同电话号码的个数？" class="headerlink" title="7. 如何统计不同电话号码的个数？"></a>7. 如何统计不同电话号码的个数？</h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>已知某个文件内包含一些电话号码，每个号码为 8 位数字，统计不同号码的个数。</p><h3 id="解答思路-6"><a href="#解答思路-6" class="headerlink" title="解答思路"></a>解答思路</h3><p>这道题本质还是求解<strong>数据重复</strong>的问题，对于这类问题，一般首先考虑位图法。</p><p>对于本题，8 位电话号码可以表示的号码个数为 108 个，即 1 亿个。我们每个号码用一个 bit 来表示，则总共需要 1 亿个 bit，内存占用约 100M。</p><p><strong>思路如下</strong>：</p><p>申请一个位图数组，长度为 1 亿，初始化为 0。然后遍历所有电话号码，把号码对应的位图中的位置置为 1。遍历完成后，如果 bit 为 1，则表示这个电话号码在文件中存在，否则不存在。bit 值为 1 的数量即为 不同电话号码的个数。</p><h3 id="方法总结-6"><a href="#方法总结-6" class="headerlink" title="方法总结"></a>方法总结</h3><p>求解数据重复问题，记得考虑位图法。</p><h2 id="8-如何从-5-亿个数中找出中位数？"><a href="#8-如何从-5-亿个数中找出中位数？" class="headerlink" title="8. 如何从 5 亿个数中找出中位数？"></a>8. 如何从 5 亿个数中找出中位数？</h2><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><p>从 5 亿个数中找出中位数。数据排序后，位置在最中间的数就是中位数。当样本数为奇数时，中位数为 第 <code>(N+1)/2</code> 个数；当样本数为偶数时，中位数为 第 <code>N/2</code> 个数与第 <code>1+N/2</code> 个数的均值。</p><h3 id="解答思路-7"><a href="#解答思路-7" class="headerlink" title="解答思路"></a>解答思路</h3><p>如果这道题没有内存大小限制，则可以把所有数读到内存中排序后找出中位数。但是最好的排序算法的时间复杂度都为 <code>O(NlogN)</code>。这里使用其他方法。</p><h4 id="方法一：双堆法"><a href="#方法一：双堆法" class="headerlink" title="方法一：双堆法"></a>方法一：双堆法</h4><p>维护两个堆，一个大顶堆，一个小顶堆。大顶堆中最大的数<strong>小于等于</strong>小顶堆中最小的数；保证这两个堆中的元素个数的差不超过 1。</p><p>若数据总数为<strong>偶数</strong>，当这两个堆建好之后，<strong>中位数就是这两个堆顶元素的平均值</strong>。当数据总数为<strong>奇数</strong>时，根据两个堆的大小，<strong>中位数一定在数据多的堆的堆顶</strong>。</p><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MedianFinder</span> &#123;        <span class="hljs-keyword">private</span> PriorityQueue&lt;Integer&gt; maxHeap;    <span class="hljs-keyword">private</span> PriorityQueue&lt;Integer&gt; minHeap;    <span class="hljs-comment">/** initialize your data structure here. */</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MedianFinder</span><span class="hljs-params">()</span> &#123;        maxHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(Comparator.reverseOrder());        minHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(Integer::compareTo);    &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;        <span class="hljs-keyword">if</span> (maxHeap.isEmpty() || maxHeap.peek() &gt; num) &#123;            maxHeap.offer(num);        &#125; <span class="hljs-keyword">else</span> &#123;            minHeap.offer(num);        &#125;                <span class="hljs-type">int</span> <span class="hljs-variable">size1</span> <span class="hljs-operator">=</span> maxHeap.size();        <span class="hljs-type">int</span> <span class="hljs-variable">size2</span> <span class="hljs-operator">=</span> minHeap.size();        <span class="hljs-keyword">if</span> (size1 - size2 &gt; <span class="hljs-number">1</span>) &#123;            minHeap.offer(maxHeap.poll());        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (size2 - size1 &gt; <span class="hljs-number">1</span>) &#123;            maxHeap.offer(minHeap.poll());        &#125;    &#125;        <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedian</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">size1</span> <span class="hljs-operator">=</span> maxHeap.size();        <span class="hljs-type">int</span> <span class="hljs-variable">size2</span> <span class="hljs-operator">=</span> minHeap.size();                <span class="hljs-keyword">return</span> size1 == size2             ? (maxHeap.peek() + minHeap.peek()) * <span class="hljs-number">1.0</span> / <span class="hljs-number">2</span>            : (size1 &gt; size2 ? maxHeap.peek() : minHeap.peek());    &#125;&#125;</code></pre><blockquote><p>见 LeetCode No.295：<a href="https://leetcode.com/problems/find-median-from-data-stream/">leetcode.com&#x2F;problems&#x2F;fi…</a></p></blockquote><p>以上这种方法，需要把所有数据都加载到内存中。当数据量很大时，就不能这样了，因此，这种方法<strong>适用于数据量较小的情况</strong>。5 亿个数，每个数字占用 4B，总共需要 2G 内存。如果可用内存不足 2G，就不能使用这种方法了，下面介绍另一种方法。</p><h4 id="方法二：分治法"><a href="#方法二：分治法" class="headerlink" title="方法二：分治法"></a>方法二：分治法</h4><p>分治法的思想是把一个大的问题逐渐转换为规模较小的问题来求解。</p><p>对于这道题，顺序读取这 5 亿个数字，对于读取到的数字 num，如果它对应的二进制中最高位为，则把这个数字写到 f1 中，否则写入 f0 中。通过这一步，可以把这 5 亿个数划分为两部分，而且 f0 中的数都大于 f1 中的数（最高位是符号位）。</p><p>划分之后，可以非常容易地知道中位数是在 f0 还是 f1 中。假设 f1 中有 1 亿个数，那么中位数一定在 f0 中，且是在 f0 中，从小到大排列的第 1.5 亿个数与它后面的一个数的平均值。</p><blockquote><p><strong>提示</strong>，5 亿数的中位数是第 2.5 亿与右边相邻一个数求平均值。若 f1 有一亿个数，那么中位数就是 f0 中从第 1.5 亿个数开始的两个数求得的平均值。</p></blockquote><p>对于 f0 可以用次高位的二进制继续将文件一分为二，如此划分下去，直到划分后的文件可以被加载到内存中，把数据加载到内存中以后直接排序，找出中位数。</p><blockquote><p><strong>注意</strong>，当数据总数为偶数，如果划分后两个文件中的数据有相同个数，那么中位数就是数据较小的文件中的最大值与数据较大的文件中的最小值的平均值。</p></blockquote><h3 id="方法总结-7"><a href="#方法总结-7" class="headerlink" title="方法总结"></a>方法总结</h3><p>分治法，真香！</p><h2 id="9-如何按照-query-的频度排序？"><a href="#9-如何按照-query-的频度排序？" class="headerlink" title="9. 如何按照 query 的频度排序？"></a>9. 如何按照 query 的频度排序？</h2><h3 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h3><p>有 10 个文件，每个文件大小为 1G，每个文件的每一行存放的都是用户的 query，每个文件的 query 都可能重复。要求按照 query 的频度排序。</p><h3 id="解答思路-8"><a href="#解答思路-8" class="headerlink" title="解答思路"></a>解答思路</h3><p>如果 query 的重复度比较大，可以考虑一次性把所有 query 读入内存中处理；如果 query 的重复率不高，那么可用内存不足以容纳所有的 query，这时候就需要采用分治法或其他的方法来解决。</p><h4 id="方法一：HashMap-法"><a href="#方法一：HashMap-法" class="headerlink" title="方法一：HashMap 法"></a>方法一：HashMap 法</h4><p>如果 query 重复率高，说明不同 query 总数比较小，可以考虑把所有的 query 都加载到内存中的 HashMap 中。接着就可以按照 query 出现的次数进行排序。</p><h4 id="方法二：分治法-1"><a href="#方法二：分治法-1" class="headerlink" title="方法二：分治法"></a>方法二：分治法</h4><p>分治法需要根据数据量大小以及可用内存的大小来确定问题划分的规模。对于这道题，可以顺序遍历 10 个文件中的 query，通过 Hash 函数 <code>hash(query) % 10</code> 把这些 query 划分到 10 个小文件中。之后对每个小文件使用 HashMap 统计 query 出现次数，根据次数排序并写入到零外一个单独文件中。</p><p>接着对所有文件按照 query 的次数进行排序，这里可以使用归并排序（由于无法把所有 query 都读入内存，因此需要使用外排序）。</p><h3 id="方法总结-8"><a href="#方法总结-8" class="headerlink" title="方法总结"></a>方法总结</h3><ul><li>内存若够，直接读入进行排序；</li><li>内存不够，先划分为小文件，小文件排好序后，整理使用外排序进行归并。</li></ul><h2 id="10-如何找出排名前-500-的数？"><a href="#10-如何找出排名前-500-的数？" class="headerlink" title="10. 如何找出排名前 500 的数？"></a>10. 如何找出排名前 500 的数？</h2><h3 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h3><p>有 20 个数组，每个数组有 500 个元素，并且有序排列。如何在这 20*500 个数中找出前 500 的数？</p><h3 id="解答思路-9"><a href="#解答思路-9" class="headerlink" title="解答思路"></a>解答思路</h3><p>对于 TopK 问题，最常用的方法是使用堆排序。对本题而言，假设数组降序排列，可以采用以下方法：</p><p>首先建立大顶堆，堆的大小为数组的个数，即为 20，把每个数组最大的值存到堆中。</p><p>接着删除堆顶元素，保存到另一个大小为 500 的数组中，然后向大顶堆插入删除的元素所在数组的下一个元素。</p><p>重复上面的步骤，直到删除完第 500 个元素，也即找出了最大的前 500 个数。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构及算法篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法实战篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>策略模式</title>
    <link href="/2023/02/06/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/02/06/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="策略模式篇"><a href="#策略模式篇" class="headerlink" title="策略模式篇"></a>策略模式篇</h1><p>标签： #Share</p><h2 id="普遍定义"><a href="#普遍定义" class="headerlink" title="普遍定义"></a>普遍定义</h2><p>定义个一个算法族， 各个算法的实现可以相互替换， 算法的实现和具体的算法使用场景隔离</p><h2 id="策略模式的进化"><a href="#策略模式的进化" class="headerlink" title="策略模式的进化"></a>策略模式的进化</h2><p>【<font color="orange">产品</font>】：我需要一堆鸭子，红色的，绿色的，黑色的，还要会飞！还要会叫！</p><p>【<font color="blue">开发</font>】：明白，秒秒钟搞定，N种鸭子只要继承了我的Duck类然后重写，就搞定一切！</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Duck</span> &#123;        <span class="hljs-comment">// 颜色属性</span>    String color;        <span class="hljs-comment">// 飞行方法</span>    fly();        <span class="hljs-comment">// 呱呱叫的方法</span>    quack();&#125;</code></pre><p>Some times later…</p><p>【<font color="red">BOSS</font>】：磕大头！你怎么回事！！！你能不能告诉我为什么橡皮鸭子会在天上飞！！！？？？</p><p>【<font color="blue">开发</font>】：（不敢说话，只有内心独白： 原来无脑继承会出大问题啊…   我是谁…  我在哪…  我该怎么办…）</p><p><img src="/2023/02/06/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/972352-07e55e231b95023f.webp" alt="img"></p><h3 id="磕大头的十万个问题"><a href="#磕大头的十万个问题" class="headerlink" title="磕大头的十万个问题"></a>磕大头的十万个问题</h3><p>Q1. 以后还有很多奇奇怪怪的情况，谁知道老板哪天要不要让橡皮鸭也飞起来，我该怎么办？</p><p>Q2. 只用封装，继承好像不行，好像还有一个多态？</p><p>Q3. 我该怎么使用多态呢？</p><p>Q4. 我是不是可以把飞这个行为<font color="red"><strong>定义成接口，然后把这个接口……   放到鸭子基类里面去！！！</strong></font></p><p><img src="/2023/02/06/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/972352-caa7a0b67a855303.webp" alt="img"></p><h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Duck</span> &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 飞行行为是动态的，可能会变的，因此抽成多个接口的组合，而不是让Duck类继承</span><span class="hljs-comment">     */</span>    FlyBehavior flyBehavior;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 每个鸭子的叫声不同，抽象成接口</span><span class="hljs-comment">     */</span>    QuackBehavior quackBehavior;&#125;</code></pre><p>这下子，好像真的就解决了呢，想怎么飞就怎么飞，想怎么叫就怎么叫</p><h2 id="遵循的设计原则"><a href="#遵循的设计原则" class="headerlink" title="遵循的设计原则"></a>遵循的设计原则</h2><ul><li>封装变化</li><li>多用组合，少用继承</li><li>针对接口编程，而不是针对实现编程</li></ul><h2 id="我之前的理解误区"><a href="#我之前的理解误区" class="headerlink" title="我之前的理解误区"></a>我之前的理解误区</h2><p>大家在初学Java的时候，肯定都绕不开设计模式这一Part，那个时候我对策略模式的认知是这样的，核心代码如下：</p><pre><code class="hljs java"><span class="hljs-comment">// 不需要看全貌，就看这一段核心代码</span><span class="hljs-keyword">public</span> <span class="hljs-title function_">strategyChoose</span><span class="hljs-params">(String mainName)</span>&#123;    <span class="hljs-keyword">switch</span> (name)&#123;        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;A&quot;</span>:            story = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StoryB</span>(name);            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;B&quot;</span>:            story = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StoryA</span>(name);            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">default</span>:            story = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StoryB</span>(name);            <span class="hljs-keyword">break</span>;    &#125;&#125;</code></pre><p><font color="red"><strong>以下是错误理解：</strong></font></p><p>我之前认为，策略模式，顾名思义就是定义不同的策略（即算法），然后动态的调用就好了，比如我定义A,B两种策略，然后通过Switch分支语句选择策略就可以</p><p>这样理解的错误点在于：错误的理解了策略模式的重点，而误把工厂模式的策略选择当作策略模式</p><p><font color="red"><strong>现在的理解：</strong></font></p><ul><li>设计模式肯定有其变种，我们不需要太拘泥于条条框框而限制了自我</li><li>任何定义都有其普遍的理解，我们在突破自我的同时，不能完全走偏</li><li>所以<font color="blue"><strong>真正的策略模式核心即：封装行为，依赖接口，组合代替继承</strong>  </font></li></ul><h2 id="为什么策略模式常和工厂模式或枚举混用？"><a href="#为什么策略模式常和工厂模式或枚举混用？" class="headerlink" title="为什么策略模式常和工厂模式或枚举混用？"></a>为什么策略模式常和工厂模式或枚举混用？</h2><p>首先我们知道了策略模式最初的起源和关键点：<strong>行为或者说算法的抽象及接口的组合</strong></p><p>那么问题来了，在我们拥有多种策略的时候，策略的数量和类型会大大增加，那么调用N种策略肯定需要一个简单的逻辑进行更好的调用，那么策略枚举，或者简单工程则会成为我们最先考虑的方式之一，也正因为如此，才会有上文中我出现的理解误区</p><h2 id="生活中的策略模式"><a href="#生活中的策略模式" class="headerlink" title="生活中的策略模式"></a>生活中的策略模式</h2><ul><li><p>LOL里我喜欢玩奶妈，因为奶妈可以加血，那么在英雄技能设计上，加血是一种行为，具体的细节每个英雄都不一样，这就是策略模式的一种体现</p></li><li><p>比如支付场景中我们会抽取支付信息中的订单，状态，付款人，金钱等等信息，但是支付的细节可以是支付宝也可以是微信</p></li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>附上策略模式的UML图</p><p><img src="/2023/02/06/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/image022.png" alt="图 23. 策略模式的结构"></p><p><img src="/2023/02/06/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/%E5%BE%AE%E4%BF%A1%E4%BA%8C%E7%BB%B4%E7%A0%81.png"></p>]]></content>
    
    
    <categories>
      
      <category>编码及设计模式篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>策略模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>装饰器模式</title>
    <link href="/2023/02/06/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/02/06/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="装饰器模式篇"><a href="#装饰器模式篇" class="headerlink" title="装饰器模式篇"></a>装饰器模式篇</h1><p>标签： #Share</p><h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>动态地给一个对象添加一些额外的职责，就增加功能来说，Decorator模式相比生成子类更为灵活</p><p><font color="red">别名：</font>包装器Wrapper</p><h2 id="装饰器模式的诞生"><a href="#装饰器模式的诞生" class="headerlink" title="装饰器模式的诞生"></a>装饰器模式的诞生</h2><p>有时我们希望给某个对象而不是整个类添加一些功能，例如：一个图形用户界面工具箱允许你对任意一个用户界面组件添加一些特性，例如边框。</p><p>使用继承机制是添加功能的一种有效途径，但这种方法不够灵活，因为边框的选择是静态的，用户不能控制对组件加边框的方式和时机。一种较为灵活的方式是将组件嵌入另一个对象中，由这个对象添加边框，我们称这个嵌入的对象为装饰。</p><p>说人话就是：</p><p>【<font color="orange">产品</font>】：开发小哥，我这里有一份代码，你需要调用它的功能并补充公司的额外功能但是不能动它本身的内容，能做到吗？</p><p><img src="/2023/02/06/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/image-20200517200105310.png" alt="image-20200517200105310"></p><p>【<font color="blue">开发</font>】：哈？怎么可能！怎么可能不改代码还要他功能，还得有额外的功能？难道让我写成这样的？</p><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">demo</span> <span class="hljs-params">()</span> &#123;    <span class="hljs-comment">// 调用原有代码功能</span>    <span class="hljs-comment">// do();</span>        <span class="hljs-comment">// 调用公司功能</span>    <span class="hljs-comment">// doMine();</span>&#125;</code></pre><p>【<font color="red">BOSS</font>】：磕大头！你不觉得这样很low吗？</p><p>【<font color="blue">开发</font>】：可是不这么写我咋改写？</p><p>【<font color="red">BOSS</font>】：你仔细看看原有的代码，<font color="red">它们都实现了同样的接口，这就是一个突破点</font></p><p>【<font color="blue">开发</font>】：我去研究研究….</p><h2 id="HeadFirst-核心代码"><a href="#HeadFirst-核心代码" class="headerlink" title="HeadFirst 核心代码"></a>HeadFirst 核心代码</h2><p>于是乎，我们开启了关于设计模式的经典书籍阅读之旅</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 装饰器模式共同的接口</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Component</span> &#123;    String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>;    <span class="hljs-type">double</span> <span class="hljs-title function_">getSpend</span><span class="hljs-params">()</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 原本的类</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteComponent</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Component</span> &#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteComponent</span><span class="hljs-params">(String name)</span> &#123;        <span class="hljs-built_in">this</span>.name = name;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getSpend</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 装饰器类 注意它利用了组合的方式，同时注意函数实现的部分</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MilkDecorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Component</span> &#123;    Component coffe;    MilkDecorator(Component coffe) &#123;        <span class="hljs-built_in">this</span>.coffe = coffe;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;       <span class="hljs-keyword">return</span> coffe.getName() + <span class="hljs-string">&quot;, 牛奶&quot;</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getSpend</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> coffe.getSpend() + <span class="hljs-number">2D</span>;    &#125;&#125;</code></pre><p><font color="red">装饰器模式的设计思路：</font></p><ul><li>Component：定义一个对象接口，统一行为及父级</li><li>ConcreteComponent：定义一个对象，可以给这个对象添加一些职责（方法）</li><li>Decorator：定义一个跟Component一致的接口，并约束需要实现的职责（方法）</li><li>ConcreteDecorator：维持一个指向Component对象的指针，并实现Component接口，以此增强对象的行为</li></ul><p>简单来说，</p><ol><li>我们需要一个接口来<font color="red">统一父级</font>，并制定一些必要的行为</li><li>默认的实现类实现相关功能</li><li>如果需要额外的增加（装饰），则实现接口并持有接口对象的指针，在实现接口方法时调用指针对象的方法并增强</li></ol><blockquote><p>如果看着有点模棱两可，就看完本文后，访问专题设计模式开源项目，里面有具体的代码示例，链接在最下面</p></blockquote><h2 id="遵循的设计原则"><a href="#遵循的设计原则" class="headerlink" title="遵循的设计原则"></a>遵循的设计原则</h2><ol><li><strong>对扩展开放，对修改关闭</strong>：完美实现了不修改其代码达到增强方法的目的</li><li><strong>针对接口编程</strong>：装饰器与其本身都有同样的父级</li></ol><h2 id="什么场景适合使用"><a href="#什么场景适合使用" class="headerlink" title="什么场景适合使用"></a>什么场景适合使用</h2><p>在不影响其他对象的情况下，以动态，透明的方式给单个对象添加职责</p><h2 id="Code-生活中的实际应用"><a href="#Code-生活中的实际应用" class="headerlink" title="Code&#x2F;生活中的实际应用"></a>Code&#x2F;生活中的实际应用</h2><p>Java 中最著名的装饰者模式的应用，就是 <font color="red">java.io</font> 包中的各种<font color="red">InputStream</font> 、<font color="red">Reader</font>和 <font color="red">Writer</font> 的实现类了。如果我们要从文件中读取文本内容，我们可以使用 <font color="red">FileReader（装饰者）</font> 和 <font color="red">FileInputStream（装饰者）</font>；</p><p>但是如果我们想让读取的速度更快，那么我们就需要 <font color="red">BufferedReader（装饰者）</font> ，这只需要改变一行代码就能实现</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p><strong>附上GOF一书中对于装饰器模式的UML图：</strong></p><p><img src="/2023/02/06/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/image-20200517201710466.png" alt="image-20200517201710466"></p><h2 id="相关代码链接"><a href="#相关代码链接" class="headerlink" title="相关代码链接"></a>相关代码链接</h2><p><a href="https://github.com/kkzhilu/Kerwin-DesignPattern">GitHub地址</a></p><ul><li>兼顾了《HeadFirst》以及《GOF》两本经典书籍中的案例</li><li>提供了友好的阅读指导</li></ul><p><img src="/2023/02/06/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/%E5%BE%AE%E4%BF%A1%E4%BA%8C%E7%BB%B4%E7%A0%81.png"></p>]]></content>
    
    
    <categories>
      
      <category>编码及设计模式篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>装饰器模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式总篇：剖析七大原则</title>
    <link href="/2023/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%AF%87%EF%BC%9A%E5%89%96%E6%9E%90%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    <url>/2023/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%AF%87%EF%BC%9A%E5%89%96%E6%9E%90%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式总篇：剖析七大原则"><a href="#设计模式总篇：剖析七大原则" class="headerlink" title="设计模式总篇：剖析七大原则"></a>设计模式总篇：剖析七大原则</h1><p>标签： #Share</p><h2 id="聊聊为什么需要原则"><a href="#聊聊为什么需要原则" class="headerlink" title="聊聊为什么需要原则"></a>聊聊为什么需要<code>原则</code></h2><p>我们所有人都看过科幻电影，都看到过未来场景中人类和机器人和平相处的场景</p><p><img src="/2023/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%AF%87%EF%BC%9A%E5%89%96%E6%9E%90%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/image-20200704115010265.png" alt="image-20200704115010265"></p><p>为了让拥有<code>自主智能</code>的机器人不失控，人类为机器人制定了三大定律：</p><ul><li><font color="red">第一定律：机器人不得伤害人类个体，或者目睹人类个体将遭受危险而袖手不管</font></li><li><font color="red">第二定律：机器人必须服从人给予它的命令，当该命令与第一定律冲突时例外</font></li><li><font color="red">第三定律：机器人在不违反第一、第二定律的情况下要尽可能保护自己的生存</font></li></ul><p>当然有时也会出现下面的情况，机器人和人类开始互为阵营，各自为敌</p><p><img src="/2023/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%AF%87%EF%BC%9A%E5%89%96%E6%9E%90%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/image-20200704115126779.png" alt="image-20200704115126779"></p><p>但是各自为敌的情况出现，一般都是机器人觉醒了自我意识，不再遵守<code>三大定律</code></p><p>从逻辑学来说，如果机器人完全遵守<code>三大定律及其衍生的条约</code>，那么机器人就可以和人类和平相处，当然也会有意外发生。</p><h2 id="写代码为什么需要设计原则"><a href="#写代码为什么需要设计原则" class="headerlink" title="写代码为什么需要设计原则"></a>写代码为什么需要设计原则</h2><p>和机器人的<code>三大定律</code>相仿，几十年的编程经验，让几代人总结出来了一些代码设计上的<code>定律</code>，这就是<code>设计模式的七大原则</code></p><p><em><strong>我们遵循七大原则，一定会写出最完美的代码吗？</strong></em></p><p>答案当然是不一定，毕竟没有人能保证自己可以完全遵循七大原则，同时个人的编程能力也会起到决定性因素。</p><p><em><strong>那我们为什么还要遵守？</strong></em></p><p>我自己想到的一句名言（以后或许可以成为名言~）</p><blockquote><p>向着最好的方向去努力，总不会是最差的结果。</p></blockquote><h2 id="七大原则详解"><a href="#七大原则详解" class="headerlink" title="七大原则详解"></a>七大原则详解</h2><h3 id="开闭原则-★★★★★"><a href="#开闭原则-★★★★★" class="headerlink" title="开闭原则 ★★★★★"></a>开闭原则 ★★★★★</h3><blockquote><p>软件实体对扩展是开放的，但对修改是关闭的，即在不修改一个软件实体的基础上去扩展其功能</p></blockquote><p><em><strong>例如：</strong></em></p><p>以策略模式为例，当我们新增一种策略的时候，只需要实现策略顶层接口，在调用的时指向新的策略即可</p><p>针对这一条原则，在实现难度上要比单一职责更难，在编码期间，我们需要充分考虑未来的拓展性，规范接口，依赖抽象，这样才能在需要拓展的时候，非常方便的实现其效果</p><p>最佳实践案例：<a href="https://juejin.im/post/5ede6ce151882543485772ea">【一起学系列】之模板方法：写SSO我只要5分钟</a></p><p>说明：在接入第三方SSO时，如果需要新增接入方，基于文中的案例，只需实现固定接口，即可优雅的实现相应需求</p><h3 id="依赖倒置原则-★★★★★"><a href="#依赖倒置原则-★★★★★" class="headerlink" title="依赖倒置原则  ★★★★★"></a>依赖倒置原则  ★★★★★</h3><blockquote><p>要针对抽象层编程，而不要针对具体类编程</p></blockquote><p><em><strong>例如：</strong></em></p><p>以适配器模式为例，将一个类的接口转换成客户希望的另外一个接口，以此实现的前提便是代码中所依赖的都是抽象的，因为只有依赖抽象，才能在代码运行期间改变其实体，利用<code>多态</code>实现需要的效果</p><p>针对该条原则，其实有一定编程经验的人一定会在无形中注意到，而且了解设计模式的话，会发现所有涉及接口和实现的设计模式都会遵从这一条原则</p><p>最佳实践案例：<a href="https://juejin.im/post/5ede6ce151882543485772ea">【一起学系列】之模板方法：写SSO我只要5分钟</a></p><p>说明：和上一条原则的侧重点不同，在SSO中必然有其固定的流程，如登录-获取Token-获取用户信息-解析-退出等等，在代码的编写阶段，需要我们定义出接口&#x2F;抽象类，然后依赖于抽象层，最终改变具体类，以此达到无缝切换的效果</p><h3 id="合成复用原则-★★★★☆"><a href="#合成复用原则-★★★★☆" class="headerlink" title="合成复用原则  ★★★★☆"></a>合成复用原则  ★★★★☆</h3><blockquote><p>总结一句话就是：多用组合，少用继承</p></blockquote><p><em><strong>例如：</strong></em></p><p>以单例模式和代理模式为例，它们都是该模式的最佳实践者，单例模式是把不同的策略接口通过<code>组合</code>的方式嵌入到<code>Context</code>类中，如代码所示：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Duck</span> &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 飞行行为是动态的，可能会变的，因此抽成多个接口的组合，而不是让Duck类继承</span><span class="hljs-comment">     */</span>    FlyBehavior flyBehavior;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 每个鸭子的叫声不同，抽象成接口</span><span class="hljs-comment">     */</span>    QuackBehavior quackBehavior;&#125;</code></pre><p>同理，代理模式也是如此，这里就考虑到一个问题，<code>为什么要多用组合而非继承？</code></p><p>其实还是Java中单继承引发的问题，同时继承的<code>语义</code>过于苛刻，因此更多的时候建议<code>善用组合</code></p><p>最佳实践案例：<a href="https://juejin.im/post/5eb67fc46fb9a043830f597a">【一起学系列】之策略模式：好多鸭子啊</a></p><p>说明：策略模式就是合成复用原则的最佳实践者，没有之一</p><h3 id="单一职责原则-★★★★☆"><a href="#单一职责原则-★★★★☆" class="headerlink" title="单一职责原则   ★★★★☆"></a>单一职责原则   ★★★★☆</h3><blockquote><p>类的职责要单一，不能将太多的职责放在一个类中</p></blockquote><p><em><strong>例如：</strong></em></p><p>在代码设计中某种场景可能存在多种不同的状态，很可能就把代码混在一起了，这时我们利用<code>状态模式</code>进行设计，把各种状态对应的实现细节都用类的级别单独划分，即体现了<code>单一职则原则</code></p><p>针对这一条原则，其实绝大多数人在设计之初都会考虑到，但问题就在于随着工作中人员职责的交叉，很有可能会破坏他人设计的最初目的，为了方便，让一个类拥有五花八门的功能</p><p>最佳实践案例：<a href="https://juejin.im/post/5ee8f64be51d452f9c27e66a">【一起学系列】之状态模式：你听过“流程”模式吗？</a></p><p>说明：在状态模式中，每一种状态的处理都是独立的一个类，每个类只需要处理自身的核心逻辑，完美体现了<code>单一职责原则</code></p><h3 id="里氏替换原则-★★★★☆"><a href="#里氏替换原则-★★★★☆" class="headerlink" title="里氏替换原则  ★★★★☆"></a>里氏替换原则  ★★★★☆</h3><blockquote><p>在软件系统中，一个可以接受基类对象的地方必然可以接受一个子类对象</p></blockquote><p>当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法</p><p>继承包含这样一层含义：父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义</p><p><em><strong>例如：</strong></em></p><p>我们都用过<code>ArrayList</code>，有谁看过 <code>forEach</code>方法的源码？</p><pre><code class="hljs java"><span class="hljs-comment">// ArrayList 的父级接口 Iterable  定义的默认方法</span><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; action)</span> &#123;    Objects.requireNonNull(action);    <span class="hljs-keyword">for</span> (T t : <span class="hljs-built_in">this</span>) &#123;        action.accept(t);    &#125;&#125;</code></pre><p><code>ArrayList</code>重写的方法：</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> E&gt; action)</span> &#123;    Objects.requireNonNull(action);    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">expectedModCount</span> <span class="hljs-operator">=</span> modCount;    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>    <span class="hljs-keyword">final</span> E[] elementData = (E[]) <span class="hljs-built_in">this</span>.elementData;    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.size;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;        action.accept(elementData[i]);    &#125;    <span class="hljs-keyword">if</span> (modCount != expectedModCount) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();    &#125;&#125;</code></pre><p>我们看到，<code>ArrayList</code>的重写只是针对数组这种结构优化了性能，其目的性和<code>Iterable</code>接口中的完全一致，因此这种方式的重写不会引起任何问题，反而可以提高效率，我们需要学习这样的方式</p><h3 id="迪米特原则-★★★☆☆"><a href="#迪米特原则-★★★☆☆" class="headerlink" title="迪米特原则  ★★★☆☆"></a>迪米特原则  ★★★☆☆</h3><blockquote><p>一个对象应该对其他对象保持最少的了解，又名：最少知道原则</p></blockquote><p><em><strong>例如：</strong></em></p><p>在代码设计场景中，某一个类的调用都会固定使用三个方法，是否可以考虑把三个方法抽取出来，提供一个公共的对外方法？这种思路就是<code>外观模式</code>，外观模式也是迪米特原则的最佳实践</p><p>最佳实践案例：<a href="https://juejin.im/post/5ed688c051882543413c1168">【一起学系列】之适配器模式：还有外观模式呢</a></p><p>说明：利用<code>外观模式</code>构建统一的对外方法，屏蔽其内部实现，这样一旦内部实现需要更改，完全不会影响调用方，你Get了吗？</p><h3 id="接口隔离原则-★★☆☆☆"><a href="#接口隔离原则-★★☆☆☆" class="headerlink" title="接口隔离原则  ★★☆☆☆"></a>接口隔离原则  ★★☆☆☆</h3><blockquote><p>使用多个专门的接口来取代一个统一的接口</p></blockquote><p>这个模式其实也很好理解，比如我们定义了接口A，接口B实现了接口A，接口C实现了接口B，基类D其实只需要接口C的方法，但是此时不得不实现所有的方法</p><p><font color="red">其实造成这个根本原因：对接口的抽象，设计出现了偏差</font></p><p>毕竟看过JDK源码或者Spring源码的同学，可以经常发现某一个接口可能实现了一大堆的接口，但是对于普通开发者而言，没有这种强大的设计能力，就需要在设计的时候多思考，如果发现违背了<code>接口隔离原则</code>的情况，就应该对接口进行拆分</p><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="/2023/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%AF%87%EF%BC%9A%E5%89%96%E6%9E%90%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/Kerwin-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%8E%9F%E5%88%99.png"></p><blockquote><p>Processon分享地址：<a href="https://www.processon.com/view/link/5f0210aa7d9c0844204b4845">https://www.processon.com/view/link/5f0210aa7d9c0844204b4845</a></p><p>PS：需要源文件的小伙伴可以在文末扫描二维码，发送【设计模式】即可</p></blockquote><h2 id="设计模式的系列文章推荐"><a href="#设计模式的系列文章推荐" class="headerlink" title="设计模式的系列文章推荐"></a>设计模式的系列文章推荐</h2><p>| 所属类型                              | 设计模式                             | 标题 &amp; 链接                                                  |<br>| - |  |  |<br>| <font color="red">行为型模式</font>   | 策略模式                             | <a href="https://juejin.im/post/5eb67fc46fb9a043830f597a">【一起学系列】之策略模式：好多鸭子啊</a> |<br>| <font color="red">行为型模式</font>   | 观察者模式                           | <a href="https://juejin.im/post/5ec2a1dde51d454ddf23697d">【一起学系列】之观察者模式：我没有在监控你啊</a> |<br>| <font color="red">行为型模式</font>   | 命令模式                             | <a href="https://juejin.im/post/5ed5265851882543477c7abf">【一起学系列】之命令模式：封装一个简单Jedis？</a> |<br>| <font color="red">行为型模式</font>   | 模板方法模式                         | <a href="https://juejin.im/post/5ede6ce151882543485772ea">【一起学系列】之模板方法：写SSO我只要5分钟</a> |<br>| <font color="red">行为型模式</font>   | 迭代器模式                           | <a href="https://juejin.im/post/5ee64aade51d45789671b974">【一起学系列】之迭代器&amp;组合：虽然有点用不上啦</a> |<br>| <font color="red">行为型模式</font>   | 状态模式                             | <a href="https://juejin.im/post/5ee8f64be51d452f9c27e66a">【一起学系列】之状态模式：你听过“流程”模式吗？</a> |<br>| <font color="red">行为型模式</font>   | 职责链模式                           | <a href="https://juejin.im/post/5efe0653e51d4534a81a9121">【一起学系列】之剩下的设计模式们</a> |<br>| <font color="red">行为型模式</font>   | 备忘录模式                           | <a href="https://juejin.im/post/5efe0653e51d4534a81a9121">【一起学系列】之剩下的设计模式们</a> |<br>| <font color="blue">结构型模式</font>  | 装饰器模式                           | <a href="https://juejin.im/post/5ec2a87c5188256e9b728e70">【一起学系列】之装饰器模式：不改代码增强功能？</a> |<br>| <font color="blue">结构型模式</font>  | 适配器模式 &amp; 外观模式                | <a href="https://juejin.im/post/5ed688c051882543413c1168">【一起学系列】之适配器模式：还有外观模式呢</a> |<br>| <font color="blue">结构型模式</font>  | 组合模式                             | <a href="https://juejin.im/post/5ee64aade51d45789671b974">【一起学系列】之迭代器&amp;组合：虽然有点用不上啦</a> |<br>| <font color="blue">结构型模式</font>  | 代理模式                             | <a href="https://juejin.im/post/5ef2b053f265da02e3401e5c">【一起学系列】之代理模式：是为了控制访问啊！</a> |<br>| <font color="green">创建型模式</font> | 工厂模式<br>（工厂方法及抽象工厂） | <a href="https://juejin.im/post/5ecbcf19e51d4578a475ea5e">【一起学系列】之工厂模式：产品？产品族?</a> |<br>| <font color="green">创建型模式</font> | 单例模式                             | <a href="https://juejin.im/post/5ecbcabc6fb9a047d070c779">【一起学系列】之单例模式：只推荐三种~</a> |<br>| <font color="green">创建型模式</font> | 建造者模式                           | <a href="https://juejin.im/post/5efe0653e51d4534a81a9121">【一起学系列】之剩下的设计模式们</a> |</p><h2 id="源码链接"><a href="#源码链接" class="headerlink" title="源码链接"></a>源码链接</h2><p><a href="https://github.com/kkzhilu/Kerwin-DesignPattern">GitHub地址</a></p><ul><li>兼顾了《HeadFirst》以及《GOF》两本经典书籍中的案例</li><li>提供了友好的阅读指导</li></ul><p><img src="/2023/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%AF%87%EF%BC%9A%E5%89%96%E6%9E%90%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/172284a1c8caf324"></p>]]></content>
    
    
    <categories>
      
      <category>编码及设计模式篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式总篇：剖析七大原则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跨域问题</title>
    <link href="/2023/02/06/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    <url>/2023/02/06/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="前端交互篇-跨域"><a href="#前端交互篇-跨域" class="headerlink" title="前端交互篇 - 跨域"></a>前端交互篇 - 跨域</h1><p>标签： #Share</p><h2 id="SpringBoot-Cors解决跨域问题-本地请求其他域名时cookie无法传输"><a href="#SpringBoot-Cors解决跨域问题-本地请求其他域名时cookie无法传输" class="headerlink" title="SpringBoot - Cors解决跨域问题 - 本地请求其他域名时cookie无法传输"></a>SpringBoot - Cors解决跨域问题 - 本地请求其他域名时cookie无法传输</h2><pre><code class="hljs java">SpringBoot 利用Cors解决跨域问题<span class="hljs-number">1.</span>依赖&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;<span class="hljs-number">2.</span>WebConfig配置类<span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCorsMappings</span><span class="hljs-params">(CorsRegistry registry)</span> &#123;        registry.addMapping(<span class="hljs-string">&quot;/**&quot;</span>)               <span class="hljs-comment">// 表示本应用的所有方法都会去处理跨域请求</span>                .allowedOrigins(<span class="hljs-string">&quot;*&quot;</span>)             <span class="hljs-comment">// 例如允许：http://localhost:8081请求</span>                .allowedMethods(<span class="hljs-string">&quot;*&quot;</span>)             <span class="hljs-comment">// 表示允许通过的请求数</span>                .allowedHeaders(<span class="hljs-string">&quot;*&quot;</span>)             <span class="hljs-comment">// 表示允许通过的请求头</span>                .allowCredentials(<span class="hljs-literal">true</span>);         <span class="hljs-comment">// 允许前端传递cookie</span>    &#125;&#125;<span class="hljs-number">3.</span>HTML测试代码&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body onload=<span class="hljs-string">&quot;testCors()&quot;</span>&gt;&lt;/body&gt;&lt;script src=<span class="hljs-string">&quot;js/jquery-3.2.1.js&quot;</span> type=<span class="hljs-string">&quot;text/javascript&quot;</span> charset=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;&lt;/script&gt;&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;function <span class="hljs-title function_">testCors</span><span class="hljs-params">()</span> &#123;$.ajax(&#123;   type:<span class="hljs-string">&#x27;POST&#x27;</span>,   url:<span class="hljs-string">&#x27;http://127.0.0.1:10909/apis/test&#x27;</span>,   xhrFields:&#123;withCredentials:<span class="hljs-literal">true</span>&#125;,   success:function(result)&#123;alert(result)   &#125;,       error: function (err) &#123;       alert(<span class="hljs-string">&quot;异常&quot;</span>)       &#125;   &#125;); &#125;&lt;/script&gt;&lt;/html&gt;</code></pre><h2 id="过滤器-CROS协议"><a href="#过滤器-CROS协议" class="headerlink" title="过滤器- CROS协议"></a>过滤器- CROS协议</h2><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@WebFilter(filterName = &quot;corsFilter&quot;, urlPatterns = &quot;/*&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CorsFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest req, ServletResponse res, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;        <span class="hljs-type">HttpServletResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> (HttpServletResponse) servletResponse;        <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">reqs</span> <span class="hljs-operator">=</span> (HttpServletRequest) servletRequest;        <span class="hljs-type">String</span> <span class="hljs-variable">origin</span> <span class="hljs-operator">=</span> reqs.getHeader(<span class="hljs-string">&quot;Origin&quot;</span>);        <span class="hljs-keyword">if</span>(StringUtils.isEmpty(origin)) &#123;            origin = reqs.getHeader(<span class="hljs-string">&quot;Referer&quot;</span>);        &#125;        response.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>, origin);        response.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>);        response.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="hljs-string">&quot;POST, GET, OPTIONS, DELETE&quot;</span>);        response.setHeader(<span class="hljs-string">&quot;Access-Control-Max-Age&quot;</span>, <span class="hljs-string">&quot;3600&quot;</span>);        response.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="hljs-string">&quot;Origin, No-Cache, X-Requested-With, If-Modified-Since, Pragma, Last-Modified, Cache-Control, Expires, Content-Type, X-E4M-With,Authorization,Token&quot;</span>);        filterChain.doFilter(servletRequest, servletResponse);    &#125;&#125;<span class="hljs-comment">// 重点 cookie处设置 根目录 -&gt; nginx,com结尾网站都可用</span><span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;auth_todo_token&quot;</span>, MD5Util.MD5(username+password)+MD5Util.MD5(password+username));cookie.setPath(<span class="hljs-string">&quot;/&quot;</span>);cookie.setDomain(<span class="hljs-string">&quot;nginx.com&quot;</span>);<span class="hljs-comment">// 重点：本地开发host配置 -&gt; 正式上线后项目Domain依据真实后缀修改即可</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>    test.nginx.com<span class="hljs-number">47.93</span><span class="hljs-number">.6</span><span class="hljs-number">.66</span>   server.nginx.com<span class="hljs-comment">// Html - Ajax请求：</span>$.ajax(&#123;type:<span class="hljs-string">&#x27;POST&#x27;</span>,url:<span class="hljs-string">&#x27;http://server.nginx.com:10909/apis/loginAccess&#x27;</span>,<span class="hljs-comment">// 重点：携带跨域cookie</span>xhrFields: &#123;withCredentials: <span class="hljs-literal">true</span>&#125;,.....&#125;);</code></pre><h2 id="最佳方案-Nginx解决跨域问题"><a href="#最佳方案-Nginx解决跨域问题" class="headerlink" title="最佳方案 - Nginx解决跨域问题"></a>最佳方案 - Nginx解决跨域问题</h2><pre><code class="hljs java">跨域问题产生原因: 域名[主域名与子域名也算]不同端口不同协议不同特注：Ip与域名之间网络交互，也属于跨域，如：<span class="hljs-number">123.23</span><span class="hljs-number">.23</span><span class="hljs-number">.12</span> 和 www.a.com因此通过nginx进行反向代理解决该问题如: nginx部署静态资源 -&gt; 地址为 <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>/html/index.html                       接口地址为： <span class="hljs-number">111.111</span><span class="hljs-number">.111</span><span class="hljs-number">.111</span>:<span class="hljs-number">8080</span>/apis/test                       则可以通过nginx 将<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> 配置前缀的方式代理真实接口地址即：<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>/apis<span class="hljs-comment">/* ===&gt;  111.111.111.111:8080/apis/test</span><span class="hljs-comment"></span><span class="hljs-comment">然后本地界面请求即不会产生跨域问题, 部署详情见nginx篇</span><span class="hljs-comment"></span></code></pre><h2 id="升级方案-oauth2-0"><a href="#升级方案-oauth2-0" class="headerlink" title="升级方案 - oauth2.0"></a>升级方案 - oauth2.0</h2><blockquote><p>JWT的思路，即无状态用户认证</p></blockquote><pre><code class="hljs java">利用oauth2<span class="hljs-number">.0</span> token验证的方式, 网关层代理及nginx代理解决跨域问题和权限验证的问题</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>跨域问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>观察者模式</title>
    <link href="/2023/02/06/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/02/06/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="观察者模式篇"><a href="#观察者模式篇" class="headerlink" title="观察者模式篇"></a>观察者模式篇</h1><p>标签： #Share</p><h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新</p><p><font color="red">别名：</font>发布-订阅模式</p><h2 id="观察者模式的诞生"><a href="#观察者模式的诞生" class="headerlink" title="观察者模式的诞生"></a>观察者模式的诞生</h2><p>将一个系统分割成一系列相互协作的类有一个常见的副作用：需要维护相关对象间的致性，我们不希望为了维持一致性而使各类紧密耦合，因为这样降低了它们的可重用性。</p><p>说人话就是：</p><p>【<font color="orange">产品</font>】：开发小哥，我需要你设计一个天气预报显示大屏，气象站会给你发送数据，你需要把它展示到大屏里，OK吗？</p><p>【<font color="blue">开发</font>】：OJBK！秒秒钟搞定一切！代码立马出来！</p><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">getTemperature</span> <span class="hljs-params">()</span> &#123;    <span class="hljs-comment">// 从气象站获取发送过来的温度数据</span>    <span class="hljs-comment">// getData();</span>            <span class="hljs-comment">// ................................</span>    <span class="hljs-comment">// 显示到大屏里面去</span>    <span class="hljs-comment">// showDataToScreen();</span>    <span class="hljs-comment">// ................................</span>&#125;<span class="hljs-keyword">void</span> <span class="hljs-title function_">getMisture</span> <span class="hljs-params">()</span> &#123;    <span class="hljs-comment">// 从气象站获取发送过来的湿度数据</span>    <span class="hljs-comment">// getData();</span>            <span class="hljs-comment">// ................................</span>    <span class="hljs-comment">// 显示到大屏里面去</span>    <span class="hljs-comment">// showDataToScreen();</span>    <span class="hljs-comment">// ................................</span>&#125;<span class="hljs-keyword">void</span> <span class="hljs-title function_">getAirindex</span> <span class="hljs-params">()</span> &#123;    <span class="hljs-comment">// 从气象站获取发送过来的空气指数数据</span>    <span class="hljs-comment">// getData();</span>            <span class="hljs-comment">// ................................</span>    <span class="hljs-comment">// 显示到大屏里面去</span>    <span class="hljs-comment">// showDataToScreen();</span>    <span class="hljs-comment">// ................................</span>&#125;</code></pre><p>【<font color="red">BOSS</font>】：磕大头！宁是准备每获取一次数据就把代码CV一遍吗？你不累吗？</p><p>【<font color="blue">开发</font>】：老大，我一点都不累！就是复制粘贴一下呀！</p><p>【<font color="red">BOSS</font>】：如果我现在不需要同步更新天气指数呢？删代码吗？</p><p>【<font color="blue">开发</font>】：对啊！一秒钟就能删掉！( •̀ ω •́ )✧</p><p>【<font color="red">BOSS</font>】：重写😃</p><p><img src="/2023/02/06/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/972352-07e55e231b95023f.webp" alt="img"></p><h2 id="HeadFirst-核心代码"><a href="#HeadFirst-核心代码" class="headerlink" title="HeadFirst 核心代码"></a>HeadFirst 核心代码</h2><p>于是乎，我们开启了关于设计模式的经典书籍阅读之旅</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 观察主题接口</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Observable</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addObserver</span><span class="hljs-params">(Observer observer)</span>;     <span class="hljs-comment">// 添加观察者</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeObserver</span><span class="hljs-params">(Observer observer)</span>;  <span class="hljs-comment">// 移除观察者</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObservers</span><span class="hljs-params">(WeatherData data)</span>;  <span class="hljs-comment">// 通知所有观察者</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 观察者</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Observer</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(WeatherData data)</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 天气主题</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Weather</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observable</span> &#123;    <span class="hljs-keyword">private</span> List&lt;Observer&gt; observers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addObserver</span><span class="hljs-params">(Observer observer)</span> &#123;        observers.add(observer);    &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeObserver</span><span class="hljs-params">(Observer observer)</span> &#123;        observers.remove(observer);    &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObservers</span><span class="hljs-params">(WeatherData data)</span> &#123;        <span class="hljs-keyword">for</span> (Observer observer : observers)            observer.update(data);    &#125;&#125;</code></pre><p><font color="red">观察者模式的设计思路：</font></p><ul><li>Subject 目标（容器）提供注册和删除观察者的接口以及更新接口</li><li>Observer（观察者）为那些在目标发生改变时需获得通知的对象定义一个更新接口</li><li>ConcreteSubject（具体目标）状态发生改变时，向各个观察者发出通知</li><li>ConcreteObserver（具体观察者）实现Observer的更新接口</li></ul><p>简单来说，</p><ol><li>我们需要一个接口来定义注册，删除和更新接口</li><li>然后由具体的目标（类）实现该接口，并且在类中创建一个容器，存储需要被通知的对象</li><li>需要被通知的对象，需要实现Observer接口中的update更新方法</li><li>将观察者对象注册进容器中，当具体目标更新时，调用所有容器类对象的update方法</li></ol><blockquote><p>如果看着有点模棱两可，就看完本文后，访问专题设计模式开源项目，里面有具体的代码示例，链接在最下面</p></blockquote><h2 id="JDK中的观察者模式"><a href="#JDK中的观察者模式" class="headerlink" title="JDK中的观察者模式"></a>JDK中的观察者模式</h2><p>JDK中已经对观察者模式有具体的实现，代码非常简单，如下所示：</p><p>具体目标：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObservableApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Observable</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> curr;        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ObservableApp</span><span class="hljs-params">(<span class="hljs-type">long</span> curr)</span> &#123;        <span class="hljs-built_in">this</span>.curr = curr;    &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">change</span><span class="hljs-params">(<span class="hljs-type">long</span> newStr)</span> &#123;        <span class="hljs-built_in">this</span>.curr = newStr;                <span class="hljs-comment">// 更改状态，发送通知</span>        setChanged();        notifyObservers(newStr);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setChanged</span><span class="hljs-params">()</span> &#123;        <span class="hljs-built_in">super</span>.setChanged();    &#125;&#125;</code></pre><p>具体观察者：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObserverA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Observable o, Object arg)</span> &#123;        System.out.println(MessageFormat.format(<span class="hljs-string">&quot;ObserverA -&gt; &#123;0&#125; changed, Begin to Work. agr is:&#123;1&#125;&quot;</span>, o.getClass().getSimpleName(), arg));    &#125;&#125;</code></pre><p>Main方法：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;        <span class="hljs-type">ObservableApp</span> <span class="hljs-variable">app</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObservableApp</span>(System.currentTimeMillis());        System.out.println(app.getCurr());        app.addObserver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObserverA</span>());        app.addObserver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObserverB</span>());        Thread.sleep(<span class="hljs-number">1000</span>);                <span class="hljs-type">long</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> System.currentTimeMillis();        app.change(curr);        System.out.println(app.getCurr());    &#125;&#125;<span class="hljs-comment">// 输出如下：</span><span class="hljs-comment">// 1589688733464</span><span class="hljs-comment">// ObserverB -&gt; ObservableApp changed, Begin to Work. agr is:1,589,688,734,469</span><span class="hljs-comment">// ObserverA -&gt; ObservableApp changed, Begin to Work. agr is:1,589,688,734,469</span><span class="hljs-comment">// 1589688734469</span></code></pre><h3 id="推模式"><a href="#推模式" class="headerlink" title="推模式"></a>推模式</h3><p>通知发给观察者，通知携带参数，这就是推，对应JDK方法中的：notifyObservers(Object arg) </p><h3 id="拉模式"><a href="#拉模式" class="headerlink" title="拉模式"></a>拉模式</h3><p>通知发给观察者，通知不携带参数，需要观察者自己去主动调用get方法获取数据，这就是拉</p><p>对应JDK方法中的：notifyObservers()，仅告知观察者数据发生了变化，至于数据的详情需要观察者主动到主题中pull数据</p><p>拉模型强调的是目标不知道它的观察者,而推模型假定目标知道一些观察者的需要的信息。推模型可能使得观察者相对难以复用，因为目标对观察者的假定可能并不总是正确的。另一方面。拉模型可能效率较差，因为观察者对象需在没有目标对象帮助的情况下确定什么改变了。</p><h2 id="遵循的设计原则"><a href="#遵循的设计原则" class="headerlink" title="遵循的设计原则"></a>遵循的设计原则</h2><ol><li><strong>封装变化</strong><ul><li>在观察者模式中会经常改变的是主题的状态，以及观察者的数目和类型</li><li>我们可以改变依赖于主题状态的对象，但是不必改变主题本身，这便是提前规划</li></ul></li><li><strong>针对接口编程</strong><ul><li>主题和观察者都使用了接口</li><li>观察者利用主题的接口向主题注册</li><li>主题利用观察者接口通知观察者，可以使两者之间正常交互，同时又具有松耦合的特性</li></ul></li><li><strong>多使用组合</strong><ul><li>观察者模式利用组合将许多观察者组合进主题中</li><li>它们之间的关系并不是通过继承得到，而是在运行时动态改变</li></ul></li></ol><h2 id="什么场景适合使用"><a href="#什么场景适合使用" class="headerlink" title="什么场景适合使用"></a>什么场景适合使用</h2><p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern），比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式</p><h2 id="Code-生活中的实际应用"><a href="#Code-生活中的实际应用" class="headerlink" title="Code&#x2F;生活中的实际应用"></a>Code&#x2F;生活中的实际应用</h2><ul><li>比如微信公众号中的订阅关注，订阅后，公众号发布文章会实时分发给各个账号</li><li>又如，我们使用Keep跑步时，如果你跑的足够激情，它会提示你，<font color="red">恭喜你，你已经打破了五公里的最好记录！</font>这样的语音提醒一定是触发式，而不是实时去检测吧？（实时检测没有意义，浪费性能）这里就可以利用观察者模式进行设计和解耦</li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p><strong>附上GOF一书中对于观察者模式的UML图：</strong></p><p><img src="/2023/02/06/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/image-20200517141746282.png" alt="image-20200517141746282"></p><h2 id="相关代码链接"><a href="#相关代码链接" class="headerlink" title="相关代码链接"></a>相关代码链接</h2><p><a href="https://github.com/kkzhilu/Kerwin-DesignPattern">GitHub地址</a></p><ul><li>兼顾了《HeadFirst》以及《GOF》两本经典书籍中的案例</li><li>提供了友好的阅读指导</li></ul><p><img src="/2023/02/06/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/%E5%BE%AE%E4%BF%A1%E4%BA%8C%E7%BB%B4%E7%A0%81.png"></p>]]></content>
    
    
    <categories>
      
      <category>编码及设计模式篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>观察者模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>迭代器和组合模式</title>
    <link href="/2023/02/06/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/02/06/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="迭代器及组合模式篇"><a href="#迭代器及组合模式篇" class="headerlink" title="迭代器及组合模式篇"></a>迭代器及组合模式篇</h1><p>标签： #Share</p><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴漏该对象的内部表示</p><h3 id="迭代器模式的诞生"><a href="#迭代器模式的诞生" class="headerlink" title="迭代器模式的诞生"></a>迭代器模式的诞生</h3><p>【<font color="orange">产品</font>】：嘿，有一个好消息，咱们旗下的餐厅把月巴克的咖啡店吞并了！太棒了！年终奖稳了！</p><p>【<font color="blue">开发</font>】：Yeah！Yeah！Yeah！</p><p>【<font color="orange">产品</font>】：但是他们好像反应一个问题，月巴克的点餐系统好像不兼容我们的体系，怎么回事？不就是一个菜单吗？</p><p>【<font color="blue">开发</font>】：Oh！No！一定它们的 <font color="red">数据结构</font> 不一样导致的，遍历出现了问题！</p><p>【<font color="orange">产品</font>】：那怎么办？BOSS，你们一起想想办法吧！</p><p>【<font color="blue">开发</font>】：老大，我们能不能把遍历方法抽取出来啊？我们遍历操作就可以不用考虑各种细节了，只需要管遍历类就好了。</p><p>【<font color="red">BOSS</font>】：什么遍历类的，这叫 <font color="red">迭代器</font>  好吗！其实JDK对于迭代器已经维护的很好了，但是咱们这业务也有一点特殊性，就按你说的办吧，办不好的话，刚才说的年终奖就没了。</p><p>【<font color="blue">开发</font>】：哦，好的（脸上笑嘻嘻，心里MMP）</p><p><img src="/2023/02/06/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/image-20200614112304352.png" alt="image-20200614112304352"></p><h3 id="HeadFirst-核心代码"><a href="#HeadFirst-核心代码" class="headerlink" title="HeadFirst 核心代码"></a>HeadFirst 核心代码</h3><h4 id="自己整一个迭代器"><a href="#自己整一个迭代器" class="headerlink" title="自己整一个迭代器"></a>自己整一个迭代器</h4><p><em><strong>定义迭代器持有者  非必须代码</strong></em></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * ******************************</span><span class="hljs-comment"> * description:  迭代器持有者</span><span class="hljs-comment"> * ******************************</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyContainer</span> &#123;    MyIterator <span class="hljs-title function_">getIterator</span><span class="hljs-params">()</span>;&#125;</code></pre><p><em><strong>迭代器接口</strong></em></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * ******************************</span><span class="hljs-comment"> * description:  迭代器接口</span><span class="hljs-comment"> * ******************************</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyIterator</span> &#123;    <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span>;    Object <span class="hljs-title function_">next</span><span class="hljs-params">()</span>;&#125;</code></pre><p><em><strong>迭代器工作类  食物菜单</strong></em></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FoodRepository</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyContainer</span> &#123;    String[] names = &#123;<span class="hljs-string">&quot;宫保鸡丁&quot;</span>, <span class="hljs-string">&quot;麻辣香锅&quot;</span>, <span class="hljs-string">&quot;油闷大虾&quot;</span>&#125;;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> MyIterator <span class="hljs-title function_">getIterator</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NameIterator</span>();    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NameIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyIterator</span> &#123;        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> index;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">return</span> index &lt; names.length;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;           <span class="hljs-keyword">return</span> hasNext() ? names[index++] : <span class="hljs-literal">null</span>;        &#125;        NameIterator() &#123;            index = <span class="hljs-number">0</span>;        &#125;    &#125;&#125;</code></pre><p><em><strong>迭代器工作类  咖啡菜单</strong></em></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CoffeeRepository</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyContainer</span> &#123;    List&lt;String&gt; names = Arrays.asList(<span class="hljs-string">&quot;雀巢咖啡&quot;</span>, <span class="hljs-string">&quot;黑糖玛奇朵&quot;</span>, <span class="hljs-string">&quot;半点寂寞&quot;</span>);    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> MyIterator <span class="hljs-title function_">getIterator</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NameIterator</span>();    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NameIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyIterator</span> &#123;        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> index;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">return</span> index &lt; names.size();        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;           <span class="hljs-keyword">return</span> hasNext() ? names.get(index++) : <span class="hljs-literal">null</span>;        &#125;        NameIterator() &#123;            index = <span class="hljs-number">0</span>;        &#125;    &#125;&#125;</code></pre><p><em><strong>测试类 观察调用的表现形式</strong></em></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;        <span class="hljs-comment">// 餐厅菜单</span>        <span class="hljs-type">FoodRepository</span> <span class="hljs-variable">food</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FoodRepository</span>();        <span class="hljs-type">MyIterator</span> <span class="hljs-variable">foodIterator</span> <span class="hljs-operator">=</span> food.getIterator();        <span class="hljs-keyword">while</span> (foodIterator.hasNext()) &#123;            System.out.println(<span class="hljs-string">&quot;Food: -&gt; &quot;</span> + foodIterator.next());        &#125;        CodeUtils.spilt();        <span class="hljs-comment">// 咖啡菜单</span>        <span class="hljs-type">CoffeeRepository</span> <span class="hljs-variable">coffee</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CoffeeRepository</span>();        <span class="hljs-type">MyIterator</span> <span class="hljs-variable">coffeeIterator</span> <span class="hljs-operator">=</span> coffee.getIterator();        <span class="hljs-keyword">while</span> (coffeeIterator.hasNext()) &#123;            System.out.println(<span class="hljs-string">&quot;Coffee: -&gt; &quot;</span> + coffeeIterator.next());        &#125;    &#125;&#125;</code></pre><h4 id="JDK中的迭代"><a href="#JDK中的迭代" class="headerlink" title="JDK中的迭代"></a>JDK中的迭代</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;        <span class="hljs-comment">// JDK</span>        List&lt;String&gt; names = Arrays.asList(<span class="hljs-string">&quot;Han&quot;</span>, <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;Tomams&quot;</span>);        Iterator&lt;String&gt; iterable = names.iterator();        <span class="hljs-keyword">while</span> (iterable.hasNext()) &#123;            System.out.println(<span class="hljs-string">&quot;JDK Iterator: -&gt; &quot;</span> + iterable.next());        &#125;        CodeUtils.spilt();        <span class="hljs-comment">// JDK</span>        names.forEach(s -&gt; System.out.println(<span class="hljs-string">&quot;JDK forEach: -&gt; &quot;</span> + s));    &#125;&#125;</code></pre><p>因此对于业务上没有什么要求且常见的数据结构，我们不再需要自行定义迭代器</p><p><font color="red">迭代器模式的设计思路：</font></p><ul><li>Iterator                     迭代器</li><li>Concretelterator      具体迭代器</li><li>Aggregate                 集合</li><li>ConcreteAggregate  具体集合</li></ul><p>简单来说，</p><ol><li>我们需要明确集合的类型（数组，链表，Map，树结构或者普通List）</li><li>我们需要定义迭代器的行为，是否有下一个（遍历完成），取值，移除等等</li><li>遍历的行为或者算法在具体的迭代器中实现，根据不同的数据结构和业务要求完成编码，实现访问一致，但细节不同的效果</li></ol><blockquote><p>如果看着有点模棱两可，就看完本文后，访问专题设计模式开源项目，里面有具体的代码示例，链接在最下面</p></blockquote><h3 id="遵循的设计原则"><a href="#遵循的设计原则" class="headerlink" title="遵循的设计原则"></a>遵循的设计原则</h3><ul><li>单一职责原则</li></ul><p>说明：迭代器类在设计中仅仅包含集合迭代的作用，它是把原本数据结构中的遍历抽取出来，达到  <font color="red">高内聚</font>  的效果。</p><p>所谓高内聚：当一个模块或一个类被设计成只支持一组相关功能时，我们说它具有 <font color="red">高内聚</font>  的特征。</p><h3 id="什么场景适合使用"><a href="#什么场景适合使用" class="headerlink" title="什么场景适合使用"></a>什么场景适合使用</h3><ul><li>访问一个聚合对象的内容而无需暴漏它的内部表示</li><li>支持对聚合对象的多种遍历</li><li>为遍历不同的聚合结构提供一个统一的接口</li></ul><h3 id="Code-生活中的实际应用"><a href="#Code-生活中的实际应用" class="headerlink" title="Code&#x2F;生活中的实际应用"></a>Code&#x2F;生活中的实际应用</h3><p>举一个不是很恰当的例子，我们都用自动贩卖机买过水，付钱之后它会自动滚出来，大家有没有想过它是怎么实现这个效果的呢？它支持瓶装的，罐装的，甚至还支持袋装的，方便面，口红等等五花八门的产品，它的内部结构可能都各不相同，但是最终的表现效果就是我们直接从出口处拿即可，这是不是迭代器模式的一种体现呢？</p><h3 id="迭代器模式UML图"><a href="#迭代器模式UML图" class="headerlink" title="迭代器模式UML图"></a>迭代器模式UML图</h3><p><img src="/2023/02/06/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/image-20200614115015075.png" alt="image-20200614115015075"></p><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><h3 id="意图-1"><a href="#意图-1" class="headerlink" title="意图"></a>意图</h3><p>将对象组合成树形结构以表示 “部分-整体” 的层次结构，Composite使得用户对单个对象和组合对象的使用具有一致性</p><p><font color="red">说人话：</font>想想Java里的File类</p><h3 id="组合模式的误区"><a href="#组合模式的误区" class="headerlink" title="组合模式的误区"></a>组合模式的误区</h3><p>组合模式 <font color="red">不是</font> 一堆模式的组合！</p><h3 id="组合模式的诞生"><a href="#组合模式的诞生" class="headerlink" title="组合模式的诞生"></a>组合模式的诞生</h3><p>【<font color="blue">开发</font>】：老大，我在写菜单类的时候感觉好痛苦啊！</p><p>【<font color="red">BOSS</font>】：怎么了？</p><p>【<font color="blue">开发</font>】：菜单有真正的菜品，还有父级菜单啊，它们俩得维护两套逻辑，混在一起好难受！</p><p>【<font color="red">BOSS</font>】：你在操作文件的时候怎么不觉得难受？你咋不动动脑子想着抽象一下啊！</p><p>【<font color="blue">开发</font>】：对啊！我去改代码！</p><h3 id="HeadFirst-核心代码-1"><a href="#HeadFirst-核心代码-1" class="headerlink" title="HeadFirst 核心代码"></a>HeadFirst 核心代码</h3><p><em><strong>定义抽象行为</strong></em></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * ******************************</span><span class="hljs-comment"> * description:  定义抽象行为</span><span class="hljs-comment"> * ******************************</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MenuComponent</span> &#123;    <span class="hljs-keyword">public</span> String name;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 添加</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(MenuComponent component)</span> <span class="hljs-keyword">throws</span> Exception;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 移除</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(MenuComponent component)</span> <span class="hljs-keyword">throws</span> Exception;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 获取菜单名</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 获取子菜单</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> MenuComponent <span class="hljs-title function_">getChild</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-keyword">throws</span> Exception;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 打印菜单</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>;&#125;</code></pre><p><em><strong>实现 “整体”</strong></em></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Menu</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MenuComponent</span>&#123;    List&lt;MenuComponent&gt; menuComponents = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Menu</span><span class="hljs-params">(String name)</span> &#123;        <span class="hljs-built_in">this</span>.name = name;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(MenuComponent component)</span> &#123;        <span class="hljs-built_in">this</span>.menuComponents.add(component);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(MenuComponent component)</span> &#123;        <span class="hljs-built_in">this</span>.menuComponents.remove(component);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> MenuComponent <span class="hljs-title function_">getChild</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;        <span class="hljs-keyword">return</span> menuComponents.get(i);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;当前菜单项: &quot;</span> + getName());        <span class="hljs-keyword">for</span> (MenuComponent component : menuComponents) &#123;            component.print();        &#125;    &#125;&#125;</code></pre><p><em><strong>实现 “部分”</strong></em></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MentItem</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MenuComponent</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MentItem</span><span class="hljs-params">(String name)</span> &#123;        <span class="hljs-built_in">this</span>.name = name;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(MenuComponent component)</span> <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(<span class="hljs-string">&quot;无法添加&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(MenuComponent component)</span> <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(<span class="hljs-string">&quot;无法移除&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> MenuComponent <span class="hljs-title function_">getChild</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(<span class="hljs-string">&quot;无子节点&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;    食物名: &quot;</span> + getName());    &#125;&#125;</code></pre><p><em><strong>测试类</strong></em></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 推荐代码阅读顺序：</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> MenuComponent</span><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> Menu</span><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> MentItem</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">Menu</span> <span class="hljs-variable">meat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Menu</span>(<span class="hljs-string">&quot;炒菜类&quot;</span>);        <span class="hljs-type">MentItem</span> <span class="hljs-variable">item1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MentItem</span>(<span class="hljs-string">&quot;宫保鸡丁&quot;</span>);        <span class="hljs-type">MentItem</span> <span class="hljs-variable">item2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MentItem</span>(<span class="hljs-string">&quot;剁椒鸡蛋&quot;</span>);        <span class="hljs-type">MentItem</span> <span class="hljs-variable">item3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MentItem</span>(<span class="hljs-string">&quot;鱼香肉丝&quot;</span>);        <span class="hljs-type">Menu</span> <span class="hljs-variable">vegetable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Menu</span>(<span class="hljs-string">&quot;素食&quot;</span>);        <span class="hljs-type">MentItem</span> <span class="hljs-variable">v1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MentItem</span>(<span class="hljs-string">&quot;酸辣土豆丝&quot;</span>);        <span class="hljs-type">MentItem</span> <span class="hljs-variable">v2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MentItem</span>(<span class="hljs-string">&quot;爆炒包菜&quot;</span>);        meat.add(item1);        meat.add(item2);        meat.add(item3);        vegetable.add(v1);        vegetable.add(v2);        meat.add(vegetable);        meat.print();    &#125;&#125;<span class="hljs-comment">/***</span><span class="hljs-comment"> * 输出内容：</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 当前菜单项: 炒菜类</span><span class="hljs-comment"> *     食物名: 宫保鸡丁</span><span class="hljs-comment"> *     食物名: 剁椒鸡蛋</span><span class="hljs-comment"> *     食物名: 鱼香肉丝</span><span class="hljs-comment"> * 当前菜单项: 素食</span><span class="hljs-comment"> *     食物名: 酸辣土豆丝</span><span class="hljs-comment"> *     食物名: 爆炒包菜</span><span class="hljs-comment"> */</span></code></pre><p><font color="red">组合模式的设计思路：</font></p><ul><li>Component      为组合的对象声明接口或抽象类</li><li>Leaf                   叶子节点（最小单元）</li><li>Composite       组合节点（即还有子节点的节点）</li><li>Client                客户端，调用方</li></ul><p>简单来说，</p><ol><li>当我们需要树形结构时，抽象叶子节点和组合节点（有子节点的节点）的共同行为</li><li>让两者实现同一个接口</li></ol><blockquote><p>如果看着有点模棱两可，就看完本文后，访问专题设计模式开源项目，里面有具体的代码示例，链接在最下面</p></blockquote><h3 id="什么场景适合使用-1"><a href="#什么场景适合使用-1" class="headerlink" title="什么场景适合使用"></a>什么场景适合使用</h3><ul><li>需要表示对象的部分-整体层次结构</li><li>希望用户忽略组合对象与单个对象的不同，用户统一地使用组合结构中所有对象</li></ul><h3 id="Code-生活中的实际应用-1"><a href="#Code-生活中的实际应用-1" class="headerlink" title="Code&#x2F;生活中的实际应用"></a>Code&#x2F;生活中的实际应用</h3><p>依然是一个不太恰当的例子，我们在操作文件和文件夹的时候，都有其移动，复制，重命名，查看文件大小等等功能，对于Java来说，它的底层实现是有一个 <code>是否是文件夹</code> 的方法来区分，但实际上这也是组合模式的根本思想，即对于表示 <font color="red">部分</font> 的对象，和 <font color="red">整体</font> 的对象，<font color="red">拥有统一的操作行为</font></p><h3 id="组合模式的UML图"><a href="#组合模式的UML图" class="headerlink" title="组合模式的UML图"></a>组合模式的UML图</h3><p><img src="/2023/02/06/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/image-20200614235513451.png" alt="image-20200614235513451"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>迭代器模式：该模式在JDK中已经封装的非常好，我们其实不太需要再自行处理，不过在处理特殊数据结构时这种统一操作的思想仍然值得借鉴</li><li>组合模式：组合模式仅在需要树形结构的场景下可发挥巨大的作用，同样的，它规范不同类型对象的行为，统一操作的思想，值得我们借鉴</li></ul><h2 id="相关代码链接"><a href="#相关代码链接" class="headerlink" title="相关代码链接"></a>相关代码链接</h2><p><a href="https://github.com/kkzhilu/Kerwin-DesignPattern">GitHub地址</a></p><ul><li>兼顾了《HeadFirst》以及《GOF》两本经典书籍中的案例</li><li>提供了友好的阅读指导</li></ul><p><img src="/2023/02/06/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/%E5%BE%AE%E4%BF%A1%E4%BA%8C%E7%BB%B4%E7%A0%81.png"></p>]]></content>
    
    
    <categories>
      
      <category>编码及设计模式篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>迭代器和组合模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>适配器模式和外观模式</title>
    <link href="/2023/02/06/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/02/06/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>标签： #Share</p><h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p><font color="red">将一个类的接口转换成客户希望的另外一个接口</font>，adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作</p><p>别名：Wrapper包装器</p><h2 id="适配器模式的诞生"><a href="#适配器模式的诞生" class="headerlink" title="适配器模式的诞生"></a>适配器模式的诞生</h2><p>【<font color="orange">产品</font>】：开发小哥，记得我们第一版的需求吗？</p><p>【<font color="blue">开发</font>】：什么玩意？</p><p>【<font color="orange">产品</font>】：我们第一版是不是造了很多鸭子啊，现在需要造一点火鸡，但是客户很奇葩，他们要让<font color="red">鸭子拥有火鸡一样的能力</font>，怎么办？</p><p>【<font color="blue">开发</font>】：把鸭子当火鸡写？</p><p>【<font color="orange">产品</font>】：不行，火鸡是火鸡，鸭子是鸭子，只有特殊的情况才需要混在一起，怎么办呢？</p><p>【<font color="blue">开发</font>】：老大，怎么办呢？</p><p>【<font color="red">BOSS</font>】：什么火鸡鸭子的，它们不都有自己的接口嘛，俩接口刚好用适配器去做，自己去查查资料！</p><p><img src="/2023/02/06/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/image-20200602232759067.png" alt="image-20200602232759067"></p><h2 id="HeadFirst-核心代码"><a href="#HeadFirst-核心代码" class="headerlink" title="HeadFirst 核心代码"></a>HeadFirst 核心代码</h2><p>根据上文，我们至少知道了一点，玩适配器模式得有俩接口？先当个问题吧，咱们待会再说</p><p><strong>鸭子接口</strong></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 鸭子接口</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Duck</span> &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 鸭叫</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">quack</span><span class="hljs-params">()</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 飞行</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span>;&#125;</code></pre><p><strong>火鸡接口</strong></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 火鸡接口</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Turkey</span> &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 火鸡叫</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">gobble</span><span class="hljs-params">()</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 飞行</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span>;&#125;</code></pre><p><strong>火鸡实现类</strong></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 火鸡实现类</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WildTurkey</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Turkey</span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">gobble</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;咯咯&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;我在飞，虽然我飞的很近&quot;</span>);    &#125;&#125;</code></pre><p><strong>关键点啦！适配！</strong></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 火鸡适配器</span><span class="hljs-comment"> * 实现鸭子接口同时持有火鸡对象，在实现的接口处用火鸡对象的方法填充一下（同时还可以做额外的事情）</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TurkeyAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Duck</span>&#123;    Turkey turkey;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quack</span><span class="hljs-params">()</span> &#123;        turkey.gobble();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;        turkey.fly();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TurkeyAdapter</span><span class="hljs-params">(Turkey turkey)</span> &#123;        <span class="hljs-built_in">this</span>.turkey = turkey;    &#125;&#125;</code></pre><p><font color="red">适配器模式的设计思路</font>：</p><ul><li>Target       定义特定领域接口</li><li>Client        符合Target接口的对象</li><li>Adaptee   定义一个存在的接口，需要适配</li><li>Adapter   适配器</li></ul><p>简单来说，当我们需要对<font color="blue">两个本不相关的接口</font>混合一起用时，<font color="blue">需要用一个适配器实现A接口，持有B对象，再用B对象的方法去填充A接口的方法</font>，同时还可以增加一些其他的逻辑</p><h2 id="和装饰器很像？"><a href="#和装饰器很像？" class="headerlink" title="和装饰器很像？"></a>和装饰器很像？</h2><p>从编程语言的技巧上来看，的确非常的像，我们来梳理一下其相同点和异同点：</p><p><em><strong>相同点：</strong></em></p><ul><li>实现技巧上，都是实现某个接口，同时持有某个对象，用对象的方法去填充需要实现的方法</li></ul><p><em><strong>不同点：</strong></em></p><ul><li>接口个数不同，装饰器一般是单个接口，而适配器则是2个以上接口混合工作</li><li>目的不同，装饰器是为了增强对象的方法，而适配器则是让本不能一起工作的接口混在一起工作</li></ul><h2 id="来一波接口适配器"><a href="#来一波接口适配器" class="headerlink" title="来一波接口适配器"></a>来一波接口适配器</h2><p>接口适配器在Java中很常见，比如：MouseListener之余MouseAdapter</p><p>举个例子：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 定义超多的方法</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">InterfaceClass</span> &#123;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span>;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span>;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">c</span><span class="hljs-params">()</span>;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">d</span><span class="hljs-params">()</span>;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">e</span><span class="hljs-params">()</span>;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span>;&#125;</code></pre><p>用一个抽象类去实现接口：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterfaceAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InterfaceClass</span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;i have override method a&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> &#123;&#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">c</span><span class="hljs-params">()</span> &#123;&#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">d</span><span class="hljs-params">()</span> &#123;&#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">e</span><span class="hljs-params">()</span> &#123;&#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;&#125;&#125;</code></pre><p>这样有什么好处呢？比如MouseAdapter，我们在学习GUI编程的时候肯定用到过，此时我只想重写点击方法，但是直接用接口的话，代码太多了，需要重写一堆的东西，用接口适配器的话，则可以很轻松的减少大量的无用代码，专注自己想要实现的方法即可</p><h2 id="什么场景适用"><a href="#什么场景适用" class="headerlink" title="什么场景适用"></a>什么场景适用</h2><ul><li>你想使用一个已经存在的类，而它的接口不符合你的需求</li><li>你想创建一个可以复用的类，该类可以与其他不相关的类或可能不兼容的类一起工作</li></ul><h2 id="Code-生活中的实际应用"><a href="#Code-生活中的实际应用" class="headerlink" title="Code&#x2F;生活中的实际应用"></a>Code&#x2F;生活中的实际应用</h2><p>现在手机都追求全面屏，安卓手机和耳机之间需要一个转接头工作，此时的转接头就是一个适配器，它持有耳机对象，实现手机插孔的接口，最终提供功能的依然是耳机，但它让本来无法联接的物体产生了联系</p><h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><p><img src="/2023/02/06/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/image-20200602234955490.png" alt="image-20200602234955490"></p><h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><h2 id="意图-1"><a href="#意图-1" class="headerlink" title="意图"></a>意图</h2><p>为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p><p><strong>核心思想：为子系统们提供一套通用的对外接口（高级API）</strong></p><h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><p>该模式过于简单所以直接上代码~</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 定义一个顶层接口</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Computer</span> &#123;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cpu</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Computer</span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;Cpu Open.&quot;</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ram</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Computer</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;Ram Open.&quot;</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ssd</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Computer</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;SSD Open.&quot;</span>);    &#125;&#125;</code></pre><p><strong>外观类</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FacadeComputer</span> &#123;    <span class="hljs-keyword">private</span> Cpu cpu;    <span class="hljs-keyword">private</span> Ram ram;    <span class="hljs-keyword">private</span> Ssd ssd;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FacadeComputer</span><span class="hljs-params">()</span> &#123;        <span class="hljs-built_in">this</span>.cpu = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cpu</span>();        <span class="hljs-built_in">this</span>.ram = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ram</span>();        <span class="hljs-built_in">this</span>.ssd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ssd</span>();    &#125;    <span class="hljs-comment">/** Cpu On **/</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCpu</span><span class="hljs-params">()</span> &#123;        <span class="hljs-built_in">this</span>.cpu.open();    &#125;    <span class="hljs-comment">/** Ram On **/</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onRam</span><span class="hljs-params">()</span> &#123;        <span class="hljs-built_in">this</span>.ram.open();    &#125;    <span class="hljs-comment">/** Ssd On **/</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSsd</span><span class="hljs-params">()</span> &#123;        <span class="hljs-built_in">this</span>.ssd.open();    &#125;    <span class="hljs-comment">/** All On **/</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">allOn</span><span class="hljs-params">()</span> &#123;        <span class="hljs-built_in">this</span>.cpu.open();        <span class="hljs-built_in">this</span>.ram.open();        <span class="hljs-built_in">this</span>.ssd.open();    &#125;&#125;</code></pre><p><strong>调用对比</strong></p><pre><code class="hljs java"><span class="hljs-comment">/****</span><span class="hljs-comment"> * 推荐阅读顺序：</span><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> Computer</span><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> Cpu | Ram | Ssd</span><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> FacadeComputer</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;    <span class="hljs-comment">// 不使用外观模式</span>    <span class="hljs-type">Computer</span> <span class="hljs-variable">cpu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cpu</span>();    <span class="hljs-type">Computer</span> <span class="hljs-variable">ram</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ram</span>();    <span class="hljs-type">Computer</span> <span class="hljs-variable">ssd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ssd</span>();    cpu.open();    ram.open();    ssd.open();    CodeUtils.spilt();    <span class="hljs-comment">// 使用外观模式</span>    <span class="hljs-type">FacadeComputer</span> <span class="hljs-variable">facadeComputer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FacadeComputer</span>();    facadeComputer.allOn();&#125;</code></pre><h2 id="什么场景适用-1"><a href="#什么场景适用-1" class="headerlink" title="什么场景适用"></a>什么场景适用</h2><ul><li>需要为一个复杂的子系统提供一个简单接口时</li><li>客户程序与抽象类的实现部分之间存在着很大依赖性（分离逻辑，提高子系统的独立性和可移植性）</li><li>需要构建一个层次结构的子系统时</li></ul><h2 id="Code-生活中的实际应用-1"><a href="#Code-生活中的实际应用-1" class="headerlink" title="Code&#x2F;生活中的实际应用"></a>Code&#x2F;生活中的实际应用</h2><p>外观模式在生活中最好的体现就是基金，基金的本质其实是由专业的团队去集资购买股票，购买股票本身有非常多的流程和注意事项，但是现在我们可以很轻松的下注基金，这就是外观模式的体现之一</p><h1 id="相关代码链接"><a href="#相关代码链接" class="headerlink" title="相关代码链接"></a>相关代码链接</h1><p><a href="https://github.com/kkzhilu/Kerwin-DesignPattern">GitHub地址</a></p><ul><li>兼顾了《HeadFirst》以及《GOF》两本经典书籍中的案例</li><li>提供了友好的阅读指导</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/6/1/17270943b7c5022b?w=487&h=185&f=png&s=17561"></p>]]></content>
    
    
    <categories>
      
      <category>编码及设计模式篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>适配器模式和外观模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>限流篇</title>
    <link href="/2023/02/06/%E9%99%90%E6%B5%81%E7%AF%87/"/>
    <url>/2023/02/06/%E9%99%90%E6%B5%81%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="请求限流"><a href="#请求限流" class="headerlink" title="请求限流"></a>请求限流</h1><p>标签： #Share</p><p><strong>开发高并发系统时，有三把利器用来保护系统：缓存、降级和限流</strong></p><p><strong>通过限流，我们可以很好地控制系统的qps，从而达到保护系统的目的。</strong></p><h2 id="计数算法（不常用）"><a href="#计数算法（不常用）" class="headerlink" title="计数算法（不常用）"></a>计数算法（不常用）</h2><pre><code class="hljs java"><span class="hljs-comment">// 模拟的伪代码</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;    <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">atomicLong</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0L</span>);    <span class="hljs-type">long</span> <span class="hljs-variable">interval</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;    <span class="hljs-type">long</span> <span class="hljs-variable">maxNums</span>  <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;    <span class="hljs-type">String</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/test/app&quot;</span>;    <span class="hljs-type">long</span> <span class="hljs-variable">targetTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();    <span class="hljs-type">int</span> <span class="hljs-variable">pass</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> <span class="hljs-variable">fail</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;        <span class="hljs-type">boolean</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> getResponse(targetTime, interval, atomicLong, maxNums, request);        <span class="hljs-keyword">if</span> (response) &#123;            pass++;        &#125; <span class="hljs-keyword">else</span> &#123;            fail++;        &#125;        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">200</span>) &#123;            Thread.sleep(<span class="hljs-number">1000</span>);        &#125;    &#125;    System.out.println(<span class="hljs-string">&quot;Pass: &quot;</span> + pass + <span class="hljs-string">&quot;  fail: &quot;</span> + fail);&#125;<span class="hljs-comment">/***</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> targetTime  请求时间</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> interval    间隔时间</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> atomicLong  计数器</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> maxNums     最大请求量</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> request     请求|模拟接口名</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 计数器算法 - 故名思意</span><span class="hljs-comment"> * 通过一段时间内对指定接口进行计数，判断是否超过最大限制</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">getResponse</span> <span class="hljs-params">(<span class="hljs-type">long</span> targetTime, <span class="hljs-type">long</span> interval, AtomicLong atomicLong, <span class="hljs-type">long</span> maxNums, String request)</span> &#123;    <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> System.currentTimeMillis();    <span class="hljs-keyword">if</span> (targetTime &lt;= now &amp;&amp; now &lt;= targetTime + interval) &#123;        <span class="hljs-type">long</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> atomicLong.getAndAdd(<span class="hljs-number">1</span>);        <span class="hljs-keyword">return</span> index &lt;= maxNums;    &#125; <span class="hljs-keyword">else</span> &#123;        atomicLong.set(<span class="hljs-number">0L</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</code></pre><blockquote><p>计数算法的实现和我们想当然的结果一致，比如 15s - 16s 这个区间，我们想当然的以某一次请求为起点，比如15s，则设置间隔为1秒，通过判断请求时间是否在 15 - 16 之间，如果在则累加，判断是否超过最大限制，不在则数据重置</p><p>但它存在的致命的问题即：</p><ol><li>无法归纳出下一次请求对上一次请求的时间变化  这点是不合理的</li><li>由于原因1的影响，用户很有可能在 15.59999的极限请求100次，在16.00001的极限请求100次</li></ol><p><img src="/2023/02/06/%E9%99%90%E6%B5%81%E7%AF%87/4f9b2b97db30494a5b2f0a1da9560451" alt="2016-09-01_20:35:21.jpg"></p><p>因此: 计数算法存在严重的临界值问题，原因是由于计数依据 -&gt; 时间导致的</p></blockquote><h2 id="滑动窗口（不常用）"><a href="#滑动窗口（不常用）" class="headerlink" title="滑动窗口（不常用）"></a>滑动窗口（不常用）</h2><p>滑动窗口的本质和计数一致，只不过通过把一个时间分区，即扩大精度，让请求数量的计算更加合理</p><p><img src="/2023/02/06/%E9%99%90%E6%B5%81%E7%AF%87/270324-20180926164034427-1114283823.jpg" alt="img"></p><blockquote><p>在上图中，整个红色的矩形框表示一个时间窗口，在我们的例子中，一个时间窗口就是一分钟。然后我们将时间窗口进行划分，比如图中，我们就将滑动窗口 划成了6格，所以每格代表的是10秒钟。每过10秒钟，我们的时间窗口就会往右滑动一格。每一个格子都有自己独立的计数器counter，比如当一个请求 在0:35秒的时候到达，那么0:30~0:39对应的counter就会加1。</p><p>那么滑动窗口怎么解决刚才的临界问题的呢？我们可以看上图，0:59到达的100个请求会落在灰色的格子中，而1:00到达的请求会落在橘黄色的格 子中。当时间到达1:00时，我们的窗口会往右移动一格，那么此时时间窗口内的总请求数量一共是200个，超过了限定的100个，所以此时能够检测出来触发了限流</p></blockquote><h2 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h2><p><img src="/2023/02/06/%E9%99%90%E6%B5%81%E7%AF%87/285763-20171204115253966-2047866938.png" alt="img"></p><blockquote><p>漏桶算法有<strong>两种</strong>实现:</p><p>一，<strong>不允许突发流量的情况</strong>，即以速率为标准是否进行限流</p><p>二,  <strong>允许突发流量的情况</strong>，即以容量为标准是否进行限流（<code>这样请求其实在等待，因此处理速率是定值，一般不采用</code>）</p><p>但无论啥哪种方式，漏水的速率是一定的，因此我们说 —》漏桶算法可以<strong>平滑网络上的突发流量</strong>（对于突发处理效率一般）</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">// 模拟的伪代码 -&gt; 允许突发流量</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LeakyBucket</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;        <span class="hljs-type">Integer</span> <span class="hljs-variable">pass</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-type">Integer</span> <span class="hljs-variable">fail</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-type">Bucket</span> <span class="hljs-variable">bucket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bucket</span>();        bucket.start();        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;            <span class="hljs-type">Integer</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> Bucket.current;            <span class="hljs-keyword">if</span> (num++ &lt; Bucket.maxValue) &#123;                Bucket.current++;                pass++;            &#125; <span class="hljs-keyword">else</span> &#123;                fail++;            &#125;            Thread.sleep(<span class="hljs-number">50</span>);        &#125;        System.out.println(<span class="hljs-string">&quot;Pass: &quot;</span> + pass + <span class="hljs-string">&quot; fail: &quot;</span> + fail);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bucket</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;        <span class="hljs-comment">// 容量</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">maxValue</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;        <span class="hljs-comment">// 速率 3次/s</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">rate</span>     <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;        <span class="hljs-comment">// 当前量</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">current</span>  <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    Thread.sleep(<span class="hljs-number">1000</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                <span class="hljs-keyword">if</span> (current &gt; <span class="hljs-number">0</span>) &#123;                    current = Math.max(<span class="hljs-number">0</span>, current -= rate);                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h2><p>和漏桶算法相反，令牌桶算法的本质是，有一个令牌的桶，以恒定的速率（变种算法也可以根据情况改变速率）往一个桶里面丢令牌，如果可以获取到令牌，则可执行，否则被限流等待</p><p><code>好处：可以很好的解决突发情况</code></p><p><img src="/2023/02/06/%E9%99%90%E6%B5%81%E7%AF%87/1570512804791.png" alt="1570512804791"></p><h2 id="轮子-Guava-RateLimiter"><a href="#轮子-Guava-RateLimiter" class="headerlink" title="轮子 -&gt; Guava RateLimiter"></a>轮子 -&gt; Guava RateLimiter</h2><pre><code class="hljs xml"> <span class="hljs-comment">&lt;!-- guava库 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>27.0.1-jre<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><pre><code class="hljs java"><span class="hljs-comment">// RateLimiter具有预消费的能力 -&gt; 即可以一次性拿走超过当前最大令牌的数量，但是下次等待时间会额外增加</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GuavaRateLimiter</span> &#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;                <span class="hljs-comment">// 线程池</span>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">exec</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();        <span class="hljs-comment">// 速率是每秒只有3个许可</span>        <span class="hljs-keyword">final</span> <span class="hljs-type">RateLimiter</span> <span class="hljs-variable">rateLimiter</span> <span class="hljs-operator">=</span> RateLimiter.create(<span class="hljs-number">3.0</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">no</span> <span class="hljs-operator">=</span> i;            <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> () -&gt; &#123;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-comment">//获取许可</span>                    rateLimiter.acquire();                    System.out.println(<span class="hljs-string">&quot;Accessing: &quot;</span> + no + <span class="hljs-string">&quot;,time:&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yy-MM-dd HH:mm:ss&quot;</span>).format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()));                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;;                        <span class="hljs-comment">//执行线程</span>            exec.execute(runnable);        &#125;                <span class="hljs-comment">//退出线程池</span>        exec.shutdown();    &#125;&#125;</code></pre><blockquote><p>根据令牌桶算法，桶中的令牌是持续生成存放的，有请求时需要先从桶中拿到令牌才能开始执行，谁来持续生成令牌存放呢？</p><p>一种解法是，开启一个定时任务，由定时任务持续生成令牌。这样的问题在于会极大的消耗系统资源，如，某接口需要分别对每个用户做访问频率限制，假设系统中存在6W用户，则至多需要开启6W个定时任务来维持每个桶中的令牌数，这样的开销是巨大的。</p><p>另一种解法则是延迟计算，其实现思路为，若当前时间晚于nextFreeTicketMicros，则计算该段时间内可以生成多少令牌，将生成的令牌加入令牌桶中并更新数据。这样一来，只需要在获取令牌时计算一次即可</p></blockquote><h2 id="分布式限流"><a href="#分布式限流" class="headerlink" title="分布式限流"></a>分布式限流</h2><blockquote><p>分布式环境下限流方案</p><p>如nginx 采取 hash ip策略，则用单机方式可以</p><p>如轮询策略，则可以借用第三方实现分布式限流，如 redis  -&gt; 基本思路即利用 lua 脚本，通过原子性的方式获取请求是否超过限制    lua脚本逻辑也很简单，即利用redis的 过期设置key-value</p></blockquote><pre><code class="hljs lua"><span class="hljs-comment">-- Demo: 下标从 1 开始</span><span class="hljs-keyword">local</span> key = KEYS[<span class="hljs-number">1</span>]<span class="hljs-keyword">local</span> now = <span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">1</span>])<span class="hljs-keyword">local</span> ttl = <span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">2</span>])<span class="hljs-keyword">local</span> expired = <span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">3</span>])<span class="hljs-comment">-- 最大访问量</span><span class="hljs-keyword">local</span> <span class="hljs-built_in">max</span> = <span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">4</span>])<span class="hljs-comment">-- 清除过期的数据</span><span class="hljs-comment">-- 移除指定分数区间内的所有元素，expired 即已经过期的 score</span><span class="hljs-comment">-- 根据当前时间毫秒数 - 超时毫秒数，得到过期时间 expired</span>redis.call(<span class="hljs-string">&#x27;zremrangebyscore&#x27;</span>, key, <span class="hljs-number">0</span>, expired)<span class="hljs-comment">-- 获取 zset 中的当前元素个数</span><span class="hljs-keyword">local</span> current = <span class="hljs-built_in">tonumber</span>(redis.call(<span class="hljs-string">&#x27;zcard&#x27;</span>, key))<span class="hljs-keyword">local</span> <span class="hljs-built_in">next</span> = current + <span class="hljs-number">1</span><span class="hljs-keyword">if</span> <span class="hljs-built_in">next</span> &gt; <span class="hljs-built_in">max</span> <span class="hljs-keyword">then</span>  <span class="hljs-comment">-- 达到限流大小 返回 0</span>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">else</span>  <span class="hljs-comment">-- 往 zset 中添加一个值、得分均为当前时间戳的元素，[value,score]</span>  redis.call(<span class="hljs-string">&quot;zadd&quot;</span>, key, now, now)  <span class="hljs-comment">-- 每次访问均重新设置 zset 的过期时间，单位毫秒</span>  redis.call(<span class="hljs-string">&quot;pexpire&quot;</span>, key, ttl)  <span class="hljs-keyword">return</span> <span class="hljs-built_in">next</span><span class="hljs-keyword">end</span></code></pre><pre><code class="hljs java"><span class="hljs-comment">// 调用方法Demo 仅仅举例而已 对应上述lua脚本</span><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldLimited</span><span class="hljs-params">(String key, <span class="hljs-type">long</span> max, <span class="hljs-type">long</span> timeout, TimeUnit timeUnit)</span> &#123;    <span class="hljs-comment">// 最终的 key 格式为：</span>    <span class="hljs-comment">// limit:自定义key:IP</span>    <span class="hljs-comment">// limit:类名.方法名:IP</span>    key = REDIS_LIMIT_KEY_PREFIX + key;    <span class="hljs-comment">// 统一使用单位毫秒</span>    <span class="hljs-type">long</span> <span class="hljs-variable">ttl</span> <span class="hljs-operator">=</span> timeUnit.toMillis(timeout);    <span class="hljs-comment">// 当前时间毫秒数</span>    <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> Instant.now().toEpochMilli();    <span class="hljs-type">long</span> <span class="hljs-variable">expired</span> <span class="hljs-operator">=</span> now - ttl;    <span class="hljs-comment">// 注意这里必须转为 String,否则会报错 java.lang.Long cannot be cast to java.lang.String</span>    <span class="hljs-type">Long</span> <span class="hljs-variable">executeTimes</span> <span class="hljs-operator">=</span> stringRedisTemplate.execute(limitRedisScript, Collections.singletonList(key), now + <span class="hljs-string">&quot;&quot;</span>, ttl + <span class="hljs-string">&quot;&quot;</span>, expired + <span class="hljs-string">&quot;&quot;</span>, max + <span class="hljs-string">&quot;&quot;</span>);    <span class="hljs-keyword">if</span> (executeTimes != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">if</span> (executeTimes == <span class="hljs-number">0</span>) &#123;            log.error(<span class="hljs-string">&quot;【&#123;&#125;】在单位时间 &#123;&#125; 毫秒内已达到访问上限，当前接口上限 &#123;&#125;&quot;</span>, key, ttl, max);            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            log.info(<span class="hljs-string">&quot;【&#123;&#125;】在单位时间 &#123;&#125; 毫秒内访问 &#123;&#125; 次&quot;</span>, key, ttl, executeTimes);            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><blockquote><p>在接口请求时候，我们可以用上述的算法控制限流，在代码层，如批量生成excel文件等业务中，为了避免同一时间文件产生过多导致IO，CPU飙增，也可以用限流的思路，通过JUC的信号量控制线程的数量，达到类似限流的目的</p></blockquote><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p>开源中国：<a href="https://segmentfault.com/a/1190000012875897">https://segmentfault.com/a/1190000012875897</a></p><p>简书：<a href="https://www.jianshu.com/p/5d4fe4b2a726">https://www.jianshu.com/p/5d4fe4b2a726</a></p><p>掘金：<a href="https://juejin.im/post/5d8036a3e51d4561ff6668c3">https://juejin.im/post/5d8036a3e51d4561ff6668c3</a></p><p>GitHub：限流Demo</p><ul><li><a href="https://github.com/xkcoding/spring-boot-demo?utm_source=gold_browser_extension">https://github.com/xkcoding/spring-boot-demo?utm_source=gold_browser_extension</a></li><li><a href="https://github.com/kkzhilu/KerwinBoots/tree/boot_ratelimit_guava">https://github.com/kkzhilu/KerwinBoots/tree/boot_ratelimit_guava</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>限流篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
