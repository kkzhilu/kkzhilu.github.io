<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>SpringBoot配置多数据源</title>
    <link href="/2023/09/12/SpringBoot%E9%85%8D%E7%BD%AE%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90/"/>
    <url>/2023/09/12/SpringBoot%E9%85%8D%E7%BD%AE%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot配置多数据源"><a href="#SpringBoot配置多数据源" class="headerlink" title="SpringBoot配置多数据源"></a>SpringBoot配置多数据源</h1><h2 id="核心技术点"><a href="#核心技术点" class="headerlink" title="核心技术点"></a>核心技术点</h2><p>​        在Spring 2.x 中引入了AbstractRoutingDataSource, 该类充当了<strong>DataSource的路由中介</strong>, 能有在<strong>运行时</strong>, 根据某种key值来<strong>动态切换</strong>到真正的DataSource上。</p><p>​        Spring动态配置多数据源，即在大型应用中对数据进行切分，并且采用多个数据库实例进行管理，这样可以有效提高系统的水平伸缩性。而这样的方案就会不同于常见的单一数据实例的方案，这就要程序在运行时根据当时的请求及系统状态来动态的决定将数据存储在哪个数据库实例中，以及从哪个数据库提取数据。</p><p>​        Spring2.x的版本中采用Proxy模式，就是我们在方案中实现一个虚拟的数据源，并且用它来<strong>封装数据源选择逻辑</strong>，这样就可以有效地将数据源选择逻辑从Client中分离出来。Client<strong>提供选择所需的上下文</strong>（因为这是Client所知道的），由虚拟的DataSource根据Client提供的上下文来实现数据源的选择。 </p><pre><code class="hljs 具体的实现如下```">&#96;&#96;&#96;javapublic class DynamicRoutingDataSource extends AbstractRoutingDataSource &#123;    @Override    protected Object determineCurrentLookupKey() &#123;        &#x2F;&#x2F; TODO        &#x2F;&#x2F; 重写 determineCurrentLookupKey 方法    &#125;&#125;</code></pre><p>原理:</p><pre><code class="hljs java"><span class="hljs-comment">// AbstractRoutingDataSource 类</span><span class="hljs-function"><span class="hljs-keyword">protected</span> DataSource <span class="hljs-title">determineTargetDataSource</span><span class="hljs-params">()</span> </span>&#123;Assert.notNull(<span class="hljs-keyword">this</span>.resolvedDataSources, <span class="hljs-string">"DataSource router not initialized"</span>);Object lookupKey = determineCurrentLookupKey();DataSource dataSource = <span class="hljs-keyword">this</span>.resolvedDataSources.get(lookupKey);<span class="hljs-keyword">if</span> (dataSource == <span class="hljs-keyword">null</span> &amp;&amp; (<span class="hljs-keyword">this</span>.lenientFallback || lookupKey == <span class="hljs-keyword">null</span>)) &#123;dataSource = <span class="hljs-keyword">this</span>.resolvedDefaultDataSource;&#125;<span class="hljs-keyword">if</span> (dataSource == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Cannot determine target DataSource for lookup key ["</span> + lookupKey + <span class="hljs-string">"]"</span>);&#125;<span class="hljs-keyword">return</span> dataSource;&#125;</code></pre><p>因此分析到，如果lookupKey 为null则会走默认配置，如果没有所谓的默认配置则会报错，如果指定了数据源，则会加载指定的配置数据源</p><h2 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h2><h3 id="去除默认数据源"><a href="#去除默认数据源" class="headerlink" title="去除默认数据源"></a>去除默认数据源</h3><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 1.配置数据库事务</span><span class="hljs-comment"> * 2.去除JDBC 自动配置数据源</span><span class="hljs-comment"> */</span><span class="hljs-meta">@EnableTransactionManagement</span><span class="hljs-meta">@SpringBootApplication</span>(exclude = DataSourceAutoConfiguration<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">KerwinBootsApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(KerwinBootsApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><h3 id="多数据源配置"><a href="#多数据源配置" class="headerlink" title="多数据源配置"></a>多数据源配置</h3><pre><code class="hljs java"><span class="hljs-comment">// 多数据源配置</span># select 库spring.datasource.select.jdbc-url=jdbc:mysql:<span class="hljs-comment">//127.0.0.1:3306/test1</span>spring.datasource.select.driverClassName=com.mysql.jdbc.Driverspring.datasource.select.username=rootspring.datasource.select.password=# update 库spring.datasource.update.jdbc-url=jdbc:mysql:<span class="hljs-comment">//127.0.0.1:3306/test2</span>spring.datasource.update.driverClassName=com.mysql.jdbc.Driverspring.datasource.update.username=rootspring.datasource.update.password=</code></pre><h3 id="配置数据源Bean"><a href="#配置数据源Bean" class="headerlink" title="配置数据源Bean"></a>配置数据源Bean</h3><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataSourceConfig</span> </span>&#123;    <span class="hljs-comment">// application.properteis中对应属性的前缀</span>    <span class="hljs-meta">@Bean</span>(name = <span class="hljs-string">"selectDataSource"</span>)    <span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"spring.datasource.select"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">selectDataSource</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> DataSourceBuilder.create().build();    &#125;    <span class="hljs-meta">@Bean</span>(name = <span class="hljs-string">"updateDataSource"</span>)    <span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"spring.datasource.update"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">updateDataSource</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> DataSourceBuilder.create().build();    &#125;&#125;</code></pre><h3 id="构造线程数据源持有者"><a href="#构造线程数据源持有者" class="headerlink" title="构造线程数据源持有者"></a>构造线程数据源持有者</h3><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataSourceContextHolder</span> </span>&#123;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * ThreadLocal提供了线程内存储变量的能力，这些变量不同之处在于每一个线程读取的变量是对应的互相独立的</span><span class="hljs-comment">     * 通过get和set方法就可以得到当前线程对应的值</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;String&gt; CONTEXT_HOLDER = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDbType</span><span class="hljs-params">(String dbType)</span> </span>&#123;        CONTEXT_HOLDER.set(dbType);    &#125;    <span class="hljs-function"><span class="hljs-keyword">static</span> String <span class="hljs-title">getDbType</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> CONTEXT_HOLDER.get();    &#125;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123; CONTEXT_HOLDER.remove();&#125;&#125;</code></pre><h3 id="复写路由方法"><a href="#复写路由方法" class="headerlink" title="复写路由方法"></a>复写路由方法</h3><pre><code class="hljs java"><span class="hljs-comment">// 名字(dataSource)  Primary  Priority</span><span class="hljs-meta">@Component</span><span class="hljs-meta">@Primary</span> <span class="hljs-comment">// 多个DataSource Bean 因此@Primary 将作为首选者</span>         <span class="hljs-comment">// @Priority 优先级</span>         <span class="hljs-comment">// 多个按类型的dataSource 为了让它找到bean可以给当前bean修改 名称 -&gt; @Component(value = "dataSource")</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DynamicRoutingDataSource</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractRoutingDataSource</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Logger logger = LoggerFactory.getLogger(DynamicRoutingDataSource<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-meta">@Qualifier</span>(<span class="hljs-string">"selectDataSource"</span>)    <span class="hljs-keyword">private</span> DataSource selectDataSource;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-meta">@Qualifier</span>(<span class="hljs-string">"updateDataSource"</span>)    <span class="hljs-keyword">private</span> DataSource updateDataSource;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">determineCurrentLookupKey</span><span class="hljs-params">()</span> </span>&#123;        logger.info(<span class="hljs-string">"切换数据源: "</span> + DataSourceContextHolder.getDbType());        <span class="hljs-keyword">return</span> DataSourceContextHolder.getDbType();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 重写after配置方法, 配置默认数据源</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> </span>&#123;        Map&lt;Object,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        map.put(<span class="hljs-string">"selectDataSource"</span>, selectDataSource);        map.put(<span class="hljs-string">"updateDataSource"</span>, updateDataSource);        setTargetDataSources(map);        setDefaultTargetDataSource(updateDataSource);        <span class="hljs-keyword">super</span>.afterPropertiesSet();    &#125;&#125;</code></pre><h3 id="考虑自动切换数据源方案-AOP-（注解或依据方法名）"><a href="#考虑自动切换数据源方案-AOP-（注解或依据方法名）" class="headerlink" title="考虑自动切换数据源方案 - AOP （注解或依据方法名）"></a>考虑自动切换数据源方案 - AOP （注解或依据方法名）</h3><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><span class="hljs-meta">@Component</span><span class="hljs-meta">@Order</span>(<span class="hljs-number">0</span>) <span class="hljs-comment">// Order设定AOP执行顺序 使之在数据库事务上先执行</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DynamicDataSourceAspect</span> </span>&#123;    <span class="hljs-meta">@Before</span>(<span class="hljs-string">"execution(* com.boot.service.*.*(..))"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processMethodName</span> <span class="hljs-params">(JoinPoint joinPoint)</span> </span>&#123;        String methodName=joinPoint.getSignature().getName();        <span class="hljs-keyword">if</span> (methodName.startsWith(<span class="hljs-string">"get"</span>)                ||methodName.startsWith(<span class="hljs-string">"count"</span>)                ||methodName.startsWith(<span class="hljs-string">"find"</span>)                ||methodName.startsWith(<span class="hljs-string">"list"</span>)                ||methodName.startsWith(<span class="hljs-string">"select"</span>)                ||methodName.startsWith(<span class="hljs-string">"check"</span>))&#123;            DataSourceContextHolder.setDbType(<span class="hljs-string">"selectDataSource"</span>);        &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//切换dataSource</span>            DataSourceContextHolder.setDbType(<span class="hljs-string">"updateDataSource"</span>);        &#125;    &#125;<span class="hljs-comment">//    @Before("execution(* com.boot.service.*.*(..))")</span><span class="hljs-comment">//    public void process(JoinPoint point) &#123;</span><span class="hljs-comment">//</span><span class="hljs-comment">//        //获得当前访问的class</span><span class="hljs-comment">//        Class&lt;?&gt; className = point.getTarget().getClass();</span><span class="hljs-comment">//</span><span class="hljs-comment">//        //获得访问的方法名</span><span class="hljs-comment">//        String methodName = point.getSignature().getName();</span><span class="hljs-comment">//</span><span class="hljs-comment">//        //得到方法的参数的类型</span><span class="hljs-comment">//        Class[] argClass = ((MethodSignature)point.getSignature()).getParameterTypes();</span><span class="hljs-comment">//</span><span class="hljs-comment">//        try &#123;</span><span class="hljs-comment">//            // 得到访问的方法对象</span><span class="hljs-comment">//            Method method = className.getMethod(methodName, argClass);</span><span class="hljs-comment">//</span><span class="hljs-comment">//            // 判断是否存在@DS注解</span><span class="hljs-comment">//            if (method.isAnnotationPresent(DS.class)) &#123;</span><span class="hljs-comment">//                DS annotation = method.getAnnotation(DS.class);</span><span class="hljs-comment">//</span><span class="hljs-comment">//                // 取出注解中的数据源名</span><span class="hljs-comment">//                String dataSource = annotation.value();</span><span class="hljs-comment">//</span><span class="hljs-comment">//                // 切换数据源</span><span class="hljs-comment">//                DataSourceContextHolder.setDbType(dataSource);</span><span class="hljs-comment">//            &#125;</span><span class="hljs-comment">//        &#125; catch (Exception e) &#123;</span><span class="hljs-comment">//            e.printStackTrace();</span><span class="hljs-comment">//            System.out.println("error.");</span><span class="hljs-comment">//        &#125;</span><span class="hljs-comment">//    &#125;</span>    <span class="hljs-meta">@After</span>(<span class="hljs-string">"execution(* com.boot.service.*.*(..))"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterswitchDs</span> <span class="hljs-params">(JoinPoint point)</span></span>&#123;        DataSourceContextHolder.clear();    &#125;&#125;</code></pre><h2 id="遗留技术点"><a href="#遗留技术点" class="headerlink" title="遗留技术点"></a>遗留技术点</h2><h3 id="ThreadLocal-的作用，DataSourceContextHolder类的意义何在"><a href="#ThreadLocal-的作用，DataSourceContextHolder类的意义何在" class="headerlink" title="ThreadLocal 的作用，DataSourceContextHolder类的意义何在"></a>ThreadLocal 的作用，DataSourceContextHolder类的意义何在</h3><p>作用：建立一个获得和设置上下文环境的类，主要负责改变上下文数据源的名称</p><p>原因：ThreadLocal 与 Synchronized 作用不同 -》</p><p>Synchronized  -&gt; 保证多线程情况下变量一致性（数据共享）</p><p>ThreadLocal    -&gt; 保证多线程情况下变量私有性（数据隔离）</p><p>即每个线程的变量只对自己本线程负责 （不会存在A线程改了影响B的情况，要的就是数据隔离）</p><p>官方解释:</p><pre><code class="hljs oxygene">This <span class="hljs-keyword">class</span> provides thread-local variables. These variables differ <span class="hljs-keyword">from</span> their normal counterparts <span class="hljs-keyword">in</span> that <span class="hljs-keyword">each</span> thread that accesses one (via its <span class="hljs-comment">&#123;@code get&#125;</span> <span class="hljs-keyword">or</span> <span class="hljs-comment">&#123;@code set&#125;</span> <span class="hljs-function"><span class="hljs-keyword">method</span>) <span class="hljs-title">has</span> <span class="hljs-title">its</span> <span class="hljs-title">own</span>, <span class="hljs-title">independently</span> <span class="hljs-title">initialized</span> <span class="hljs-title">copy</span> <span class="hljs-title">of</span> <span class="hljs-title">the</span> <span class="hljs-title">variable</span>. <span class="hljs-comment">&#123;@code ThreadLocal&#125;</span> <span class="hljs-title">instances</span> <span class="hljs-title">are</span> <span class="hljs-title">typically</span> <span class="hljs-title">private</span> <span class="hljs-title">static</span> <span class="hljs-title">fields</span> <span class="hljs-title">in</span> <span class="hljs-title">classes</span> <span class="hljs-title">that</span> <span class="hljs-title">wish</span> <span class="hljs-title">to</span> <span class="hljs-title">associate</span> <span class="hljs-title">state</span> <span class="hljs-title">with</span> <span class="hljs-title">a</span> <span class="hljs-title">thread</span> <span class="hljs-params">(e.g., a user ID <span class="hljs-keyword">or</span> Transaction ID)</span>.</span></code></pre><p>总结:</p><blockquote><p>总结一下重点：</p><ul><li>ThreadLocal 提供了一种访问某个变量的特殊方式：访问到的变量属于当前线程，即保证每个线程的变量不一样，而同一个线程在任何地方拿到的变量都是当前这个线程私有的，这就是所谓的线程隔离。</li><li>如果要使用 ThreadLocal，通常定义为 private static 类型，最好是定义为 private static final 类型。</li></ul></blockquote><h3 id="2-为什么重写了-determineCurrentLookupKey-方法，SpringBoot真正在执行的时候就会调用我们重写的类呢？"><a href="#2-为什么重写了-determineCurrentLookupKey-方法，SpringBoot真正在执行的时候就会调用我们重写的类呢？" class="headerlink" title="2.为什么重写了 determineCurrentLookupKey 方法，SpringBoot真正在执行的时候就会调用我们重写的类呢？"></a>2.为什么重写了 determineCurrentLookupKey 方法，SpringBoot真正在执行的时候就会调用我们重写的类呢？</h3><pre><code class="hljs java"><span class="hljs-comment">// 多数据源方案二代码...核心如下： 此种方案有显示的放入事务数据源中</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * 配置<span class="hljs-doctag">@Transactional</span>注解</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> PlatformTransactionManager <span class="hljs-title">transactionManager</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DataSourceTransactionManager(dynamicDataSource());&#125;</code></pre><p>回顾方案一，跟踪断点发现如下代码:</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ConditionalOnClass</span>(&#123; DataSource<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">JdbcTemplate</span>.<span class="hljs-title">class</span> &#125;)</span><span class="hljs-class">@<span class="hljs-title">ConditionalOnSingleCandidate</span>(<span class="hljs-title">DataSource</span>.<span class="hljs-title">class</span>)</span><span class="hljs-class">@<span class="hljs-title">AutoConfigureAfter</span>(<span class="hljs-title">DataSourceAutoConfiguration</span>.<span class="hljs-title">class</span>)</span><span class="hljs-class">@<span class="hljs-title">EnableConfigurationProperties</span>(<span class="hljs-title">JdbcProperties</span>.<span class="hljs-title">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">JdbcTemplateAutoConfiguration</span> </span>&#123;<span class="hljs-meta">@Configuration</span><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcTemplateConfiguration</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DataSource dataSource;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> JdbcProperties properties;JdbcTemplateConfiguration(DataSource dataSource, JdbcProperties properties) &#123;<span class="hljs-keyword">this</span>.dataSource = dataSource;<span class="hljs-keyword">this</span>.properties = properties;&#125;<span class="hljs-meta">@Bean</span><span class="hljs-meta">@Primary</span><span class="hljs-meta">@ConditionalOnMissingBean</span>(JdbcOperations<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">JdbcTemplate</span> <span class="hljs-title">jdbcTemplate</span>() </span>&#123;JdbcTemplate jdbcTemplate = <span class="hljs-keyword">new</span> JdbcTemplate(<span class="hljs-keyword">this</span>.dataSource);JdbcProperties.Template template = <span class="hljs-keyword">this</span>.properties.getTemplate();jdbcTemplate.setFetchSize(template.getFetchSize());jdbcTemplate.setMaxRows(template.getMaxRows());<span class="hljs-keyword">if</span> (template.getQueryTimeout() != <span class="hljs-keyword">null</span>) &#123;jdbcTemplate.setQueryTimeout((<span class="hljs-keyword">int</span>) template.getQueryTimeout().getSeconds());&#125;<span class="hljs-keyword">return</span> jdbcTemplate;&#125;&#125;<span class="hljs-meta">@Configuration</span><span class="hljs-meta">@Import</span>(JdbcTemplateConfiguration<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">static</span> <span class="hljs-title">class</span> <span class="hljs-title">NamedParameterJdbcTemplateConfiguration</span> </span>&#123;<span class="hljs-meta">@Bean</span><span class="hljs-meta">@Primary</span><span class="hljs-meta">@ConditionalOnSingleCandidate</span>(JdbcTemplate<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">ConditionalOnMissingBean</span>(<span class="hljs-title">NamedParameterJdbcOperations</span>.<span class="hljs-title">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">NamedParameterJdbcTemplate</span> <span class="hljs-title">namedParameterJdbcTemplate</span>(<span class="hljs-title">JdbcTemplate</span> <span class="hljs-title">jdbcTemplate</span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NamedParameterJdbcTemplate(jdbcTemplate);&#125;&#125;&#125;<span class="hljs-comment">//*********************************************</span><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ConditionalOnClass</span>(&#123; JdbcTemplate<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">PlatformTransactionManager</span>.<span class="hljs-title">class</span> &#125;)</span><span class="hljs-class">@<span class="hljs-title">AutoConfigureOrder</span>(<span class="hljs-title">Ordered</span>.<span class="hljs-title">LOWEST_PRECEDENCE</span>)</span><span class="hljs-class">@<span class="hljs-title">EnableConfigurationProperties</span>(<span class="hljs-title">DataSourceProperties</span>.<span class="hljs-title">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">DataSourceTransactionManagerAutoConfiguration</span> </span>&#123;<span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ConditionalOnSingleCandidate</span>(DataSource<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">static</span> <span class="hljs-title">class</span> <span class="hljs-title">DataSourceTransactionManagerConfiguration</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DataSource dataSource;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TransactionManagerCustomizers transactionManagerCustomizers;DataSourceTransactionManagerConfiguration(DataSource dataSource,ObjectProvider&lt;TransactionManagerCustomizers&gt; transactionManagerCustomizers) &#123;<span class="hljs-keyword">this</span>.dataSource = dataSource;<span class="hljs-keyword">this</span>.transactionManagerCustomizers = transactionManagerCustomizers.getIfAvailable();&#125;<span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span>(PlatformTransactionManager<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">DataSourceTransactionManager</span> <span class="hljs-title">transactionManager</span>(<span class="hljs-title">DataSourceProperties</span> <span class="hljs-title">properties</span>) </span>&#123;DataSourceTransactionManager transactionManager = <span class="hljs-keyword">new</span> DataSourceTransactionManager(<span class="hljs-keyword">this</span>.dataSource);<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.transactionManagerCustomizers != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">this</span>.transactionManagerCustomizers.customize(transactionManager);&#125;<span class="hljs-keyword">return</span> transactionManager;&#125;&#125;&#125;</code></pre><p>我们发现SpringBoot，当注入了唯一DataSource Bean之后，会调用我们创建的指定数据源，将其放入boot核心代码中，之后事务数据源，JDBC数据源都会引用我们注入的Bean，因此我们重写之后，注入完成，SpringBoot真正在执行的时候就会调用我们重写的类</p><h3 id="3-为什么要使用-Primary-注解，有没有其他的方案"><a href="#3-为什么要使用-Primary-注解，有没有其他的方案" class="headerlink" title="3.为什么要使用@Primary 注解，有没有其他的方案"></a>3.为什么要使用@Primary 注解，有没有其他的方案</h3><p>DataSource Bean 需要被初始化，作为数据库连接所使用，但是在类 DataSourceConfig 中，有两个bean都是DataSource，且 DynamicRoutingDataSource的本质也是一个 DataSource</p><p>因此 Spring容器在真正调用DataSource时，会通过类型找到此Bean，但是由于有三个同类型的Bean，因此无法确定，所以又会按名称查找，但是还是找不到，所以如果无法确定到底哪个Bean 被用作数据源连接，则会抛出异常</p><p>解决方案有三种</p><pre><code class="hljs java"><span class="hljs-comment">// 多个DataSource Bean 因此@Primary 将作为首选者</span><span class="hljs-comment">// @Priority 优先级</span><span class="hljs-comment">// 多个按类型的dataSource 为了让它找到bean可以给当前bean修改 名称 -&gt; @Component(value = "dataSource")</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>框架篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot配置多数据源</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>菜鸟变大鸟的感悟</title>
    <link href="/2023/09/12/%E8%8F%9C%E9%B8%9F%E5%8F%98%E5%A4%A7%E9%B8%9F%E7%9A%84%E6%84%9F%E6%82%9F/"/>
    <url>/2023/09/12/%E8%8F%9C%E9%B8%9F%E5%8F%98%E5%A4%A7%E9%B8%9F%E7%9A%84%E6%84%9F%E6%82%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="菜鸟变大鸟的感悟"><a href="#菜鸟变大鸟的感悟" class="headerlink" title="菜鸟变大鸟的感悟"></a>菜鸟变大鸟的感悟</h1><blockquote><p>作者: 程顺鹏</p></blockquote><p>我们当初更多放在了技术的运用上了，这些技术虽然在我们工作后并没有用上多少，但是为我们的简历增加了一份亮点，也扩大了我们的视野。想想当初写个bean转化json，费了劲还不好用，后来才知道有现成的这种工具，这就是视野小了啊。当自己能运用的技术逐渐变多时，解决问题的方案也会更多，也更优秀。一些原理层次的知识虽然不能直接产生价值，却在潜移默化地影响着自己的工作。试想一下如果你对一些原理了如指掌的话，出了什么问题，你能从源码的角度迅速定位问题；而如果你不懂原理，出了问题你只会复制堆栈搜索，搜索结果的好坏决定了你的问题解决速度。不懂算法的人不会考虑量大的情况下对程序性能的影响，懂算法的人会从机器的角度去写代码，考虑机器哪些地方做了冗余的事情，从而优化效率。设计模式同样如此，不懂的人只会写机器懂的代码，懂的人能写人能懂的代码。这些“造火箭”的事大部分对工作没有直接作用，甚至不会“造火箭”的人也能做，但是能“造火箭”人的工作质量更高。这也成为了高级工程师的必备素质</p>]]></content>
    
    
    <categories>
      
      <category>程序人生篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>菜鸟变大鸟的感悟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux常用命令</title>
    <link href="/2023/09/12/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2023/09/12/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-常用命令"><a href="#Linux-常用命令" class="headerlink" title="Linux 常用命令"></a>Linux 常用命令</h1><h2 id="Nginx相关命令"><a href="#Nginx相关命令" class="headerlink" title="Nginx相关命令"></a>Nginx相关命令</h2><h3 id="本机Mac"><a href="#本机Mac" class="headerlink" title="本机Mac"></a>本机Mac</h3><pre><code class="hljs bash"><span class="hljs-comment"># 判断配置文件是否有问题</span>sudo nginx -t <span class="hljs-comment"># 修改配置后重新加载生效</span>sudo nginx -s  reload<span class="hljs-comment"># 启动</span>sudo nginx<span class="hljs-comment"># 快速停止nginx</span>sudo nginx -s stop  <span class="hljs-comment"># 完整有序的停止nginx/优雅关闭（先服务完已打开的连接）</span>sudo nginx -s quit</code></pre><h2 id="Mac-Brew管理服务"><a href="#Mac-Brew管理服务" class="headerlink" title="Mac Brew管理服务"></a>Mac Brew管理服务</h2><pre><code class="hljs bash">brew services list           <span class="hljs-comment"># 查看现有服务状态</span>brew services start [xxx]    <span class="hljs-comment"># 启动服务，并注册开机自启</span>brew services stop [xxx]     <span class="hljs-comment"># 停止服务，并取消开机自启</span>brew services restart [xxx]  <span class="hljs-comment"># 重启服务，并注册开机自启</span>brew services run [xxx]      <span class="hljs-comment"># 启动服务</span>brew services cleanup        <span class="hljs-comment"># 清除已卸载应用的无用配置</span></code></pre><h2 id="字体安装"><a href="#字体安装" class="headerlink" title="字体安装"></a>字体安装</h2><h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><p>Ubuntu如果需要安装其他字体，参考步骤：</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 安装字体管理工具</span>sudo apt-get install font-manager<span class="hljs-meta">#</span><span class="bash"> 查看现有字体（可查看到字体安装位置）</span>fc-list</code></pre><p>安装字体：</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 安装字体</span><span class="hljs-meta">#</span><span class="bash"> 方式一：</span><span class="hljs-meta">#</span><span class="bash"> 在/usr/share/fonts目录下，新建如 chinese文件夹，将需要的tff文件复制进文件夹，如微软雅黑等</span><span class="hljs-meta">#</span><span class="bash"> 然后执行如下命令：</span>mkfontscalemkfontdirfc-cache -fv （刷新字体缓存）<span class="hljs-meta">#</span><span class="bash"> 方式二，通过软件安装：</span>sudo apt-get install ttf-wqy-microhei   #文泉驿-微米黑sudo apt-get install ttf-wqy-zenhei     #文泉驿-正黑 （全平台兼容字体）sudo apt-get install xfonts-wqy         #文泉驿-点阵宋体<span class="hljs-meta">#</span><span class="bash"> 注意通过软件安装的方式，其实也是在/usr/share/fonts目录下新建了文件夹并移入了tff字体，因此卸载逻辑和下面一致</span></code></pre><p>卸载字体：</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 卸载字体的方式非常简单，例如我们新建了chinese目录，只需要 rm -rf ....chinese（包含字体的目录）</span><span class="hljs-meta">#</span><span class="bash"> 再刷新字体缓存即可</span>rm -rf /usr/share/fonts/demofc-cache -fv</code></pre><h3 id="Ubuntu全平台兼容字体"><a href="#Ubuntu全平台兼容字体" class="headerlink" title="Ubuntu全平台兼容字体"></a>Ubuntu全平台兼容字体</h3><pre><code class="hljs shell">sudo apt-get install ttf-wqy-zenhei     #文泉驿-正黑 （全平台兼容字体）</code></pre><h2 id="建立软链接"><a href="#建立软链接" class="headerlink" title="建立软链接"></a>建立软链接</h2><pre><code class="hljs sh">ln -s /<span class="hljs-built_in">export</span>  /Users/kexianming1/Desktop/<span class="hljs-built_in">local</span>/<span class="hljs-built_in">export</span></code></pre><h2 id="设置文件夹可读可写"><a href="#设置文件夹可读可写" class="headerlink" title="设置文件夹可读可写"></a>设置文件夹可读可写</h2><pre><code class="hljs sh">sudo chmod -R 777 /目录地址</code></pre>]]></content>
    
    
    <categories>
      
      <category>操作系统篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux常用命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac</title>
    <link href="/2023/09/12/Mac/"/>
    <url>/2023/09/12/Mac/</url>
    
    <content type="html"><![CDATA[<h2 id="软连接"><a href="#软连接" class="headerlink" title="软连接"></a>软连接</h2><p>Mac 或者 Linux 中可以通过软连接的方式做一些操作，类比：Windows中的快捷方式</p><p>通过命令的方式用Sublime打开文件</p><pre><code class="hljs shell">open -a Sublime\ Text files/demo.html</code></pre><p>另外， sublime 提供命令行的工具叫subs，路径位于</p><pre><code class="hljs bash">/Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl</code></pre><p>构建软链接</p><pre><code class="hljs shell">ln  /Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl /usr/local/bin/subl</code></pre><p>PS：切换到 /usr/local/bin 目录发现，brew 所安装的软件也自动建立了软连接，所以可以直接 sudo nginx</p><p>同样，IDEA，PyCharm也自动设置了，通过上述设置即可实现 subl [文件] 的方式快速打开文件进行编辑</p><h2 id="Mac升级Catalina，根目录下无法创建个人文件夹"><a href="#Mac升级Catalina，根目录下无法创建个人文件夹" class="headerlink" title="Mac升级Catalina，根目录下无法创建个人文件夹"></a>Mac升级Catalina，根目录下无法创建个人文件夹</h2><blockquote><p>关闭系统完整性保护，在系统恢复模式下创建自己的文件夹，然后再打开完整性保护机制。</p></blockquote><ul><li>首先重启电脑按cmd+R进入恢复模式</li><li>关闭SIP(命令: csrutil disable )，之后正常重启</li><li>重新挂载根目录 (命令: sudo mount -uw /)，在你喜欢的地方建立data目录, 比如 mkdir /Users/tal/data, 然后建立软连接sudo ln -s /Users/tal/data /data</li><li>重新进入恢复模式，重新打开SIP(命令: csrutil enable)</li></ul><h2 id="Mac-TouchBar异常的解决方案"><a href="#Mac-TouchBar异常的解决方案" class="headerlink" title="Mac TouchBar异常的解决方案"></a>Mac TouchBar异常的解决方案</h2><pre><code class="hljs bash"><span class="hljs-comment"># 执行命令杀死TouchBar程序即可，程序会自动重启</span>sudo pkill TouchBarServer;</code></pre><h2 id="Mac-声音异常的解决方案"><a href="#Mac-声音异常的解决方案" class="headerlink" title="Mac 声音异常的解决方案"></a>Mac 声音异常的解决方案</h2><pre><code class="hljs bash">sudo killall coreaudiod</code></pre><h2 id="Mac-调整启动台菜单大小"><a href="#Mac-调整启动台菜单大小" class="headerlink" title="Mac 调整启动台菜单大小"></a>Mac 调整启动台菜单大小</h2><pre><code class="hljs pgsql">defaults <span class="hljs-keyword">write</span> com.apple.dock springboard-<span class="hljs-keyword">rows</span> -<span class="hljs-type">int</span> <span class="hljs-number">8</span>defaults <span class="hljs-keyword">write</span> com.apple.dock springboard-<span class="hljs-keyword">columns</span> -<span class="hljs-type">int</span> <span class="hljs-number">8</span>killall Dock</code></pre>]]></content>
    
    
    <categories>
      
      <category>设备篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mac</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac环境搭建</title>
    <link href="/2023/09/12/Mac%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2023/09/12/Mac%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="配置篇"><a href="#配置篇" class="headerlink" title="配置篇"></a>配置篇</h2><h3 id="长按删除"><a href="#长按删除" class="headerlink" title="长按删除"></a>长按删除</h3><p>系统偏好设置 - 键盘 - 将【按键重复】及【重复前延迟】设置到最高即可</p><h3 id="Windows-键盘映射"><a href="#Windows-键盘映射" class="headerlink" title="Windows 键盘映射"></a>Windows 键盘映射</h3><p>系统偏好设置 - 键盘 - 修饰 - 调整映射为：</p><p>Option - <code>Command</code></p><p>Command - <code>Option</code></p><h3 id="默认浏览器"><a href="#默认浏览器" class="headerlink" title="默认浏览器"></a>默认浏览器</h3><p>系统偏好设置 - 通用 - 默认网页浏览器</p><h3 id="鼠标滚轮方向"><a href="#鼠标滚轮方向" class="headerlink" title="鼠标滚轮方向"></a>鼠标滚轮方向</h3><p>系统偏好设置 - 鼠标 - 滚动方向</p><h3 id="启动台大小"><a href="#启动台大小" class="headerlink" title="启动台大小"></a>启动台大小</h3><pre><code class="hljs sh">defaults write com.apple.dock springboard-rows -int 8defaults write com.apple.dock springboard-columns -int 8killall Dock</code></pre><h3 id="分辨率调整"><a href="#分辨率调整" class="headerlink" title="分辨率调整"></a>分辨率调整</h3><p>在Mac外接显示器上调整分辨率时，如果想要打开更多的缩放选项，可以按照以下步骤进行操作：</p><ol><li>连接外接显示器并打开“系统偏好设置”。</li><li>点击“显示器”选项。</li><li>按住“Option”键，然后点击“缩放”选项。</li><li>这将会展示更多的缩放选项，包括使用额外像素高保真度（HiDPI）模式的选项。</li><li>选择适合您的屏幕的缩放比例，并关闭“系统偏好设置”。</li></ol><h2 id="软件篇"><a href="#软件篇" class="headerlink" title="软件篇"></a>软件篇</h2><blockquote><p>前置：MAC应用无法打开或提示“来自身份不明开发者”</p><p>解决方案：<a href="https://blog.csdn.net/qq_40519226/article/details/122333309" target="_blank" rel="noopener">https://blog.csdn.net/qq_40519226/article/details/122333309</a></p></blockquote><h3 id="Google浏览器"><a href="#Google浏览器" class="headerlink" title="Google浏览器"></a>Google浏览器</h3><p>官方下载，登录即可</p><h3 id="搜狗输入法"><a href="#搜狗输入法" class="headerlink" title="搜狗输入法"></a>搜狗输入法</h3><p>官网下载安装即可，调整一些不需要的配置</p><h3 id="Easy-New-File"><a href="#Easy-New-File" class="headerlink" title="Easy New File"></a>Easy New File</h3><p>下载地址：<a href="https://xclient.info/s/easy-new-file.html" target="_blank" rel="noopener">https://xclient.info/s/easy-new-file.html</a></p><p>安装后打开软件，点击最下方打开系统设置，配置 <code>添加扩展</code> 即可</p><h3 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h3><p>安装地址：<a href="https://masuit.com/2112?kw=typora&amp;t=vlizrt2c9a80" target="_blank" rel="noopener">https://masuit.com/2112?kw=typora&amp;t=vlizrt2c9a80</a></p><p>CSS样式：设备篇/Typora-CSS/kerwin-css.css</p><h3 id="GitHub-Desktop"><a href="#GitHub-Desktop" class="headerlink" title="GitHub Desktop"></a>GitHub Desktop</h3><p>下载地址：官网直接下载即可</p><h3 id="Obsidian"><a href="#Obsidian" class="headerlink" title="Obsidian"></a>Obsidian</h3><p>下载地址：官网下载即可</p><p>配合GitHub知识库，打开项目，调整中文即可</p><h3 id="滴答清单"><a href="#滴答清单" class="headerlink" title="滴答清单"></a>滴答清单</h3><p>官网下载，登录即可</p><h3 id="TinyCal"><a href="#TinyCal" class="headerlink" title="TinyCal"></a>TinyCal</h3><p>安装地址：<a href="https://xclient.info/s/tinycal.html#versions" target="_blank" rel="noopener">https://xclient.info/s/tinycal.html#versions</a></p><h3 id="网易云音乐"><a href="#网易云音乐" class="headerlink" title="网易云音乐"></a>网易云音乐</h3><p>官网下载即可</p><h3 id="SwitchHost"><a href="#SwitchHost" class="headerlink" title="SwitchHost"></a>SwitchHost</h3><p>官网下载即可</p><h3 id="PostMan"><a href="#PostMan" class="headerlink" title="PostMan"></a>PostMan</h3><p>下载地址：<a href="https://www.postman.com/downloads/" target="_blank" rel="noopener">https://www.postman.com/downloads/</a></p><p>Google登录即可</p><h3 id="Microsoft-全家桶（OutLook邮箱）"><a href="#Microsoft-全家桶（OutLook邮箱）" class="headerlink" title="Microsoft 全家桶（OutLook邮箱）"></a>Microsoft 全家桶（OutLook邮箱）</h3><p>安装破解链接：<a href="http://www.itmind.net/17271.html" target="_blank" rel="noopener">http://www.itmind.net/17271.html</a></p><h3 id="WPS"><a href="#WPS" class="headerlink" title="WPS"></a>WPS</h3><p>官网下载安装、登录即可</p><h3 id="Navicat"><a href="#Navicat" class="headerlink" title="Navicat"></a>Navicat</h3><p>下载地址：<a href="https://www.imacso.com/navicat-premium.html" target="_blank" rel="noopener">https://www.imacso.com/navicat-premium.html</a></p><h2 id="IntelliJ-IDEA-专题"><a href="#IntelliJ-IDEA-专题" class="headerlink" title="IntelliJ IDEA 专题"></a>IntelliJ IDEA 专题</h2><blockquote><p>注意M1芯片需要专门下载特定的版本</p></blockquote><p>历史版本下载地址：<a href="https://www.jetbrains.com/idea/download/other.html" target="_blank" rel="noopener">https://www.jetbrains.com/idea/download/other.html</a></p><p>破解相关：<a href="https://zhile.io/2020/11/18/jetbrains-eval-reset-deprecated.html" target="_blank" rel="noopener">https://zhile.io/2020/11/18/jetbrains-eval-reset-deprecated.html</a></p><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>安装XCode、或终端 git -version 自动触发下载</p><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>寻找公开的包下载安装</p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>IDE Eval Reset (2.3.5) </p><p>IDEA 扫描插件 (2.4.3) </p><p>Jd Center (2.0.1) </p><p>Key Promoter X (2021.1.1) </p><p>LeetCode Editor (8.7) </p><p>Maven Helper (4.13.203.000.0) </p><p>Rainbow Brackets (2023.2.6-ij) </p><p>RestfulTool (1.3.4) </p><p>SequenceDiagram (2.2.6) </p><p>Translation (3.4.2+203u212)</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>/Users/kexianming1/OneDrive/— File-Tools —/— 电脑配置备份 —</p>]]></content>
    
    
    <categories>
      
      <category>设备篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mac环境搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis-Plus篇</title>
    <link href="/2023/09/12/Mybatis-Plus%E7%AF%87/"/>
    <url>/2023/09/12/Mybatis-Plus%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="Mybatis-Plus篇"><a href="#Mybatis-Plus篇" class="headerlink" title="Mybatis-Plus篇"></a>Mybatis-Plus篇</h1><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑； </li><li>损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作； </li><li>强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求；</li><li>支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错；</li><li>支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题； </li><li>支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作； </li><li>支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ）；</li><li>内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用；</li><li>内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询；</li><li>分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库；</li><li>内置性能分析插件：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询；</li><li>内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作。 </li></ul><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><h3 id="POM"><a href="#POM" class="headerlink" title="POM"></a>POM</h3><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--mybatis-plus依赖--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h3 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h3><pre><code class="hljs java"><span class="hljs-comment">// 基于Lombok插件</span><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CodeFile</span> </span>&#123;    <span class="hljs-meta">@TableField</span>    <span class="hljs-keyword">private</span> String uuid;    <span class="hljs-meta">@TableField</span>(value = <span class="hljs-string">"fileName"</span>)    <span class="hljs-keyword">private</span> String fileName;    <span class="hljs-meta">@TableField</span>(value = <span class="hljs-string">"fileType"</span>)    <span class="hljs-keyword">private</span> String fileType;    <span class="hljs-keyword">private</span> String path;    <span class="hljs-keyword">private</span> String content;&#125;</code></pre><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CodeFileMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseMapper</span>&lt;<span class="hljs-title">CodeFile</span>&gt; </span>&#123; &#125;<span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@MapperScan</span>(<span class="hljs-string">"com.boot.mapper"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KerwinBootsApplication</span> </span>&#123;&#125;</code></pre><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><pre><code class="hljs CODE```">&#96;&#96;&#96;java@Configuration@ConditionalOnClass(value &#x3D; &#123;PaginationInterceptor.class&#125;)public class MybatisPlusConfig &#123;    @Bean    public PaginationInterceptor paginationInterceptor() &#123;        return new PaginationInterceptor();    &#125;&#125;&#x2F;&#x2F; Servicepublic List&lt;CodeFile&gt; selectPage (int page, int pageSize) &#123;    IPage&lt;CodeFile&gt; userPage &#x3D; new Page&lt;&gt;(page, pageSize);    userPage &#x3D; codeFileMapper.selectPage(userPage, null);    return userPage.getRecords();&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>框架篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis-Plus篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql技巧及面试篇</title>
    <link href="/2023/09/12/Mysql%E6%8A%80%E5%B7%A7%E5%8F%8A%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
    <url>/2023/09/12/Mysql%E6%8A%80%E5%B7%A7%E5%8F%8A%E9%9D%A2%E8%AF%95%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL技巧及面试篇"><a href="#MySQL技巧及面试篇" class="headerlink" title="MySQL技巧及面试篇"></a>MySQL技巧及面试篇</h1><h2 id="MySQL技巧篇"><a href="#MySQL技巧篇" class="headerlink" title="MySQL技巧篇"></a>MySQL技巧篇</h2><h3 id="如何记录慢SQL"><a href="#如何记录慢SQL" class="headerlink" title="如何记录慢SQL"></a>如何记录慢SQL</h3><p>配置项：<code>slow_query_log</code></p><p>可以使用<code>show variables like ‘slov_query_log’</code>查看是否开启，如果状态值为<code>OFF</code>，可以使用<code>set GLOBAL slow_query_log = on</code>来开启，它会在<code>datadir</code>下产生一个<code>xxx-slow.log</code>的文件。</p><p><strong>设置临界时间</strong></p><p>配置项：<code>long_query_time</code></p><p>查看：<code>show VARIABLES like &#39;long_query_time&#39;</code>，单位秒</p><p>设置：<code>set long_query_time=0.5</code></p><p>实操时应该从长时间设置到短的时间，即将最慢的SQL优化掉</p><p><strong>查看日志</strong></p><p>一旦SQL超过了我们设置的临界时间就会被记录到<code>xxx-slow.log</code>中</p><h3 id="压测工具mysqlslap"><a href="#压测工具mysqlslap" class="headerlink" title="压测工具mysqlslap"></a>压测工具mysqlslap</h3><p>安装MySQL时附带了一个压力测试工具<code>mysqlslap</code>（位于<code>bin</code>目录下）</p><p><strong>自动生成sql测试</strong></p><pre><code class="hljs shell">C:\Users\zaw&gt;mysqlslap --auto-generate-sql -uroot -prootmysqlslap: [Warning] Using a password on the command line interface can be insecure.Benchmark        Average number of seconds to run all queries: 1.219 seconds        Minimum number of seconds to run all queries: 1.219 seconds        Maximum number of seconds to run all queries: 1.219 seconds        Number of clients running queries: 1        Average number of queries per client: 0</code></pre><p><strong>并发测试</strong></p><pre><code class="hljs shell">C:\Users\zaw&gt;mysqlslap --auto-generate-sql --concurrency=100 -uroot -prootmysqlslap: [Warning] Using a password on the command line interface can be insecure.Benchmark        Average number of seconds to run all queries: 3.578 seconds        Minimum number of seconds to run all queries: 3.578 seconds        Maximum number of seconds to run all queries: 3.578 seconds        Number of clients running queries: 100        Average number of queries per client: 0        C:\Users\zaw&gt;mysqlslap --auto-generate-sql --concurrency=150 -uroot -prootmysqlslap: [Warning] Using a password on the command line interface can be insecure.Benchmark        Average number of seconds to run all queries: 5.718 seconds        Minimum number of seconds to run all queries: 5.718 seconds        Maximum number of seconds to run all queries: 5.718 seconds        Number of clients running queries: 150        Average number of queries per client: 0</code></pre><p><strong>多轮测试</strong></p><pre><code class="hljs shell">C:\Users\zaw&gt;mysqlslap --auto-generate-sql --concurrency=150 --iterations=10 -uroot -prootmysqlslap: [Warning] Using a password on the command line interface can be insecure.Benchmark        Average number of seconds to run all queries: 5.398 seconds        Minimum number of seconds to run all queries: 4.313 seconds        Maximum number of seconds to run all queries: 6.265 seconds        Number of clients running queries: 150        Average number of queries per client: 0</code></pre><p><strong>存储引擎测试</strong></p><pre><code class="hljs shell">C:\Users\zaw&gt;mysqlslap --auto-generate-sql --concurrency=150 --iterations=3 --engine=innodb -uroot -prootmysqlslap: [Warning] Using a password on the command line interface can be insecure.Benchmark        Running for engine innodb        Average number of seconds to run all queries: 5.911 seconds        Minimum number of seconds to run all queries: 5.485 seconds        Maximum number of seconds to run all queries: 6.703 seconds        Number of clients running queries: 150        Average number of queries per client: 0</code></pre><h2 id="MySQL面试篇"><a href="#MySQL面试篇" class="headerlink" title="MySQL面试篇"></a>MySQL面试篇</h2><h3 id="Q1：如何快速导入大量数据"><a href="#Q1：如何快速导入大量数据" class="headerlink" title="Q1：如何快速导入大量数据"></a>Q1：如何快速导入大量数据</h3><p>在恢复数据时，可能会导入大量的数据。此时为了快速导入，需要掌握一些技巧：</p><p>导入时先禁用索引和约束：</p><pre><code class="hljs mysql">alter table table-name disable keys</code></pre><p>待数据导入完成之后，再开启索引和约束，一次性创建索引</p><pre><code class="hljs mysql">alter table table-name enable keys</code></pre><p>数据库如果使用的引擎是<code>Innodb</code>，那么它默认会给每条写指令加上事务（这也会消耗一定的时间），因此建议先手动开启事务，再执行一定量的批量导入，最后手动提交事务。</p><p>如果批量导入的SQL指令格式相同只是数据不同，那么你应该先<code>prepare</code>预编译一下，这样也能节省很多重复编译的时间。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql技巧及面试篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ping与Telnet</title>
    <link href="/2023/09/12/Ping%E4%B8%8ETelnet/"/>
    <url>/2023/09/12/Ping%E4%B8%8ETelnet/</url>
    
    <content type="html"><![CDATA[<h1 id="Ping和Telnet的妙用"><a href="#Ping和Telnet的妙用" class="headerlink" title="Ping和Telnet的妙用"></a>Ping和Telnet的妙用</h1><pre><code class="hljs armasm"><span class="hljs-symbol">ping</span>  realtest.api.pro.testin.cn   ----&gt; 原理知识：由A主机发出 ping xxxx(域名或<span class="hljs-built_in">IP</span> 称为主机<span class="hljs-keyword">B) </span>如果是域名则先进行DNS解析获取其<span class="hljs-built_in">IP</span>地址，由主机A通过 -&gt; Ping命令会构建一个固定格式的ICMP请求数据包，由ICMP协议将目标<span class="hljs-built_in">IP</span>和数据包一起交给<span class="hljs-built_in">IP</span>协议，<span class="hljs-built_in">IP</span>协议会把本机地址作为源地址，目标<span class="hljs-built_in">ip</span>作为源地址，加上一些控制信息构建一个<span class="hljs-built_in">IP</span>数据包，并在一个映射表中查找出目标<span class="hljs-built_in">IP</span>所对应的物理地址（MAC地址），一并交给数据链路层，数据链路层构建一个数据帧，依据以太网的介质访问规则，将它们传送出去主机<span class="hljs-keyword">B收到这个数据帧后，先检查它的目的地址，并和本机的物理地址对比，如符合，则接收；否则丢弃。接收后检查该数据帧，将IP数据包从帧中提取出来，交给本机的IP层协议。同样，IP层检查后，将有用的信息提取后交给ICMP协议，后者处理后，马上构建一个ICMP应答包，发送给主机A，其过程和主机A发送ICMP请求包到主机B一模一样</span><span class="hljs-keyword"> </span>   <span class="hljs-symbol">PS</span>:（ICMP协议是TCP/<span class="hljs-built_in">IP</span>下的一个子协议，具有无连接的特性，主要用途是对于网络连接情况的勘探，ICMP就是一个“错误侦测与回报机制”）  使用技巧或场景：<span class="hljs-number">1</span>.看是否ping通，可以得到域名和<span class="hljs-built_in">ip</span>的映射关系是否正常(比如部署服务时，请求无法到达可以用此方法检查映射是否正常)<span class="hljs-number">2</span>.单方面通可能的原因：A到<span class="hljs-keyword">B可以，B到A不行，可能是由于A配置防火墙等，</span><span class="hljs-keyword">/******************************************************************/</span><span class="hljs-keyword"></span><span class="hljs-keyword">telnet </span>realtest.api.pro.testin.cn <span class="hljs-number">7005</span>  ----&gt; <span class="hljs-symbol">Telnet</span>协议是TCP/<span class="hljs-built_in">IP</span>协议族中的一员,是Internet远程登陆服务的标准协议和主要方式，Telnet是常用的远程控制Web服务器的方法使用技巧或场景：通过 域名或<span class="hljs-built_in">IP</span> 加端口的方式，可以检测web服务是否正常启动</code></pre>]]></content>
    
    
    <categories>
      
      <category>网络篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ping与Telnet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-自定义starter</title>
    <link href="/2023/09/12/SpringBoot-%E8%87%AA%E5%AE%9A%E4%B9%89starter/"/>
    <url>/2023/09/12/SpringBoot-%E8%87%AA%E5%AE%9A%E4%B9%89starter/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-Boot-Starter简介"><a href="#Spring-Boot-Starter简介" class="headerlink" title="Spring Boot Starter简介"></a>Spring Boot Starter简介</h1><p>Starter是Spring Boot中的一个非常重要的概念，Starter相当于模块，它能将模块所需的依赖整合起来并对模块内的Bean根据环境（ 条件）进行自动配置。使用者只需要依赖相应功能的Starter，无需做过多的配置和依赖，Spring Boot就能自动扫描并加载相应的模块。</p><p>例如在Maven的依赖中加入spring-boot-starter-web就能使项目支持Spring MVC，并且Spring Boot还为我们做了很多默认配置，无需再依赖spring-web、spring-webmvc等相关包及做相关配置就能够立即使用起来。</p><h2 id="Starter的开发步骤"><a href="#Starter的开发步骤" class="headerlink" title="Starter的开发步骤"></a>Starter的开发步骤</h2><p>编写Starter非常简单，与编写一个普通的Spring Boot应用没有太大区别，总结如下：</p><pre><code>1.新建Maven项目，在项目的POM文件中定义使用的依赖；2.新建配置类，写好配置项和默认的配置值，指明配置项前缀；3.新建自动装配类，使用@Configuration和@Bean来进行自动装配；4.新建spring.factories文件，指定Starter的自动装配类；</code></pre><h2 id="Starter的开发示例"><a href="#Starter的开发示例" class="headerlink" title="Starter的开发示例"></a>Starter的开发示例</h2><p>下面，我就以创建一个自动配置来讲一下各个步骤及细节。<br>1.新建Maven项目，在项目的POM文件中定义使用的依赖。</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre><p>2.新建配置类，写好配置项和默认的配置值，指明配置项前缀。</p><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties</span>(<span class="hljs-string">"example.service"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StarterServiceProperties</span> </span>&#123;    <span class="hljs-keyword">private</span> String config;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> enabled;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setConfig</span><span class="hljs-params">(String config)</span> </span>&#123;        <span class="hljs-keyword">this</span>.config = config;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getConfig</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> config;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEnabled</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> enabled;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEnabled</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> enabled)</span> </span>&#123;        <span class="hljs-keyword">this</span>.enabled = enabled;    &#125;&#125;</code></pre><blockquote><p>指定配置项前缀为<code>example.service</code>，各配置项均有默认值，默认值可以通过模块使用者的配置文件进行覆盖。</p></blockquote><p>3.新建自动装配类，使用<code>@Configuration</code>和<code>@Bean</code>来进行自动装配。</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableConfigurationProperties</span>(StarterServiceProperties<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">StarterAutoConfigure</span> </span>&#123;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 注意：构建SpringBoot项目时候会自动增加plugin 工具，starter 不需要boot启动类</span><span class="hljs-comment">     * 如果install 时报错和工具相关，需要删除plugin相关配置</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> StarterServiceProperties properties;    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@ConditionalOnMissingBean</span>(StarterService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">    @<span class="hljs-title">ConditionalOnProperty</span>(<span class="hljs-title">prefix</span> </span>= <span class="hljs-string">"example.service"</span>, value = <span class="hljs-string">"enabled"</span>, havingValue = <span class="hljs-string">"true"</span>)    <span class="hljs-function">StarterService <span class="hljs-title">starterService</span> <span class="hljs-params">()</span></span>&#123;        StarterService starterService = <span class="hljs-keyword">new</span> StarterService();        starterService.setConfig(properties.getConfig());        <span class="hljs-keyword">return</span> starterService;    &#125;&#125;</code></pre><p>4.新建spring.factories文件，指定Starter的自动装配类。</p><pre><code class="hljs ini"><span class="hljs-comment"># 配置自动注入的类</span><span class="hljs-attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=com.bootstarter.StarterAutoConfigure</code></pre><blockquote><p>spring.factories文件位于resources/META-INF目录下，需要手动创建;<br><code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code>后面的类名说明了自动装配类，如果有多个 ，则用逗号分开;<br>使用者应用（SpringBoot）在启动的时候，会通过<code>org.springframework.core.io.support.SpringFactoriesLoader</code>读取classpath下每个Starter的spring.factories文件，加载自动装配类进行Bean的自动装配；</p></blockquote><p>至此，整个Starter开发完毕，Deploy到中央仓库或Install到本地仓库后即可使用</p><h2 id="Starter的使用"><a href="#Starter的使用" class="headerlink" title="Starter的使用"></a>Starter的使用</h2><p>1.创建Maven项目，依赖刚才发布的es-starter包。</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 依赖自定义starter --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre><blockquote><p>只需依赖刚才开发的es-starter即可</p></blockquote><p>2.根据要求进行配置</p><pre><code class="hljs ini"><span class="hljs-comment"># starter 配置文件</span><span class="hljs-attr">example.service.config</span>  = abc-des-dde,SSS-DRS-RE,SDR-SDFR-XXX<span class="hljs-attr">example.service.enabled</span> = <span class="hljs-literal">false</span></code></pre><p>3.编写应用程序启动类。</p><pre><code class="hljs java"><span class="hljs-comment">// 根据example.service.enabled 参数配置是否进行自动装配</span><span class="hljs-meta">@Component</span><span class="hljs-meta">@ConditionalOnExpression</span>(<span class="hljs-string">"$&#123;example.service.enabled:true&#125;"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationRunner</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> StarterService starterService;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(ApplicationArguments args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(Arrays.toString(starterService.split(<span class="hljs-string">","</span>)));    &#125;&#125;</code></pre><p>5.运行程序测试</p><pre><code class="hljs maxima">  .   ____          <span class="hljs-symbol">_</span>            <span class="hljs-symbol">__</span> <span class="hljs-symbol">_</span> <span class="hljs-symbol">_</span> /\\ / ___'<span class="hljs-symbol">_</span> <span class="hljs-symbol">__</span> <span class="hljs-symbol">_</span> <span class="hljs-symbol">_</span>(<span class="hljs-symbol">_</span>)<span class="hljs-symbol">_</span> <span class="hljs-symbol">__</span>  <span class="hljs-symbol">__</span> <span class="hljs-symbol">_</span> \ \ \ \( ( )\___ | '<span class="hljs-symbol">_</span> | '<span class="hljs-symbol">_</span>| | '<span class="hljs-symbol">_</span> \/ <span class="hljs-symbol">_</span>` | \ \ \ \ \\/  ___)| |<span class="hljs-symbol">_</span>)| | | | | || (<span class="hljs-symbol">_</span>| |  ) ) ) )  '  |____| .<span class="hljs-symbol">__</span>|<span class="hljs-symbol">_</span>| |<span class="hljs-symbol">_</span>|<span class="hljs-symbol">_</span>| |<span class="hljs-symbol">_</span>\<span class="hljs-symbol">__</span>, | / / / / =========|<span class="hljs-symbol">_</span>|==============|___/=/<span class="hljs-symbol">_</span>/<span class="hljs-symbol">_</span>/<span class="hljs-symbol">_</span>/ :: Spring Boot ::        (v2<span class="hljs-number">.1</span><span class="hljs-number">.7</span>.RELEASE)<span class="hljs-number">2019</span>-<span class="hljs-number">08</span>-<span class="hljs-number">29</span> <span class="hljs-number">14</span>:<span class="hljs-number">28</span>:<span class="hljs-number">27.061</span>  INFO <span class="hljs-number">9844</span> --- [           main] com.<span class="hljs-built_in">demo</span>.BootDemoApplication             : Starting BootDemoApplication on Kerwin with PID <span class="hljs-number">9844</span> (C:\Users\Administrator\Desktop\Codes\KerwinBoots\boot-<span class="hljs-built_in">demo</span>\target\classes started by Administrator <span class="hljs-keyword">in</span> C:\Users\Administrator\Desktop\Codes\KerwinBoots)<span class="hljs-number">2019</span>-<span class="hljs-number">08</span>-<span class="hljs-number">29</span> <span class="hljs-number">14</span>:<span class="hljs-number">28</span>:<span class="hljs-number">27.064</span>  INFO <span class="hljs-number">9844</span> --- [           main] com.<span class="hljs-built_in">demo</span>.BootDemoApplication             : No active profile set, falling back to default profiles: default<span class="hljs-number">2019</span>-<span class="hljs-number">08</span>-<span class="hljs-number">29</span> <span class="hljs-number">14</span>:<span class="hljs-number">28</span>:<span class="hljs-number">28.317</span>  INFO <span class="hljs-number">9844</span> --- [           main] com.<span class="hljs-built_in">demo</span>.BootDemoApplication             : Started BootDemoApplication <span class="hljs-keyword">in</span> <span class="hljs-number">1.733</span> seconds (JVM running <span class="hljs-keyword">for</span> <span class="hljs-number">2.975</span>)[abc-des-dde, SSS-DRS-RE,SDR-SDFR-XXX]</code></pre><blockquote><p>运行程序，观察控制台输出: 源码可见: <a href="https://github.com/kkzhilu/KerwinBoots" target="_blank" rel="noopener">https://github.com/kkzhilu/KerwinBoots</a> | boot_starter 分支</p></blockquote><h2 id="注解说明"><a href="#注解说明" class="headerlink" title="注解说明"></a>注解说明</h2><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td><code>@ConditionalOnSingleCandidate</code></td><td>当给定类型的bean存在并且指定为Primary的给定类型存在时,返回true</td></tr><tr><td><code>@ConditionalOnMissingBean</code></td><td>当给定的类型、类名、注解、昵称在beanFactory中不存在时返回true.各类型间是or的关系</td></tr><tr><td><code>@ConditionalOnBean</code></td><td>与上面相反，要求bean存在</td></tr><tr><td><code>@ConditionalOnMissingClass</code></td><td>当给定的类名在类路径上不存在时返回true,各类型间是and的关系</td></tr><tr><td><code>@ConditionalOnClass</code></td><td>与上面相反，要求类存在</td></tr><tr><td><code>@ConditionalOnCloudPlatform</code></td><td>当所配置的CloudPlatform为激活时返回true</td></tr><tr><td><code>@ConditionalOnExpression</code></td><td>spel表达式执行为true</td></tr><tr><td><code>@ConditionalOnJava</code></td><td>运行时的java版本号是否包含给定的版本号.如果包含,返回匹配,否则,返回不匹配</td></tr><tr><td><code>@ConditionalOnProperty</code></td><td>要求配置属性匹配条件</td></tr><tr><td><code>@ConditionalOnJndi</code></td><td>给定的jndi的Location 必须存在一个.否则,返回不匹配</td></tr><tr><td><code>@ConditionalOnNotWebApplication</code></td><td>web环境不存在时</td></tr><tr><td><code>@ConditionalOnWebApplication</code></td><td>web环境存在时</td></tr><tr><td><code>@ConditionalOnResource</code></td><td>要求制定的资源存在</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>框架篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot-自定义starter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot篇</title>
    <link href="/2023/09/12/SpringBoot%E7%AF%87/"/>
    <url>/2023/09/12/SpringBoot%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot篇"><a href="#SpringBoot篇" class="headerlink" title="SpringBoot篇"></a>SpringBoot篇</h1><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><pre><code class="hljs armasm"><span class="hljs-number">41</span>. 谈谈你对 Spring <span class="hljs-keyword">Boot </span>的理解？<span class="hljs-number">42</span>. Spring <span class="hljs-keyword">Boot </span>的优势是什么？为什么要使用 Spring <span class="hljs-keyword">Boot？</span><span class="hljs-keyword"></span><span class="hljs-keyword">43. </span>Spring <span class="hljs-keyword">Boot </span>的配置文件有几种格式？区别是什么？<span class="hljs-number">44</span>. 谈谈你知道的 Spring <span class="hljs-keyword">Boot </span>核心注解。<span class="hljs-number">45</span>. 如何自动开启 Spring <span class="hljs-keyword">Boot </span>各个组件？<span class="hljs-number">46</span>. Spring <span class="hljs-keyword">Boot </span>中 starter 的原理是什么？<span class="hljs-number">47</span>. Spring <span class="hljs-keyword">Boot </span>不能使用 XML 配置，这句话对吗?</code></pre><h3 id="SpringBoot中Component注解和bean注解的区别"><a href="#SpringBoot中Component注解和bean注解的区别" class="headerlink" title="SpringBoot中Component注解和bean注解的区别"></a>SpringBoot中Component注解和bean注解的区别</h3><pre><code class="hljs java">你想要将第三方库中的组件装配到你的应用中，在这种情况下，是没有办法在它的类上添加<span class="hljs-meta">@Component</span>和<span class="hljs-meta">@Autowired</span>注解的，因此就不能使用自动化装配的方案了<span class="hljs-meta">@Component</span>和<span class="hljs-meta">@Bean</span>都是用来注册Bean并装配到Spring容器中，但是Bean比Component的自定义性更强。可以实现一些Component实现不了的自定义加载类<span class="hljs-meta">@Bean</span>一般和<span class="hljs-meta">@Configuration</span>配合使用bean的使用，如:<span class="hljs-comment">/***</span><span class="hljs-comment"> * 自定义token filter - global</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> TokenFilter <span class="hljs-title">tokenFilter</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TokenFilter();&#125;</code></pre><h3 id="如何在普通类获取Ioc注入的Bean"><a href="#如何在普通类获取Ioc注入的Bean" class="headerlink" title="如何在普通类获取Ioc注入的Bean"></a>如何在普通类获取Ioc注入的Bean</h3><pre><code class="hljs java">Spring容器会检测容器中的所有Bean，如果发现某个Bean实现了ApplicationContextAware接口，Spring容器会在创建该Bean之后，自动调用该Bean的setApplicationContextAware()方法，调用该方法时，会将容器本身作为参数传给该方法——该方法中的实现部分将Spring传入的参数（容器本身）赋给该类对象的applicationContext实例变量，因此接下来可以通过该applicationContext实例变量来访问容器本身代码如下：<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringContextUtil</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationContextAware</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 上下文对象实例</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ApplicationContext applicationContext;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setApplicationContext</span><span class="hljs-params">(ApplicationContext applicationContext)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;        SpringContextUtil.applicationContext = applicationContext;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取applicationContext</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ApplicationContext <span class="hljs-title">getApplicationContext</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> applicationContext;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 通过name获取 Bean.</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getBean</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">return</span> getApplicationContext().getBean(name);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 通过class获取Bean.</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> clazz</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt;</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(Class&lt;T&gt; clazz)</span> </span>&#123;        <span class="hljs-keyword">return</span> getApplicationContext().getBean(clazz);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 通过name,以及Clazz返回指定的Bean</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> clazz</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt;</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(String name, Class&lt;T&gt; clazz)</span> </span>&#123;        <span class="hljs-keyword">return</span> getApplicationContext().getBean(name, clazz);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>框架篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud篇</title>
    <link href="/2023/09/12/SpringCloud%E7%AF%87/"/>
    <url>/2023/09/12/SpringCloud%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringCloud篇"><a href="#SpringCloud篇" class="headerlink" title="SpringCloud篇"></a>SpringCloud篇</h1><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><pre><code class="hljs angelscript"><span class="hljs-number">51.</span> 什么是 Spring Cloud？<span class="hljs-number">52.</span> Spring Cloud 和 Spring 之间有什么关联关系？<span class="hljs-number">53.</span> Spring Cloud 实现服务注册和发现的原理是什么？<span class="hljs-number">54.</span> Ribbon 和 Feign 有什么区别？<span class="hljs-number">55.</span> 为什么要使用 Spring Cloud 熔断器，它的作用是什么？<span class="hljs-number">56.</span> 什么是 Hystrix？<span class="hljs-number">57.</span> Eureka 和 ZooKeeper 的区别是什么？<span class="hljs-number">58.</span> 为什么要使用负载均衡？<span class="hljs-number">59.</span> Spring Cloud 实现服务注册和发现的具体流程是什么？<span class="hljs-number">60.</span> 为什么要使用 Spring Cloud ，它有哪些优势？<span class="hljs-number">61.</span> 谈谈你对微服务的理解。<span class="hljs-number">62.</span> 微服务分别有哪些优点，哪些缺点？服务的优势和劣势分别是什么？<span class="hljs-number">63.</span> 谈谈微服务之间是如何实现通信的。<span class="hljs-number">64.</span> Spring Boot 如何集成 MyBatis？<span class="hljs-number">65.</span> Spring Boot 和 Spring Cloud 有哪些区别？<span class="hljs-number">66.</span> 使用 layui 的数据表格组件展示业务数据，后台实体类应该如何定义？<span class="hljs-number">67.</span> JPA 和 Spring Data JPA 是一回事吗？<span class="hljs-number">68.</span> 如果要给项目添加权限管理系统，一般包含哪些需求？<span class="hljs-number">69.</span> 微服务架构的拆分都有哪些原则？<span class="hljs-number">70.</span> Feign 和 Ribbon+RestTemplate 的区别是什么？</code></pre>]]></content>
    
    
    <categories>
      
      <category>框架篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VPN</title>
    <link href="/2023/09/12/VPN/"/>
    <url>/2023/09/12/VPN/</url>
    
    <content type="html"><![CDATA[<h1 id="翻墙与VPN"><a href="#翻墙与VPN" class="headerlink" title="翻墙与VPN"></a>翻墙与VPN</h1><h2 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h2><p>账号：<a href="mailto:806857264@qq.com">806857264@qq.com</a></p><p>密码：kxmmyyy317</p><p>网站：<a href="https://paoluz.link/user" target="_blank" rel="noopener">https://paoluz.link/user</a></p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><p>网站：<a href="https://paoluz.link/user" target="_blank" rel="noopener">https://paoluz.link/user</a></p><p>预先充值</p><p><img src="/2023/09/12/VPN/image-20210903112510558.png" srcset="/img/loading.gif" alt="image-20210903112510558"></p><h2 id="购买套餐"><a href="#购买套餐" class="headerlink" title="购买套餐"></a>购买套餐</h2><p><img src="/2023/09/12/VPN/image-20210903112626175.png" srcset="/img/loading.gif" alt="image-20210903112626175"></p><h2 id="接入使用"><a href="#接入使用" class="headerlink" title="接入使用"></a>接入使用</h2><blockquote><p>选择性接入软件，根据介绍文档使用即可</p></blockquote><p><img src="/2023/09/12/VPN/image-20210903112654886.png" srcset="/img/loading.gif" alt="image-20210903112654886"></p><h2 id="Windows接入"><a href="#Windows接入" class="headerlink" title="Windows接入"></a>Windows接入</h2><p>Clash 操作指南：<a href="https://www.kancloud.cn/carol/note/1879682#0x02__clash_for_windows__13" target="_blank" rel="noopener">https://www.kancloud.cn/carol/note/1879682#0x02__clash_for_windows__13</a></p><p>Clash 汉化版下载地址：<a href="http://www.32r.com/soft/96150.html?continueFlag=0bd571975ad206e07980d8cf6d8f8a03" target="_blank" rel="noopener">http://www.32r.com/soft/96150.html?continueFlag=0bd571975ad206e07980d8cf6d8f8a03</a></p><h2 id="Mac-ClashX使用教程"><a href="#Mac-ClashX使用教程" class="headerlink" title="Mac ClashX使用教程"></a>Mac ClashX使用教程</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>配置-托管功能-设置相关配置，如图所示（基于软件选择订阅方式即可，例如Clash）：</p><p>地址案例：<a href="https://api.bianyuan.xyz/sub?target=clash&amp;udp=true&amp;new_name=true&amp;url=https://rss.paoluz.xyz/link/oZK2jE9vR2LGRqAT?sub=2&amp;insert=false&amp;config=https%3A%2F%2Fraw.githubusercontent.com%2FHynoR%2FACL4SSR%2Fmaster%2FClash%2Fconfig%2FACL4SSR_Online_NoAuto.ini&amp;exclude=GAME&amp;emoji=true&amp;filename=Paoluz_Clash4SS">https://api.bianyuan.xyz/sub?target=clash&amp;udp=true&amp;new_name=true&amp;url=https://rss.paoluz.xyz/link/oZK2jE9vR2LGRqAT?sub=2&amp;insert=false&amp;config=https%3A%2F%2Fraw.githubusercontent.com%2FHynoR%2FACL4SSR%2Fmaster%2FClash%2Fconfig%2FACL4SSR_Online_NoAuto.ini&amp;exclude=GAME&amp;emoji=true&amp;filename=Paoluz_Clash4SS</a></p><p><img src="/2023/09/12/VPN/image-20211122171023528.png" srcset="/img/loading.gif" alt="image-20211122171023528"></p><h3 id="选择节点"><a href="#选择节点" class="headerlink" title="选择节点"></a>选择节点</h3><p>选择绿色的可用节点即可</p><p><img src="/2023/09/12/VPN/image-20211122171149104.png" srcset="/img/loading.gif" alt="image-20211122171149104"></p><h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><p>注意上面提到的两个功能：</p><ul><li>设置为系统代理 =》 即将代理整个电脑的所有网络出口（但部分系统由于权限问题可能不可用，比如Mac M系列）</li><li>复制终端代理命令 =》 终端命令是在当前Shell窗口生效，非常好用，可以在例如Git拉取时使用</li></ul><h2 id="更安全精准的方式：Google-插件"><a href="#更安全精准的方式：Google-插件" class="headerlink" title="更安全精准的方式：Google 插件"></a>更安全精准的方式：Google 插件</h2><p>Google插件：<a href="chrome-extension://padekgcemlokbadohgkifijomclgjgif/options.html#!/about">SwitchyOmega</a></p><p>具体解释如下：</p><h3 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h3><p>配置基本的代理能力，例如ClashX代理的端口为7890，如下所示：</p><p><img src="/2023/09/12/VPN/image-20211122171929869.png" srcset="/img/loading.gif" alt="image-20211122171929869"></p><h3 id="autoSwitch"><a href="#autoSwitch" class="headerlink" title="autoSwitch"></a>autoSwitch</h3><p>选择性启用是否代理，可以更精确的控制流量，也更安全，如下所示</p><p>原理：基于域名匹配或正则触发，触发后使用情景模式（即proxy模式）</p><p><img src="/2023/09/12/VPN/image-20211122172031030.png" srcset="/img/loading.gif" alt="image-20211122172031030"></p><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ul><li>全机器自动同步</li></ul><p><img src="/2023/09/12/VPN/image-20211122172130603.png" srcset="/img/loading.gif" alt="image-20211122172130603"></p><ul><li><p>日常使用</p><p>日常可以持续开启ClashX（不会耗费流量），Omega插件可以稳定至系统代理方式，当需要使用的可以选择 proxy（全网站代理），autoSwitch（根据自身规则代理）</p></li></ul><p><img src="/2023/09/12/VPN/image-20211122172153917.png" srcset="/img/loading.gif" alt="image-20211122172153917"></p><h2 id="其他平台"><a href="#其他平台" class="headerlink" title="其他平台"></a>其他平台</h2><p>地址：<a href="https://xn--4gq62f52gdss.com/#/registe" target="_blank" rel="noopener">https://xn--4gq62f52gdss.com/#/registe</a></p><p>地址（和耳朵）：<a href="https://sockboom.bar/auth/register?affid=390907" target="_blank" rel="noopener">https://sockboom.bar/auth/register?affid=390907</a></p><p>地址（程越）：<a href="https://www.elkcloud.top/auth/register?code=kYrX" target="_blank" rel="noopener">https://www.elkcloud.top/auth/register?code=kYrX</a></p><h2 id="同一局域网如何连接"><a href="#同一局域网如何连接" class="headerlink" title="同一局域网如何连接"></a>同一局域网如何连接</h2><ol><li><p>打开Clash的<code>Allow Lan</code></p></li><li><p>通过 ipconig 获取使用VPN电脑的IP地址，同时查看 Clash 打开的端口号</p></li><li><p>手机或其它设备先连接上同一局域网，进入手机 <strong>WiFi</strong> 的详细设置界面，把选项 <strong>代理</strong> 从 <strong>无</strong> 改成 <strong>手动</strong> ，选项 <strong>主机名</strong> 设置为 <code>IP地址</code>，选项 <strong>代理服务器端口</strong> 改为 <code>端口</code>，确认即可</p></li><li><p>其他电脑可以使用 <a href="chrome-extension://padekgcemlokbadohgkifijomclgjgif/options.html#!/about">SwitchyOmega</a> 直接连接目标电脑的 IP + 端口即可</p><p><img src="/2023/09/12/VPN/image-20230224000711989.png" srcset="/img/loading.gif" alt="image-20230224000711989"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>网络篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VPN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>世界的规则</title>
    <link href="/2023/09/12/%E4%B8%96%E7%95%8C%E7%9A%84%E8%A7%84%E5%88%99/"/>
    <url>/2023/09/12/%E4%B8%96%E7%95%8C%E7%9A%84%E8%A7%84%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1 id="The-rules-of-Coding-and-Life："><a href="#The-rules-of-Coding-and-Life：" class="headerlink" title="The rules of Coding and Life："></a>The rules of Coding and Life：</h1><blockquote><p>码农翻身：<a href="https://mp.weixin.qq.com/s/1vmyoh0HG9mC3kguBtMfXA" target="_blank" rel="noopener">统治软件开发的著名定律，让你无处可逃！</a></p></blockquote><ul><li>墨菲定律 (Murphy’s Law) </li></ul><pre><code class="hljs plain">凡是可能出错的事就一定会出错推论：计算机会按照你写出来的方式运行，而不是你臆想出来的</code></pre><ul><li>布鲁克斯法则(Brook’s Law) </li></ul><pre><code class="hljs plain">向一个延期的项目增加人手只会让它延期得更加厉害</code></pre><ul><li>霍夫斯塔特定律 (Hofstadter’s Law) </li></ul><pre><code class="hljs plain">事情总是要花费比你预想更长的时间，即使你把霍夫斯塔特定律也考虑在内</code></pre><ul><li>康威定律 (Conway’s Law) </li></ul><pre><code class="hljs plain">软件的任何一部分都反应了创建它的组织结构你想要什么样的系统设计，就架构什么样的团队，这会带来事半功倍的效果。</code></pre><ul><li>伯斯塔尔定律(Postel’s Law) </li></ul><pre><code class="hljs plain">发送时要保守，接收时要大方</code></pre><ul><li>帕累托法则 (Pareto Principle)   — 又称80/20法则(The 80-20 rule) </li></ul><pre><code class="hljs angelscript">在软件开发中的体现是： 代码中<span class="hljs-number">80</span>%的错误都是由代码中的<span class="hljs-number">20</span>%引起的。另外，公司<span class="hljs-number">80</span>%的工作是由<span class="hljs-number">20</span>%的员工完成的。问题是你并不总是清楚谁是那<span class="hljs-number">20</span>%。</code></pre><ul><li>彼得原则(The Peter Principle) </li></ul><pre><code class="hljs plain">在等级制度中，每个员工都倾向于提升到他无法胜任的等级</code></pre><ul><li>柯克霍夫原则(Kerchkhoff’s Principle) </li></ul><pre><code class="hljs plain">在密码学中，即使一个系统中的所有东西都是公开的（密钥除外），该系统也应当是安全的</code></pre><ul><li>林纳斯定律 (Linus’s Law) </li></ul><pre><code class="hljs armasm">众目睽睽之下，一切 <span class="hljs-keyword">bug </span>都无所遁形</code></pre><ul><li>摩尔定律 (Moore’s Law) </li></ul><pre><code class="hljs angelscript">集成电路上可容纳的元器件的数目，约每隔<span class="hljs-number">18</span>个月便会增加一倍。计算机的处理性能每隔两年翻一倍。</code></pre><ul><li>90-90法则 (Ninety-ninety rule) </li></ul><pre><code class="hljs angelscript">前<span class="hljs-number">90</span>%的代码要花费<span class="hljs-number">90</span>%的开发时间，剩余的<span class="hljs-number">10</span>%的代码要再花费<span class="hljs-number">90</span>%的开发时间。</code></pre><ul><li>90/10法则</li></ul><pre><code class="hljs angelscript">人生只有<span class="hljs-number">10</span>%会被发生在你身上的事情影响，然而却有<span class="hljs-number">90</span>%是被你面对事情时的反应决定</code></pre><ul><li>克努特优化原则 (Knuth’s optimization principle) </li></ul><pre><code class="hljs plain">不成熟的优化是万恶之源。</code></pre><ul><li>诺维格定律 (Norvig’s Law) </li></ul><pre><code class="hljs angelscript">当公司的市场份额超过<span class="hljs-number">50</span>%之后，就不能再翻番了。</code></pre>]]></content>
    
    
    <categories>
      
      <category>程序人生篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>世界的规则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>享元模式</title>
    <link href="/2023/09/12/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/09/12/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="享元模式篇"><a href="#享元模式篇" class="headerlink" title="享元模式篇"></a>享元模式篇</h1><h3 id="官方解释"><a href="#官方解释" class="headerlink" title="官方解释"></a>官方解释</h3><p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能，这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式</p><h3 id="享元模式的使用"><a href="#享元模式的使用" class="headerlink" title="享元模式的使用"></a>享元模式的使用</h3><p> 1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面<br> 2、数据库的数据池</p><h3 id="官方示例"><a href="#官方示例" class="headerlink" title="官方示例"></a>官方示例</h3><p>Head First：<a href="https://www.cnblogs.com/adamjwh/p/9070107.html" target="_blank" rel="noopener">https://www.cnblogs.com/adamjwh/p/9070107.html</a><br>菜鸟教程：<a href="https://www.runoob.com/design-pattern/flyweight-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/flyweight-pattern.html</a></p><h3 id="工作举例"><a href="#工作举例" class="headerlink" title="工作举例"></a>工作举例</h3><pre><code class="hljs crystal">详情见：<span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/github.com/kkzhilu</span><span class="hljs-regexp">/KerwinTools/tree</span><span class="hljs-regexp">/master/src</span><span class="hljs-regexp">/main/java</span><span class="hljs-regexp">/design/pattern</span>享元模式相关</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><pre><code class="hljs java"><span class="hljs-comment">/***</span><span class="hljs-comment"> * 享元模式</span><span class="hljs-comment"> *     主要解决：在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 关键代码</span><span class="hljs-comment"> *     1.构建产品类</span><span class="hljs-comment"> *     2.构建享元工厂, 通过唯一的key进行判断，是否重复创建对象</span><span class="hljs-comment"> *     3.通过key拿到对象后，根据set方法变化数据，达到想要的目的</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 值得注意</span><span class="hljs-comment"> *     外部状态和内部状态的变化</span><span class="hljs-comment"> */</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>编码及设计模式篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>享元模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是高级工程师</title>
    <link href="/2023/09/12/%E4%BB%80%E4%B9%88%E6%98%AF%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    <url>/2023/09/12/%E4%BB%80%E4%B9%88%E6%98%AF%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88/</url>
    
    <content type="html"><![CDATA[<h1 id="有人问我什么是高级程序员，-该怎么衡量？"><a href="#有人问我什么是高级程序员，-该怎么衡量？" class="headerlink" title="有人问我什么是高级程序员， 该怎么衡量？"></a>有人问我什么是高级程序员， 该怎么衡量？</h1><blockquote><p>作者：码农翻身 - 大刘</p><p>微信公众号：码农翻身</p></blockquote><p>工作了5年以上？<br>带了十多人的团队？<br>知识体系完整，基础扎实？<br>开发了系统的核心模块？<br>精通xxxx技术？<br>代码写得极为优雅漂亮，并且Bug极少？<br>特别擅长解决疑难杂症，找Bug特别快？<br>……</p><p>这些的确是一个高级程序员能表现出的特质， 但是高级程序员本身就是一个比较“虚”的词，在不同的公司对它的定义都不一样。 </p><p>我在Quora上看到了Stevan Popovic的回答，一个高级程序员可以从四个维度来考察，这四个维度并不涉及到具体的技术，  我觉得总结得非常好，尤其是抽象得非常好，分享给大家：</p><ol><li><p>独立 (Independence)<br>在成为高级程序员的过程中，这个人变得越来独立，对别人的依赖很少， 他可以创建合理的任务（通过主动发现问题），并且给出好地解决方案。<br>老刘评价： 如果你一直是被动地等待着被分配工作，在工作中对业务不熟悉，对技术不熟悉，经常需要问别人，寻求别人的帮助，只满足于自己手头的一亩三分地， 那你就不是高级程序员。 </p></li><li><p>权威的声音 (Voice of Authority)</p></li></ol><p>这个人对特定产品或者一个大系统的组件，能发出权威的声音，在团队讨论中，能引导同事找到最佳的解决方案，并且提前指出潜在的问题。 </p><p>老刘评价： 简单来说，就是你发出的声音会被大家倾听，被大家信服。 如果在讨论中，你只是带着耳朵去听，一声不吭，或者你的思路和方案不能被大家接受，那就不是高级程序员。 </p><p>这其实暗含着沟通的能力，不仅仅自己有能力，还得能准确地表达出自己的观点，从而说服大家，引导大家前进。 在特定产品或者一个大系统的组件上，你就是那个引路人。</p><ol start="3"><li>设计 (Design)<br>这个人不仅仅只是Coding，相反，他会对整个系统或项目的设计做出越来越多的贡献。 </li></ol><p>老刘评价： 这一条并不是贬低Coding， 因为Coding只是软件开发中的一部分，更重要的工作是设计， 简单的项目，设计可能只存在于你的脑海中，直接Coding； 复杂的项目，设计就需要文档化。<br>当你的想法逐渐变成系统的设计方案，大家来遵守执行的时候，你就是高级程序员。</p><ol start="4"><li>影响力的范围 (Areas of Influence)<br>一个较为初级的程序员倾向于“向内看” (Inward Looking)， 经常专注于自己手头的Task，需要Fix的Bug。<br>一个更高级的程序员会变得“向外看” (Outward Looking)， 这包括招聘，管理，跨部门的协作和沟通，外部客户沟通等等。 随着开发人员变得高级，他会不断地扩大影响的范围。 </li></ol><p>老刘点评： 我在IBM的时候老板就老是讲Influence ，只有影响力到了，才更容易升到下一职位。<br>在小公司可能不觉得，一旦进入大公司，如果没有影响力，职业发展就寸步难行。 我现在还记得在公司升职的时候，老板问的一个问题，如果你升了职，你如何利用你的影响力帮助我们的部门？ </p><p>最后问一下自己，看看自己是不是达到了高级程序员的要求：</p><p>我能独立地完成工作吗？<br>我对于工作的项目和产品能发出权威的声音吗？<br>我能对整个系统的设计做出贡献吗？<br>我的影响力在什么范围？  小组？ 部门？公司？业界？</p><p><img src="/2023/09/12/%E4%BB%80%E4%B9%88%E6%98%AF%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88/FhAn7xXY-cdtRHWkbdJi8XiG4JhX.jfif" srcset="/img/loading.gif" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>程序人生篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>什么是高级工程师</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式</title>
    <link href="/2023/09/12/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/09/12/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="单例模式篇"><a href="#单例模式篇" class="headerlink" title="单例模式篇"></a>单例模式篇</h1><h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p><font color="red">别名：单件模式</font></p><h2 id="单例模式的诞生"><a href="#单例模式的诞生" class="headerlink" title="单例模式的诞生"></a>单例模式的诞生</h2><p>【<font color="blue">开发</font>】：老大，为什么我保存配置信息，每次都和我预期的不一样啊，总是会覆盖？</p><p>【<font color="red">BOSS</font>】：哈？我来看看。</p><p>【<font color="red">BOSS</font>】：你每次使用的时候都会new一个新的配置对象吗？</p><p>【<font color="blue">开发</font>】：对啊，有什么问题？</p><p>【<font color="red">BOSS</font>】：那肯定不对啊，像这种配置信息，全局只应该有一个，不然会互相影响！</p><p><img src="/2023/09/12/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/image-20200524135834920.png" srcset="/img/loading.gif" alt="image-20200524135834920"></p><h2 id="HeadFirst-核心代码"><a href="#HeadFirst-核心代码" class="headerlink" title="HeadFirst 核心代码"></a>HeadFirst 核心代码</h2><h3 id="饿汉型-（不推荐）"><a href="#饿汉型-（不推荐）" class="headerlink" title="饿汉型 （不推荐）"></a>饿汉型 （不推荐）</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HazardousTypeSingleton</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> App APP = <span class="hljs-keyword">new</span> App();    <span class="hljs-comment">// 私有构造方法</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">HazardousTypeSingleton</span> <span class="hljs-params">()</span> </span>&#123;&#125;    <span class="hljs-comment">// 类加载时已初始化，不会有多线程的问题</span>    <span class="hljs-function"><span class="hljs-keyword">static</span> App <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"APP - 饿汉型模式"</span>);        <span class="hljs-keyword">return</span> APP;    &#125;&#125;</code></pre><blockquote><p>名字由来：因为随着类加载而加载，显得很“急迫”，所以称之为饿汉型</p></blockquote><p><strong>评价：</strong>这样的写法和全局变量没有本质的区别，不推荐</p><h3 id="懒汉型-（不推荐）"><a href="#懒汉型-（不推荐）" class="headerlink" title="懒汉型 （不推荐）"></a>懒汉型 （不推荐）</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyTypeSingleton</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">LazyTypeSingleton</span> <span class="hljs-params">()</span> </span>&#123;&#125;    <span class="hljs-comment">// 静态私用成员，没有初始化</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> App intance = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 直接加synchronized关键字</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">synchronized</span>  <span class="hljs-keyword">static</span> App <span class="hljs-title">getIntance</span> <span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"APP - 懒汉型模式"</span>);        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == intance) &#123;            intance = <span class="hljs-keyword">new</span> App();            <span class="hljs-keyword">return</span> intance;        &#125;        <span class="hljs-keyword">return</span> intance;    &#125;&#125;</code></pre><blockquote><p>名字由来：调用时才加载，因此称之为懒汉型</p></blockquote><p><strong>评价：</strong>这样写有延迟加载的功能，但是加了一个synchronized大锁，因此多线程环境下效率较低</p><h3 id="懒汉型之双重锁校验-🧡"><a href="#懒汉型之双重锁校验-🧡" class="headerlink" title="懒汉型之双重锁校验 🧡"></a>懒汉型之双重锁校验 🧡</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyTypeSingleton</span> </span>&#123;    <span class="hljs-comment">// volatile关键字修饰，防止指令重排</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> App app = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * Double Check Lock（DCL） 双重锁校验</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">static</span> App <span class="hljs-title">getInstanceByDCL</span> <span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == app) &#123;            <span class="hljs-keyword">synchronized</span> (LazyTypeSingleton<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == app) &#123;                    System.out.println(<span class="hljs-string">"APP - 饿汉模式DCL 双重锁校验"</span>);                    app = <span class="hljs-keyword">new</span> App();                    <span class="hljs-keyword">return</span> app;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> app;    &#125;&#125;</code></pre><blockquote><p>注意volatile关键字起到的作用，详情请见：<a href="https://juejin.im/post/5ebadd9df265da7bda414c20" target="_blank" rel="noopener">https://juejin.im/post/5ebadd9df265da7bda414c20</a></p></blockquote><p><strong>评价：</strong>比较推荐的写法，可以保证线程安全，同时具备延时加载的效果</p><h3 id="静态内部类方式🧡"><a href="#静态内部类方式🧡" class="headerlink" title="静态内部类方式🧡"></a>静态内部类方式🧡</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnterTypeSingleton</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">InnterTypeSingleton</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException();    &#125;    <span class="hljs-comment">// 静态内部类方式，类似饿汉保证天然的线程安全</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span></span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> App app = <span class="hljs-keyword">new</span> App();    &#125;    <span class="hljs-function"><span class="hljs-keyword">static</span> App <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"APP - 静态内部类方式(Holder)"</span>);        <span class="hljs-keyword">return</span> SingletonHolder.app;    &#125;&#125;</code></pre><p><strong>评价：</strong>线程安全，调用效率高，可以延时加载</p><h3 id="静态内部类之神奇的报错"><a href="#静态内部类之神奇的报错" class="headerlink" title="静态内部类之神奇的报错"></a>静态内部类之神奇的报错</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnterTypeSingletonError</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">InnterTypeSingletonError</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-number">5</span> / <span class="hljs-number">0</span>);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span></span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> InnterTypeSingletonError app = <span class="hljs-keyword">new</span> InnterTypeSingletonError();    &#125;    <span class="hljs-function"><span class="hljs-keyword">static</span> InnterTypeSingletonError <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"APP - 静态内部类方式(Holder)"</span>);        <span class="hljs-keyword">return</span> SingletonHolder.app;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        <span class="hljs-keyword">try</span> &#123;            InnterTypeSingletonError.getInstance();        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;            t.printStackTrace();        &#125;        <span class="hljs-keyword">try</span> &#123;            InnterTypeSingletonError.getInstance();        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;            t.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>注意看上文中代码块：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">InnterTypeSingletonError</span><span class="hljs-params">()</span></span>&#123;System.out.println(<span class="hljs-number">5</span> / <span class="hljs-number">0</span>);&#125;</code></pre><p>这样一定会出错，运行结果报错信息如下：</p><pre><code class="hljs properties"><span class="hljs-attr">APP</span> <span class="hljs-string">- 静态内部类方式(Holder)</span><span class="hljs-attr">APP</span> <span class="hljs-string">- 静态内部类方式(Holder)</span><span class="hljs-attr">java.lang.ExceptionInInitializerError</span><span class="hljs-attr">at</span> <span class="hljs-string">com.design.singleton.InnterTypeSingletonError.getInstance(InnterTypeSingletonError.java:23)</span><span class="hljs-attr">at</span> <span class="hljs-string">com.design.singleton.InnterTypeSingletonError.main(InnterTypeSingletonError.java:28)</span><span class="hljs-attr">Caused</span> <span class="hljs-string">by: java.lang.ArithmeticException: / by zero</span><span class="hljs-attr">at</span> <span class="hljs-string">com.design.singleton.InnterTypeSingletonError.&lt;init&gt;(InnterTypeSingletonError.java:14)</span><span class="hljs-attr">at</span> <span class="hljs-string">com.design.singleton.InnterTypeSingletonError.&lt;init&gt;(InnterTypeSingletonError.java:11)</span><span class="hljs-attr">at</span> <span class="hljs-string">com.design.singleton.InnterTypeSingletonError$SingletonHolder.&lt;clinit&gt;(InnterTypeSingletonError.java:18)</span><span class="hljs-meta">...</span> <span class="hljs-string">2 more</span><span class="hljs-meta">java.lang.NoClassDefFoundError</span>: <span class="hljs-string">Could not initialize class com.design.singleton.InnterTypeSingletonError$SingletonHolder</span><span class="hljs-attr">at</span> <span class="hljs-string">com.design.singleton.InnterTypeSingletonError.getInstance(InnterTypeSingletonError.java:23)</span><span class="hljs-attr">at</span> <span class="hljs-string">com.design.singleton.InnterTypeSingletonError.main(InnterTypeSingletonError.java:34)</span></code></pre><p>可以发现它第一次报错是正常的异常，第二次如果再报错就是<font color="blue">Could not initialize class </font>，为什么呢？</p><p>因为：<strong>类加载时静态变量只会在第一次加载时，进行初始化，此后不管成不成功，都不会进行第二次初始化了</strong></p><p>所以使用的时候需要注意</p><h3 id="枚举方式🧡"><a href="#枚举方式🧡" class="headerlink" title="枚举方式🧡"></a>枚举方式🧡</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span>  EnumSingleton &#123;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * APP对象</span><span class="hljs-comment">     */</span>    APP;    <span class="hljs-keyword">private</span> App app;    EnumSingleton() &#123;        app = <span class="hljs-keyword">new</span> App();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> App <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"**************************"</span>);        System.out.println(<span class="hljs-string">"APP - 枚举方式"</span>);        <span class="hljs-keyword">return</span> app;    &#125;&#125;</code></pre><p><strong>评价：</strong>线程安全，调用效率高，不能延时加载，可以天然的防止反射和反序列化调用</p><h3 id="什么场景适用"><a href="#什么场景适用" class="headerlink" title="什么场景适用"></a>什么场景适用</h3><p>在以下情况可以使用单例模式：</p><ul><li>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时</li><li>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时</li></ul><h3 id="Code-生活中的实际应用"><a href="#Code-生活中的实际应用" class="headerlink" title="Code/生活中的实际应用"></a>Code/生活中的实际应用</h3><p>在很多项目中的数据库连接池，亦或是配置中心，配置文件对象等等，非常常见~</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>感谢Java3Y的文章：<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247487997&idx=1&sn=49c53a5cd66a6abf6cdf261de501206a&chksm=ebd750fcdca0d9eab476e21dfae06a4a81da4732fdc8698536e6466a7c8843ab6d9dcfa3a003&scene=126&sessionid=1590301045&key=b1bca8bd86b0ad8c164b148788862fa06cb138632b5964ec6f43017e86abb318e4ae4ace123f10a8a5cddff82896564cc9aaf68ba9a06e75a7c15da859f29061a6ca6b313fc185edf422dd6fd48b1778&ascene=1&uin=MjMxMjY2NTAwMw%3D%3D&devicetype=Windows+10+x64&version=62090070&lang=zh_CN&exportkey=Ac5DfHaLdHapqlkgTQV%2F0uY%3D&pass_ticket=52XHEG2v%2F3jbLNsGB58V0iQlGTQCZcBqIQ64EdwtExoOuAs8XSGQBjaGtniIitaV" target="_blank" rel="noopener">三歪写Bug写哭了</a>，从中学习到了内部类使用时的神器报错</p><p>单例模式使用的场景其实固化，任何需要单一对象工作时的场景都可以使用单例模式，同时只推荐以下三种写法：</p><ul><li>基于双重锁校验的懒汉型</li><li>静态内部类方式</li><li>枚举方式</li></ul><h2 id="相关代码链接"><a href="#相关代码链接" class="headerlink" title="相关代码链接"></a>相关代码链接</h2><p><a href="https://github.com/kkzhilu/Kerwin-DesignPattern" target="_blank" rel="noopener">GitHub地址</a></p><ul><li>兼顾了《HeadFirst》以及《GOF》两本经典书籍中的案例</li><li>提供了友好的阅读指导</li></ul><p><img src="/2023/09/12/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/%E5%BE%AE%E4%BF%A1%E4%BA%8C%E7%BB%B4%E7%A0%81.png" srcset="/img/loading.gif" alt></p>]]></content>
    
    
    <categories>
      
      <category>编码及设计模式篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单例模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原型模式</title>
    <link href="/2023/09/12/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/09/12/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="原型模式篇"><a href="#原型模式篇" class="headerlink" title="原型模式篇"></a>原型模式篇</h1><h3 id="官方解释"><a href="#官方解释" class="headerlink" title="官方解释"></a>官方解释</h3><p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。</p><h3 id="命令模式生活中使用"><a href="#命令模式生活中使用" class="headerlink" title="命令模式生活中使用"></a>命令模式生活中使用</h3><p>用原型模式实现细胞分裂</p><p>分析：所有细胞的构造，构造都相同，无需重新从无到有的创建，而是以类似克隆的方式即可</p><h3 id="官方示例"><a href="#官方示例" class="headerlink" title="官方示例"></a>官方示例</h3><p>Head First：<a href="https://www.cnblogs.com/xcsn/p/7352136.html" target="_blank" rel="noopener">https://www.cnblogs.com/xcsn/p/7352136.html</a></p><p>菜鸟教程：<a href="https://www.runoob.com/design-pattern/prototype-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/prototype-pattern.html</a></p><p>简书：<a href="https://www.jianshu.com/p/1e41ee3ac4b5" target="_blank" rel="noopener">https://www.jianshu.com/p/1e41ee3ac4b5</a></p><h3 id="工作举例"><a href="#工作举例" class="headerlink" title="工作举例"></a>工作举例</h3><pre><code class="hljs crystal">详情见：<span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/github.com/kkzhilu</span><span class="hljs-regexp">/KerwinTools/tree</span><span class="hljs-regexp">/master/src</span><span class="hljs-regexp">/main/java</span><span class="hljs-regexp">/design/pattern</span>原型模式相关</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 总结</span><span class="hljs-comment"> *    原型模式分为：</span><span class="hljs-comment"> *        Shallow cloning 浅克隆</span><span class="hljs-comment"> *        Deep cloning    深克隆</span><span class="hljs-comment"> *       （实质是Java中关于引用传递的问题）</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 特点</span><span class="hljs-comment"> *    A. 原型模式克隆,不会克隆final关键字的对象，两者不可兼容，另外克隆不会执行构造方法（内存操作，无视构造方法和访问权限）</span><span class="hljs-comment"> *    B. 原型模式是在内存二进制流的拷贝，要比直接new一个对象性能好很多，特别是在一个循环体内产生大量的对象时，原型模式可以更好地体现其优点</span><span class="hljs-comment"> *    C. 从工厂方法到模板...到原型模式  创建对象的方式慢慢从编码过度到基于内存</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 浅度克隆：当被克隆的类中有引用对象（String或Integer等包装类型除外）时，</span><span class="hljs-comment"> *    克隆出来的类中的引用变量存储的还是之前的内存地址，也就是说克隆与被克隆的对象是同一个</span><span class="hljs-comment"> *    这样的话两个对象共享了一个私有变量，所有人都可以改，是一个种非常不安全的方式，在实际项目中使用还是比较少的</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 深度拷贝：final 类型修饰的成员变量不能进行深度拷贝</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 使用场景：</span><span class="hljs-comment"> *     1、在创建对象的时候，我们不只是希望被创建的对象继承其基类的基本结构，还希望继承原型对象的数据。</span><span class="hljs-comment"> * 　　2、希望对目标对象的修改不影响既有的原型对象（深度克隆的时候可以完全互不影响）。</span><span class="hljs-comment"> * 　　3、隐藏克隆操作的细节，很多时候，对对象本身的克隆需要涉及到类本身的数据细节。</span><span class="hljs-comment"> * 　　4、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等；</span><span class="hljs-comment"> * 　　5、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式；</span><span class="hljs-comment"> * 　　6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用</span><span class="hljs-comment"> *    在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone的方法创建一个对象，</span><span class="hljs-comment"> *    然后由工厂方法提供给调用者。</span><span class="hljs-comment"> */</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>编码及设计模式篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原型模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>布隆过滤器</title>
    <link href="/2023/09/12/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <url>/2023/09/12/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><h2 id="什么是布隆过滤器"><a href="#什么是布隆过滤器" class="headerlink" title="什么是布隆过滤器"></a>什么是布隆过滤器</h2><p>本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。</p><p>相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的</p><h2 id="布隆过滤器数据结构"><a href="#布隆过滤器数据结构" class="headerlink" title="布隆过滤器数据结构"></a>布隆过滤器数据结构</h2><p>布隆过滤器是一个 bit 向量或者说 bit 数组，长这样：</p><p><img src="/2023/09/12/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/image-20210418134922226.png" srcset="/img/loading.gif" alt="image-20210418134922226"></p><p>如果我们要映射一个值到布隆过滤器中，我们需要使用多个不同的哈希函数生成多个哈希值，并对每个生成的哈希值指向的 bit 位置 1，例如针对值 “baidu” 和三个不同的哈希函数分别生成了哈希值 1、4、7，则上图转变为：</p><p><img src="/2023/09/12/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/image-20210418134953198.png" srcset="/img/loading.gif" alt="image-20210418134953198"></p><p>Ok，我们现在再存一个值 “tencent”，如果哈希函数返回 3、4、8 的话，图继续变为：</p><p><img src="/2023/09/12/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/image-20210418135011510.png" srcset="/img/loading.gif" alt="image-20210418135011510"></p><p>值得注意的是，4 这个 bit 位由于两个值的哈希函数都返回了这个 bit 位，因此它被覆盖了。现在我们如果想查询 “dianping” 这个值是否存在，哈希函数返回了 1、5、8三个值，结果我们发现 5 这个 bit 位上的值为 0，说明没有任何一个值映射到这个 bit 位上，因此我们可以很确定地说 “dianping” 这个值不存在。而当我们需要查询 “baidu” 这个值是否存在的话，那么哈希函数必然会返回 1、4、7，然后我们检查发现这三个 bit 位上的值均为 1，那么我们可以说 “baidu” 存在了么？答案是不可以，只能是 “baidu” 这个值可能存在。</p><p>这是为什么呢？答案跟简单，因为随着增加的值越来越多，被置为 1 的 bit 位也会越来越多，这样某个值 “taobao” 即使没有被存储过，但是万一哈希函数返回的三个 bit 位都被其他值置位了 1 ，那么程序还是会判断 “taobao” 这个值存在</p><h2 id="支持删除么"><a href="#支持删除么" class="headerlink" title="支持删除么"></a>支持删除么</h2><p>目前我们知道布隆过滤器可以支持 add 和 isExist 操作，那么 delete 操作可以么，答案是不可以，例如上图中的 bit 位 4 被两个值共同覆盖的话，一旦你删除其中一个值例如 “tencent” 而将其置位 0，那么下次判断另一个值例如 “baidu” 是否存在的话，会直接返回 false，而实际上你并没有删除它。</p><p>如何解决这个问题，答案是计数删除。但是计数删除需要存储一个数值，而不是原先的 bit 位，会增大占用的内存大小。这样的话，增加一个值就是将对应索引槽上存储的值加一，删除则是减一，判断是否存在则是看值是否大于0</p><h2 id="快速集成BloomFilter"><a href="#快速集成BloomFilter" class="headerlink" title="快速集成BloomFilter"></a>快速集成BloomFilter</h2><p>关于布隆过滤器，我们不需要自己实现，谷歌已经帮我们实现好了。</p><ul><li>pom引入依赖</li></ul><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.google.guava/guava --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>25.1-jre<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><ul><li>核心api</li></ul><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">   * Creates a &#123;<span class="hljs-doctag">@link</span> BloomFilter BloomFilter&lt;T&gt;&#125; with the expected number of</span><span class="hljs-comment">   * insertions and expected false positive probability.</span><span class="hljs-comment">   *</span><span class="hljs-comment">   * &lt;p&gt;Note that overflowing a &#123;<span class="hljs-doctag">@code</span> BloomFilter&#125; with significantly more elements</span><span class="hljs-comment">   * than specified, will result in its saturation, and a sharp deterioration of its</span><span class="hljs-comment">   * false positive probability.</span><span class="hljs-comment">   *</span><span class="hljs-comment">   * &lt;p&gt;The constructed &#123;<span class="hljs-doctag">@code</span> BloomFilter&lt;T&gt;&#125; will be serializable if the provided</span><span class="hljs-comment">   * &#123;<span class="hljs-doctag">@code</span> Funnel&lt;T&gt;&#125; is.</span><span class="hljs-comment">   *</span><span class="hljs-comment">   * &lt;p&gt;It is recommended that the funnel be implemented as a Java enum. This has the</span><span class="hljs-comment">   * benefit of ensuring proper serialization and deserialization, which is important</span><span class="hljs-comment">   * since &#123;<span class="hljs-doctag">@link</span> #equals&#125; also relies on object identity of funnels.</span><span class="hljs-comment">   *</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> funnel the funnel of T's that the constructed &#123;<span class="hljs-doctag">@code</span> BloomFilter&lt;T&gt;&#125; will use</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> expectedInsertions the number of expected insertions to the constructed</span><span class="hljs-comment">   *     &#123;<span class="hljs-doctag">@code</span> BloomFilter&lt;T&gt;&#125;; must be positive</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> fpp the desired false positive probability (must be positive and less than 1.0)</span><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> a &#123;<span class="hljs-doctag">@code</span> BloomFilter&#125;</span><span class="hljs-comment">   */</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">BloomFilter&lt;T&gt; <span class="hljs-title">create</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">      Funnel&lt;T&gt; funnel, <span class="hljs-keyword">int</span> expectedInsertions <span class="hljs-comment">/* n */</span>, <span class="hljs-keyword">double</span> fpp)</span> </span>&#123;    checkNotNull(funnel);    checkArgument(expectedInsertions &gt;= <span class="hljs-number">0</span>, <span class="hljs-string">"Expected insertions (%s) must be &gt;= 0"</span>,        expectedInsertions);    checkArgument(fpp &gt; <span class="hljs-number">0.0</span>, <span class="hljs-string">"False positive probability (%s) must be &gt; 0.0"</span>, fpp);    checkArgument(fpp &lt; <span class="hljs-number">1.0</span>, <span class="hljs-string">"False positive probability (%s) must be &lt; 1.0"</span>, fpp);    <span class="hljs-keyword">if</span> (expectedInsertions == <span class="hljs-number">0</span>) &#123;      expectedInsertions = <span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">/*</span><span class="hljs-comment">     * TODO(user): Put a warning in the javadoc about tiny fpp values,</span><span class="hljs-comment">     * since the resulting size is proportional to -log(p), but there is not</span><span class="hljs-comment">     * much of a point after all, e.g. optimalM(1000, 0.0000000000000001) = 76680</span><span class="hljs-comment">     * which is less than 10kb. Who cares!</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">long</span> numBits = optimalNumOfBits(expectedInsertions, fpp);    <span class="hljs-keyword">int</span> numHashFunctions = optimalNumOfHashFunctions(expectedInsertions, numBits);    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BloomFilter&lt;T&gt;(<span class="hljs-keyword">new</span> BitArray(numBits), numHashFunctions, funnel,          BloomFilterStrategies.MURMUR128_MITZ_32);    &#125; <span class="hljs-keyword">catch</span> (IllegalArgumentException e) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Could not create BloomFilter of "</span> + numBits + <span class="hljs-string">" bits"</span>, e);    &#125;  &#125;<span class="hljs-comment">/**</span><span class="hljs-comment">   * Returns &#123;<span class="hljs-doctag">@code</span> true&#125; if the element &lt;i&gt;might&lt;/i&gt; have been put in this Bloom filter,</span><span class="hljs-comment">   * &#123;<span class="hljs-doctag">@code</span> false&#125; if this is &lt;i&gt;definitely&lt;/i&gt; not the case.</span><span class="hljs-comment">   */</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">mightContain</span><span class="hljs-params">(T object)</span> </span>&#123;    <span class="hljs-keyword">return</span> strategy.mightContain(object, funnel, numHashFunctions, bits);  &#125;</code></pre><ul><li>一个小例子</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String... args)</span></span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 创建一个插入对象为一亿，误报率为0.01%的布隆过滤器</span><span class="hljs-comment">     */</span>    BloomFilter&lt;CharSequence&gt; bloomFilter = BloomFilter.create(Funnels.stringFunnel(Charset.forName(<span class="hljs-string">"utf-8"</span>)), <span class="hljs-number">100000000</span>, <span class="hljs-number">0.0001</span>);    bloomFilter.put(<span class="hljs-string">"121"</span>);    bloomFilter.put(<span class="hljs-string">"122"</span>);    bloomFilter.put(<span class="hljs-string">"123"</span>);    System.out.println(bloomFilter.mightContain(<span class="hljs-string">"121"</span>));&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构及算法篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>布隆过滤器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度分页通用解决方案</title>
    <link href="/2023/09/12/%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2023/09/12/%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h2 id="面试题-amp-真实经历"><a href="#面试题-amp-真实经历" class="headerlink" title="面试题 &amp; 真实经历"></a>面试题 &amp; 真实经历</h2><blockquote><p>面试题：在数据量很大的情况下，怎么实现深度分页？</p></blockquote><p>大家在面试时，或者准备面试中可能会遇到上述的问题，大多的回答基本上是<code>分库分表建索引</code>，这是一种很<code>标准的正确回答</code>，但现实总是很骨感，所以面试官一般会追问你一句，<font color="red">现在工期不足，人员不足，该怎么实现深度分页？</font></p><p>这个时候没有实际经验的同学基本麻爪，So，请听我娓娓道来。</p><h2 id="惨痛的教训"><a href="#惨痛的教训" class="headerlink" title="惨痛的教训"></a>惨痛的教训</h2><p><strong><em>首先必须明确一点：</em></strong>深度分页可以做，但是<font color="red">深度随机跳页绝对需要禁止。</font></p><p>上一张图：</p><p><img src="/2023/09/12/%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20200714233120650.png" srcset="/img/loading.gif" alt="image-20200714233120650"></p><p>你们猜，我点一下第<code>142360</code>页，服务会不会爆炸？</p><p>像<code>MySQL</code>，<code>MongoDB</code>数据库还好，本身就是专业的数据库，处理的不好，最多就是慢，但如果涉及到<code>ES</code>，性质就不一样了，我们不得不利用 <code>SearchAfter</code> Api，去循环获取数据，这就牵扯到内存占用的问题，如果当时代码写的不优雅，直接就可能导致内存溢出。</p><h2 id="为什么不能允许随机深度跳页"><a href="#为什么不能允许随机深度跳页" class="headerlink" title="为什么不能允许随机深度跳页"></a>为什么不能允许随机深度跳页</h2><p>从技术的角度浅显的聊一聊为什么不能允许随机深度跳页，或者说为什么不建议深度分页</p><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p>分页的基本原理：</p><pre><code class="hljs mysql">SELECT * FROM test ORDER BY id DESC LIMIT 10000, 20;</code></pre><p>LIMIT 10000 , 20的意思扫描满足条件的10020行，扔掉前面的10000行，返回最后的20行。如果是LIMIT 1000000 , 100，需要扫描1000100 行，在一个高并发的应用里，每次查询需要扫描超过100W行，不炸才怪。</p><h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><p>分页的基本原理：</p><pre><code class="hljs mysql">db.t_data.find().limit(5).skip(5);</code></pre><p>同样的，随着页码的增大，skip 跳过的条目也会随之变大，而这个操作是通过 cursor 的迭代器来实现的，对于cpu的消耗会非常明显，当页码非常大时且频繁时，必然爆炸。</p><h3 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h3><p>从业务的角度来说，<code>ElasticSearch</code>不是典型的数据库，它是一个搜索引擎，如果在筛选条件下没有搜索出想要的数据，继续深度分页也不会找到想要的数据，退一步讲，假如我们把<code>ES</code>作为数据库来使用进行查询，在进行分页的时候一定会遇到<code>max_result_window</code>的限制，看到没，官方都告诉你最大偏移量限制是一万。</p><p>查询流程：</p><ol><li>如查询第501页，每页10条，客户端发送请求到某节点</li><li>此节点将数据广播到各个分片，各分片各自查询前 5010 条数据</li><li>查询结果返回至该节点，然后对数据进行整合，取出前 5010 条数据</li><li>返回给客户端</li></ol><p>由此可以看出为什么要限制偏移量，另外，如果使用 <code>Search After</code> 这种滚动式API进行深度跳页查询，也是一样需要每次滚动几千条，可能一共需要滚动上百万，千万条数据，就为了最后的20条数据，效率可想而知。</p><h2 id="再次和产品对线"><a href="#再次和产品对线" class="headerlink" title="再次和产品对线"></a>再次和产品对线</h2><p><font color="red">俗话说的好，技术解决不了的问题，就由业务来解决！</font></p><p>在实习的时候信了产品的邪，必须实现深度分页 + 跳页，如今必须<code>拨乱反正</code>，业务上必须有如下更改：</p><ul><li><font color="red">尽可能的增加默认的筛选条件，如：时间周期</font>，目的是为了减少数据量的展示</li><li><font color="red">修改跳页的展现方式，改为滚动显示，或小范围跳页</font></li></ul><p>滚动显示参考图：</p><p><img src="/2023/09/12/%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20200715001921905.png" srcset="/img/loading.gif" alt="image-20200715001921905"></p><p>小规模跳页参考图：</p><p><img src="/2023/09/12/%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20200715001959027.png" srcset="/img/loading.gif" alt="image-20200715001959027"></p><h2 id="通用解决方案"><a href="#通用解决方案" class="headerlink" title="通用解决方案"></a>通用解决方案</h2><p>短时间内快速解决的方案主要是以下几点：</p><ul><li>必备：对排序字段，筛选条件务必设置好索引</li><li>核心：<font color="red">利用小范围页码的已知数据，或者滚动加载的已知数据，减少偏移量</font></li><li>额外：如果遇到不好处理的情况，也可以获取多余的数据，进行一定的截取，性能影响并不大</li></ul><h3 id="MySQL-1"><a href="#MySQL-1" class="headerlink" title="MySQL"></a>MySQL</h3><p>原分页SQL：</p><pre><code class="hljs mysql"># 第一页SELECT * FROM &#96;year_score&#96; where &#96;year&#96; &#x3D; 2017 ORDER BY id limit 0, 20;# 第N页SELECT * FROM &#96;year_score&#96; where &#96;year&#96; &#x3D; 2017 ORDER BY id limit (N - 1) * 20, 20;</code></pre><p>通过上下文关系，改写为：</p><pre><code class="hljs mysql"># XXXX 代表已知的数据SELECT * FROM &#96;year_score&#96; where &#96;year&#96; &#x3D; 2017 and id &gt; XXXX ORDER BY id limit 20;</code></pre><p>在 <a href="https://juejin.im/post/5ea16dede51d45470b4ffc5b#heading-9" target="_blank" rel="noopener">没内鬼，来点干货！SQL优化和诊断</a> 一文中提到过，LIMIT会在满足条件下停止查询，因此该方案的扫描总量会急剧减少，效率提升Max！</p><h3 id="ES"><a href="#ES" class="headerlink" title="ES"></a>ES</h3><p>方案和<code>MySQL</code>相同，此时我们就可以随用所欲的使用 <code>FROM-TO</code> Api，而且不用考虑最大限制的问题。</p><h3 id="MongoDB-1"><a href="#MongoDB-1" class="headerlink" title="MongoDB"></a>MongoDB</h3><p>方案基本类似，基本代码如下：</p><p><img src="/2023/09/12/%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/6635252.png" srcset="/img/loading.gif" alt="img"></p><p>相关性能测试：</p><p><img src="/2023/09/12/%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/5698435.png" srcset="/img/loading.gif" alt="img"></p><h2 id="我的方案：基于时间分割"><a href="#我的方案：基于时间分割" class="headerlink" title="我的方案：基于时间分割"></a>我的方案：基于时间分割</h2><p>我这次的数据展现方案，最终定的是时间分割策略，因为我们的数据展现都会有时间排序，示意图如下：</p><p><img src="/2023/09/12/%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20200723163317073.png" srcset="/img/loading.gif" alt></p><h2 id="如果非要深度随机跳页"><a href="#如果非要深度随机跳页" class="headerlink" title="如果非要深度随机跳页"></a>如果非要深度随机跳页</h2><p>如果你没有杠过产品经理，又该怎么办呢，没关系，还有一丝丝的机会。</p><p>在 <a href="https://juejin.im/post/5ea16dede51d45470b4ffc5b#heading-8" target="_blank" rel="noopener">SQL优化</a> 一文中还提到过<code>MySQL</code>深度分页的处理技巧，代码如下：</p><pre><code class="hljs mysql"># 反例（耗时129.570s）select * from task_result LIMIT 20000000, 10;# 正例（耗时5.114s）SELECT a.* FROM task_result a, (select id from task_result LIMIT 20000000, 10) b where a.id &#x3D; b.id;# 说明# task_result表为生产环境的一个表，总数据量为3400万，id为主键，偏移量达到2000万</code></pre><p>该方案的核心逻辑即基于<code>聚簇索引</code>，在不通过<code>回表</code>的情况下，快速拿到指定偏移量数据的主键ID，然后利用<code>聚簇索引</code>进行回表查询，此时总量仅为10条，效率很高。</p><p>因此我们在处理<code>MySQL</code>，<code>ES</code>，<code>MongoDB</code>时，也可以采用一样的办法：</p><ol><li>限制获取的字段，只通过筛选条件，深度分页获取主键ID</li><li>通过主键ID定向查询需要的数据</li></ol><p>瑕疵：当偏移量非常大时，耗时较长，如文中的 5s</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>参考文章：<a href="https://mongoing.com/archives/25469" target="_blank" rel="noopener">MongoDB中文社区</a></p><p>参考文章：<a href="https://mongoing.com/archives/25469" target="_blank" rel="noopener">https://mongoing.com/archives/25469</a></p><p>参考文章：<a href="https://my.oschina.net/u/1787735/blog/3024051" target="_blank" rel="noopener">https://my.oschina.net/u/1787735/blog/3024051</a></p><p>参考文章：<a href="https://www.cnblogs.com/kebibuluan/p/12987290.html" target="_blank" rel="noopener">https://www.cnblogs.com/kebibuluan/p/12987290.html</a></p><p>感谢 @程大设计师 为我倾情设计的二维码😜</p><p>如果觉得对你有用的话，不要忘记点个赞啊~</p><p><img src="/2023/09/12/%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/LOGO-1594745448393.jpg" srcset="/img/loading.gif" alt></p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度分页通用解决方案</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第10章  复制</title>
    <link href="/2023/09/12/%E7%AC%AC10%E7%AB%A0%20%20%E5%A4%8D%E5%88%B6/"/>
    <url>/2023/09/12/%E7%AC%AC10%E7%AB%A0%20%20%E5%A4%8D%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="第10章-复制"><a href="#第10章-复制" class="headerlink" title="第10章  复制"></a>第10章  复制</h1><blockquote><p>本文为《高性能Mysql 第三版》第十章读书笔记，Mysql版本为5.5</p></blockquote><h2 id="复制概述"><a href="#复制概述" class="headerlink" title="复制概述"></a>复制概述</h2><p>复制解决的是让一台服务器和其他服务器保持同步。</p><p>Mysql 支持两种复制方式：</p><ul><li>基于行的复制（逻辑复制）</li><li>基于语句的复制，都是通过在主库上记录二进制日志，在备库重放日志的方式实现异步的数据复制</li></ul><p>复制通常不会增加主库的开销，但启用二进制日志会有开销，可能会增加网络IO的开销</p><h3 id="复制解决问题"><a href="#复制解决问题" class="headerlink" title="复制解决问题"></a>复制解决问题</h3><ul><li><p><code>数据分布</code>（mysql复制通常不会给宽带带来太大的压力，但基于行的复制压力会较大）</p></li><li><p><code>负载均衡</code>（ 通过读操作，可以将读操作分布到多个服务器上 ）</p></li><li><p><code>备份</code>（ 复制是备份的技术补充，但不是备份 ）</p></li><li><p><code>高可用性和故障切换</code>（复制能够避免mysql单点失败）</p></li><li><p><code>Mysql升级测试</code>（使用更高版本的mysql作为备库，保证升级全部实例前，查询能够在备库按预期执行）</p></li></ul><h3 id="复制如何工作"><a href="#复制如何工作" class="headerlink" title="复制如何工作"></a>复制如何工作</h3><ol><li><p>在主库上把数据更改记录到二进制日志（Binary log）中</p></li><li><p>备库讲主库上的日志复制到自己的中继日志(Relay log)中</p></li><li><p>备库读取中继日志中的事件，将其重放到备库数据之上</p><p>![image.png](第10章  复制/1584756635094-55651914-ae8d-45db-97f0-d28d6935d078.png) </p></li></ol><p>第一步 是在主库上记录二进制日志</p><p>在每次数据库提交事务完成数据更新前，主库将数据更新的事件记录到二进制日志中，mysql会按照事务提交的顺序，而不是每条语句执行的顺序记录二进制，记录到日志后，告诉存储引擎可以提交事务了</p><p>第二步 备库将主库的二进制日志复制到本地的中继日志中</p><p>首先，备库会启动一个I/O线程，和主库简历普通的客户端连接，然后再主库上启动一个特殊的二进制转储线程（没有对应的sql命令），这个二进制转储线程会读取主库上二进制日志中的事件，如果追赶上了主库，就进入休眠状态，直到主库发送新的事件将其唤醒，备库I/O收到新的事件记录到中继日志中</p><p>第三步 备库的sql线程，从中继日志读取事件并在备库执行，实现备库数据库的更新</p><p>这种架构限制了复制的过程，因为主库并发运行的查询在备库只能串行化查询，只有一个线程来重放中继日志中的事件，这是很多工作负载的瓶颈所在</p><h2 id="配置复制"><a href="#配置复制" class="headerlink" title="配置复制"></a>配置复制</h2><p> 配置复制分为以下3步 ：</p><ul><li>在每台服务器上创建复制账号 </li><li>配置主库和备库 </li><li>通知备库连接到主库并从主库复制数据 </li></ul><h3 id="创建复制账号"><a href="#创建复制账号" class="headerlink" title="创建复制账号"></a>创建复制账号</h3><p>备库的I/O线程会建立一个到主库的TCP/IP连接，主库需要创建一个用户，并赋予合适的权限，备库已该用户名连接到主库并读取二进制日志</p><p>![image.png](第10章  复制/1584775672371-b58f984e-fe3b-49e5-b3f9-5f86644bf0fa-1586164971305.png)</p><p>在主库和备库都创建该账号</p><h3 id="配置主库和备库"><a href="#配置主库和备库" class="headerlink" title="配置主库和备库"></a>配置主库和备库</h3><p>打开二进制日志，并给一个唯一的id,在主库的my.conf文件增加或修改如下</p><p>![image.png](第10章  复制/1584776827840-2b2fa5d2-94d0-47de-b8ff-d24bae98a4cd-1586165001533.png)</p><p>可以使用如下命令 查看</p><p>![image.png](第10章  复制/1584776891242-4c45b0d3-164e-4531-a121-e230444da2ef-1586165001540.png)</p><p>备库也需要在my.cnf中配置</p><p>![image.png](第10章  复制/1584776924199-43289e2f-663a-43a9-9b4f-31db0e7b1ee2-1586165001558.png)</p><p>relay_log:指定中继日志的位置和命名</p><p>log_slave_updates:允许备库将重放的事件也记录到自身的二进制日志中</p><p>如果只开启了二进制日志却没开启 log_salave_update，可能会碰到一些奇怪的现象，比如 可能会导致备库数据被修改，最好使用read_only选项</p><p>tips:</p><p>![image.png](第10章  复制/1584777354295-c306d392-95fb-4b56-896a-4eef7d377c3d-1586165001569.png)</p><h3 id="启动复制"><a href="#启动复制" class="headerlink" title="启动复制"></a>启动复制</h3><p>告诉备库 如何连接到主库并重放二进制日志，这一步不是通过修改my.cnf配置，而是使用change master to 开始复制的基本命令：</p><p> ![image.png](第10章  复制/1584779288120-ff333486-0c45-47b8-b273-1eefabc1b2c6-1586165068577.png) </p><p>因为日志要从头开始读起，MASTER_LOG_POS  参数被设置为0，执行完后可以通过SHOW SLAVE STATUS语句来检查复制是否正确执行 </p><p> ![image.png](第10章  复制/1584779446288-9604ad76-e94e-4003-9ccf-44ec4ebe8baf-1586165085313.png) </p><p>Slave_IO_State、Slave_IO_Running 和 Slave_SQL_Running 这三列显示当前备库尚未运行。日志头从4开始是因为0不是日志真正的开始位置，仅仅意味着“在日志文件头”，mysql知道第一个事件从文件的第四位开始读</p><p>tips:</p><p>事实上 根据show master status 看到的，真正的日志起始位置是98，一旦备库连接到主库就开始工作，现在连接还未发生</p><p>运行命令，开始复制</p><p>![image.png](第10章  复制/1584779758615-cee31637-4133-47a4-b6e8-5d6761d3042e-1586165105653.png)</p><p>执行show slave status命令检查</p><p>![image.png](第10章  复制/1584782316164-f8f5bcdb-fd7d-4779-b66e-6e3fd12223a1-1586165105667.png)</p><p>在主库执行 查看状态</p><p>![image.png](第10章  复制/1584782463834-34d6b08d-10cb-40bb-a1dc-f5303fdef2c4-1586165105729.png)</p><p>在备库执行查看状态</p><p>![image.png](第10章  复制/1584782555636-26cd99fd-bd1b-40ed-a5ce-8fba454a02e8-1586165105754.png)</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第10章  复制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第11章  可扩展的MySQL</title>
    <link href="/2023/09/12/%E7%AC%AC11%E7%AB%A0%20%20%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84MySQL/"/>
    <url>/2023/09/12/%E7%AC%AC11%E7%AB%A0%20%20%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84MySQL/</url>
    
    <content type="html"><![CDATA[<h1 id="第11章-可扩展的MySQL"><a href="#第11章-可扩展的MySQL" class="headerlink" title="第11章  可扩展的MySQL"></a>第11章  可扩展的MySQL</h1><blockquote><p>本文为《高性能Mysql 第三版》第十一章读书笔记，Mysql版本为5.5</p></blockquote><h2 id="什么是可扩展"><a href="#什么是可扩展" class="headerlink" title="什么是可扩展"></a>什么是可扩展</h2><p>性能定义为响应时间</p><p>系统容量表示在一定的时间内完成的工作量，系统的最大吞吐量 不是容量，如达到最大吞吐量，性能会下降，因此系统的真实容量定义为在可接受的性能的情况下能够达到的吞吐量，容量可以简单的认为是处理负载的能力</p><ul><li>数据量</li><li>用户量</li><li>用户活跃度</li><li>相关数据集的大小</li></ul><h3 id="正式的可扩展性定义"><a href="#正式的可扩展性定义" class="headerlink" title="正式的可扩展性定义"></a>正式的可扩展性定义</h3><p>基于种种原因，我们在设备的投入等等，起到的反馈结果并不是线性增长，就如同项目开发而言，理论上人越多效率越高，但实际上其实并不是如此，下图为正式的可扩展性图：</p><p> ![image.png](第11章  可扩展的MySQL/1585709675000-8b97a41d-2a17-49d4-b0c9-34ee3c2e8297.png) </p><h2 id="扩展MySQL"><a href="#扩展MySQL" class="headerlink" title="扩展MySQL"></a>扩展MySQL</h2><p>扩展的几种方式，向上扩展，向外扩展，通过多实例扩展，集群扩展以及向内扩展</p><ul><li>向上扩展（<code>垂直扩展</code>）：购买更多性能强悍的硬件解决 ===》有致命上限，且成本较高</li><li>向外扩展（<code>水平扩展</code>）：主要策略包括，<code>复制，拆分，数据分片</code> ===》无上限的主流做法</li><li>多实例扩展：即针对高性能服务器运行多个MYSQL实例，以达到硬件的最大使用效率</li><li>集群扩展：通过组件数据库集群以此满意更大的数据查询及写入的需求</li><li>对内扩展：简单思路即对表自身进行优化，如将数据归档，不经常用的数据存储到指定的表中等</li></ul><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>负载均衡的思路很简单，在一个服务器集群中尽可能地平衡负载量，通常的做法即在服务器前端设置一个负载均衡器，然后由负载均衡器将请求的连接路由到最空闲的可用服务器。</p><p>负载均衡有五个常见的目的：</p><ul><li>可拓展性：负载均衡对某些扩展策略有帮助，比如读写分离时从备库读数据</li><li>高效性：有利于更有效的使用资源</li><li>可用性：一个灵活的负载均衡方案能够使用时刻保持可用的服务器</li><li>透明性：客户端无需知道是否存在负载均衡装置，完全透明</li><li>一致性：如果应用是有状态的（数据库事务，网站会话）等，那么负载均衡器就应该将相关的查询指向同一个服务器，以防止状态丢失，应用无须跟踪到底连接的是哪个服务器</li></ul><p>MySQL负载均衡的几种常用策略：</p><ul><li>随机</li><li>轮询</li><li>最少连接数</li><li>最快响应</li><li>哈希</li><li>权重</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>正确地扩展 MYSQL并没有看起来那么美好，从第一天就建立下一个 Facebook架构,这并不是正确的方式。</p><p>最好的策略是实现应用所明确需要的，并为可能的快速增长做好预先规划，成功的规划是可以为任何必要的措施筹集资金以满足需求。为可扩展性制定一个数学意义上的定义是很有意义的，就像为性能制定了一个精确概念样。同时,许多可扩展性问题并不是可以从数学上定义的。可能是由于组织内部的问题，例如缺少团队协作或其他不适当的问題。 </p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第11章  可扩展的MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第4章  Schema 与数据类型优化</title>
    <link href="/2023/09/12/%E7%AC%AC4%E7%AB%A0%20%20Schema%20%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%8C%96/"/>
    <url>/2023/09/12/%E7%AC%AC4%E7%AB%A0%20%20Schema%20%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="第4章-Schema-与数据类型优化"><a href="#第4章-Schema-与数据类型优化" class="headerlink" title="第4章  Schema 与数据类型优化"></a>第4章  Schema 与数据类型优化</h1><blockquote><p>本文为《高性能Mysql 第三版》第四章读书笔记，Mysql版本为5.5</p></blockquote><h2 id="选择优化的数据类型"><a href="#选择优化的数据类型" class="headerlink" title="选择优化的数据类型"></a>选择优化的数据类型</h2><pre><code class="hljs 选择合适数据类型的三个原则```">- 更小的通常更好 - 速度更快，占用更少- 简单就好 - 简单数据类型占用更少的CPU周期，例如整型的比字符串操作代价更低- 尽量避免NULL - 查询包含NULL的列，对Mysql来说更难优化，因为会使得索引，索引统计和值比较更为复杂### 整数类型整数的类型有：TINYINT 、SMALLINT、MEDIUMINT、INT、BIGINT，分别使用8，16，24，32，64位存储空间它们存储的值的范围：-2&lt;sup&gt;（N-1）&lt;&#x2F;sup&gt; 到  2&lt;sup&gt;（N-1）&lt;&#x2F;sup&gt;- 1其中N为存储空间的位数Mysql可以为整数类型指定宽度，例如INT(11)，对大多数应用这是没有意义的，它不会限制值的合法范围，只是规定了一些交互工具用来显示字符的个数而已，对于存储和计算来说，INT(1) 和 INT(20) 是相同的### 实数类型在mysql的数据类型中浮点型分为两种，float()与double()类型，定点型为decimal() 数据类型(M,D)  -》M：精度，数据的总长度；  D：标度，小数点后的长度；其区别在于：- 当不指定精度时，Float、Double默认会保存实际精度，而Decimal默认是整数- 当标度不够时，都会四舍五入，但Decimal会警告信息### 字符串类型 VARCHAR 和 CHAR是最主要的字符串类型，CHAR自不必说，实际使用的情况较少，例如存储男&#x2F;女，YES&#x2F;NO等确定长度的字符串，但是这种固定的情况有时候用整型去存储效率更高，所以视情况而定吧VARCHAR存储的是可变长字符串，它比定长类型更节省空间，因为它仅使用必要的空间，它需要用1个或者2个额外字节记录字符串长度BLOB和TEXT类型：- BLOB：二进制存储，没有排序规则和字符集- TEXT：字符串存储，有排序规则和字符集&gt; 当BLOB和TEXT值太大时，InnoDB会使用专门的“外部”存储区域来进行存储，此时每个值在行内都需要1~4个字节存储一个指针，然后在外部存储区域存储实际的值### 日期和时间类型对于日期和时间类型，据我了解到身边的人大多都不会把时间直接存储到数据库中，同时《高性能Mysql》一书中也推荐另一种做法去存储时间，在这里推荐一下，即：通过BIGINT类型存储毫秒&#x2F;微秒级别的时间戳，再显示或者计算的时候都基于时间戳进行计算### 选择标识符选择标识列（identifier column）类型时，不仅要考虑存储类型还要考虑如何进行计算和比较，一旦选定了一种类型，还要确保所有关联表中使用同样的类型，类型之间需要精确匹配（包括UNSIGNED这样的属性）整数通常是ID列最好的选择。使用MD5(),SHA1(),UUID()产生的字符串的值会随机分布在很大的空间中，导致INSERT和一些SELECT语句变得很慢：- 插入值随机写到索引的不同位置，导致页分裂，磁盘随机访问等，详见第五章- 逻辑上相邻的行会分布在磁盘和内存的不同地方- 随机值使得缓存赖以工作的&#96;访问局部性原理&#96;失效。存储UUID值应该移除“-”符号；最好使用UNHEX()函数将UUID值转换为16字节的数字，存储在BINARY(16)列中。检索时可以通过HEX()函数格式化成十六进制格式### 特殊类型数据例如：IPV4地址，人们经常使用 VARCHAR(15)列来存储IP地址。然而,它们实际上是32位无符号整数,不是字符串。用小数点将地址分成四段的表示方法只是为了让人们阅读容易。所以应该用无符号整数存储IP地址，MYSQL提供INET_ATON()和 INET NTOA()函数在这两种表示方法之间转换## MySQL schema 设计中的陷阱我们应该避免以下几种情况的出现：- 太多的列- 太多的关联（上限61张表）- 全能的枚举，变相的枚举- 随随便便的NULL## 范式和反范式反范式的标志：信息冗余随着时代和机器的发展，我们会经常使用空间换时间的策略，因此基本淘汰了完全遵循范式的做法，但是在范式与反范式中间一定要根据业务需求做好设计，减少不必要的空间浪费## 缓存表和汇总表利用Mysql做缓存的可能很少，用作汇总表的可能很多，提供原文中两个场景的较好的解决方案：&#96;&#96;&#96;例如，如何更好的汇总一天中任务执行次数?</code></pre><p>我们可以采用分割的思想，把一天划成小时，一天过去进行数据汇总时全部累加即可</p><p><code>例如，如果统计网站访问人数更合适?</code></p><p>我们当然可以用一条记录总人数，也可以用N天（条）数据记录总人数，然后累加，但是Mysql在执行时候有一定的延时，可能一秒之内有好几十个人点击，那我们可以针对一条数据进行分割成1-100条数据，通过算法求余等等，让100条数据可以均匀的一起工作这样可以大幅度增加效率，最终再汇总即可</p><h2 id="加快ALTER-TABLE操作的速度"><a href="#加快ALTER-TABLE操作的速度" class="headerlink" title="加快ALTER TABLE操作的速度"></a>加快ALTER TABLE操作的速度</h2><p>不知道其他公司对于底层数据库的字段是否会经常调整，反正我们公司每次需求都会涉及数据库字段的调整，每次都需要执行ALTER操作，如何提高效率？</p><ul><li>主从库切换，减少ALTER影响时间</li><li>“影子拷贝”，完全创建新表，然后通过重命名+删除的方式替换旧表（无数据的情况）</li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第4章  Schema 与数据类型优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>策略模式</title>
    <link href="/2023/09/12/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/09/12/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="策略模式篇"><a href="#策略模式篇" class="headerlink" title="策略模式篇"></a>策略模式篇</h1><h2 id="普遍定义"><a href="#普遍定义" class="headerlink" title="普遍定义"></a>普遍定义</h2><p>定义个一个算法族， 各个算法的实现可以相互替换， 算法的实现和具体的算法使用场景隔离</p><h2 id="策略模式的进化"><a href="#策略模式的进化" class="headerlink" title="策略模式的进化"></a>策略模式的进化</h2><p>【<font color="orange">产品</font>】：我需要一堆鸭子，红色的，绿色的，黑色的，还要会飞！还要会叫！</p><p>【<font color="blue">开发</font>】：明白，秒秒钟搞定，N种鸭子只要继承了我的Duck类然后重写，就搞定一切！</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Duck</span> </span>&#123;        <span class="hljs-comment">// 颜色属性</span>    String color;        <span class="hljs-comment">// 飞行方法</span>    fly();        <span class="hljs-comment">// 呱呱叫的方法</span>    quack();&#125;</code></pre><p>Some times later…</p><p>【<font color="red">BOSS</font>】：磕大头！你怎么回事！！！你能不能告诉我为什么橡皮鸭子会在天上飞！！！？？？</p><p>【<font color="blue">开发</font>】：（不敢说话，只有内心独白： 原来无脑继承会出大问题啊…   我是谁…  我在哪…  我该怎么办…）</p><p><img src="/2023/09/12/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/972352-07e55e231b95023f.webp" srcset="/img/loading.gif" alt="img"></p><h3 id="磕大头的十万个问题"><a href="#磕大头的十万个问题" class="headerlink" title="磕大头的十万个问题"></a>磕大头的十万个问题</h3><p>Q1. 以后还有很多奇奇怪怪的情况，谁知道老板哪天要不要让橡皮鸭也飞起来，我该怎么办？</p><p>Q2. 只用封装，继承好像不行，好像还有一个多态？</p><p>Q3. 我该怎么使用多态呢？</p><p>Q4. 我是不是可以把飞这个行为<font color="red"><strong>定义成接口，然后把这个接口……   放到鸭子基类里面去！！！</strong></font></p><p><img src="/2023/09/12/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/972352-caa7a0b67a855303.webp" srcset="/img/loading.gif" alt="img"></p><h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Duck</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 飞行行为是动态的，可能会变的，因此抽成多个接口的组合，而不是让Duck类继承</span><span class="hljs-comment">     */</span>    FlyBehavior flyBehavior;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 每个鸭子的叫声不同，抽象成接口</span><span class="hljs-comment">     */</span>    QuackBehavior quackBehavior;&#125;</code></pre><p>这下子，好像真的就解决了呢，想怎么飞就怎么飞，想怎么叫就怎么叫</p><h2 id="遵循的设计原则"><a href="#遵循的设计原则" class="headerlink" title="遵循的设计原则"></a>遵循的设计原则</h2><ul><li>封装变化</li><li>多用组合，少用继承</li><li>针对接口编程，而不是针对实现编程</li></ul><h2 id="我之前的理解误区"><a href="#我之前的理解误区" class="headerlink" title="我之前的理解误区"></a>我之前的理解误区</h2><p>大家在初学Java的时候，肯定都绕不开设计模式这一Part，那个时候我对策略模式的认知是这样的，核心代码如下：</p><pre><code class="hljs java"><span class="hljs-comment">// 不需要看全貌，就看这一段核心代码</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">strategyChoose</span><span class="hljs-params">(String mainName)</span></span>&#123;    <span class="hljs-keyword">switch</span> (name)&#123;        <span class="hljs-keyword">case</span> <span class="hljs-string">"A"</span>:            story = <span class="hljs-keyword">new</span> StoryB(name);            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-string">"B"</span>:            story = <span class="hljs-keyword">new</span> StoryA(name);            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">default</span>:            story = <span class="hljs-keyword">new</span> StoryB(name);            <span class="hljs-keyword">break</span>;    &#125;&#125;</code></pre><p><font color="red"><strong>以下是错误理解：</strong></font></p><p>我之前认为，策略模式，顾名思义就是定义不同的策略（即算法），然后动态的调用就好了，比如我定义A,B两种策略，然后通过Switch分支语句选择策略就可以</p><p>这样理解的错误点在于：错误的理解了策略模式的重点，而误把工厂模式的策略选择当作策略模式</p><p><font color="red"><strong>现在的理解：</strong></font></p><ul><li>设计模式肯定有其变种，我们不需要太拘泥于条条框框而限制了自我</li><li>任何定义都有其普遍的理解，我们在突破自我的同时，不能完全走偏</li><li>所以<font color="blue"><strong>真正的策略模式核心即：封装行为，依赖接口，组合代替继承</strong>  </font></li></ul><h2 id="为什么策略模式常和工厂模式或枚举混用？"><a href="#为什么策略模式常和工厂模式或枚举混用？" class="headerlink" title="为什么策略模式常和工厂模式或枚举混用？"></a>为什么策略模式常和工厂模式或枚举混用？</h2><p>首先我们知道了策略模式最初的起源和关键点：<strong>行为或者说算法的抽象及接口的组合</strong></p><p>那么问题来了，在我们拥有多种策略的时候，策略的数量和类型会大大增加，那么调用N种策略肯定需要一个简单的逻辑进行更好的调用，那么策略枚举，或者简单工程则会成为我们最先考虑的方式之一，也正因为如此，才会有上文中我出现的理解误区</p><h2 id="生活中的策略模式"><a href="#生活中的策略模式" class="headerlink" title="生活中的策略模式"></a>生活中的策略模式</h2><ul><li><p>LOL里我喜欢玩奶妈，因为奶妈可以加血，那么在英雄技能设计上，加血是一种行为，具体的细节每个英雄都不一样，这就是策略模式的一种体现</p></li><li><p>比如支付场景中我们会抽取支付信息中的订单，状态，付款人，金钱等等信息，但是支付的细节可以是支付宝也可以是微信</p></li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>附上策略模式的UML图</p><p><img src="/2023/09/12/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/image022.png" srcset="/img/loading.gif" alt="图 23. 策略模式的结构"></p><p><img src="/2023/09/12/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/%E5%BE%AE%E4%BF%A1%E4%BA%8C%E7%BB%B4%E7%A0%81.png" srcset="/img/loading.gif" alt></p>]]></content>
    
    
    <categories>
      
      <category>编码及设计模式篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>策略模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编程游戏</title>
    <link href="/2023/09/12/%E7%BC%96%E7%A8%8B%E6%B8%B8%E6%88%8F/"/>
    <url>/2023/09/12/%E7%BC%96%E7%A8%8B%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="这个游戏太难了"><a href="#这个游戏太难了" class="headerlink" title="这个游戏太难了"></a>这个游戏太难了</h1><blockquote><p>作者：码农翻身 - 大刘</p><p>微信公众号：码农翻身</p></blockquote><h2 id="第一关：入门"><a href="#第一关：入门" class="headerlink" title="第一关：入门"></a>第一关：入门</h2><p>怀着好奇和希望开始，去Google、知乎、QQ群或者朋友那里问了一圈，选定了一个方向，开始学习某编程语言以及相关框架。<br>有过犹豫和彷徨，但最终还是咬牙坚持了下来。<br>刚入门掌握的信息比较少，认识不足。容易被忽悠，喜欢与人进行口水战，捍卫自己付出努力的东西：XXX大法好，XXX语言是垃圾， XXX框架是垃圾，XXX IDE是垃圾。     </p><h2 id="第二关：可以应对日常工作，例如简单的CRUD，调用接口"><a href="#第二关：可以应对日常工作，例如简单的CRUD，调用接口" class="headerlink" title="第二关：可以应对日常工作，例如简单的CRUD，调用接口"></a>第二关：可以应对日常工作，例如简单的CRUD，调用接口</h2><p>进入公司，经过熟悉期/学习期以后，正式开始工作，发现日常工作就是实现业务，写接口，调接口。<br>加班不断，一个又一个的需求，身心俱疲。<br>接触更多的技术，迷茫，不知道该如何学起， 什么都看，很多东西都是做个尝试，写个小程序，浅尝辄止。<br>也许停留在这一阶段，踯躅不前好几年，接近三十就会焦虑。<br>被替代性比较强，第一阶段的人虎视眈眈，随时准备上来用自己的青春和热血抢班夺权。<br>可能会离开单纯的编程，转到项目管理，产品经理，销售，技术支持……</p><h2 id="第三关：从项目局部看到整体"><a href="#第三关：从项目局部看到整体" class="headerlink" title="第三关：从项目局部看到整体"></a>第三关：从项目局部看到整体</h2><p>程序员突破了CRUD，就会来到这一关。<br>不满足于当前的工作，开始学会从全局，从端到端看待系统，思考问题。<br>项目代码的核心贡献者，追求高质量的代码，能够看到项目开发中重复的东西，写出高质量的库函数，让大家调用。<br>能够引入、开发新的工具，帮助团队提高生产率。<br>做开发有了成就感，正向循环开始建立，优秀程序员的声望开始传播。<br>简历中有亮点，有了跳槽的主动权。<br>有不少人会被拉去做管理，走上另外一条路。</p><h2 id="第四关：能够看到项目和项目之间通用的东西，这就是看到架构了"><a href="#第四关：能够看到项目和项目之间通用的东西，这就是看到架构了" class="headerlink" title="第四关：能够看到项目和项目之间通用的东西，这就是看到架构了"></a>第四关：能够看到项目和项目之间通用的东西，这就是看到架构了</h2><p>积累了很多项目经验，开始看透语言、框架、甚至项目之间的共同模式，上升到了架构层面。<br>处于团队的核心地位，项目架构的搭建者，技术决策有极大的影响力。<br>需要和客户、技术人员、管理人员频繁打交道，对软技能的要求越来越高。<br>经常接到猎头的电话和邮件。</p><h2 id="第五关：更多的时候是从业务角度思考问题，技术变成了实现业务的手段"><a href="#第五关：更多的时候是从业务角度思考问题，技术变成了实现业务的手段" class="headerlink" title="第五关：更多的时候是从业务角度思考问题，技术变成了实现业务的手段"></a>第五关：更多的时候是从业务角度思考问题，技术变成了实现业务的手段</h2><p>把握行业发展趋势，分析竞争对手，进行产品发展的规划。<br>跟踪新技术，考虑如何用新技术促进业务的发展，或者开辟新的业务。<br>考虑研发团队的发展和转型，以适应业务发展。</p><h2 id="第六关：发现市场机会，用技术来满足，创业！"><a href="#第六关：发现市场机会，用技术来满足，创业！" class="headerlink" title="第六关：发现市场机会，用技术来满足，创业！"></a>第六关：发现市场机会，用技术来满足，创业！</h2><p>发现市场需求（也可能只是一个自我感觉良好的点子），和公司业务不符，或者公司不愿进入，自己想实现最大价值，横下一条心：还是自己干吧！<br>创业成功，走上人生巅峰！<br>创业失败，退回到4或者5。</p>]]></content>
    
    
    <categories>
      
      <category>程序人生篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程游戏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>装饰器模式</title>
    <link href="/2023/09/12/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/09/12/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="装饰器模式篇"><a href="#装饰器模式篇" class="headerlink" title="装饰器模式篇"></a>装饰器模式篇</h1><h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>动态地给一个对象添加一些额外的职责，就增加功能来说，Decorator模式相比生成子类更为灵活</p><p><font color="red">别名：</font>包装器Wrapper</p><h2 id="装饰器模式的诞生"><a href="#装饰器模式的诞生" class="headerlink" title="装饰器模式的诞生"></a>装饰器模式的诞生</h2><p>有时我们希望给某个对象而不是整个类添加一些功能，例如：一个图形用户界面工具箱允许你对任意一个用户界面组件添加一些特性，例如边框。</p><p>使用继承机制是添加功能的一种有效途径，但这种方法不够灵活，因为边框的选择是静态的，用户不能控制对组件加边框的方式和时机。一种较为灵活的方式是将组件嵌入另一个对象中，由这个对象添加边框，我们称这个嵌入的对象为装饰。</p><p>说人话就是：</p><p>【<font color="orange">产品</font>】：开发小哥，我这里有一份代码，你需要调用它的功能并补充公司的额外功能但是不能动它本身的内容，能做到吗？</p><p><img src="/2023/09/12/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/image-20200517200105310.png" srcset="/img/loading.gif" alt="image-20200517200105310"></p><p>【<font color="blue">开发</font>】：哈？怎么可能！怎么可能不改代码还要他功能，还得有额外的功能？难道让我写成这样的？</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">demo</span> <span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 调用原有代码功能</span>    <span class="hljs-comment">// do();</span>        <span class="hljs-comment">// 调用公司功能</span>    <span class="hljs-comment">// doMine();</span>&#125;</code></pre><p>【<font color="red">BOSS</font>】：磕大头！你不觉得这样很low吗？</p><p>【<font color="blue">开发</font>】：可是不这么写我咋改写？</p><p>【<font color="red">BOSS</font>】：你仔细看看原有的代码，<font color="red">它们都实现了同样的接口，这就是一个突破点</font></p><p>【<font color="blue">开发</font>】：我去研究研究….</p><h2 id="HeadFirst-核心代码"><a href="#HeadFirst-核心代码" class="headerlink" title="HeadFirst 核心代码"></a>HeadFirst 核心代码</h2><p>于是乎，我们开启了关于设计模式的经典书籍阅读之旅</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 装饰器模式共同的接口</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Component</span> </span>&#123;    <span class="hljs-function">String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getSpend</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 原本的类</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteComponent</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Component</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteComponent</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getSpend</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 装饰器类 注意它利用了组合的方式，同时注意函数实现的部分</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MilkDecorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Component</span> </span>&#123;    Component coffe;    MilkDecorator(Component coffe) &#123;        <span class="hljs-keyword">this</span>.coffe = coffe;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-keyword">return</span> coffe.getName() + <span class="hljs-string">", 牛奶"</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getSpend</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> coffe.getSpend() + <span class="hljs-number">2</span>D;    &#125;&#125;</code></pre><p><font color="red">装饰器模式的设计思路：</font></p><ul><li>Component：定义一个对象接口，统一行为及父级</li><li>ConcreteComponent：定义一个对象，可以给这个对象添加一些职责（方法）</li><li>Decorator：定义一个跟Component一致的接口，并约束需要实现的职责（方法）</li><li>ConcreteDecorator：维持一个指向Component对象的指针，并实现Component接口，以此增强对象的行为</li></ul><p>简单来说，</p><ol><li>我们需要一个接口来<font color="red">统一父级</font>，并制定一些必要的行为</li><li>默认的实现类实现相关功能</li><li>如果需要额外的增加（装饰），则实现接口并持有接口对象的指针，在实现接口方法时调用指针对象的方法并增强</li></ol><blockquote><p>如果看着有点模棱两可，就看完本文后，访问专题设计模式开源项目，里面有具体的代码示例，链接在最下面</p></blockquote><h2 id="遵循的设计原则"><a href="#遵循的设计原则" class="headerlink" title="遵循的设计原则"></a>遵循的设计原则</h2><ol><li><strong>对扩展开放，对修改关闭</strong>：完美实现了不修改其代码达到增强方法的目的</li><li><strong>针对接口编程</strong>：装饰器与其本身都有同样的父级</li></ol><h2 id="什么场景适合使用"><a href="#什么场景适合使用" class="headerlink" title="什么场景适合使用"></a>什么场景适合使用</h2><p>在不影响其他对象的情况下，以动态，透明的方式给单个对象添加职责</p><h2 id="Code-生活中的实际应用"><a href="#Code-生活中的实际应用" class="headerlink" title="Code/生活中的实际应用"></a>Code/生活中的实际应用</h2><p>Java 中最著名的装饰者模式的应用，就是 <font color="red">java.io</font> 包中的各种<font color="red">InputStream</font> 、<font color="red">Reader</font>和 <font color="red">Writer</font> 的实现类了。如果我们要从文件中读取文本内容，我们可以使用 <font color="red">FileReader（装饰者）</font> 和 <font color="red">FileInputStream（装饰者）</font>；</p><p>但是如果我们想让读取的速度更快，那么我们就需要 <font color="red">BufferedReader（装饰者）</font> ，这只需要改变一行代码就能实现</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p><strong>附上GOF一书中对于装饰器模式的UML图：</strong></p><p><img src="/2023/09/12/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/image-20200517201710466.png" srcset="/img/loading.gif" alt="image-20200517201710466"></p><h2 id="相关代码链接"><a href="#相关代码链接" class="headerlink" title="相关代码链接"></a>相关代码链接</h2><p><a href="https://github.com/kkzhilu/Kerwin-DesignPattern" target="_blank" rel="noopener">GitHub地址</a></p><ul><li>兼顾了《HeadFirst》以及《GOF》两本经典书籍中的案例</li><li>提供了友好的阅读指导</li></ul><p><img src="/2023/09/12/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/%E5%BE%AE%E4%BF%A1%E4%BA%8C%E7%BB%B4%E7%A0%81.png" srcset="/img/loading.gif" alt></p>]]></content>
    
    
    <categories>
      
      <category>编码及设计模式篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>装饰器模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自动化运维-shell</title>
    <link href="/2023/09/12/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4-shell/"/>
    <url>/2023/09/12/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4-shell/</url>
    
    <content type="html"><![CDATA[<h1 id="自动化运维-shell命令"><a href="#自动化运维-shell命令" class="headerlink" title="自动化运维 - shell命令"></a>自动化运维 - shell命令</h1><blockquote><p>文件请见：/相关文件/monitor.sh</p></blockquote><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><span class="hljs-meta">#</span><span class="bash">这里可替换为你自己的执行程序以及日志目录，其他代码无需更改</span>APP_NAME=juejin-news-1.0.0-SNAPSHOT.jarPROPERTIES_PATH=application.properties<span class="hljs-meta">#</span><span class="bash">使用说明，用来提示输入参数</span>usage() &#123;    echo "Usage: sh 执行脚本.sh [start|stop|restart|status]"    exit 1&#125;<span class="hljs-meta">#</span><span class="bash">检查程序是否在运行</span>is_exist()&#123;  pid=`ps -ef|grep $APP_NAME|grep -v grep|grep -v kill|awk '&#123;print $2&#125;' `<span class="hljs-meta">  #</span><span class="bash">如果不存在返回1，存在返回0     </span>  if [ -z "$&#123;pid&#125;" ]; then   return 1  else    return 0  fi&#125;<span class="hljs-meta">#</span><span class="bash">启动方法</span>start()&#123;  is_exist  if [ $? -eq "0" ]; then    echo "$&#123;APP_NAME&#125; is already running. pid=$&#123;pid&#125; ."  else     nohup java -Xms1024m -Xmx1024m -XX:PermSize=128M -XX:MaxNewSize=256m -XX:MaxPermSize=256m -jar -Dspring.config.location=$PROPERTIES_PATH $APP_NAME  &gt; catalina.out  2&gt;&amp;1 &amp;  fi&#125;<span class="hljs-meta">#</span><span class="bash">停止方法</span>stop()&#123;  is_exist  if [ $? -eq "0" ]; then    kill -9 $pid  else    echo "$&#123;APP_NAME&#125; is not running"  fi&#125;<span class="hljs-meta">#</span><span class="bash">输出运行状态</span>status()&#123;  is_exist  if [ $? -eq "0" ]; then    echo "$&#123;APP_NAME&#125; is running. Pid is $&#123;pid&#125;"  else    echo "$&#123;APP_NAME&#125; is NOT running."  fi&#125;<span class="hljs-meta">#</span><span class="bash">重启</span>restart()&#123;  stop  start&#125;<span class="hljs-meta">#</span><span class="bash">根据输入参数，选择执行对应方法，不输入则执行使用说明</span>case "$1" in  "start")    start    ;;  "stop")    stop    ;;  "status")    status    ;;  "restart")    restart    ;;  *)    usage    ;;esac</code></pre><h1 id="简易方式进入Docker"><a href="#简易方式进入Docker" class="headerlink" title="简易方式进入Docker"></a>简易方式进入Docker</h1><blockquote><p>文件请见：/相关文件/docker.sh</p></blockquote><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">使用说明，用来提示输入参数</span>usage() &#123;    echo "Usage: sh 执行脚本.sh [rpcapp|tomcat|nginx|mysql]"    exit 1&#125;rpcapp()&#123;  DOCKER_ID=$(docker ps | grep "rpcapp" | awk '&#123;print $1&#125;')  docker exec -it $DOCKER_ID bash&#125;tomcat()&#123;  DOCKER_ID=$(docker ps | grep "tomcat" | awk '&#123;print $1&#125;')  docker exec -it $DOCKER_ID bash&#125;nginx()&#123;  DOCKER_ID=$(docker ps | grep "nginx" | awk '&#123;print $1&#125;')  docker exec -it $DOCKER_ID bash&#125;mysql()&#123;  DOCKER_ID=$(docker ps | grep "mysql" | awk '&#123;print $1&#125;')  docker exec -it $DOCKER_ID bash&#125;<span class="hljs-meta">#</span><span class="bash">根据输入参数，选择执行对应方法，不输入则执行使用说明</span>case "$1" in  "rpcapp")    rpcapp    ;;  "tomcat")    tomcat    ;;  "nginx")    nginx    ;;  "mysql")    mysql    ;;  *)    usage    ;;esac</code></pre><h1 id="JS-操作-Mongo"><a href="#JS-操作-Mongo" class="headerlink" title="JS 操作 Mongo"></a>JS 操作 Mongo</h1><blockquote><p>文件请见：/相关文件/Mongo_Rebuild_Index.js</p></blockquote><pre><code class="hljs bash"><span class="hljs-comment"># 执行命令</span>mongo xxx.js</code></pre><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> mongoInfo = <span class="hljs-string">"127.0.0.1:27017/pmreal_db"</span>;db = connect(mongoInfo);print(<span class="hljs-string">"connect database. database:"</span> + mongoInfo);<span class="hljs-comment">// 需要调整的表</span><span class="hljs-keyword">var</span> tarray = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-string">"pmonitorScriptRunInfo"</span>);<span class="hljs-comment">// 索引</span><span class="hljs-keyword">var</span> monitorFinishTimeIndexes = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(&#123;<span class="hljs-string">"monitorid"</span>: <span class="hljs-number">1</span>, <span class="hljs-string">"finishTime"</span>: <span class="hljs-number">-1</span>&#125;);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> tindex = <span class="hljs-number">0</span>; tindex &lt; tarray.length; tindex++) &#123;  <span class="hljs-keyword">var</span> tablename = tarray[tindex];  <span class="hljs-keyword">var</span> tableIndexes = monitorFinishTimeIndexes;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;    <span class="hljs-keyword">var</span> tname;    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">10</span>) &#123;      tname = tablename + <span class="hljs-string">"_0"</span> + i;    &#125; <span class="hljs-keyword">else</span> &#123;      tname = tablename + <span class="hljs-string">"_"</span> + i;    &#125;    print(<span class="hljs-string">"Building index. tablename:"</span> + tname);    <span class="hljs-comment">// 建立索引</span>    buildIndex(db, tname, tableIndexes);  &#125;&#125;<span class="hljs-comment">// 建立索引</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildIndex</span>(<span class="hljs-params">db, tablename, tableIndexes</span>) </span>&#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; tableIndexes.length; i++) &#123;    <span class="hljs-keyword">var</span> tableIndex = tableIndexes[i];    db[tablename].ensureIndex(tableIndex, &#123;<span class="hljs-attr">background</span>:<span class="hljs-literal">true</span>&#125;);    print(<span class="hljs-string">"Build index success. tablename:"</span> + tablename + <span class="hljs-string">"; tableindex:"</span> + <span class="hljs-built_in">JSON</span>.stringify(tableIndex));  &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>操作系统篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自动化运维-shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>适配器模式和外观模式</title>
    <link href="/2023/09/12/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/09/12/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p><font color="red">将一个类的接口转换成客户希望的另外一个接口</font>，adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作</p><p>别名：Wrapper包装器</p><h2 id="适配器模式的诞生"><a href="#适配器模式的诞生" class="headerlink" title="适配器模式的诞生"></a>适配器模式的诞生</h2><p>【<font color="orange">产品</font>】：开发小哥，记得我们第一版的需求吗？</p><p>【<font color="blue">开发</font>】：什么玩意？</p><p>【<font color="orange">产品</font>】：我们第一版是不是造了很多鸭子啊，现在需要造一点火鸡，但是客户很奇葩，他们要让<font color="red">鸭子拥有火鸡一样的能力</font>，怎么办？</p><p>【<font color="blue">开发</font>】：把鸭子当火鸡写？</p><p>【<font color="orange">产品</font>】：不行，火鸡是火鸡，鸭子是鸭子，只有特殊的情况才需要混在一起，怎么办呢？</p><p>【<font color="blue">开发</font>】：老大，怎么办呢？</p><p>【<font color="red">BOSS</font>】：什么火鸡鸭子的，它们不都有自己的接口嘛，俩接口刚好用适配器去做，自己去查查资料！</p><p><img src="/2023/09/12/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/image-20200602232759067.png" srcset="/img/loading.gif" alt="image-20200602232759067"></p><h2 id="HeadFirst-核心代码"><a href="#HeadFirst-核心代码" class="headerlink" title="HeadFirst 核心代码"></a>HeadFirst 核心代码</h2><p>根据上文，我们至少知道了一点，玩适配器模式得有俩接口？先当个问题吧，咱们待会再说</p><p><strong>鸭子接口</strong></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 鸭子接口</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Duck</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 鸭叫</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quack</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 飞行</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p><strong>火鸡接口</strong></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 火鸡接口</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Turkey</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 火鸡叫</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">gobble</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 飞行</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p><strong>火鸡实现类</strong></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 火鸡实现类</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WildTurkey</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Turkey</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">gobble</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"咯咯"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"我在飞，虽然我飞的很近"</span>);    &#125;&#125;</code></pre><p><strong>关键点啦！适配！</strong></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 火鸡适配器</span><span class="hljs-comment"> * 实现鸭子接口同时持有火鸡对象，在实现的接口处用火鸡对象的方法填充一下（同时还可以做额外的事情）</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TurkeyAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Duck</span></span>&#123;    Turkey turkey;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quack</span><span class="hljs-params">()</span> </span>&#123;        turkey.gobble();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123;        turkey.fly();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TurkeyAdapter</span><span class="hljs-params">(Turkey turkey)</span> </span>&#123;        <span class="hljs-keyword">this</span>.turkey = turkey;    &#125;&#125;</code></pre><p><font color="red">适配器模式的设计思路</font>：</p><ul><li>Target       定义特定领域接口</li><li>Client        符合Target接口的对象</li><li>Adaptee   定义一个存在的接口，需要适配</li><li>Adapter   适配器</li></ul><p>简单来说，当我们需要对<font color="blue">两个本不相关的接口</font>混合一起用时，<font color="blue">需要用一个适配器实现A接口，持有B对象，再用B对象的方法去填充A接口的方法</font>，同时还可以增加一些其他的逻辑</p><h2 id="和装饰器很像？"><a href="#和装饰器很像？" class="headerlink" title="和装饰器很像？"></a>和装饰器很像？</h2><p>从编程语言的技巧上来看，的确非常的像，我们来梳理一下其相同点和异同点：</p><p><strong><em>相同点：</em></strong></p><ul><li>实现技巧上，都是实现某个接口，同时持有某个对象，用对象的方法去填充需要实现的方法</li></ul><p><strong><em>不同点：</em></strong></p><ul><li>接口个数不同，装饰器一般是单个接口，而适配器则是2个以上接口混合工作</li><li>目的不同，装饰器是为了增强对象的方法，而适配器则是让本不能一起工作的接口混在一起工作</li></ul><h2 id="来一波接口适配器"><a href="#来一波接口适配器" class="headerlink" title="来一波接口适配器"></a>来一波接口适配器</h2><p>接口适配器在Java中很常见，比如：MouseListener之余MouseAdapter</p><p>举个例子：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 定义超多的方法</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InterfaceClass</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">c</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">d</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">e</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p>用一个抽象类去实现接口：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterfaceAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InterfaceClass</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"i have override method a"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;&#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">c</span><span class="hljs-params">()</span> </span>&#123;&#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">d</span><span class="hljs-params">()</span> </span>&#123;&#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">e</span><span class="hljs-params">()</span> </span>&#123;&#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;&#125;&#125;</code></pre><p>这样有什么好处呢？比如MouseAdapter，我们在学习GUI编程的时候肯定用到过，此时我只想重写点击方法，但是直接用接口的话，代码太多了，需要重写一堆的东西，用接口适配器的话，则可以很轻松的减少大量的无用代码，专注自己想要实现的方法即可</p><h2 id="什么场景适用"><a href="#什么场景适用" class="headerlink" title="什么场景适用"></a>什么场景适用</h2><ul><li>你想使用一个已经存在的类，而它的接口不符合你的需求</li><li>你想创建一个可以复用的类，该类可以与其他不相关的类或可能不兼容的类一起工作</li></ul><h2 id="Code-生活中的实际应用"><a href="#Code-生活中的实际应用" class="headerlink" title="Code/生活中的实际应用"></a>Code/生活中的实际应用</h2><p>现在手机都追求全面屏，安卓手机和耳机之间需要一个转接头工作，此时的转接头就是一个适配器，它持有耳机对象，实现手机插孔的接口，最终提供功能的依然是耳机，但它让本来无法联接的物体产生了联系</p><h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><p><img src="/2023/09/12/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/image-20200602234955490.png" srcset="/img/loading.gif" alt="image-20200602234955490"></p><h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><h2 id="意图-1"><a href="#意图-1" class="headerlink" title="意图"></a>意图</h2><p>为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p><p><strong>核心思想：为子系统们提供一套通用的对外接口（高级API）</strong></p><h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><p>该模式过于简单所以直接上代码~</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 定义一个顶层接口</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Computer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cpu</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Computer</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"Cpu Open."</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ram</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Computer</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"Ram Open."</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ssd</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Computer</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"SSD Open."</span>);    &#125;&#125;</code></pre><p><strong>外观类</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FacadeComputer</span> </span>&#123;    <span class="hljs-keyword">private</span> Cpu cpu;    <span class="hljs-keyword">private</span> Ram ram;    <span class="hljs-keyword">private</span> Ssd ssd;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FacadeComputer</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.cpu = <span class="hljs-keyword">new</span> Cpu();        <span class="hljs-keyword">this</span>.ram = <span class="hljs-keyword">new</span> Ram();        <span class="hljs-keyword">this</span>.ssd = <span class="hljs-keyword">new</span> Ssd();    &#125;    <span class="hljs-comment">/** Cpu On **/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCpu</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.cpu.open();    &#125;    <span class="hljs-comment">/** Ram On **/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onRam</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.ram.open();    &#125;    <span class="hljs-comment">/** Ssd On **/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSsd</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.ssd.open();    &#125;    <span class="hljs-comment">/** All On **/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">allOn</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.cpu.open();        <span class="hljs-keyword">this</span>.ram.open();        <span class="hljs-keyword">this</span>.ssd.open();    &#125;&#125;</code></pre><p><strong>调用对比</strong></p><pre><code class="hljs java"><span class="hljs-comment">/****</span><span class="hljs-comment"> * 推荐阅读顺序：</span><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> Computer</span><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> Cpu | Ram | Ssd</span><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> FacadeComputer</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-comment">// 不使用外观模式</span>    Computer cpu = <span class="hljs-keyword">new</span> Cpu();    Computer ram = <span class="hljs-keyword">new</span> Ram();    Computer ssd = <span class="hljs-keyword">new</span> Ssd();    cpu.open();    ram.open();    ssd.open();    CodeUtils.spilt();    <span class="hljs-comment">// 使用外观模式</span>    FacadeComputer facadeComputer = <span class="hljs-keyword">new</span> FacadeComputer();    facadeComputer.allOn();&#125;</code></pre><h2 id="什么场景适用-1"><a href="#什么场景适用-1" class="headerlink" title="什么场景适用"></a>什么场景适用</h2><ul><li>需要为一个复杂的子系统提供一个简单接口时</li><li>客户程序与抽象类的实现部分之间存在着很大依赖性（分离逻辑，提高子系统的独立性和可移植性）</li><li>需要构建一个层次结构的子系统时</li></ul><h2 id="Code-生活中的实际应用-1"><a href="#Code-生活中的实际应用-1" class="headerlink" title="Code/生活中的实际应用"></a>Code/生活中的实际应用</h2><p>外观模式在生活中最好的体现就是基金，基金的本质其实是由专业的团队去集资购买股票，购买股票本身有非常多的流程和注意事项，但是现在我们可以很轻松的下注基金，这就是外观模式的体现之一</p><h1 id="相关代码链接"><a href="#相关代码链接" class="headerlink" title="相关代码链接"></a>相关代码链接</h1><p><a href="https://github.com/kkzhilu/Kerwin-DesignPattern" target="_blank" rel="noopener">GitHub地址</a></p><ul><li>兼顾了《HeadFirst》以及《GOF》两本经典书籍中的案例</li><li>提供了友好的阅读指导</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/6/1/17270943b7c5022b?w=487&h=185&f=png&s=17561" srcset="/img/loading.gif" alt></p>]]></content>
    
    
    <categories>
      
      <category>编码及设计模式篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>适配器模式和外观模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CV程序员的一次进步</title>
    <link href="/2023/09/12/CV%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%B8%80%E6%AC%A1%E8%BF%9B%E6%AD%A5/"/>
    <url>/2023/09/12/CV%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%B8%80%E6%AC%A1%E8%BF%9B%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="CV程序员的一次进步"><a href="#CV程序员的一次进步" class="headerlink" title="CV程序员的一次进步"></a>CV程序员的一次进步</h2><blockquote><p>原文链接：<a href="https://juejin.im/post/5dfe2e72518825125f39a2de?utm_source=gold_browser_extension" target="_blank" rel="noopener">掘金</a></p></blockquote><h3 id="一、调整顺序，让程序更高效"><a href="#一、调整顺序，让程序更高效" class="headerlink" title="一、调整顺序，让程序更高效"></a>一、调整顺序，让程序更高效</h3><p>假设业务需求是这样：会员，第一次登陆时，需要发一条感谢短信。如果没有经过思考，代码直接这样写了</p><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-variable">isUserVip</span> &amp;&amp; <span class="hljs-variable">isFirstLogin</span>)&#123;</span><span class="hljs-function">    <span class="hljs-title">sendMsg</span>();</span><span class="hljs-function">&#125;</span><span class="hljs-function">复制代码</span></code></pre><p><strong>假设总共有5个请求，isUserVip通过的有3个请求，isFirstLogin通过的有1个请求。</strong> 那么以上代码，isUserVip执行的次数为5次，isFirstLogin执行的次数也是3次，如下：</p><p><img src="/2023/09/12/CV%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%B8%80%E6%AC%A1%E8%BF%9B%E6%AD%A5/16f4312ee2db2f80" srcset="/img/loading.gif" alt="img"></p><p><strong>如果调整一下isUserVip和isFirstLogin的顺序呢？</strong></p><pre><code class="hljs java"><span class="hljs-keyword">if</span>(isFirstLogin &amp;&amp; isUserVip )&#123;    sendMsg();&#125;</code></pre><p>isFirstLogin执行的次数是5次，isUserVip执行的次数是1次，如下：</p><p><img src="/2023/09/12/CV%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%B8%80%E6%AC%A1%E8%BF%9B%E6%AD%A5/16f4319b9710a1a9" srcset="/img/loading.gif" alt="img"></p><p><strong>酱紫你的程序是否更高效呢？</strong></p><h3 id="二、是否创建了不必要的对象。"><a href="#二、是否创建了不必要的对象。" class="headerlink" title="二、是否创建了不必要的对象。"></a>二、是否创建了不必要的对象。</h3><p>举个粟子吧，判断用户会员是否处于有效期，通常有以下类似代码：</p><pre><code class="hljs java"><span class="hljs-comment">//判断用户会员是否在有效期</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isUserVIPValid</span><span class="hljs-params">()</span> </span>&#123;  Date now = <span class="hljs-keyword">new</span> Date();  Calendar gmtCal = Calendar.getInstance();  gmtCal.set(<span class="hljs-number">2019</span>, Calendar.JANUARY, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);  Date beginTime = gmtCal.getTime();  gmtCal.set(<span class="hljs-number">2020</span>, Calendar.JANUARY, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);  Date endTime= gmtCal.getTime();  <span class="hljs-keyword">return</span> now.compareTo(beginTime) &gt;= <span class="hljs-number">0</span> &amp;&amp; now.compareTo(endTime) &lt;= <span class="hljs-number">0</span>;&#125;</code></pre><p>但是呢，每次调用isUserVIPValid方法，都会创建Calendar和Date对象。其实吧，除了New Date，其他对象都是不变的，我们可以<strong>抽出全局变量</strong>，<strong>避免创建了不必要的对象</strong>，从而提高程序效率，如下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Date BEGIN_TIME;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Date END_TIME;    <span class="hljs-keyword">static</span> &#123;        Calendar gmtCal = Calendar.getInstance();        gmtCal.set(<span class="hljs-number">2019</span>, Calendar.JANUARY, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);        BEGIN_TIME = gmtCal.getTime();        gmtCal.set(<span class="hljs-number">2020</span>, Calendar.JANUARY, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);        END_TIME = gmtCal.getTime();    &#125;    <span class="hljs-comment">//判断用户会员是否在有效期</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isUserVIPValid</span><span class="hljs-params">()</span> </span>&#123;        Date now = <span class="hljs-keyword">new</span> Date();        <span class="hljs-keyword">return</span> now.compareTo(BEGIN_TIME) &gt;= <span class="hljs-number">0</span> &amp;&amp; now.compareTo(END_TIME) &lt;= <span class="hljs-number">0</span>;    &#125;&#125;</code></pre><h3 id="三、有没有查多了数据？"><a href="#三、有没有查多了数据？" class="headerlink" title="三、有没有查多了数据？"></a>三、有没有查多了数据？</h3><p>大家都知道，查库是比较耗时的操作，尤其数据量大的时候。所以，查询DB时，我们取所需就好，没有必要大包大揽。</p><p>假设业务场景是这样：查询某个用户是否是会员。曾经看过实现代码是这样。。。</p><pre><code class="hljs java">List&lt;Long&gt; userIds = sqlMap.queryList(<span class="hljs-string">"select userId from user where vip=1"</span>);<span class="hljs-keyword">boolean</span> isVip = userIds.contains(userId);</code></pre><p>为什么先把所有会有查出来，再判断是否包含这个useId，来确定useId是否是会员呢？直接把userId传进sql，它不香吗？如下：</p><pre><code class="hljs java">Long userId = sqlMap.queryObject(<span class="hljs-string">"select userId from user where userId='userId' and vip='1' "</span>)<span class="hljs-keyword">boolean</span> isVip = userId！=<span class="hljs-keyword">null</span>;</code></pre><p>实际上，我们除了把查询条件都传过去，避免数据库查多余的数据回来，还可以通过<strong>select 具体字段</strong>代替<code>select *</code>，从而使程序更高效。</p><h3 id="四、加了一行通知类的代码，总不能影响到主要流程吧。"><a href="#四、加了一行通知类的代码，总不能影响到主要流程吧。" class="headerlink" title="四、加了一行通知类的代码，总不能影响到主要流程吧。"></a>四、加了一行通知类的代码，总不能影响到主要流程吧。</h3><p>假设业务流程这样：需要在用户登陆时，添加个短信通知它的粉丝。 很容易想到的实现流程如下：</p><p><img src="/2023/09/12/CV%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%B8%80%E6%AC%A1%E8%BF%9B%E6%AD%A5/16f47ecebb5949d7" srcset="/img/loading.gif" alt="img"></p><p>假设提供sendMsgNotify服务的<strong>系统挂了</strong>，或者<strong>调用sendMsgNotify失败</strong>了，那么用户登陆就失败了。。。</p><p>一个通知功能导致了登陆主流程不可用，明显的捡了芝麻丢西瓜。那么有没有鱼鱼熊掌兼得的方法呢？有的，给发短信接口<strong>捕获异常处理</strong>，或者<strong>另开线程异步处理</strong>，如下：</p><p><img src="/2023/09/12/CV%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%B8%80%E6%AC%A1%E8%BF%9B%E6%AD%A5/16f47f59d45320c4" srcset="/img/loading.gif" alt="img"></p><p>因此，我们添加通知类等不是非主要，可降级的接口时，应该静下心来考虑是否会影响主要流程，思考怎么处理最好。</p><h3 id="五、对空指针保持嗅觉，如使用equals比较时，常量或确定值放左边。"><a href="#五、对空指针保持嗅觉，如使用equals比较时，常量或确定值放左边。" class="headerlink" title="五、对空指针保持嗅觉，如使用equals比较时，常量或确定值放左边。"></a>五、对空指针保持嗅觉，如使用equals比较时，常量或确定值放左边。</h3><p>NullPointException在Java世界早已司空见惯，我们在写代码时，可以三思而后写，尽量避免低级的空指针问题。</p><p>比如有以下业务场景，判断用户是否是会员，经常可见如下代码：</p><pre><code class="hljs java"><span class="hljs-keyword">boolean</span> isVip = user.getUserFlag().equals(<span class="hljs-string">"1"</span>);</code></pre><p>如果让这个行代码上生产环境，待君蓦然回首，可能那空指针bug，就在灯火阑珊处。显然，这样可能会产生空指针异常，因为user.getUserFlag()可能是null。</p><p>怎样避免空指针问题呢？把常量1放到左边就可以啦，如下：</p><pre><code class="hljs java"><span class="hljs-keyword">boolean</span> isVip = <span class="hljs-string">"1"</span>.equals(user.getUserFlag());</code></pre><h3 id="六、你的关键业务代码是否有日志保驾护航？"><a href="#六、你的关键业务代码是否有日志保驾护航？" class="headerlink" title="六、你的关键业务代码是否有日志保驾护航？"></a>六、你的关键业务代码是否有日志保驾护航？</h3><p>关键业务代码无论身处何地，都应该有足够的<strong>日志</strong>保驾护航。</p><p>比如：<strong>你实现转账业务，转个几百万，然后转失败了，接着客户投诉，然后你还没有打印到日志，想想那种水深火热的困境下，你却毫无办法</strong>。。。</p><p>那么，你的转账业务都<strong>需要那些日志信息</strong>呢？至少，方法调用前，入参需要打印需要吧，接口调用后，需要捕获一下异常吧，同时打印异常相关日志吧，如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">(TransferDTO transferDTO)</span></span>&#123;    log.info(<span class="hljs-string">"invoke tranfer begin"</span>);    <span class="hljs-comment">//打印入参</span>    log.info(<span class="hljs-string">"invoke tranfer,paramters:&#123;&#125;"</span>,transferDTO);    <span class="hljs-keyword">try</span> &#123;      res=  transferService.transfer(transferDTO);    &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;     log.error(<span class="hljs-string">"transfer fail,cifno:&#123;&#125;，account：&#123;&#125;"</span>,transferDTO.getCifno（），     transferDTO.getaccount（）)     log.error(<span class="hljs-string">"transfer fail,exception:&#123;&#125;"</span>,e);    &#125;    log.info(<span class="hljs-string">"invoke tranfer end"</span>);    &#125;</code></pre><p>除了打印足够的日志，我们还需要注意一点是，<strong>日志级别别混淆使用</strong>，别本该打印info的日志，你却打印成error级别，告警半夜三更催你起来排查问题就不好了。</p><h3 id="七、对于行数比较多的函数，是否可以划分小函数来优化呢？"><a href="#七、对于行数比较多的函数，是否可以划分小函数来优化呢？" class="headerlink" title="七、对于行数比较多的函数，是否可以划分小函数来优化呢？"></a>七、对于行数比较多的函数，是否可以划分小函数来优化呢？</h3><p>我们在维护老代码的时候，经常会见到一坨坨的代码，有些<strong>函数几百行甚至上千行</strong>，阅读起来比较吃力。</p><p>假设现在有以下代码</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Vector&lt;Order&gt; orders = <span class="hljs-keyword">new</span> Vector&lt;Order&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printOwing</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//print banner</span>        System.out.println(<span class="hljs-string">"****************"</span>);        System.out.println(<span class="hljs-string">"*****customer Owes *****"</span>);        System.out.println(<span class="hljs-string">"****************"</span>);        <span class="hljs-comment">//calculate totalAmount</span>        Enumeration env = orders.elements();        <span class="hljs-keyword">double</span> totalAmount = <span class="hljs-number">0.0</span>;        <span class="hljs-keyword">while</span> (env.hasMoreElements()) &#123;            Order order = (Order) env.nextElement();            totalAmount += order.getAmout();        &#125;        <span class="hljs-comment">//print details</span>        System.out.println(<span class="hljs-string">"name:"</span> + name);        System.out.println(<span class="hljs-string">"amount:"</span> + totalAmount);    &#125;&#125;</code></pre><p><strong>划分为功能单一的小函数后：</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Vector&lt;Order&gt; orders = <span class="hljs-keyword">new</span> Vector&lt;Order&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printOwing</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//print banner</span>        printBanner();        <span class="hljs-comment">//calculate totalAmount</span>        <span class="hljs-keyword">double</span> totalAmount = getTotalAmount();        <span class="hljs-comment">//print details</span>        printDetail(totalAmount);    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printBanner</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"****************"</span>);        System.out.println(<span class="hljs-string">"*****customer Owes *****"</span>);        System.out.println(<span class="hljs-string">"****************"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getTotalAmount</span><span class="hljs-params">()</span></span>&#123;        Enumeration env = orders.elements();        <span class="hljs-keyword">double</span> totalAmount = <span class="hljs-number">0.0</span>;        <span class="hljs-keyword">while</span> (env.hasMoreElements()) &#123;            Order order = (Order) env.nextElement();            totalAmount += order.getAmout();        &#125;        <span class="hljs-keyword">return</span> totalAmount;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printDetail</span><span class="hljs-params">(<span class="hljs-keyword">double</span> totalAmount)</span></span>&#123;        System.out.println(<span class="hljs-string">"name:"</span> + name);        System.out.println(<span class="hljs-string">"amount:"</span> + totalAmount);    &#125;    &#125;</code></pre><p>一个过于<strong>冗长</strong>的函数或者一段<strong>需要注释才能让人理解</strong>用途的代码，可以考虑把它切分成一个功能明确的函数单元，并定义清晰简短的函数名，这样会让代码变得更加优雅。</p><h3 id="八、某些可变因素，如红包皮肤等等，做成配置化是否会更好呢。"><a href="#八、某些可变因素，如红包皮肤等等，做成配置化是否会更好呢。" class="headerlink" title="八、某些可变因素，如红包皮肤等等，做成配置化是否会更好呢。"></a>八、某些可变因素，如红包皮肤等等，做成配置化是否会更好呢。</h3><p>假如产品提了个红包需求，圣诞节的时候，红包皮肤为圣诞节相关的，春节的时候，红包皮肤等。</p><p>如果在代码写死控制，可有类似以下代码：</p><pre><code class="hljs java"><span class="hljs-keyword">if</span>(duringChristmas)&#123;   img = redPacketChristmasSkin;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(duringSpringFestival)&#123;   img =  redSpringFestivalSkin;&#125;......</code></pre><p>如果到了元宵节的时候，运营小姐姐突然又有想法，红包皮肤换成灯笼相关的，这时候，是不是要去修改代码了，重新发布了？</p><p>从一开始，实现一张红包皮肤的配置表，将红包皮肤做成配置化呢？更换红包皮肤，只需修改一下表数据就好了。</p><h3 id="九、多余的import-类，局部变量，没引用是不是应该删除"><a href="#九、多余的import-类，局部变量，没引用是不是应该删除" class="headerlink" title="九、多余的import 类，局部变量，没引用是不是应该删除"></a>九、多余的import 类，局部变量，没引用是不是应该删除</h3><p>如果看到代码存在没使用的import 类，没被使用到的局部变量等，就删掉吧，如下这些：</p><p><img src="/2023/09/12/CV%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%B8%80%E6%AC%A1%E8%BF%9B%E6%AD%A5/16f4b8634695bf0b" srcset="/img/loading.gif" alt="img"></p><p>这些没被引用的局部变量，如果没被使用到，就删掉吧，它又不是陈年的女儿红，留着会越发醇香。它还是会一起被编译的，就是说它还是耗着资源的呢。</p><h3 id="十、查询大表时，是否加了索引，你的sql走了索引嘛。"><a href="#十、查询大表时，是否加了索引，你的sql走了索引嘛。" class="headerlink" title="十、查询大表时，是否加了索引，你的sql走了索引嘛。"></a>十、查询大表时，是否加了索引，你的sql走了索引嘛。</h3><p>查询数据量比较大的表时，我们需要确认三点：</p><ul><li>你的表是否建了索引</li><li>你的查询sql是否命中索引</li><li>你的sql是否还有优化余地</li></ul><p>一般情况下，数据量超过10万的表，就要考虑给表加索引了。哪些情况下，索引会失效呢？like通配符、索引列运算等会导致索引失效。有兴趣的朋友可以看一下我这篇文章。 <a href="https://juejin.im/post/5de99dd2518825125e1ba49d" target="_blank" rel="noopener">后端程序员必备：索引失效的十大杂症</a></p><h3 id="十一、你的方法到底应该返回空集合还是-null呢？"><a href="#十一、你的方法到底应该返回空集合还是-null呢？" class="headerlink" title="十一、你的方法到底应该返回空集合还是 null呢？"></a>十一、你的方法到底应该返回空集合还是 null呢？</h3><p>如果返回null，调用方在忘记检测的时候，可能会抛出空指针异常。返回一个空集合呢，就省去该问题了。</p><p>mybatis查询的时候，如果返回一个集合，结果为空时也会返回一个空集合，而不是null。</p><p><strong>正例</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;UserResult&gt; <span class="hljs-title">getUserResultList</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">return</span> Collections.EMPTY_LIST;&#125;</code></pre><h3 id="十二、初始化集合时尽量指定其大小"><a href="#十二、初始化集合时尽量指定其大小" class="headerlink" title="十二、初始化集合时尽量指定其大小"></a>十二、初始化集合时尽量指定其大小</h3><p>阿里开发手册推荐了这一点</p><p><img src="/2023/09/12/CV%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%B8%80%E6%AC%A1%E8%BF%9B%E6%AD%A5/16f4c63cf25c4b13" srcset="/img/loading.gif" alt="img"></p><p>假设你的map要存储的元素个数是15个左右，最优写法如下</p><pre><code class="hljs java"><span class="hljs-comment">//initialCapacity = 15/0.75+1=21</span>Map map = <span class="hljs-keyword">new</span> HashMap(<span class="hljs-number">21</span>);</code></pre><h3 id="十三、查询数据库时，如果数据返回过多，考虑分批进行。"><a href="#十三、查询数据库时，如果数据返回过多，考虑分批进行。" class="headerlink" title="十三、查询数据库时，如果数据返回过多，考虑分批进行。"></a>十三、查询数据库时，如果数据返回过多，考虑分批进行。</h3><p>假设你的订单表有10万数据要更新状态，不能一次性查询所有未更新的订单，要分批。</p><p><strong>反例：</strong></p><pre><code class="hljs java">List&lt;Order&gt; list = sqlMap.queryList(<span class="hljs-string">"select * from Order where status='0'"</span>);<span class="hljs-keyword">for</span>(Order order:list)&#123;  order.setStatus(<span class="hljs-number">1</span>);  sqlMap.update(order);  &#125;</code></pre><p><strong>正例：</strong></p><pre><code class="hljs java">Integer count = sqlMap.queryCount(<span class="hljs-function">select <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span> from Order where status </span>=<span class="hljs-string">'0'</span>);<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;    <span class="hljs-keyword">int</span> size=sqlMap.batchUpdate(params);    <span class="hljs-keyword">if</span>（size&lt;<span class="hljs-number">500</span>）&#123;        <span class="hljs-keyword">break</span>;    &#125;&#125;</code></pre><h3 id="十四、你的接口是否考虑到幂等性-并发情况呢？"><a href="#十四、你的接口是否考虑到幂等性-并发情况呢？" class="headerlink" title="十四、你的接口是否考虑到幂等性,并发情况呢？"></a>十四、你的接口是否考虑到幂等性,并发情况呢？</h3><p><strong>幂等性是什么？</strong> 一次和多次请求某一个资源对于资源本身应该具有同样的结果。就是说，其任意多次执行对资源本身所产生的影响均与一次执行的影响相同。</p><p><strong>为什么需要幂等性？</strong></p><ul><li>用户在APP上连续点击了多次提交订单，总不能生成多个订单吧</li><li>用户因为网络卡了，连续点击发送消息，接受者总不能收到重复的同一条消息吧。</li></ul><p><strong>假设有业务场景：</strong></p><p>用户点击下载按钮，系统开始下载文件，用户再次点击下载，会提示文件正在下载中。</p><p>有一部分人会这样实现：</p><pre><code class="hljs java">Integer count = sqlMap.selectCount(<span class="hljs-string">"select count(1) from excel where state=1"</span>);<span class="hljs-keyword">if</span>(count&lt;=<span class="hljs-number">0</span>)&#123;    Excel.setStatus(<span class="hljs-number">1</span>);    updateExcelStatus();    downLoadExcel();&#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-string">"文件正在下载中"</span>&#125;</code></pre><p>我们可以看一下，两个请求过来可能会有什么问题？</p><p><img src="/2023/09/12/CV%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%B8%80%E6%AC%A1%E8%BF%9B%E6%AD%A5/16f4d0dc9516f996" srcset="/img/loading.gif" alt="img"></p><p>执行流程：</p><ul><li>第一步，A查询没有下载中的文件。</li><li>第二步，B查询没有下载中的文件。</li><li>第三步，A开始下载文件</li><li>第四部，B 开始下载文件</li></ul><p>显然，这样有问题，同时两个文件在下载了。正确的实现方式呢？</p><pre><code class="hljs java"><span class="hljs-keyword">if</span>(updateExcelStatus(<span class="hljs-number">1</span>)&#123;    downLoadExcel(); &#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-string">"文件正在下载中"</span>&#125;</code></pre><h3 id="十五、用一个私有构造器强化你的工具类，此不美哉？"><a href="#十五、用一个私有构造器强化你的工具类，此不美哉？" class="headerlink" title="十五、用一个私有构造器强化你的工具类，此不美哉？"></a>十五、用一个私有构造器强化你的工具类，此不美哉？</h3><p>工具类的方法都是静态方法，通过类来直接调用即可。但是有些调用方可能会先实例化，再用对象去调用，而这就不好了。怎么避免这种情况，让你的工具类到达可控状态呢，<strong>添加私有构造器</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringUtis</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">StringUtis</span><span class="hljs-params">()</span></span>&#123;&#125; <span class="hljs-comment">///私有构造类，防止意外实例出现</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> bool <span class="hljs-title">validataString</span><span class="hljs-params">(String str)</span></span>&#123;    &#125;&#125;</code></pre><h3 id="十六、基本不变的用户数据，缓存起来，性能是否有所提升呢"><a href="#十六、基本不变的用户数据，缓存起来，性能是否有所提升呢" class="headerlink" title="十六、基本不变的用户数据，缓存起来，性能是否有所提升呢"></a>十六、基本不变的用户数据，缓存起来，性能是否有所提升呢</h3><p>假设你的接口需要查询很多次数据库，获取到各中数据，然后再根据这些数据进行各种排序等等操作，这一系列猛如虎的操作下来，接口性能肯定不好。典型应用场景比如：直播列表这些。</p><p>那么，怎么优化呢？剖析你排序的各部分数据，实时变的数据，继续查DB，不变的数据，如用户年龄这些，搞个定时任务，把它们从DB拉取到缓存，直接走缓存。</p><p>因此，这个点的思考就是，在恰当地时机，适当的使用缓存。</p>]]></content>
    
    
    <categories>
      
      <category>程序人生篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CV程序员的一次进步</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL优化与诊断</title>
    <link href="/2023/09/12/SQL%E4%BC%98%E5%8C%96%E4%B8%8E%E8%AF%8A%E6%96%AD/"/>
    <url>/2023/09/12/SQL%E4%BC%98%E5%8C%96%E4%B8%8E%E8%AF%8A%E6%96%AD/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL优化与诊断"><a href="#SQL优化与诊断" class="headerlink" title="SQL优化与诊断"></a>SQL优化与诊断</h1><h2 id="Explain诊断"><a href="#Explain诊断" class="headerlink" title="Explain诊断"></a>Explain诊断</h2><p>Explain各参数的含义如下：</p><p>| <strong>列名</strong>     | <strong>说明</strong>                                                     |<br>|  |  |<br>| id           | 执行编号，标识select所属的行。如果在语句中没有子查询或关联查询，只有唯一的select，每行都将显示1.否则，内层的select语句一般会顺序编号，对应于其在原始语句中的位置 |<br>| select_type  | 显示本行是简单或复杂select，如果查询有任何复杂的子查询，则最外层标记为PRIMARY（DERIVED、UNION、UNION RESUIT） |<br>| table        | 访问引用哪个表（引用某个查询，如“derived3”）                 |<br>| type         | 数据访问/读取操作类型（All、index、range、ref、eq_ref、const/system、NULL） |<br>| possible_key | 揭示哪一些索引可能有利于高效的查找                           |<br>| key          | 显示mysql实际决定采用哪个索引来优化查询                      |<br>| key_len      | 显示mysql在索引里使用的字节数                                |<br>| ref          | 显示了之前的表在key列记录的索引中查找值所用的列或常量        |<br>| rows         | 为了找到所需要的行而需要读取的行数，估算值                   |<br>| Extra        | 额外信息，如using index、filesort等                          |</p><h3 id="select-type-常见类型及其含义"><a href="#select-type-常见类型及其含义" class="headerlink" title="select_type 常见类型及其含义"></a>select_type 常见类型及其含义</h3><ul><li><strong>SIMPLE</strong>：不包含子查询或者 UNION 操作的查询</li><li><strong>PRIMARY</strong>：查询中如果包含任何子查询，那么最外层的查询则被标记为 PRIMARY </li><li><strong>SUBQUERY</strong>：子查询中第一个 SELECT</li><li><strong>DEPENDENT SUBQUERY</strong>：子查询中的第一个 SELECT，取决于外部查询</li><li><strong>UNION</strong>：UNION 操作的第二个或者之后的查询</li><li><strong>DEPENDENT UNION</strong>：UNION 操作的第二个或者之后的查询,取决于外部查询</li><li><strong>UNION RESULT</strong>：UNION 产生的结果集</li><li><strong>DERIVED</strong>：出现在 FROM 字句中的子查询</li></ul><h3 id="type常见类型及其含义"><a href="#type常见类型及其含义" class="headerlink" title="type常见类型及其含义"></a>type常见类型及其含义</h3><ul><li><strong>system</strong>：这是 const 类型的一个特例，只会出现在待查询的表只有一行数据的情况下 </li><li><code>consts</code>：常出现在主键或唯一索引与常量值进行比较的场景下，此时查询性能是最优的 </li><li><strong>eq_ref</strong>：当连接使用的是完整的索引并且是 PRIMARY KEY 或 UNIQUE NOT NULL INDEX 时使用它 </li><li><code>ref</code>：当连接使用的是前缀索引或连接条件不是 PRIMARY KEY 或 UNIQUE INDEX 时则使用它 </li><li><strong>ref_or_null</strong>：类似于 ref 类型的查询，但是附加了对 NULL 值列的查询 </li><li><strong>index_merge</strong>：该联接类型表示使用了索引进行合并优化 </li><li><code>range</code>：使用索引进行范围扫描，常见于 between、&gt; 、&lt; 这样的查询条件 </li><li><code>index</code>：索引连接类型与 ALL 相同，只是扫描的是索引树，通常出现在索引是该查询的覆盖索引的情况 </li><li><strong>ALL</strong>：全表扫描，效率最差的查找方式 </li></ul><p>阿里编码规范要求：<code>至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好</code></p><h3 id="key列"><a href="#key列" class="headerlink" title="key列"></a>key列</h3><p>实际在查询中是否使用到索引的标志字段</p><h3 id="Extra列"><a href="#Extra列" class="headerlink" title="Extra列"></a>Extra列</h3><p>Extra 列主要用于显示额外的信息，常见信息及其含义如下：</p><ul><li><strong>Using where</strong> ：MySQL 服务器会在存储引擎检索行后再进行过滤</li><li><strong>Using filesort</strong>：通常出现在 GROUP BY 或 ORDER BY 语句中，且排序或分组没有基于索引，此时需要使用文件在内存中进行排序，因为使用索引排序的性能好于使用文件排序，所以出现这种情况可以考虑通过添加索引进行优化</li><li><strong>Using index</strong>：使用了覆盖索引进行查询，此时不需要访问表，从索引中就可以获取到所需的全部数据</li><li><strong>Using index condition：</strong>查找使用了索引，但是需要回表查询数据</li><li><strong>Using temporary</strong>：表示需要使用临时表来处理查询，常出现在 GROUP BY 或 ORDER BY 语句中</li></ul><h3 id="如何查看Mysql优化器优化之后的SQL"><a href="#如何查看Mysql优化器优化之后的SQL" class="headerlink" title="如何查看Mysql优化器优化之后的SQL"></a>如何查看Mysql优化器优化之后的SQL</h3><pre><code class="hljs mysql"># 仅在服务器环境下或通过Navicat进入命令列界面explain extended  SELECT * FROM &#96;student&#96; where &#96;name&#96; &#x3D; 1 and &#96;age&#96; &#x3D; 1;# 再执行show warnings;# 结果如下：&#x2F;* select#1 *&#x2F; select &#96;mytest&#96;.&#96;student&#96;.&#96;age&#96; AS &#96;age&#96;,&#96;mytest&#96;.&#96;student&#96;.&#96;name&#96; AS &#96;name&#96;,&#96;mytest&#96;.&#96;student&#96;.&#96;year&#96; AS &#96;year&#96; from &#96;mytest&#96;.&#96;student&#96; where ((&#96;mytest&#96;.&#96;student&#96;.&#96;age&#96; &#x3D; 1) and (&#96;mytest&#96;.&#96;student&#96;.&#96;name&#96; &#x3D; 1))</code></pre><p>为什么要做这个事呢？我们知道Mysql有一个最左匹配原则，那么如果我的索引建的是age，name，那我以name，age这样的顺序去查询能否使用到索引呢？实际上是可以的，就是因为Mysql查询优化器可以帮助我们自动对SQL的执行顺序等进行优化，以选取代价最低的方式进行查询（注意是代价最低，不是时间最短）</p><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><h3 id="超大分页场景解决方案"><a href="#超大分页场景解决方案" class="headerlink" title="超大分页场景解决方案"></a>超大分页场景解决方案</h3><p>如表中数据需要进行深度分页，如何提高效率？在阿里出品的Java编程规范中写道：</p><pre><code class="hljs 利用延迟关联或者子查询优化超多分页场景```">说明：MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写&#96;&#96;&#96;mysql# 反例（耗时129.570s）select * from task_result LIMIT 20000000, 10;# 正例（耗时5.114s）SELECT a.* FROM task_result a, (select id from task_result LIMIT 20000000, 10) b where a.id &#x3D; b.id;# 说明task_result表为生产环境的一个表，总数据量为3400万，id为主键，偏移量达到2000万</code></pre><h3 id="获取一条数据时的Limit-1"><a href="#获取一条数据时的Limit-1" class="headerlink" title="获取一条数据时的Limit 1"></a>获取一条数据时的Limit 1</h3><p>如果数据表的情况已知，某个业务需要获取符合某个Where条件下的一条数据，注意使用Limit</p><p>说明：在很多情况下我们已知数据仅存在一条，此时我们应该告知数据库只用查一条，否则将会转化为全表扫描</p><pre><code class="hljs mysql"># 反例（耗时2424.612s）select * from task_result where unique_key &#x3D; &#39;ebbf420b65d95573db7669f21fa3be3e_861414030800727_48&#39;;# 正例（耗时1.036s）select * from task_result where unique_key &#x3D; &#39;ebbf420b65d95573db7669f21fa3be3e_861414030800727_48&#39; LIMIT 1;# 说明task_result表为生产环境的一个表，总数据量为3400万，where条件非索引字段，数据所在行为第19486条记录</code></pre><h3 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h3><pre><code class="hljs mysql"># 反例INSERT into person(name,age) values(&#39;A&#39;,24)INSERT into person(name,age) values(&#39;B&#39;,24)INSERT into person(name,age) values(&#39;C&#39;,24)# 正例INSERT into person(name,age) values(&#39;A&#39;,24),(&#39;B&#39;,24),(&#39;C&#39;,24);# 说明比较常规，就不多做说明了</code></pre><h3 id="like语句的优化"><a href="#like语句的优化" class="headerlink" title="like语句的优化"></a>like语句的优化</h3><p>like语句一般业务要求都是 <code>&#39;%关键字%&#39;</code>这种形式，但是依然要思考能否考虑使用右模糊的方式去替代产品的要求，其中阿里的编码规范提到：</p><pre><code class="hljs 页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决```">&#96;&#96;&#96;mysql# 反例（耗时78.843s）EXPLAIN select * from task_result where taskid LIKE &#39;%tt600e6b601677b5cbfe516a013b8e46%&#39; LIMIT 1;# 正例（耗时0.986s）select * from task_result where taskid LIKE &#39;tt600e6b601677b5cbfe516a013b8e46%&#39; LIMIT 1########################################################################### 对正例的Explain1SIMPLEtask_resultrangeadapt_idadapt_id9899100.00Using index condition# 对反例的Explain1SIMPLEtask_resultALL                    3362855411.11Using where# 说明task_result表为生产环境的一个表，总数据量为3400万，taskid是一个普通索引列，可见%%这种匹配方式完全无法使用索引，从而进行全表扫描导致效率极低，而正例通过索引查找数据只需要扫描99条数据即可</code></pre><h3 id="避免SQL中对where字段进行函数转换或表达式计算"><a href="#避免SQL中对where字段进行函数转换或表达式计算" class="headerlink" title="避免SQL中对where字段进行函数转换或表达式计算"></a>避免SQL中对where字段进行函数转换或表达式计算</h3><pre><code class="hljs mysql"># 反例select * from task_result where id + 1 &#x3D; 15551;# 正例select * from task_result where id &#x3D; 15550;########################################################################### 对正例的Explain1SIMPLEtask_resultconstPRIMARYPRIMARY8const1100.00# 对反例的Explain1SIMPLEtask_resultALL                33631512  100.00Using where# 说明其实在知道了有SQL优化器之后，我个人感觉这种普通的表达式转换应该可以提前进行处理再进行查询，这样一来就可以用到索引了，但是问题又来了，如果mysql优化器可以提前计算出结果，那么写sql语句的人也一定可以提前计算出结果，所以矛盾点在这个地方，导致5.7版本以前的此种情况都无法使用索引吧，未来可能会对其进行优化</code></pre><h3 id="使用-ISNULL-来判断是否为-NULL-值"><a href="#使用-ISNULL-来判断是否为-NULL-值" class="headerlink" title="使用 ISNULL()来判断是否为 NULL 值"></a>使用 ISNULL()来判断是否为 NULL 值</h3><p>说明：NULL 与任何值的直接比较都为 NULL</p><pre><code class="hljs mysql"># 1） NULL&lt;&gt;NULL 的返回结果是 NULL，而不是 false。 # 2） NULL&#x3D;NULL 的返回结果是 NULL，而不是 true。 # 3） NULL&lt;&gt;1 的返回结果是 NULL，而不是 true。</code></pre><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p>我所在的公司基本禁止了多表查询，那如果必须使用到的话，我们可以一起参考一下阿里的编码规范</p><p>Eg：超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引</p><h3 id="明明有索引为什么还走全表扫描"><a href="#明明有索引为什么还走全表扫描" class="headerlink" title="明明有索引为什么还走全表扫描"></a>明明有索引为什么还走全表扫描</h3><p>之前回答一些面试问题的时候，对某一个点的理解出现了偏差，即我认为只要查询的列有索引则一定会使用索引去Push数据</p><p>然而实际上不仅仅是这样，真正应该是：<code>针对查询的数据行占总数据量过多时会转化成全表查询</code></p><p>那么这个过多指代的是多少呢？</p><p>我的测试结果是50%，但个人认为MySQL优化器不会完全纠结于行数区分是否全表，而是有很多其他因素综合考虑发现全表扫描的效率更高等等，所以充分认识到该问题即可</p><h3 id="count-还是-count-id"><a href="#count-还是-count-id" class="headerlink" title="count(*) 还是 count(id)"></a>count(*) 还是 count(id)</h3><p>阿里的Java编码规范中有以下内容：</p><pre><code class="hljs 【强制】不要使用">count(*) 是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。 说明：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行### 字段类型不同导致索引失效阿里的Java编码规范中有以下内容：&#96;&#96;&#96;【推荐】防止因字段类型不同造成的隐式转换，导致索引失效</code></pre><p>实际上数据库在查询的时候会作一层隐式的转换，比如 varchar 类型字段通过 数字去查询</p><pre><code class="hljs mysql"># 正例EXPLAIN SELECT * FROM &#96;user_coll&#96; where pid &#x3D; &#39;1&#39;;type：refref：constrows:1Extra:Using index condition# 反例EXPLAIN SELECT * FROM &#96;user_coll&#96; where pid &#x3D; 1;type：indexref：NULLrows:3(总记录数)Extra:Using where; Using index# 说明pid字段有相应索引，且格式为varchar</code></pre><h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>感谢以下博文及其作者：</p><p><a href="https://juejin.im/post/5e0f5eec5188253a9d4a436f#heading-4" target="_blank" rel="noopener">干货！SQL性能优化，书写高质量SQL语句</a></p><p><a href="https://juejin.im/post/5e1eb8ebf265da3e4244e094" target="_blank" rel="noopener">干货！SQL性能优化，书写高质量SQL语句（二）</a></p><p><a href="https://dev.mysql.com/doc/refman/5.6/en/optimize-overview.html" target="_blank" rel="noopener">MySQL官方文档</a></p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>自建数据表进行测试</p><pre><code class="hljs mysql">CREATE TABLE &#96;student&#96; (  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;,  &#96;name&#96; varchar(255) NOT NULL,  &#96;class&#96; varchar(255) DEFAULT NULL,  &#96;page&#96; bigint(20) DEFAULT NULL,  &#96;status&#96; tinyint(3) unsigned NOT NULL COMMENT &#39;状态：0 正常，1 冻结，2 删除&#39;,  PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;0 DEFAULT CHARSET&#x3D;utf8mb4</code></pre><p>插入数据</p><pre><code class="hljs mysql">DELIMITER ;;    CREATE PROCEDURE insertData()    BEGIN        declare i int;        set i &#x3D; 1 ;        WHILE (i &lt; 1000000) DO            INSERT INTO student(&#96;name&#96;,class,&#96;page&#96;,&#96;status&#96;)                VALUES(CONCAT(&#39;class_&#39;, i),                    CONCAT(&#39;class_&#39;, i),                i, (SELECT FLOOR(RAND() * 2)));            set i &#x3D; i + 1;        END WHILE;        commit;END;;CALL insertData();</code></pre>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL优化与诊断</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux-YUM 安装Mysql</title>
    <link href="/2023/09/12/Linux-YUM%20%E5%AE%89%E8%A3%85Mysql/"/>
    <url>/2023/09/12/Linux-YUM%20%E5%AE%89%E8%A3%85Mysql/</url>
    
    <content type="html"><![CDATA[<h1 id="阿里云Linux安装mysql，修改密码，远程连接"><a href="#阿里云Linux安装mysql，修改密码，远程连接" class="headerlink" title="阿里云Linux安装mysql，修改密码，远程连接"></a>阿里云Linux安装mysql，修改密码，远程连接</h1><p>博文：<a href="https://www.cnblogs.com/dianqijiaodengdai/p/7731562.html" target="_blank" rel="noopener">https://www.cnblogs.com/dianqijiaodengdai/p/7731562.html</a></p><p>1.安装yum包</p><p>进入mysql官网 <a href="https://dev.mysql.com/downloads/file/?id=470281" target="_blank" rel="noopener">https://dev.mysql.com/downloads/file/?id=470281</a></p><p>获取mysql57-community-release-el7-11.noarch.rpm 下载地址</p><pre><code class="hljs vim">在root下输入指令：wgethttp<span class="hljs-variable">s:</span>//dev.mysql.<span class="hljs-keyword">com</span>/<span class="hljs-built_in">get</span>/mysql57-community-release-el7-<span class="hljs-number">11</span>.noarch.rpm</code></pre><p>2.rpm源下载完成后，输入指令</p><pre><code class="hljs sql">yum <span class="hljs-keyword">install</span> mysql-<span class="hljs-keyword">server</span>安装依赖包过程一直输入y，至安装完毕</code></pre><p>3.相关命令</p><pre><code class="hljs sql">输入systemctl <span class="hljs-keyword">start</span> mysqld 启动mysql输入systemctl <span class="hljs-keyword">status</span> mysqld 查询mysql状态</code></pre><p>4.获取初始密码</p><pre><code class="hljs stata"><span class="hljs-keyword">more</span> /<span class="hljs-keyword">var</span>/<span class="hljs-keyword">log</span>/mysqld.<span class="hljs-keyword">log</span>找到 <span class="hljs-string">"temporary password"</span>所在行，获取初始密码</code></pre><p>5.重置密码 - yum安装密码有一定的限制，因此先要修改密码规则:</p><pre><code class="hljs sql">首先要修改规则链接地址：https://www.cnblogs.com/ivictor/p/5142809.html1.set <span class="hljs-keyword">global</span> validate_password_policy=<span class="hljs-number">0</span>;2.set <span class="hljs-keyword">global</span> validate_password_length=<span class="hljs-number">1</span>;// 3.set <span class="hljs-keyword">global</span> validate_password_mixed_case_count=<span class="hljs-number">2</span>;修改密码为：123456命令:<span class="hljs-keyword">alter</span> <span class="hljs-keyword">user</span> <span class="hljs-string">'root'</span>@<span class="hljs-string">'localhost'</span> <span class="hljs-keyword">identified</span> <span class="hljs-keyword">by</span> <span class="hljs-string">'root'</span></code></pre><p>6.检查端口是否开启 - 主要是阿里云安全组的端口，查看是否开启即可</p><p>7.开启远程链接，反思：注意看到代码先分析</p><pre><code class="hljs sql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">privileges</span> <span class="hljs-keyword">on</span> *.* <span class="hljs-keyword">to</span> <span class="hljs-string">'root'</span>@<span class="hljs-string">'%'</span> <span class="hljs-keyword">identified</span> <span class="hljs-keyword">by</span> <span class="hljs-string">'123456'</span>;<span class="hljs-keyword">flush</span> <span class="hljs-keyword">privileges</span>;</code></pre><p>8.本地navicat测试连接</p><p><strong>额外</strong></p><p>提示：Failed to start mysqld.service: Unit not found</p><p>解决方案：<a href="https://my.oschina.net/iyinghui/blog/2246986" target="_blank" rel="noopener">https://my.oschina.net/iyinghui/blog/2246986</a></p>]]></content>
    
    
    <categories>
      
      <category>操作系统篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux-YUM 安装Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC篇</title>
    <link href="/2023/09/12/SpringMVC%E7%AF%87/"/>
    <url>/2023/09/12/SpringMVC%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC篇"><a href="#SpringMVC篇" class="headerlink" title="SpringMVC篇"></a>SpringMVC篇</h1><h2 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h2><pre><code class="hljs angelscript"><span class="hljs-number">11.</span> 简单谈谈你对 MVC 的理解。<span class="hljs-number">12.</span> 什么是 Spring MVC ？简单介绍下你对 Spring MVC 的理解?<span class="hljs-number">13.</span> Spring MVC 的优点有哪些？<span class="hljs-number">14.</span> Spring MVC 的核心组件有哪些？<span class="hljs-number">15.</span> Spring MVC 的实现流程是什么？<span class="hljs-number">16.</span> Spring MVC 怎么样设定重定向和转发的？<span class="hljs-number">17.</span> 如何解决 POST 请求中文乱码问题，GET 的又如何处理呢？<span class="hljs-number">18.</span> @ModelAttribute 如何使用？<span class="hljs-number">19.</span> 说说你对自定义数据类型转换器的理解。<span class="hljs-number">20.</span> 使用 Hibernate Validator 注解方式校验 Email 数据格式应该怎么写？</code></pre><h2 id="ModelAttribute注解"><a href="#ModelAttribute注解" class="headerlink" title="@ModelAttribute注解"></a>@ModelAttribute注解</h2><pre><code class="hljs java">Controller层一般都单独作为一个类使用，但是一个合理的设计，可以设计如 BaseController，通过继承的方式，让所有的controller都可以有一定的公共参数<span class="hljs-comment">// 该注解会在所有方法之前被调用，可以用作公共配置的设置等等</span><span class="hljs-meta">@ModelAttribute</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testModelAttribute</span> <span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;System.out.println(<span class="hljs-string">"1111"</span>);request.setAttribute(<span class="hljs-string">"myTest"</span>, <span class="hljs-string">"my test"</span>);&#125;<span class="hljs-comment">// 加次注解后，@RequestMapping失效，请求会报404错误，但是方法仍会依照ModelAttribute特性执行（先执行）</span><span class="hljs-meta">@ModelAttribute</span> <span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/users"</span>, method = RequestMethod.GET)<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">restful</span> <span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;System.out.println(<span class="hljs-string">"查询所有"</span>);System.out.println(request.getAttribute(<span class="hljs-string">"myTest"</span>));<span class="hljs-keyword">return</span> <span class="hljs-string">"ok"</span>;&#125;</code></pre><h2 id="统一异常处理-注解方式"><a href="#统一异常处理-注解方式" class="headerlink" title="统一异常处理 - 注解方式"></a>统一异常处理 - 注解方式</h2><pre><code class="hljs @ControllerAdvice">博文地址：https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;3f3d9e8d1efa?utm_campaign&#x3D;haruki&amp;utm_content&#x3D;note&amp;utm_medium&#x3D;reader_share&amp;utm_source&#x3D;weixin&gt; 注意 ExceptionHandler不能同时重复捕获Excepiton&#96;&#96;&#96;java@RestControllerAdvicepublic class MyExceptionHandler &#123;&#x2F;&#x2F;    &#x2F;***&#x2F;&#x2F;     * 自定义异常GeneralException处理&#x2F;&#x2F;     * @param ex       GeneralException&#x2F;&#x2F;     * @param request  HttpServletRequest&#x2F;&#x2F;     * @return         BaseResult&#x2F;&#x2F;     *&#x2F;&#x2F;&#x2F;    @ExceptionHandler(value &#x3D; &#123;MyException.class&#125;)&#x2F;&#x2F;    public Result generalException (final MyException ex, final HttpServletRequest request) &#123;&#x2F;&#x2F;        Result res &#x3D; new Result();&#x2F;&#x2F;        res.setCode(&quot;MyException&quot;);&#x2F;&#x2F;        res.setData(&quot;&#x2F;url: &quot; + request.getRequestURI());&#x2F;&#x2F;        System.out.println(&quot;11111&quot;);&#x2F;&#x2F;        return res;&#x2F;&#x2F;    &#125;&#x2F;&#x2F;&#x2F;&#x2F;    &#x2F;***&#x2F;&#x2F;     * Exception处理&#x2F;&#x2F;     * @param ex       Exception&#x2F;&#x2F;     * @param request  HttpServletRequest&#x2F;&#x2F;     * @return         BaseResult&#x2F;&#x2F;     *&#x2F;&#x2F;&#x2F;    @ExceptionHandler(value &#x3D; &#123;Exception.class&#125;)&#x2F;&#x2F;    public Result generalException (final Exception ex, final HttpServletRequest request) &#123;&#x2F;&#x2F;        Result res &#x3D; new Result();&#x2F;&#x2F;        res.setCode(&quot;Exception&quot;);&#x2F;&#x2F;        res.setData(&quot;&#x2F;url: &quot; + request.getRequestURI());&#x2F;&#x2F;        System.out.println(&quot;22222&quot;);&#x2F;&#x2F;        return res;&#x2F;&#x2F;    &#125;        &#x2F;***      * 支持通过默认方式  通过 instanceof 关键字进行级别判断，减少重复代码     *&#x2F;    @ExceptionHandler    public Result generalqqqException (final Exception ex, final HttpServletRequest request) &#123;        Result res &#x3D; new Result();        res.setCode(&quot;Exception&quot;);        res.setData(&quot;&#x2F;url: &quot; + request.getRequestURI());        &#x2F;&#x2F; 404异常        if (ex instanceof NoHandlerFoundException) &#123;            System.out.println(request.getRequestURI() + &quot;is error.&quot;);        &#125; else if (ex instanceof MyException) &#123;            System.out.println(&quot;1111&quot;);        &#125; else &#123;            System.out.println(&quot;22222&quot;);        &#125;        return res;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">// 原来的mapping - 直接抛异常即可</span><span class="hljs-comment">/***</span><span class="hljs-comment"> * 告警类型占比分析</span><span class="hljs-comment"> */</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/typeData"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> BaseResult <span class="hljs-title">typeData</span> <span class="hljs-params">(@RequestBody Map&lt;String, Object&gt; conditionMap)</span> <span class="hljs-keyword">throws</span> GeneralException </span>&#123;    <span class="hljs-keyword">if</span> (checkParams(conditionMap , <span class="hljs-string">"mpid"</span> , <span class="hljs-string">"appid"</span> , <span class="hljs-string">"assignTime"</span> , <span class="hljs-string">"period"</span>)) &#123;        <span class="hljs-keyword">return</span> printMissParams(conditionMap , <span class="hljs-string">"mpid"</span> , <span class="hljs-string">"appid"</span> , <span class="hljs-string">"assignTime"</span> , <span class="hljs-string">"period"</span>);    &#125;    List&lt;Map&lt;String,Object&gt;&gt; dataList = ialarmflowservice.getAlarmTypeData(conditionMap);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BaseResult&lt;&gt;(ResultCode.success.getCode(), ResultCode.success.getDescr(), dataList);&#125;</code></pre><h3 id="404异常配置"><a href="#404异常配置" class="headerlink" title="404异常配置"></a>404异常配置</h3><pre><code class="hljs java"># 404 交给异常处理器处理spring.mvc.<span class="hljs-keyword">throw</span>-exception-<span class="hljs-keyword">if</span>-no-handler-found=<span class="hljs-keyword">true</span>spring.resources.add-mappings=<span class="hljs-keyword">false</span></code></pre><h2 id="统一异常处理-接口实现"><a href="#统一异常处理-接口实现" class="headerlink" title="统一异常处理 - 接口实现"></a>统一异常处理 - 接口实现</h2><p>详情见：KerwinBoots - boot_code_generator分支</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfigurer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 统一异常处理</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureHandlerExceptionResolvers</span><span class="hljs-params">(List&lt;HandlerExceptionResolver&gt; exceptionResolvers)</span> </span>&#123;        exceptionResolvers.add((request, response, handler, e) -&gt; &#123;            Result result = <span class="hljs-keyword">new</span> Result();            <span class="hljs-comment">//业务失败的异常，如[账号或密码错误]</span>            <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> ServiceException) &#123;                result.setCode(ResultCode.FAIL).setMessage(e.getMessage());                logger.info(e.getMessage());            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> NoHandlerFoundException) &#123;                result.setCode(ResultCode.NOT_FOUND).setMessage(<span class="hljs-string">"接口 ["</span> + request.getRequestURI() + <span class="hljs-string">"] 不存在"</span>);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> ServletException) &#123;                result.setCode(ResultCode.FAIL).setMessage(e.getMessage());            &#125; <span class="hljs-keyword">else</span> &#123;                result.setCode(ResultCode.INTERNAL_SERVER_ERROR).setMessage(<span class="hljs-string">"接口 ["</span> + request.getRequestURI() + <span class="hljs-string">"] 内部错误，请联系管理员"</span>);                String message;                <span class="hljs-keyword">if</span> (handler <span class="hljs-keyword">instanceof</span> HandlerMethod) &#123;                    HandlerMethod handlerMethod = (HandlerMethod) handler;                    message = String.format(<span class="hljs-string">"接口 [%s] 出现异常，方法：%s.%s，异常摘要：%s"</span>,                            request.getRequestURI(),                            handlerMethod.getBean().getClass().getName(),                            handlerMethod.getMethod().getName(),                            e.getMessage());                &#125; <span class="hljs-keyword">else</span> &#123;                    message = e.getMessage();                &#125;                logger.error(message, e);            &#125;            responseResult(response, result);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ModelAndView();        &#125;);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">responseResult</span><span class="hljs-params">(HttpServletResponse response, Result result)</span> </span>&#123;        response.setCharacterEncoding(<span class="hljs-string">"UTF-8"</span>);        response.setHeader(<span class="hljs-string">"Content-type"</span>, <span class="hljs-string">"application/json;charset=UTF-8"</span>);        response.setStatus(<span class="hljs-number">200</span>);        <span class="hljs-keyword">try</span> &#123;            response.getWriter().write(JSON.toJSONString(result));        &#125; <span class="hljs-keyword">catch</span> (IOException ex) &#123;            logger.error(ex.getMessage());        &#125;    &#125;&#125;</code></pre><h3 id="404异常配置-1"><a href="#404异常配置-1" class="headerlink" title="404异常配置"></a>404异常配置</h3><pre><code class="hljs java"># 404 交给异常处理器处理spring.mvc.<span class="hljs-keyword">throw</span>-exception-<span class="hljs-keyword">if</span>-no-handler-found=<span class="hljs-keyword">true</span>spring.resources.add-mappings=<span class="hljs-keyword">false</span></code></pre><h2 id="ResponseBody-注解作用及原理"><a href="#ResponseBody-注解作用及原理" class="headerlink" title="@ResponseBody 注解作用及原理"></a>@ResponseBody 注解作用及原理</h2><blockquote><p>MVC中@ResponseBody可以把结果返回值以JSON字符串的形式输出，所以@ResponseBody注解到底做了什么事？</p><ol><li>ModelAndView 类型对象会有JSPView处理器进行处理，而@ResponseBody会通过response进行输出</li><li>HttpMessageConverter 进行数据转换，把输入流转化成对象，对象返回值转化为输出流，而@ResponseBody注解工作的实质即以下两行代码</li></ol><pre><code class="hljs java">response.setContentType(<span class="hljs-string">"application/json;charset=UTF-8"</span>);response.getWriter().write(JSON.toJSONString(invoke));</code></pre><p>无论是调用该注解，或者自行response输出json字符串，返回结果都可以保证是JSON字符串，但为什么只有加了注解的才可以在ajax中，直接作为对象使用？ 关键在于头信息</p><p>JQuery有内部处理机制去识别 -》 application/json;charset=UTF-8</p><p> <img src="/2023/09/12/SpringMVC%E7%AF%87/image-20191125163620881.png" srcset="/img/loading.gif" alt="image-20191125163620881"></p><p>关键词：【HttpMessageConverter】</p><p>参考博文： <a href="https://www.jianshu.com/p/333ed5ee958d" target="_blank" rel="noopener">https://www.jianshu.com/p/333ed5ee958d</a> </p></blockquote><h2 id="Service，-Controller注解互换可以吗"><a href="#Service，-Controller注解互换可以吗" class="headerlink" title="@Service，@Controller注解互换可以吗"></a>@Service，@Controller注解互换可以吗</h2><blockquote><p>@Service，@Controller的本质和@Component一致，都是为了标明一个bean</p><p>因此，@Service注解换成@Controller，或者@Component都是可以的，@Service只是用作业务上的区分</p><p>@Controller不同，它还包含@RequestMapping注解的配合使用，如果用@service代替，会让所有的mapping都失效，所有请求都是404</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>框架篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringMVC篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Testin - JSP项目有感</title>
    <link href="/2023/09/12/Testin%20-%20JSP%E9%A1%B9%E7%9B%AE%E6%9C%89%E6%84%9F/"/>
    <url>/2023/09/12/Testin%20-%20JSP%E9%A1%B9%E7%9B%AE%E6%9C%89%E6%84%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="Testin-JSP项目有感"><a href="#Testin-JSP项目有感" class="headerlink" title="Testin - JSP项目有感"></a>Testin - JSP项目有感</h1><p>最近被分配到Web自动化测试的项目开发任务，由于时间紧张，因此为求迅速，节约前端成本，把部分的前端开发任务挪给后端，通过JSP这种老掉牙的技术去做，但是在真正的制作当中，有很多以往没有想到，或者没有规范话的好经验值得我去深思和回顾，大致内容如下：</p><h2 id="公共分页展示JS"><a href="#公共分页展示JS" class="headerlink" title="公共分页展示JS"></a>公共分页展示JS</h2><p>真正的官网或者Web项目中，分页随处可见，且复杂的工程分页要求也比较麻烦，比如默认如何显示，比如还需要显示条数，查询窗口等等，代码非常复杂，但这往往具有通用性，回想实习时候，第一次真正做企业级开发，什么东西都自己写，根本没有意识到，这种代码是完全可以重用的，现在想来懊悔不已，给个例子如下：</p><pre><code class="hljs java"><span class="hljs-comment">// 全文请见: Testin-JSP项目有感</span>&lt;c:<span class="hljs-keyword">if</span> test=<span class="hljs-string">"$&#123;pager.totalCount gt 0&#125;"</span>&gt;    &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"pagination-panel"</span>&gt;        &lt;c:choose&gt;            &lt;c:when test=<span class="hljs-string">"$&#123;pager.startPageNo == 1&#125;"</span>&gt;                &lt;c:<span class="hljs-keyword">if</span> test=<span class="hljs-string">"$&#123;pager.totalCount &lt;= pager.pageSize&#125;"</span>&gt;                    &lt;span&gt;&lt;fmt:message key='common.page_txt1'/&gt;1-$&#123;pager.totalCount&#125;&lt;fmt:message key='common.page_txt2'/&gt;&lt;fmt:message key='common.page_txt3'/&gt;$&#123;pager.totalCount&#125;&lt;fmt:message key='common.page_txt4'/&gt;&lt;/span&gt;                &lt;/c:if&gt;                &lt;c:<span class="hljs-keyword">if</span> test=<span class="hljs-string">"$&#123;pager.totalCount &gt; pager.pageSize&#125;"</span>&gt;                    &lt;span&gt;&lt;fmt:message key='common.page_txt1'/&gt;1-$&#123;pager.pageSize&#125;&lt;fmt:message key='common.page_txt2'/&gt;&lt;fmt:message key='common.page_txt3'/&gt;$&#123;pager.totalCount&#125;&lt;fmt:message key='common.page_txt4'/&gt;&lt;/span&gt;                &lt;/c:if&gt;            &lt;/c:when&gt;            &lt;c:when test=<span class="hljs-string">"$&#123;pager.startPageNo == pager.totalPageCount&#125;"</span>&gt;                &lt;span&gt;&lt;fmt:message key='common.page_txt1'/&gt;$&#123;(pager.startPageNo-1)*pager.pageSize + 1&#125;-$&#123;pager.totalCount&#125;&lt;fmt:message key='common.page_txt2'/&gt;&lt;fmt:message key='common.page_txt3'/&gt;$&#123;pager.totalCount&#125;&lt;fmt:message key='common.page_txt4'/&gt;&lt;/span&gt;            &lt;/c:when&gt;            &lt;c:otherwise&gt;                &lt;span&gt;&lt;fmt:message key='common.page_txt1'/&gt;$&#123;(pager.startPageNo-1)*pager.pageSize + 1&#125;-$&#123;pager.startPageNo*pager.pageSize&#125;&lt;fmt:message key='common.page_txt2'/&gt;&lt;fmt:message key='common.page_txt3'/&gt;$&#123;pager.totalCount&#125;&lt;fmt:message key='common.page_txt4'/&gt;&lt;/span&gt;            &lt;/c:otherwise&gt;        &lt;/c:choose&gt;        &lt;c:<span class="hljs-keyword">if</span> test=<span class="hljs-string">"$&#123;sessionScope.deploy_target eq 'PRIVATE CLOUDS' and isScriptSelectPage eq 1&#125;"</span>&gt;&lt;span style=<span class="hljs-string">"margin-left: 5px;"</span>&gt;&lt;fmt:message key=<span class="hljs-string">'common.page_txt5'</span>/&gt;</code></pre><p>我们做过MVC开发的都知道可以给model增加属性，因此，重要属性名称一致，参数名保证一致，即可完全做到高效的重用，做后端开发的伙伴都知道工具类的重要性，但是经常会忽略，其实前端也有工具类的说法，至少我在学习期间几乎没有意识到这种问题，因为毕竟前端的需求针对性较强一些，也不复杂，但真正的面向对象的思考，是一个开发者应该一直坚持的事情。</p><h2 id="装饰模式-核心界面为其装饰头，尾，菜单的效果"><a href="#装饰模式-核心界面为其装饰头，尾，菜单的效果" class="headerlink" title="装饰模式 - 核心界面为其装饰头，尾，菜单的效果"></a>装饰模式 - 核心界面为其装饰头，尾，菜单的效果</h2><p>我们去看阿里云或者其他实用型官网项目，如果有复杂的头，尾，左侧导航等界面，难道我们都得在界面中去实现吗？在学习jsp的时候，有import这个说法，可以把界面引入到本界面来，实现上述的效果，但是总觉得每次写一堆代码怪怪的，而且头部，尾部，菜单还得分开引用，比较麻烦。那么可以考虑配置装饰的方式，通过配置给界面主动添加如头部，尾部，菜单的界面</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sitemesh</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 指明满足“/json/”的页面，将被排除，不被装饰 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/json/*"</span> <span class="hljs-attr">exclue</span>=<span class="hljs-string">"true"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/ajax/*"</span> <span class="hljs-attr">exclue</span>=<span class="hljs-string">"true"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/login*"</span> <span class="hljs-attr">exclue</span>=<span class="hljs-string">"true"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/*/ajax/*"</span> <span class="hljs-attr">exclue</span>=<span class="hljs-string">"true"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/*/*/ajax/*"</span> <span class="hljs-attr">exclue</span>=<span class="hljs-string">"true"</span>/&gt;</span>    ....................................<span class="hljs-tag">&lt;/<span class="hljs-name">sitemesh</span>&gt;</span></code></pre><h2 id="合理的界面分层"><a href="#合理的界面分层" class="headerlink" title="合理的界面分层"></a>合理的界面分层</h2><p>刚开始做开发，没人教，或者有人教的时候，总是喜欢这么做，把所有东西堆到一个界面里去，然后传递参数到后端，后端把数据获取到，添加到model里，再展示到前端，顺便通过jquery把请求的界面节点的数据部分拿出来，再替换当前界面里的内容，以此完成一个完美的 “Ajax界面刷新的效果”，但是这么做有不好的地方</p><ol><li>想要这么做，在ajax请求时必须对返回的界面转化为jquery对象，然后通过find或者其他方法把数据节点位置找到再替换当前的内容，这里存在两个问题，一个是低版本的jq转换H5界面时候一直报错（换成高版本就OK）另外数据节点的寻找需要进行DOM的解析，会耗时</li><li>把参数什么的刷到后台，然后又从后台转到前台来，有点多此一举</li></ol><p>如果这么做呢？<br>查询条件界面 （留一个数据Div填充）- 数据界面（直接被Div包含，去掉多余的样式，body，html等无用的东西）</p><p>然后通过默认函数加载数据，通过分页跳转界面再加载数据等等…  完美解决了上面的需求，同时有以下的好处：</p><ul><li>界面分开后，代码会更加清晰。哪个部分干什么事一目了然</li><li>参数只用往后传，不用再往前传，完全解决了各种莫名其妙的回显问题</li><li>效率更高（由于不用再解析返回的界面了，直接通过jquery append到指定节点位置即可）</li></ul><h2 id="MVC-mapping-占位符的妙用"><a href="#MVC-mapping-占位符的妙用" class="headerlink" title="MVC mapping * 占位符的妙用"></a>MVC mapping * 占位符的妙用</h2><p>在MVC开发中，总有这样的需求前端三个界面不同，但是功能类似，此时映射三个mapping，到底写三个还是写一个然后把想法抽取？当然不可能写三个，但是写一个想法抽取的话，在语义上不明确，而且增加了额外的方法，让类变得更加复杂了，比较麻烦，那为何不利用 <code>*</code>去站位匹配呢？</p><pre><code class="hljs java"><span class="hljs-comment">// 此时匹配 list-任意内容 -&gt; 如 list-ajax  list-jsp等等</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/list-*"</span>)</code></pre><p>这样做的好处，可以把代码减少的最少，同时语义稍微明确一点，再来看一个更加方便的用处把</p><p>在初期学习界面，写的界面比较简单，总会用到各种各样的不包含太多逻辑的index界面，或者包含非常简单的基本数据而已，但是利用MVC设计的话，需要映射mapping，怎么做可以让代码更加简洁而且通用呢？</p><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseController</span> </span>&#123;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/path/*"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">jumpPath</span> <span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;        String path = request.getServletPath();        <span class="hljs-comment">// 截取path/ 之后的具体路径  如 finalPath</span>        String finalPath = path.sub........        <span class="hljs-keyword">return</span> finalPath;    &#125;&#125;<span class="hljs-comment">// 前端页面</span>href = <span class="hljs-string">"/path/task-list"</span>href = <span class="hljs-string">"/path/monkey-list"</span>href = <span class="hljs-string">"/path/money-list"</span>此时不再需要给每一个不需要什么逻辑的界面单独写一个controller去映射界面，是不是方便了很多？</code></pre><h2 id="一行代码，10个BUG"><a href="#一行代码，10个BUG" class="headerlink" title="一行代码，10个BUG"></a>一行代码，10个BUG</h2><p>真正开始工作之后才知道，什么jsp。ssm都是老掉牙的东西，整个编程的风气如今都是高并发，高可用诸如此类的，但是有天看到一句笑话，一位程序员说，<strong><em>天天尼玛高并发，高可用，一行代码，10个BUG，玩NM的高并发</em></strong>，如此粗俗的话一下子击中了我，后来我渐渐发现，原来我也是整天想着高并发高可用，完全没有意识到真正基础的重要性，最近做一个大批量文件导入的模块，涉及文件上传，用户操作配置，文件解析，文件导入等几个步骤，刷刷刷，代码写完，自测没毛病，交给测试了，后来一堆隐患问题就来了，直接掠过过程说问题：</p><ol><li>耗时操作的部分按钮没有加上限制，即点击后仍然处于可操作状态 -&gt; 非常致命</li><li>代码设计上，想到哪里写到哪里，功能最后都实现了，但是总的来说不完美，虽然不擅长JS。但这也不应该是借口，比如弹窗，按钮等等的重置效果，成功或者失败的响应效果，就应该封装好，统一调用等等</li></ol><p>总结：做一个事情不难，想真正做好一件事情，难</p><blockquote><p>一切都是有可能的，甚至那些不可能的也是.</p></blockquote><p>实习加工作10个月了，突然回顾之前的知识，觉得太浅显，但是仍然从如此浅显的内容中提炼出了以前并没有意识到的技巧或者更好的设计方式等等，因此记录了此篇感触，用以醒悟自身，不要自傲。</p><p>​                                                                                                                                                                                             2019年 8月26日 Kerwin</p>]]></content>
    
    
    <categories>
      
      <category>程序人生篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Testin - JSP项目有感</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「奇淫技巧」如何写最少的代码</title>
    <link href="/2023/09/12/%E3%80%8C%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7%E3%80%8D%E5%A6%82%E4%BD%95%E5%86%99%E6%9C%80%E5%B0%91%E7%9A%84%E4%BB%A3%E7%A0%81/"/>
    <url>/2023/09/12/%E3%80%8C%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7%E3%80%8D%E5%A6%82%E4%BD%95%E5%86%99%E6%9C%80%E5%B0%91%E7%9A%84%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于性格原因，笔者很难沉下心来进行严肃的系统学习，总是喜欢折腾一些奇淫技巧，非常喜欢代码设计，扣代码的细节，所以本次分享一下我所知道的<code>如何写最少的代码</code>的小技巧，如果你有更好的方案，欢迎在评论区留言，<code>方案很棒的话，加我微信，为你送上冬天的一杯奶茶~</code></p><h2 id="Java：我想返回多个返回值"><a href="#Java：我想返回多个返回值" class="headerlink" title="Java：我想返回多个返回值"></a>Java：我想返回多个返回值</h2><p>秀一下<code>Go</code>的多返回值：</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-comment">// 返回 X + Y 和 X * Y</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Computer</span><span class="hljs-params">(X, Y <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span></span> &#123;    <span class="hljs-keyword">return</span> X + Y, X * Y&#125;</code></pre><p>众所周知，Java仅支持单一返回值，一般情况下如果需要返回多个对象，我们会根据代码语义选择容器或者新建一个新的类，把我们需要的数据包起来。</p><p><code>这样做有没有问题？</code>当然没有问题，但是瑕疵就在于：可能会产生没啥语义但又不得不存在的<code>中间类</code>，我个人非常讨论该类代码，那么该如何解决这种问题呢？</p><p>首先需要认识到，解决方案必须满足几个要求：</p><ul><li>代码可复用</li><li>语义要清晰</li><li>安全</li></ul><p>既然如此，我们可以采用<code>泛型</code>来满足复用、语义清晰的要求，用<code>中间类</code>来满足代码安全性的要求，代码如下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MultipleTwoReturn</span>&lt;<span class="hljs-title">A</span>, <span class="hljs-title">B</span>&gt; </span>&#123;    <span class="hljs-comment">/** 第一个返回值 **/</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> A first;    <span class="hljs-comment">/** 第二个返回值 **/</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> B second;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MultipleTwoReturn</span><span class="hljs-params">(A first, B second)</span> </span>&#123;        <span class="hljs-keyword">this</span>.first = first;        <span class="hljs-keyword">this</span>.second = second;    &#125;    <span class="hljs-comment">// 省略Get方法</span>&#125;</code></pre><p>同时，我们可以依赖于<code>继承</code>，让该工具类拓展更多的参数：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MultipleThreeReturn</span>&lt;<span class="hljs-title">A</span>, <span class="hljs-title">B</span>, <span class="hljs-title">C</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">MultipleTwoReturn</span>&lt;<span class="hljs-title">A</span>, <span class="hljs-title">B</span>&gt; </span>&#123;    <span class="hljs-comment">/** 第三个返回值 **/</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> C third;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MultipleThreeReturn</span><span class="hljs-params">(A first, B second, C third)</span> </span>&#123;        <span class="hljs-keyword">super</span>(first, second);        <span class="hljs-keyword">this</span>.third = third;    &#125;&#125;</code></pre><p>测试类：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MultipleApp</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        MultipleTwoReturn&lt;Integer, String&gt; returnTest = MultipleApp.getReturnTest();        System.out.println(returnTest.getFirst());        System.out.println(returnTest.getSecond());    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> MultipleTwoReturn&lt;Integer, String&gt; <span class="hljs-title">getReturnTest</span><span class="hljs-params">()</span> </span>&#123;        MultipleTwoReturn&lt;Integer, String&gt; demo = <span class="hljs-keyword">new</span> MultipleTwoReturn&lt;&gt;(<span class="hljs-number">0</span>, <span class="hljs-string">"Kerwin Demo."</span>);        <span class="hljs-keyword">return</span> demo;    &#125;&#125;</code></pre><p>本质还是<code>普通对象</code>，但是加上<code>泛型</code>后威力剧增！由于在方法定义时就强制了<code>泛型约束</code>，语义非常清晰，同时可以完全杜绝上述的无语义中间类，当然一些必要的，有业务含义的组装类，不建议使用这种方式。</p><h2 id="泛型：我想new一个对象"><a href="#泛型：我想new一个对象" class="headerlink" title="泛型：我想new一个对象"></a>泛型：我想new一个对象</h2><p>大家在学Java泛型之初有没有这种想法？我想利用<T>作为泛型约束，却需要<code>new</code>一个<code>T</code>，但是Java它<code>new</code>不出来啊 😂</T></p><p>很久之前我在写一个通用的<code>Java爬虫接口</code>，里面有一个功能就是<code>传入目标网页的即可获取到针对不同网页设计的Bean</code>，大概如下所示：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SpiderBeansHandle</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-comment">/** 获取Url **/</span>    <span class="hljs-function">String <span class="hljs-title">getUrl</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">/** 获取Cookie **/</span>    <span class="hljs-function">String <span class="hljs-title">getCookie</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">/** 获取CSS selector **/</span>    <span class="hljs-function">String <span class="hljs-title">getSelector</span><span class="hljs-params">()</span></span>;        <span class="hljs-comment">// ....</span> &#125;</code></pre><p>中间关键的一点即如何获取到这个Bean，那个时候我只有一个想法：<code>new 一个 T</code></p><p>事实证明，我过于天真了 🙄</p><p>但是换种思路，既然<code>new</code>不出来，那我就返回一下吧，于是代码出炉了~</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SpiderBeansHandle</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取Url</span><span class="hljs-comment">     */</span>    <span class="hljs-function">String <span class="hljs-title">getUrl</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取Cookie</span><span class="hljs-comment">     */</span>    <span class="hljs-function">String <span class="hljs-title">getCookie</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 获取CSS selector</span><span class="hljs-comment">     */</span>    <span class="hljs-function">String <span class="hljs-title">getSelector</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 解析Element</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> element  element</span><span class="hljs-comment">     */</span>    <span class="hljs-function">T <span class="hljs-title">parseElement</span><span class="hljs-params">(Element element)</span></span>;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * Get Beans</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> handle  Bean对象 | handle对象</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt;     Bean类型</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>        List&lt;Beans&gt;</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">getBeans</span><span class="hljs-params">(SpiderBeansHandle&lt;T&gt; handle)</span> </span>&#123;        List&lt;T&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        List&lt;Element&gt; elements = SpiderUtils.getElementWithCookie(handle.getUrl(), handle.getSelector(), handle.getCookie());        <span class="hljs-keyword">for</span> (Element element : elements) &#123;            T bean = handle.parseElement(element);            <span class="hljs-keyword">if</span> (bean != <span class="hljs-keyword">null</span>) &#123;                list.add(bean);            &#125;        &#125;        <span class="hljs-keyword">return</span> list;    &#125;&#125;</code></pre><p>关键一步就在于：</p><pre><code class="hljs java"><span class="hljs-comment">/***</span><span class="hljs-comment"> * 解析Element</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> element  element</span><span class="hljs-comment"> */</span><span class="hljs-function">T <span class="hljs-title">parseElement</span><span class="hljs-params">(Element element)</span></span>;</code></pre><p>那么这个小技巧有什么用呢？仔细看会不会觉得它像一种设计模式的变形体？没错！真相只有一个：<code>模板方法模式</code></p><p>我刚提到了我需要一个<code>处理爬虫的通用接口</code>，因为简单爬虫无非就是拿到url然后请求，解析细节封装到自身的Bean里，然后获取一个列表，那么在开发业务代码的时候类似，肯定有某些场景和需求具有高度的一致性，那么使用这种设计方案即可大大的减少重复代码~</p><h2 id="方法：你到底想干嘛？"><a href="#方法：你到底想干嘛？" class="headerlink" title="方法：你到底想干嘛？"></a>方法：你到底想干嘛？</h2><p>咱们在写代码的时候有没有遇到过这种问题？写了一个工具类方法，但是功能又过于单一，虽说单一原则好吧，但是一个小逻辑写一堆方法，总感觉不得劲，如何解决咧？</p><p>Java8提供的函数式编程即可帮我们一定程度上解决这种问题，如：</p><pre><code class="hljs java"><span class="hljs-comment">// 写一个获取文件列表，且判断是否为txt结尾的工具类方法，新手会这么写</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> File <span class="hljs-title">getFileWithTxt</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    File file = <span class="hljs-keyword">new</span> File(path);    <span class="hljs-keyword">if</span> (!file.exists()) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">"File is not exist."</span>);    &#125;    <span class="hljs-keyword">if</span> (file.getName().endsWith(<span class="hljs-string">".txt"</span>)) &#123;        <span class="hljs-keyword">return</span> file;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre><p>老手一般会把 <code>.txt</code> 作为参数传入，<code>但是某一天我需要判断文件大小，文件长度，甚至是文件内容的时候，我该咋办？再写N个？</code></p><p>最好的方案即传入 <code>Predicate</code> 谓词，让调用者<code>自定义处理逻辑</code>，然后再把最常用的逻辑基于该方法复写一下，拓展性Max！代码如下：</p><pre><code class="hljs java"><span class="hljs-comment">/***</span><span class="hljs-comment"> * 文件夹谓词匹配</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> file          文件</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> predicate     谓词匹配</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span>              List&lt;File&gt;</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IOException  IOException</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;File&gt; <span class="hljs-title">listFilesInDirWithFilter</span><span class="hljs-params">(File file, Predicate&lt;String&gt; predicate)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<span class="hljs-keyword">if</span> (!file.exists()) &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">"File is not exist."</span>);     &#125;List&lt;File&gt; fileList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-keyword">if</span> (file.isDirectory()) &#123;File[] files = file.listFiles();<span class="hljs-keyword">for</span> (File f : Objects.requireNonNull(files)) &#123;fileList.addAll(listFilesInDirWithFilter(f, predicate));         &#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> (predicate.test(file.getName())) &#123;fileList.add(file);&#125;&#125;<span class="hljs-keyword">return</span> fileList;&#125;</code></pre><p>类似的还比如说处理 <code>IO</code>，直接上代码：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readLine</span><span class="hljs-params">(BufferedReader br, Consumer&lt;String&gt; handle, <span class="hljs-keyword">boolean</span> close)</span> </span>&#123;    String s;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">while</span> (((s = br.readLine()) != <span class="hljs-keyword">null</span>)) &#123;            handle.accept(s);        &#125;    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;        e.printStackTrace();    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-keyword">if</span> (close &amp;&amp; br != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">try</span> &#123;                br.close();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre><p><code>方法</code>说你到底想干嘛？！算了，你想干嘛就干嘛吧，请随意😎~ </p><h2 id="重载：写的更多也是为了写的更少"><a href="#重载：写的更多也是为了写的更少" class="headerlink" title="重载：写的更多也是为了写的更少"></a>重载：写的更多也是为了写的更少</h2><p><code>写的更多也是为了写的更少</code>，这句话乍一听感觉非常矛盾，但是编程经验比较丰富的小伙伴应该能体会到<code>方法重载</code>的威力，尤其是在写工具类或者底层接口的时候，建议大家先写一个大而全的<code>内部方法</code>，然后一点点去根据需要重载它，会有意想不到的好处。</p><p>最简单的例子，如下：</p><pre><code class="hljs java"><span class="hljs-comment">// Root 方法</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readLine</span><span class="hljs-params">(BufferedReader br, Consumer&lt;String&gt; handle, <span class="hljs-keyword">boolean</span> close)</span> </span>&#123;    String s;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">while</span> (((s = br.readLine()) != <span class="hljs-keyword">null</span>)) &#123;            handle.accept(s);        &#125;    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;        e.printStackTrace();    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-keyword">if</span> (close &amp;&amp; br != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">try</span> &#123;                br.close();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;<span class="hljs-comment">// 重载方法一</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readLine</span><span class="hljs-params">(String path, Consumer&lt;String&gt; handle, <span class="hljs-keyword">boolean</span> close)</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(path));        readLine(br, handle, close);    &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;        e.printStackTrace();    &#125;&#125;<span class="hljs-comment">// 重载方法二</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readLine</span><span class="hljs-params">(String path, Consumer&lt;String&gt; handle)</span> </span>&#123;readLine(path, handle, <span class="hljs-keyword">true</span>);&#125;</code></pre><p><code>重载</code>可以让我们的方法调用方式变得丰富多彩，在语义明确的情况下，写代码有如神助，配合函数式编程，可以让工具类或者底层接口的能力大大增强。</p><p>同时，当我们需要调整某一个方法逻辑时，也可以使用<code>继续重载</code>的方式，将影响面降到最小，尽量不动其他模块的代码。</p><h2 id="终极：从设计模式到抽象"><a href="#终极：从设计模式到抽象" class="headerlink" title="终极：从设计模式到抽象"></a>终极：从设计模式到抽象</h2><p>与其说是<code>如何写最少的代码</code>，不如说是：<code>如何只写真正有价值的代码</code>。</p><p>面对这种问题的时候，我们第一反应肯定就是设计模式了，例如上文的泛型章节提到的<code>模板方法模式</code>，小小的推荐一下我之前的文章：</p><ul><li><a href="https://juejin.cn/post/6844904176653172749" target="_blank" rel="noopener">【一起学系列】之模板方法：写SSO我只要5分钟</a></li><li><a href="https://juejin.cn/post/6846687591425638413" target="_blank" rel="noopener">设计模式总篇：从为什么需要原则到实际落地</a></li></ul><p>通过良好的设计模式或者其变形体，我们可以得到高内聚低耦合的代码，这是一个非常好的思路。</p><p>另一个思路，所有人都认同一点：<code>程序 = 算法 + 数据结构</code>，选择好正确的数据结构可以事倍功半，比如说我们做<code>类似文件夹需求</code>的时候，会想到使用<code>链表</code>或者<code>树</code>结构，在做如：<code>如何高效的给用户发送生日短信</code>时会想到用<code>堆</code>结构（用当前时间对比堆中的最大值，满足则继续迭代，减少遍历）等等。</p><p>这其实都是抽象，或深或浅而已，我最开始学习Java的时候，老师会说一句话：万物皆为对象，我们来看看上面的技巧各自对应着什么？</p><ul><li>多返回值：封装对象 + 泛型约束</li><li>泛型：封装对象的公共接口，高度抽象</li><li>函数式方法：把方法当作一个对象</li><li>重载：对象方法（行为）的不断演化</li></ul><p>所以如何只写真正有价值的代码？官方一点的话就是：<code>把变化的抽象出来</code>，那么到底该怎么抽？</p><p>这就需要我们一点点的去探索了，毕竟<code>奇淫技巧</code>只是小道尔，不过我会一直探索下去。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>如果你觉得这篇内容对你有帮助的话：</p><ol><li>当然要点赞支持一下啦~</li><li>另外，搜索并关注公众号「<strong>是Kerwin啊</strong>」，一起在技术的路上走下去吧~ 😋</li></ol>]]></content>
    
    
    <categories>
      
      <category>编码及设计模式篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>「奇淫技巧」如何写最少的代码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「生产事故」MongoDB复合索引引发的灾难</title>
    <link href="/2023/09/12/%E3%80%8C%E7%94%9F%E4%BA%A7%E4%BA%8B%E6%95%85%E3%80%8DMongoDB%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95%E5%BC%95%E5%8F%91%E7%9A%84%E7%81%BE%E9%9A%BE/"/>
    <url>/2023/09/12/%E3%80%8C%E7%94%9F%E4%BA%A7%E4%BA%8B%E6%95%85%E3%80%8DMongoDB%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95%E5%BC%95%E5%8F%91%E7%9A%84%E7%81%BE%E9%9A%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="「生产事故」MongoDB复合索引引发的灾难"><a href="#「生产事故」MongoDB复合索引引发的灾难" class="headerlink" title="「生产事故」MongoDB复合索引引发的灾难"></a>「生产事故」MongoDB复合索引引发的灾难</h1><h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><ol><li>11月末<code>我司商品服务</code>的<code>MongoDB主库</code>曾出现过严重抖动、频繁锁库等情况。</li><li>由于诸多业务存在插入<code>MongoDB</code>、然后立即查询等逻辑，因此项目并未开启读写分离。</li><li>最终定位问题是由于：服务器自身磁盘 + 大量<code>慢查询</code>导致</li><li>基于上述情况，运维同学后续着重增强了对<code>MongoDB慢查询</code>的监控和告警</li></ol><blockquote><p><strong>幸运的一点</strong>：在出事故之前刚好完成了缓存过期时间的升级且过期时间为一个月，<code>C端查询</code>都落在缓存上，因此没有造成<code>P0级</code>事故，仅仅阻塞了部分<code>B端逻辑</code></p></blockquote><br><h2 id="事故回放"><a href="#事故回放" class="headerlink" title="事故回放"></a>事故回放</h2><p>我司的各种监控做的比较到位，当天突然收到了数据库服务器负载较高的告警通知，于是我和同事们就赶紧登录了<code>Zabbix监控</code>，如下图所示，截图的时候是正常状态，当时事故期间忘记留图了，可以想象当时的数据曲线反正是该高的很低，该低的很高就是了。</p><blockquote><p>Zabbix 分布式监控系统官网:<a href="https://www.zabbix.com/" target="_blank" rel="noopener">https://www.zabbix.com/</a></p></blockquote><p><img src="/2023/09/12/%E3%80%8C%E7%94%9F%E4%BA%A7%E4%BA%8B%E6%95%85%E3%80%8DMongoDB%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95%E5%BC%95%E5%8F%91%E7%9A%84%E7%81%BE%E9%9A%BE/image-20201209005754862.png" srcset="/img/loading.gif" alt="image-20201209005754862"></p><br><h2 id="开始分析"><a href="#开始分析" class="headerlink" title="开始分析"></a>开始分析</h2><p>我们研发是没有操控服务器权限的，因此委托运维同学帮助我们抓取了部分查询记录，如下所示：</p><pre><code class="hljs bash">---+Op          | Duration | Query                                                                                                                   ---+query       | 5 s      | &#123;<span class="hljs-string">"filter"</span>: &#123;<span class="hljs-string">"orgCode"</span>: 350119, <span class="hljs-string">"fixedStatus"</span>: &#123;<span class="hljs-string">"<span class="hljs-variable">$in</span>"</span>: [1, 2]&#125;&#125;, <span class="hljs-string">"sort"</span>: &#123;<span class="hljs-string">"_id"</span>: -1&#125;, <span class="hljs-string">"find"</span>: <span class="hljs-string">"sku_main"</span>&#125;               query       | 5 s      | &#123;<span class="hljs-string">"filter"</span>: &#123;<span class="hljs-string">"orgCode"</span>: 350119, <span class="hljs-string">"fixedStatus"</span>: &#123;<span class="hljs-string">"<span class="hljs-variable">$in</span>"</span>: [1, 2]&#125;&#125;, <span class="hljs-string">"sort"</span>: &#123;<span class="hljs-string">"_id"</span>: -1&#125;, <span class="hljs-string">"find"</span>: <span class="hljs-string">"sku_main"</span>&#125;               query       | 4 s      | &#123;<span class="hljs-string">"filter"</span>: &#123;<span class="hljs-string">"orgCode"</span>: 346814, <span class="hljs-string">"fixedStatus"</span>: &#123;<span class="hljs-string">"<span class="hljs-variable">$in</span>"</span>: [1, 2]&#125;&#125;, <span class="hljs-string">"sort"</span>: &#123;<span class="hljs-string">"_id"</span>: -1&#125;, <span class="hljs-string">"find"</span>: <span class="hljs-string">"sku_main"</span>&#125;               query       | 4 s      | &#123;<span class="hljs-string">"filter"</span>: &#123;<span class="hljs-string">"orgCode"</span>: 346814, <span class="hljs-string">"fixedStatus"</span>: &#123;<span class="hljs-string">"<span class="hljs-variable">$in</span>"</span>: [1, 2]&#125;&#125;, <span class="hljs-string">"sort"</span>: &#123;<span class="hljs-string">"_id"</span>: -1&#125;, <span class="hljs-string">"find"</span>: <span class="hljs-string">"sku_main"</span>&#125;              query       | 4 s      | &#123;<span class="hljs-string">"filter"</span>: &#123;<span class="hljs-string">"orgCode"</span>: 346814, <span class="hljs-string">"fixedStatus"</span>: &#123;<span class="hljs-string">"<span class="hljs-variable">$in</span>"</span>: [1, 2]&#125;&#125;, <span class="hljs-string">"sort"</span>: &#123;<span class="hljs-string">"_id"</span>: -1&#125;, <span class="hljs-string">"find"</span>: <span class="hljs-string">"sku_main"</span>&#125;...</code></pre><p>查询很慢的话所有研发应该第一时间想到的就是<code>索引</code>的使用问题，所以立即检查了一遍索引，如下所示：</p><pre><code class="hljs bash"><span class="hljs-comment">### 当时的索引</span>db.sku_main.ensureIndex(&#123;<span class="hljs-string">"_id"</span>: -1&#125;,&#123;background:<span class="hljs-literal">true</span>&#125;);db.sku_main.ensureIndex(&#123;<span class="hljs-string">"orgCode"</span>: 1, <span class="hljs-string">"_id"</span>: -1&#125;,&#123;background:<span class="hljs-literal">true</span>&#125;);db.sku_main.ensureIndex(&#123;<span class="hljs-string">"orgCode"</span>: 1, <span class="hljs-string">"upcCode"</span>: 1&#125;,&#123;background:<span class="hljs-literal">true</span>&#125;);....</code></pre><p>我屏蔽了干扰项，反正能很明显的看出来，这个查询是完全可以命中索引的，所以就需要直面第一个问题：</p><p><strong><font color="red">上述查询记录中排首位的慢查询到底是不是出问题的根源？</font></strong></p><p>我的判断是：它应该不是数据库整体缓慢的根源，因为第一它的查询条件足够简单暴力，完全命中索引，在索引之上有一点其他的查询条件而已，第二在查询记录中也存在相同结构不同条件的查询，耗时非常短。</p><p>在运维同学继续排查查询日志时，发现了另一个比较惊爆的查询，如下：</p><pre><code class="hljs bash"><span class="hljs-comment">### 当时场景日志</span>query: &#123; <span class="hljs-variable">$query</span>: &#123; shopCategories.0: &#123; <span class="hljs-variable">$exists</span>: <span class="hljs-literal">false</span> &#125;, orgCode: 337451, fixedStatus: &#123; <span class="hljs-variable">$in</span>: [ 1, 2 ] &#125;, _id: &#123; <span class="hljs-variable">$lt</span>: 2038092587 &#125; &#125;, <span class="hljs-variable">$orderby</span>: &#123; _id: -1 &#125; &#125; planSummary: IXSCAN &#123; _id: 1 &#125; ntoreturn:1000 ntoskip:0 keysExamined:37567133 docsExamined:37567133 cursorExhausted:1 keyUpdates:0 writeConflicts:0 numYields:293501 nreturned:659 reslen:2469894 locks:&#123; Global: &#123; acquireCount: &#123; r: 587004 &#125; &#125;, Database: &#123; acquireCount: &#123; r: 293502 &#125; &#125;, Collection: &#123; acquireCount: &#123; r: 293502 &#125; &#125; &#125; <span class="hljs-comment"># 耗时</span>179530ms</code></pre><p>耗时180秒且基于查询的<code>执行计划</code>可以看出，它走的是<code>_id_</code>索引，进行了全表扫描，扫描的数据总量为：37567133，不慢才怪。</p><br><h2 id="迅速解决"><a href="#迅速解决" class="headerlink" title="迅速解决"></a>迅速解决</h2><p>定位到问题后，没办法立即修改，第一要务是：<code>止损</code></p><p>结合当时的时间也比较晚了，因此我们发了公告，禁止了上述查询的功能并短暂暂停了部分业务，，过了一会之后进行了<code>主从切换</code>，再去看<code>Zabbix监控</code>就一切安好了。</p><br><h2 id="分析根源"><a href="#分析根源" class="headerlink" title="分析根源"></a>分析根源</h2><p>我们回顾一下查询的语句和我们预期的索引，如下所示：</p><pre><code class="hljs bash"><span class="hljs-comment">### 原始Query</span>db.getCollection(<span class="hljs-string">"sku_main"</span>).find(&#123;         <span class="hljs-string">"orgCode"</span> : NumberLong(337451),         <span class="hljs-string">"fixedStatus"</span> : &#123;             <span class="hljs-string">"<span class="hljs-variable">$in</span>"</span> : [                1.0,                 2.0            ]        &#125;,         <span class="hljs-string">"shopCategories"</span> : &#123;             <span class="hljs-string">"<span class="hljs-variable">$exists</span>"</span> : <span class="hljs-literal">false</span>        &#125;,         <span class="hljs-string">"_id"</span> : &#123;             <span class="hljs-string">"<span class="hljs-variable">$lt</span>"</span> : NumberLong(2038092587)        &#125;    &#125;).sort(    &#123;         <span class="hljs-string">"_id"</span> : -1.0    &#125;).skip(1000).<span class="hljs-built_in">limit</span>(1000);<span class="hljs-comment">### 期望的索引</span>db.sku_main.ensureIndex(&#123;<span class="hljs-string">"orgCode"</span>: 1, <span class="hljs-string">"_id"</span>: -1&#125;,&#123;background:<span class="hljs-literal">true</span>&#125;);</code></pre><p>乍一看，好像一切都很Nice啊，字段<code>orgCode</code>等值查询，字段<code>_id</code>按照创建索引的方向进行倒序排序，为啥会这么慢？</p><p>但是，关键的一点就在 <code>$lt</code> 上</p><h3 id="知识点一：索引、方向及排序"><a href="#知识点一：索引、方向及排序" class="headerlink" title="知识点一：索引、方向及排序"></a>知识点一：索引、方向及排序</h3><p>在MongoDB中，排序操作可以通过从索引中按照索引的顺序获取文档的方式，来保证结果的有序性。</p><p>如果MongoDB的查询计划器没法从索引中得到排序顺序，那么它就需要在内存中对结果排序。</p><blockquote><p><strong>注意</strong>：在内存排序时，默认最大限制是32M，超过即会抛出错误</p></blockquote><h3 id="知识点二：单列索引不在乎方向"><a href="#知识点二：单列索引不在乎方向" class="headerlink" title="知识点二：单列索引不在乎方向"></a>知识点二：单列索引不在乎方向</h3><p>无论是MongoDB还是MySQL都是用的树结构作为索引，如果<code>排序方向</code>和<code>索引方向</code>相反，只需要从另一头开始遍历即可，如下所示：</p><pre><code class="hljs bash"><span class="hljs-comment"># 索引</span>db.records.createIndex(&#123;a:1&#125;); <span class="hljs-comment"># 查询</span>db.records.find().sort(&#123;a:-1&#125;);<span class="hljs-comment"># 索引为升序，但是我查询要按降序，我只需要从右端开始遍历即可满足需求，反之亦然</span>MIN 0 1 2 3 4 5 6 7 MAX</code></pre><h3 id="MongoDB的复合索引结构"><a href="#MongoDB的复合索引结构" class="headerlink" title="MongoDB的复合索引结构"></a>MongoDB的复合索引结构</h3><blockquote><p>官方介绍：MongoDB supports <em>compound indexes</em>, where a single index structure holds references to multiple fields within a collection’s documents. </p></blockquote><p>复合索引结构示意图如下所示：</p><p><img src="/2023/09/12/%E3%80%8C%E7%94%9F%E4%BA%A7%E4%BA%8B%E6%95%85%E3%80%8DMongoDB%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95%E5%BC%95%E5%8F%91%E7%9A%84%E7%81%BE%E9%9A%BE/image-20201209012242728.png" srcset="/img/loading.gif" alt="image-20201209012242728"></p><p>该索引刚好和我们讨论的是一样的，<code>userid顺序</code>，<code>score倒序</code>，同时假设当前表存在单列索引: <code>{&quot;score&quot;: -1}</code></p><p>我们需要直面第二个问题：<strong><font color="red">复合索引在使用时需不需要在乎方向？</font></strong></p><p>假设两个查询条件：</p><pre><code class="hljs bash"><span class="hljs-comment"># 查询 一</span>db.getCollection(<span class="hljs-string">"records"</span>).find(&#123;   <span class="hljs-string">"userid"</span> : <span class="hljs-string">"ca2"</span>&#125;).sort(&#123;<span class="hljs-string">"score"</span> : -1.0&#125;);<span class="hljs-comment"># 使用索引</span>&#123;<span class="hljs-string">"userid"</span>:1, <span class="hljs-string">"score"</span>:-1&#125;<span class="hljs-comment"># 查询 二</span>db.getCollection(<span class="hljs-string">"records"</span>).find(&#123;   <span class="hljs-string">"userid"</span> : <span class="hljs-string">"ca2"</span>&#125;).sort(&#123;<span class="hljs-string">"score"</span> : 1.0&#125;);<span class="hljs-comment"># 使用索引</span>&#123;<span class="hljs-string">"userid"</span>:1, <span class="hljs-string">"score"</span>:-1&#125;</code></pre><p>上述的查询没有任何问题，因为受到<code>score</code>字段排序的影响，只是数据从左侧还是从右侧遍历的问题，那么下面的一个查询呢？</p><pre><code class="hljs bash"><span class="hljs-comment"># 错误示范</span>db.getCollection(<span class="hljs-string">"records"</span>).find(&#123;   <span class="hljs-string">"userid"</span> : <span class="hljs-string">"ca2"</span>,  <span class="hljs-string">"score"</span> : &#123;     <span class="hljs-string">"<span class="hljs-variable">$lt</span>"</span> : NumberLong(2038092587)  &#125;&#125;).sort(&#123;<span class="hljs-string">"score"</span> : -1.0&#125;);<span class="hljs-comment"># 使用索引</span>&#123;<span class="hljs-string">"score"</span>:-1&#125;</code></pre><p>错误原因如下：</p><ul><li><strong><font color="red">由于score字段按照倒序排序，因此为了使用该索引，所以需要从左侧开始遍历</font></strong></li><li><strong><font color="red">从倒序顺序中找小于某个值的数据，势必会扫描很多无用数据，然后丢弃，当前场景下找大于某个值才是最佳方案</font></strong></li><li><strong><font color="red">所以MongoDB为了更多场景考虑，在该种情况下，放弃了复合索引，选用其他的索引，如 score 的单列索引</font></strong></li></ul><h2 id="针对性修改"><a href="#针对性修改" class="headerlink" title="针对性修改"></a>针对性修改</h2><p>仔细阅读了根源之后，再回顾线上的查询语句，针对性修改，把 <code>$lt</code> 条件改为 <code>$gt</code> 观察优化结果:</p><pre><code class="hljs bash"><span class="hljs-comment"># 原始查询</span>[TEMP INDEX] =&gt; lt: &#123;<span class="hljs-string">"limit"</span>:1000,<span class="hljs-string">"queryObject"</span>:&#123;<span class="hljs-string">"_id"</span>:&#123;<span class="hljs-string">"<span class="hljs-variable">$lt</span>"</span>:2039180008&#125;,<span class="hljs-string">"categoryId"</span>:23372,<span class="hljs-string">"orgCode"</span>:351414,<span class="hljs-string">"fixedStatus"</span>:&#123;<span class="hljs-string">"<span class="hljs-variable">$in</span>"</span>:[1,2]&#125;&#125;,<span class="hljs-string">"restrictedTypes"</span>:[],<span class="hljs-string">"skip"</span>:0,<span class="hljs-string">"sortObject"</span>:&#123;<span class="hljs-string">"_id"</span>:-1&#125;&#125;<span class="hljs-comment"># 原始耗时</span>[TEMP LT] =&gt; 超时 （超时时间10s）<span class="hljs-comment"># 优化后查询</span>[TEMP INDEX] =&gt; gt: &#123;<span class="hljs-string">"limit"</span>:1000,<span class="hljs-string">"queryObject"</span>:&#123;<span class="hljs-string">"_id"</span>:&#123;<span class="hljs-string">"<span class="hljs-variable">$gt</span>"</span>:2039180008&#125;,<span class="hljs-string">"categoryId"</span>:23372,<span class="hljs-string">"orgCode"</span>:351414,<span class="hljs-string">"fixedStatus"</span>:&#123;<span class="hljs-string">"<span class="hljs-variable">$in</span>"</span>:[1,2]&#125;&#125;,<span class="hljs-string">"restrictedTypes"</span>:[],<span class="hljs-string">"skip"</span>:0,<span class="hljs-string">"sortObject"</span>:&#123;<span class="hljs-string">"_id"</span>:-1&#125;&#125;<span class="hljs-comment"># 优化后耗时</span>[TEMP GT] =&gt; 耗时: 383ms , List Size: 999</code></pre><h2 id="修改方案"><a href="#修改方案" class="headerlink" title="修改方案"></a>修改方案</h2><ol><li><p>反向排序条件即可</p><pre><code class="hljs bash"><span class="hljs-comment"># 上文提到了索引可以从左或者从右开始遍历，因此调整文档扫描方向即可</span><span class="hljs-comment"># 注: 需要主动申明首位(orgCode)字段查询方向，否则会按默认方向查找</span>sort(&#123; <span class="hljs-string">"orgCode"</span> : -1.0&#125;,&#123; <span class="hljs-string">"_id"</span> : 1.0&#125;)</code></pre></li><li><p>修改业务代码</p><ol><li>预先查出查询条件下<code>_id</code>最小值（完全利用索引，速度非常快）</li><li>将 <code>lt</code> 查询换成 <code>gt</code> 查询即可</li></ol></li></ol><h2 id="拓展场景：无其他索引干扰时的场景"><a href="#拓展场景：无其他索引干扰时的场景" class="headerlink" title="拓展场景：无其他索引干扰时的场景"></a>拓展场景：无其他索引干扰时的场景</h2><p>上文中为了模拟线上事故，所以我们假定了一个复合索引以及一个单列索引，即：</p><pre><code class="hljs bash">&#123;<span class="hljs-string">"userid"</span>: 1, <span class="hljs-string">"score"</span>: -1&#125;&#123;<span class="hljs-string">"score"</span>: -1&#125;</code></pre><p>当我们删除单列索引，按不符合方向的查询，会有什么现象呢？</p><pre><code class="hljs bash"><span class="hljs-comment"># 仅剩复合索引时</span>db.getCollection(<span class="hljs-string">"records"</span>).find(&#123;   <span class="hljs-string">"userid"</span> : <span class="hljs-string">"ca2"</span>,  <span class="hljs-string">"score"</span> : &#123;     <span class="hljs-string">"<span class="hljs-variable">$lt</span>"</span> : NumberLong(2038092587)  &#125;&#125;).sort(&#123;<span class="hljs-string">"score"</span> : -1.0&#125;);<span class="hljs-comment"># 使用索引</span>&#123;<span class="hljs-string">"userid"</span>:1, <span class="hljs-string">"score"</span>:-1&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>分析了小2000字，其实改动就是两个字符而已，当然真正的改动需要考虑业务的需要，但是问题既然已经定位，修改什么的就不难了，回顾上述内容总结如下：</p><ul><li>学习数据库知识的时候可以用类比的方式，但是需要额外注意其不同的地方（MySQL、MongoDB索引、索引的方向）</li><li>MongoDB单列索引可以不在乎方向</li><li>MongoDB无法通过索引排序时会在内存中进行排序，超过默认大小（32M）限制后悔报错</li><li><code>MongoDB数据库复合索引在使用中一定要注意其方向</code>，要完全理解其逻辑，<code>要么完全相同，要么完全相反</code>，避免索引失效</li><li>针对上一条：<code>但当索引选择器没有更优解时，即使查询方向不符合索引方向，也会使用目标索引</code></li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>如果你觉得这篇内容对你挺有帮助的话：</p><ol><li>当然要点赞支持一下啦~</li><li>搜索并关注公众号「<strong>是Kerwin啊</strong>」，一起唠唠嗑~</li><li>再来看看最近几篇的「<strong>查漏补缺</strong>」系列吧，该系列会持续输出~<ul><li><a href="https://juejin.cn/post/6870264679063617550" target="_blank" rel="noopener">「查缺补漏」巩固你的Nginx知识体系</a></li><li><a href="https://juejin.cn/post/6862865811137101837" target="_blank" rel="noopener">「查缺补漏」巩固你的RocketMQ知识体系</a></li><li><a href="https://juejin.cn/post/6857667542652190728" target="_blank" rel="noopener">「查缺补漏」巩固你的Redis知识体系（笑）</a></li><li><a href="https://juejin.cn/post/6860262796618268680" target="_blank" rel="noopener">悄咪咪提高团队幸福感 &amp; Surprise！</a></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>MongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>「生产事故」MongoDB复合索引引发的灾难</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一文入门DNS？从访问GitHub开始</title>
    <link href="/2023/09/12/%E4%B8%80%E6%96%87%E5%85%A5%E9%97%A8DNS%EF%BC%9F%E4%BB%8E%E8%AE%BF%E9%97%AEGitHub%E5%BC%80%E5%A7%8B/"/>
    <url>/2023/09/12/%E4%B8%80%E6%96%87%E5%85%A5%E9%97%A8DNS%EF%BC%9F%E4%BB%8E%E8%AE%BF%E9%97%AEGitHub%E5%BC%80%E5%A7%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大家都是做开发的，都有<code>GitHub</code>的账号，在日常使用中肯定会遇到这种情况，在不修改任何配置的情况下，有时可以正常访问GitHub，有时又直接未响应，来一起捋捋到底是为啥。</p><h2 id="GitHub访问的千层套路"><a href="#GitHub访问的千层套路" class="headerlink" title="GitHub访问的千层套路"></a>GitHub访问的千层套路</h2><p>以我家里的电脑为例，在不修改任何配置，不启用什么代理工具的情况下，访问<code>GitHub</code>会得到以下结果：</p><p><img src="/2023/09/12/%E4%B8%80%E6%96%87%E5%85%A5%E9%97%A8DNS%EF%BC%9F%E4%BB%8E%E8%AE%BF%E9%97%AEGitHub%E5%BC%80%E5%A7%8B/%E9%94%99%E4%B9%B1.png" srcset="/img/loading.gif" alt></p><p>😂😂😂</p><p>虽然很戳心，但好歹能展示一部分。</p><p>从网上搜了一堆乱七八糟的攻略，知道了可以通过修改电脑的<code>Hosts</code>文件达到正常访问的能力，于是胡搜了一通，</p><p>步骤：<a href="https://jingyan.baidu.com/article/9113f81b49ed2f2b3214c7fa.html" target="_blank" rel="noopener">百度经验</a></p><p>效果如下：</p><p><img src="/2023/09/12/%E4%B8%80%E6%96%87%E5%85%A5%E9%97%A8DNS%EF%BC%9F%E4%BB%8E%E8%AE%BF%E9%97%AEGitHub%E5%BC%80%E5%A7%8B/%E4%BC%98%E5%8C%96-1.png" srcset="/img/loading.gif" alt></p><p>访问效果依然很感人，最近活动数据不显示，整个界面加载都快接近2分钟了，有什么办法没有咧~</p><h3 id="站长工具-PING-PING-PING"><a href="#站长工具-PING-PING-PING" class="headerlink" title="站长工具 PING PING PING"></a>站长工具 PING PING PING</h3><p>都是搞开发的，都会用F12看看网络或者资源请求的地址是什么，以上面耗时最慢的地址为例，域名为：<code>github.githu.com</code></p><p>打开站长工具的PING功能，地址为：<a href="http://ping.chinaz.com/github.githu.com" target="_blank" rel="noopener">http://ping.chinaz.com/github.githu.com</a></p><p>结果如下：</p><p><img src="/2023/09/12/%E4%B8%80%E6%96%87%E5%85%A5%E9%97%A8DNS%EF%BC%9F%E4%BB%8E%E8%AE%BF%E9%97%AEGitHub%E5%BC%80%E5%A7%8B/image-20200722010132371.png" srcset="/img/loading.gif" alt="image-20200722010132371"></p><p>我发现 <code>185.199.108.154</code> 这个IP地址速度快的一批，于是立马更换 <code>Hosts</code>中该域名对应的IP地址</p><p>再次访问，效果如下：</p><p><img src="/2023/09/12/%E4%B8%80%E6%96%87%E5%85%A5%E9%97%A8DNS%EF%BC%9F%E4%BB%8E%E8%AE%BF%E9%97%AEGitHub%E5%BC%80%E5%A7%8B/%E4%BC%98%E5%8C%96-2.png" srcset="/img/loading.gif" alt></p><p>那句话怎么说的来着？如什么什么般丝滑，我感觉这就非常丝滑~  🤪</p><h3 id="GitHub项目定时发布最新Hosts"><a href="#GitHub项目定时发布最新Hosts" class="headerlink" title="GitHub项目定时发布最新Hosts"></a>GitHub项目定时发布最新Hosts</h3><p>当然了，如果每次访问都得折腾一次，那滋味，简直不要太难受，所以网上已经有人开源了相关的项目，会定时发布最新的 <code>GitHub</code> IP地址，链接：<a href="https://github.com/521xueweihan/GitHub520" target="_blank" rel="noopener">https://github.com/521xueweihan/GitHub520</a></p><p>本文撰写时的Hosts</p><pre><code class="hljs bash"><span class="hljs-comment"># github</span>185.199.108.154               github.githu.com199.232.68.133                camo.githubusercontent.com52.168.24.190                 github.map.fastly.net199.232.69.194                github.global.ssl.fastly.net140.82.112.4                  github.com140.82.112.5                  api.github.com199.232.68.133                raw.githubusercontent.com199.232.68.133                user-images.githubusercontent.com199.232.68.133                favicons.githubusercontent.com199.232.68.133                avatars5.githubusercontent.com199.232.68.133                avatars4.githubusercontent.com199.232.68.133                avatars3.githubusercontent.com199.232.68.133                avatars2.githubusercontent.com199.232.68.133                avatars1.githubusercontent.com199.232.68.133                avatars0.githubusercontent.com</code></pre><p>该项目会自动发布在指定的地址上，结合软件使用，可以完全自动化，无需持续更新</p><p>当然也可以自行手动更改</p><h2 id="为什么改了Hosts就能访问GitHub"><a href="#为什么改了Hosts就能访问GitHub" class="headerlink" title="为什么改了Hosts就能访问GitHub"></a>为什么改了Hosts就能访问GitHub</h2><p>平常都是百度 + 谷歌，今天非要探究一下原理！咱们一步一步来，首先大家都需要明确一点，在网络的世界中 <code>域名</code> 只是为了便于记忆和识别而存在的一个唯一地址，真正工作的仍然是 <code>IP</code></p><h3 id="Hosts文件是干吗的"><a href="#Hosts文件是干吗的" class="headerlink" title="Hosts文件是干吗的"></a>Hosts文件是干吗的</h3><p>简单来说，Hosts文件是存储本机网址域名与其对应的IP地址的一个文件，在网络请求阶段发挥作用</p><h3 id="为什么改了Hosts就能生效"><a href="#为什么改了Hosts就能生效" class="headerlink" title="为什么改了Hosts就能生效"></a>为什么改了Hosts就能生效</h3><p>这就涉及到了域名解析，因为Hosts文件存放的就是 <code>域名</code> 和 <code>IP</code> 的对应关系，因此它可以在域名解析阶段发挥作用，为什么呢？因为在域名解析的流程中 <code>本机Hosts</code> 解析处于顺序二</p><p>即：浏览器解析 -》<code>本机解析</code> -》XXXX（后面的稍后再提）</p><p>所以有时候我们白嫖软件，都会改一下 <code>Hosts</code>，因为需要把它在线验证的域名指向错误的地址去，另外可能存在一定的浏览器缓存或者本机缓存，可以通过重开浏览器或者 <code>PING</code> 域名来检查更改是否生效。</p><h3 id="DNS解析到底是什么玩意？"><a href="#DNS解析到底是什么玩意？" class="headerlink" title="DNS解析到底是什么玩意？"></a>DNS解析到底是什么玩意？</h3><p>上文中多次提到<code>解析</code>，其实说的就是 <code>DNS解析</code> </p><p>同时上文也提到过，在网络世界中真正发挥作用的是 <code>IP</code>，而一般情况下我们访问的都是 <code>域名</code>，为什么能实现这种效果，就是因为域名与IP地址的对应关系存储在一个叫做 <code>DNS（Domain Name System）</code> 的系统里。DNS是一个全球化的分布式数据库，它所提供的服务就是将域名转换为互联网IP地址。</p><h3 id="DNS解析的全部流程"><a href="#DNS解析的全部流程" class="headerlink" title="DNS解析的全部流程"></a>DNS解析的全部流程</h3><p>网上的关于流程的图很多，我从中借鉴了一副，如下所示：</p><p><img src="/2023/09/12/%E4%B8%80%E6%96%87%E5%85%A5%E9%97%A8DNS%EF%BC%9F%E4%BB%8E%E8%AE%BF%E9%97%AEGitHub%E5%BC%80%E5%A7%8B/385704-20190108192401036-1125761048.png" srcset="/img/loading.gif" alt="img"></p><ol><li><p>浏览器缓存：一次请求会首先通过浏览器缓存信息寻找域名映射的IP地址，这也是为什么有时候我们改了本机hosts，需要关闭再打开浏览器才能正常使用，如果找到则返回，没找到则继续到下一级</p></li><li><p>本机系统缓存：即上文中提到的，通过 <code>hosts</code> 文件来映射域名和IP，在上古时期有很多垃圾软件会悄咪咪的修改系统的 hosts文件，达到 <code>DNS劫持</code> 的目的，即把淘宝域名指向另一个 <code>IP</code>，然后部署一个高仿的淘宝商城，静静等你输入账号，密码，然后凉凉…</p></li><li><p>本地域名解析服务系统：本地域名系统LDNS一般都是本地区的域名服务器。离你的位置都比较近，Windows系统使用命令<code>ipconfig</code> 就可以查看，在Linux和Mac系统下，直接使用命令 <code>cat /etc/resolv.conf</code> 来查看LDNS服务地址。<br>LDNS一般都缓存了大部分的域名解析的结果，大部分的解析工作到这里就差不多已经结束了</p></li></ol><p>   以下即是所谓的 <code>递归解析</code></p><ol start="4"><li><p>根域名解析：本地域名解析服务系统无法解析时，会向 <code>13根</code> 发起域名解析请求</p><p><font color="red">说明：</font> 所谓的 13根，指的是根域名服务器，是架构因特网所必须的基础设施。根服务器主要用来管理互联网的主目录，由于DNS解析中采用的是UDP协议，仅能传递512字节的有效报文，因此只能构建出A-M 13个根服务器，而真正工作运行肯定不止13台服务器，而是包含很多服务器镜像的</p></li><li><p>根域名解析服务器返回  <code>gTLD (Generic top-level domain)</code> 给本地解析服务器，即该域名所属的顶级域及其所在的服务器，顶级域名即如：.com .cn等等</p></li><li><p>本地解析服务器已知顶级域名服务器地址后，发起解析请求</p></li><li><p>顶级域名解析服务器返回 <code>权限域名服务器</code> 信息给本地解析服务器，<code>权限域名服务器</code> 即如：taobao.com</p></li><li><p>本地解析服务器已知权限域名服务器地址后，发起解析请求</p></li><li><p>权限域名服务器返回域名对应的IP地址给本地解析服务器</p></li><li><p>本地解析服务器缓存相关信息，并返回给用户</p></li></ol><p>是不是有点绕？咱们来整个图吧，<code>递归解析</code> 如下所示：</p><p><img src="/2023/09/12/%E4%B8%80%E6%96%87%E5%85%A5%E9%97%A8DNS%EF%BC%9F%E4%BB%8E%E8%AE%BF%E9%97%AEGitHub%E5%BC%80%E5%A7%8B/image-20200722233231460.png" srcset="/img/loading.gif" alt="image-20200722233231460"></p><h3 id="再问一遍为什么改Hosts就可以访问GitHub"><a href="#再问一遍为什么改Hosts就可以访问GitHub" class="headerlink" title="再问一遍为什么改Hosts就可以访问GitHub"></a>再问一遍为什么改Hosts就可以访问GitHub</h3><p>了解了上文之后，对于这个问题就更好回答了，因为GitHub毕竟为外国的网站，咱们访问时有一层 <code>DNS污染</code>，即把对应的域名指向了不可达的IP上，或者禁止访问的IP上，因此很多时候无法使用</p><p>修改Hosts文件后即避免了DNS污染，直达目标IP，即可正常访问了，当然了，这种方法是全部通用吗？</p><p>答案：肯定不是，因为刚才也提到了，网关层是可以控制某些IP禁止访问的</p><p>整一个工具来验证一下猜想，顺便看看我们的整个请求流程：</p><p>软件名：BestTrace</p><p><img src="/2023/09/12/%E4%B8%80%E6%96%87%E5%85%A5%E9%97%A8DNS%EF%BC%9F%E4%BB%8E%E8%AE%BF%E9%97%AEGitHub%E5%BC%80%E5%A7%8B/trans.png" srcset="/img/loading.gif" alt></p><p>我请求的域名是 <code>github.githu.com</code>，最终请求接收方IP和我Hosts配置的IP一致，那我换一个  facebook.com </p><p><img src="/2023/09/12/%E4%B8%80%E6%96%87%E5%85%A5%E9%97%A8DNS%EF%BC%9F%E4%BB%8E%E8%AE%BF%E9%97%AEGitHub%E5%BC%80%E5%A7%8B/image-20200722234214751.png" srcset="/img/loading.gif" alt="image-20200722234214751"></p><p>可以看到，当请求到达 221.183.46.249 这个IP时，整个请求就被拦截下来了，因此这并不是万能的办法</p><p>除了访问GitHub，还有什么时候可能用到呢？</p><p>比如下载 <code>IDEA插件</code>时，如果发现老是刷新不出来插件库，或者下载失败，就可以通过PING工具去配置最佳IP，方便下载~</p><h2 id="DNS除了解析还能做什么"><a href="#DNS除了解析还能做什么" class="headerlink" title="DNS除了解析还能做什么"></a>DNS除了解析还能做什么</h2><h3 id="智能DNS"><a href="#智能DNS" class="headerlink" title="智能DNS"></a>智能DNS</h3><p>网络请求交由域名解析服务器来处理，分配到最佳的服务器IP上</p><p>例如：请求的源头是电信还是联通等，如果是电信则将解析的IP分流到电信对应的IP上，或者返回距离最近的服务器IP地址</p><h3 id="反向代理水平扩展"><a href="#反向代理水平扩展" class="headerlink" title="反向代理水平扩展"></a>反向代理水平扩展</h3><p>典型的互联网架构中，可以通过增加<code>web-server</code>来扩充web层的性能，但反向代理nginx仍是整个系统的唯一入口</p><p><strong>如果系统吞吐超过nginx的性能极限</strong>，那么将难以扩容，此时就需要<code>dns-server</code>来配合水平扩展。</p><p>即DNS解析服务器有序的把域名解析到不同的网关层，每次DNS解析请求，轮询返回不同的ip，这样就能实现nginx的水平扩展，这个方法叫 “<strong>DNS轮询</strong>”</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>参考资料：</p><p><a href="https://www.cnblogs.com/kongtongshu/p/11069559.html" target="_blank" rel="noopener">博客园  DNS解析全过程分析</a></p><p><a href="https://blog.csdn.net/shenjian58/article/details/107273629/" target="_blank" rel="noopener">除了解析域名，DNS还能干吗</a></p><p>如果觉得对你有用的话，不要忘记点个赞啊~    也可以扫描二维码关注我，一起朝着技术人的顶峰前进！</p><p><img src="/2023/09/12/%E4%B8%80%E6%96%87%E5%85%A5%E9%97%A8DNS%EF%BC%9F%E4%BB%8E%E8%AE%BF%E9%97%AEGitHub%E5%BC%80%E5%A7%8B/1734e416a4d04ce4" srcset="/img/loading.gif" alt></p>]]></content>
    
    
    <categories>
      
      <category>网络篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>一文入门DNS？从访问GitHub开始</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代理模式</title>
    <link href="/2023/09/12/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/09/12/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="代理模式篇"><a href="#代理模式篇" class="headerlink" title="代理模式篇"></a>代理模式篇</h1><h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>为其他对象提供一种代理以控制对这个对象的访问</p><h2 id="代理模式的诞生"><a href="#代理模式的诞生" class="headerlink" title="代理模式的诞生"></a>代理模式的诞生</h2><p>【<font color="orange">产品</font>】：Kerwin，我记得你是在通州租房住吧？</p><p>【<font color="blue">开发</font>】：是啊，怎么了？</p><p>【<font color="orange">产品</font>】：你是房东直租还是中介啊？我最近真是特别烦中介，收费都好黑！</p><p>【<font color="blue">开发</font>】：我啊，我租的房子名义上倒是房东直租，但估计还是中介，你知道吗，中介的扩张是一个必然。</p><p>【<font color="orange">产品</font>】：扩张？你指的是全北京的房子都是中介的意思吗？</p><p>【<font color="blue">开发</font>】：现在肯定不至于全部都是，但也是大部分了，为什么会这样呢，因为中介需要控制租户，控制租金市场，如果租户直租房东，房东钱多人好，就很有可能很便宜，这就会打乱市场价格，所以拿下所有房老板，<font color="red">不仅为了赚钱，也是为了控制这种市场关系</font>。</p><p>【<font color="orange">产品</font>】：我看你们程序员平常“傻傻的”，怎么对这个这么了解？莫非有计算机相关的故事？</p><p>【<font color="blue">开发</font>】：被你说中了，这个就是代理模式！它的诞生就是为了控制对象的访问，<font color="red">不过我们一般是用来增强其功能</font>，不像XXX🤪</p><p><img src="/2023/09/12/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/image-20200622004018317.png" srcset="/img/loading.gif" alt="image-20200622004018317"></p><h2 id="HeadFirst-核心代码"><a href="#HeadFirst-核心代码" class="headerlink" title="HeadFirst 核心代码"></a>HeadFirst 核心代码</h2><p><strong><em>定义正常业务类接口</em></strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PhoneInterface</span> </span>&#123;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 更新电话号码</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> phoneNum    电话号码</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception  可能抛出Exception 异常</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updatePhone</span><span class="hljs-params">(Long phoneNum)</span></span>;&#125;</code></pre><p><strong><em>实现正常业务类</em></strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhoneServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PhoneInterface</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updatePhone</span><span class="hljs-params">(Long phoneNum)</span> </span>&#123;        System.out.println(<span class="hljs-string">"update phoneNum is: -&gt; "</span> + phoneNum);    &#125;&#125;</code></pre><p><strong><em>静态代理业务类</em></strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhoneServiceProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PhoneInterface</span> </span>&#123;    <span class="hljs-comment">/** 代理模式一般自行New对象, 反观装饰器模式则是传入对象 **/</span>    <span class="hljs-keyword">private</span> PhoneInterface phoneInterface;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PhoneServiceProxy</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.phoneInterface = <span class="hljs-keyword">new</span> PhoneServiceImpl();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updatePhone</span><span class="hljs-params">(Long phoneNum)</span> </span>&#123;        before(phoneNum);        phoneInterface.updatePhone(phoneNum);        after();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">(Long phoneNum)</span> </span>&#123;        System.out.println(MessageFormat.format(<span class="hljs-string">"log start time:&#123;0&#125; , phoneNum is: &#123;1&#125;"</span>, <span class="hljs-keyword">new</span> Date(), phoneNum));        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == phoneNum || String.valueOf(phoneNum).length() != <span class="hljs-number">11</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Update phoneNum fail, phoneNum is wrong."</span>);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(MessageFormat.format(<span class="hljs-string">"log end time:&#123;0&#125;"</span>, <span class="hljs-keyword">new</span> Date()));    &#125;&#125;</code></pre><p><font color="red">静态代理模式的设计思路：</font></p><ul><li>Proxy  代理类</li><li>RealSubject  定义被代理的实体</li><li>Subject  定义RealSubject和Proxy共用接口</li></ul><p>简单来说，</p><ol><li>需要一个普通接口及其普通实现类</li><li>代理类同时实现该接口，自行new出对应实现类对象，对接口方法的前后增加额外操作</li></ol><blockquote><p>如果看着有点模棱两可，建议看完本文后，访问专题设计模式开源项目，里面有具体的代码示例，链接在最下面</p></blockquote><h2 id="装饰器模式和代理模式的区别"><a href="#装饰器模式和代理模式的区别" class="headerlink" title="装饰器模式和代理模式的区别"></a>装饰器模式和代理模式的区别</h2><ul><li>持有对象方式：代理模式一般是New，装饰器模式则是传入同一接口对象</li><li>意图：装饰器模式意在增强方法功能，代理模式意在控制对象的访问（例如代码中增加校验）</li></ul><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>刚才 HeadFirst核心代码 章节展示的是其静态代码的书写方式，如果所有的类都基于这样实现，那势必发生类膨胀的无解问题，因此真正常用的还是动态代理，分为两种 CGLIB | JDK动态代理</p><h3 id="JDK-动态代理之MyBatis"><a href="#JDK-动态代理之MyBatis" class="headerlink" title="JDK 动态代理之MyBatis"></a>JDK 动态代理之MyBatis</h3><p><strong><em>注意事项：</em></strong></p><ol><li>JDK动态代理的本质是创造一个实现了同一个接口的Proxy代理类，去进行真正的调用</li><li>JDK动态代理在实现中的本质是反射技术</li><li>由于所有的代理类都实现了Proxy.class -&gt; 包括帮我们创造的代理类也是，因此由于JAVA单继承的特点，只能想要实现代理必须实现某一个接口</li></ol><p><strong><em>JDK 动态代理必不可少的三要素：InvocationHandler，newProxyInstance，invoke</em></strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisInvocation</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 代理指定的接口</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> tClass 接口class</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt;    接口类型</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">newProxyInstance</span><span class="hljs-params">(Class&lt;T&gt; tClass)</span> </span>&#123;        <span class="hljs-keyword">return</span> (T) Proxy.newProxyInstance(tClass.getClassLoader(), <span class="hljs-keyword">new</span> Class[]&#123;tClass&#125;, <span class="hljs-keyword">new</span> MybatisInvocation());    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        <span class="hljs-keyword">if</span> (method.isAnnotationPresent(Select<span class="hljs-class">.<span class="hljs-keyword">class</span>)) </span>&#123;            Select select = method.getAnnotation(Select<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            System.out.println(MessageFormat.format(<span class="hljs-string">"Method Name: &#123;0&#125; , Annotation Value is: &#123;1&#125;"</span>, method.getName(), select.value()));        &#125;        <span class="hljs-comment">// 获取到SQL及参数, 即可通过JDBC进行数据库操作查询数据, MyBatis不再神秘</span>        <span class="hljs-keyword">return</span> Arrays.asList(<span class="hljs-string">"I"</span>, <span class="hljs-string">" am"</span>, <span class="hljs-string">" Kerwin~"</span>);    &#125;&#125;</code></pre><p><strong><em>被代理的接口</em></strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyBatis</span> </span>&#123;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"select * from demo"</span>)    <span class="hljs-function">List&lt;String&gt; <span class="hljs-title">select</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p><strong><em>测试调用</em></strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// JDK动态代理：模拟 MyBatis 核心代理阶段</span>        MyBatis batis = MybatisInvocation.newProxyInstance(MyBatis<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        System.out.println(<span class="hljs-string">"Result:"</span> + batis.select());    &#125;&#125;</code></pre><p><strong><em>输出结果</em></strong></p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> Method Name: select , Annotation Value is: select * from demo</span><span class="hljs-meta">#</span><span class="bash"> Result:[I,  am,  Kerwin~]</span></code></pre><p><font color="red">MyBatis中的JDK 动态代理：</font>我们在使用MyaBtis的时候，肯定想过，它凭什么一个接口就可以输出结果，利用JDK 动态代理，可以非常方便的构建接口的代理，我们便可以在 <code>Invoke</code> 方法中大做文章，解析方法注解的值，解析其方法返回值，然后利用JDBC即可实现数据库查询实现一个简单ORM框架，推荐大家自行尝试一下</p><h3 id="CGLIB-动态代理之AOP"><a href="#CGLIB-动态代理之AOP" class="headerlink" title="CGLIB 动态代理之AOP"></a>CGLIB 动态代理之AOP</h3><p><strong><em>基础使用</em></strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhoneCglibProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;    Object target;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PhoneCglibProxy</span><span class="hljs-params">(Object o)</span> </span>&#123;        <span class="hljs-keyword">this</span>.target = o;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">newProxyInstance</span><span class="hljs-params">()</span></span>&#123;        Enhancer en = <span class="hljs-keyword">new</span> Enhancer();        <span class="hljs-comment">// 设置要代理的目标类</span>        en.setSuperclass(target.getClass());        <span class="hljs-comment">// 设置要代理的拦截器</span>        en.setCallback(<span class="hljs-keyword">this</span>);        <span class="hljs-comment">// 生成代理类的实例</span>        <span class="hljs-keyword">return</span> en.create();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        System.out.println(MessageFormat.format(<span class="hljs-string">"Method Name is: &#123;0&#125; Params is: &#123;1&#125;"</span>, method.getName(), Arrays.toString(objects)));        <span class="hljs-keyword">return</span> methodProxy.invokeSuper(o, objects);    &#125;&#125;</code></pre><p><strong><em>测试调用</em></strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * CGLIB动态代理</span><span class="hljs-comment">     *      如果类是final的，则无法生成代理对象，报错</span><span class="hljs-comment">     *      如果方法是final的，代理无效</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * 关键代码：</span><span class="hljs-comment">     *     1.PhoneCglibProxy 实现 MethodInterceptor 方法拦截器接口  同时实现其 newProxyInstance方法 -&gt; 该方法内容比较固定</span><span class="hljs-comment">     *     2.通过代理工厂构建, 创建对象, 使用即可</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * Spring 3.2之后默认包含了cglib依赖</span><span class="hljs-comment">     * 普通项目 CGLIB依赖如下:</span><span class="hljs-comment">     *</span><span class="hljs-comment">     *     &lt;dependency&gt;</span><span class="hljs-comment">     *        &lt;groupId&gt;cglib&lt;/groupId&gt;</span><span class="hljs-comment">     *        &lt;artifactId&gt;cglib-nodep&lt;/artifactId&gt;</span><span class="hljs-comment">     *        &lt;version&gt;2.2.2&lt;/version&gt;</span><span class="hljs-comment">     *     &lt;/dependency&gt;</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * 推荐代码阅读顺序：</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> PhoneServiceImpl</span><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> PhoneCglibProxy</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        PhoneServiceImpl phone = <span class="hljs-keyword">new</span> PhoneServiceImpl();        PhoneCglibProxy proxyFactory = <span class="hljs-keyword">new</span> PhoneCglibProxy(phone);        PhoneServiceImpl service = (PhoneServiceImpl) proxyFactory.newProxyInstance();        service.updatePhone(<span class="hljs-number">15186564812L</span>);    &#125;&#125;</code></pre><p><font color="red">CGLIB 动态代理：</font>Spring 3.2之后默认包含了cglib依赖，在使用中也要注意 final 关键字会使CGLIB代理失效，另外<font color="red">Spring AOP 默认采用JDK 动态代理，同时配合CGLIB代理一起实现的</font>。</p><h3 id="两种动态代理总结"><a href="#两种动态代理总结" class="headerlink" title="两种动态代理总结"></a>两种动态代理总结</h3><ul><li>JDK 动态代理只能针对实现了接口的类的接口方法进行代理</li><li>CgLib 动态代理基于继承来实现代理，所以无法对final类、private方法和static方法实现代理</li></ul><p><strong><em>Spring AOP</em></strong>：</p><ul><li>如果目标对象实现了接口，则默认采用JDK 动态代理</li><li>如果目标对象没有实现接口，则采用CgLib 动态代理</li><li>如果目标对象实现了接口，且强制CgLib 代理，则采用CgLib进行动态代理</li></ul><blockquote><p>关于两种动态原理的实现原理可以查查其他的文章~</p></blockquote><h2 id="遵循的设计原则"><a href="#遵循的设计原则" class="headerlink" title="遵循的设计原则"></a>遵循的设计原则</h2><ul><li>封装变化：在父级接口中提供 default 方法，子类实现其对应的状态方法即可</li><li>多用组合，少用继承：代理模式经常和策略模式做对比，它们都是利用组合而非继承增强其变化和能力</li></ul><h2 id="什么场景适合使用代理模式"><a href="#什么场景适合使用代理模式" class="headerlink" title="什么场景适合使用代理模式"></a>什么场景适合使用代理模式</h2><p>当我们需要为额外控制对象方法的执行时，比如历史项目的接口都没有记录日志，在Spring环境下，我们可以对所有的Bean方法增加日志功能，又或是多数据源时，通过注解标明对应的数据源，解耦代码等等</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p><strong>附上GOF一书中对于代理模式的UML图：</strong></p><p><img src="/2023/09/12/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/image-20200622012022768.png" srcset="/img/loading.gif" alt="image-20200622012022768"></p><h2 id="相关代码链接"><a href="#相关代码链接" class="headerlink" title="相关代码链接"></a>相关代码链接</h2><p><a href="https://github.com/kkzhilu/Kerwin-DesignPattern" target="_blank" rel="noopener">GitHub地址</a></p><ul><li>兼顾了《HeadFirst》以及《GOF》两本经典书籍中的案例</li><li>提供了友好的阅读指导</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/5/18/172284a1c8caf324?w=487&h=185&f=png&s=17561" srcset="/img/loading.gif" alt></p>]]></content>
    
    
    <categories>
      
      <category>编码及设计模式篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代理模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单测实践</title>
    <link href="/2023/09/12/%E5%8D%95%E6%B5%8B%E5%AE%9E%E8%B7%B5/"/>
    <url>/2023/09/12/%E5%8D%95%E6%B5%8B%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="单测实践"><a href="#单测实践" class="headerlink" title="单测实践"></a>单测实践</h1><h2 id="认知与误区"><a href="#认知与误区" class="headerlink" title="认知与误区"></a>认知与误区</h2><p>我之前以为的单测：</p><ul><li>基于整个Spring体系（测试Profile/预发Profile）运行代码、连接实际的数据库、Redis、中间件</li><li>模拟实际数据，拿到对应的返回结果</li></ul><p>理论上来说，这样的思路也没问题，因为在实际单测的场景中确实有一部分代码需要实际与中间件交互，来排查问题、整合数据、或者干脆测试环境DeBug。</p><p>新的领域：单测不仅仅可以通过完全复刻环境的方式进行，也可以通过<code>模拟</code>来进行，其本质是修改字节码，让其返回我需要的数据，进而保障整个方法的运行，保障方法内部if else的覆盖。</p><h2 id="Jacoco-实践"><a href="#Jacoco-实践" class="headerlink" title="Jacoco 实践"></a>Jacoco 实践</h2><h1 id="接入方式"><a href="#接入方式" class="headerlink" title="接入方式"></a>接入方式</h1><p>以离线方式为例(方便后续使用Powermock对静态方法、构造方法进行mock)</p><h2 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h2><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">jacoco.version</span>&gt;</span>0.8.2<span class="hljs-tag">&lt;/<span class="hljs-name">jacoco.version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span></code></pre><p>在最外层的pom中全局引入jacoco依赖：</p><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.jacoco<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>org.jacoco.agent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">classifier</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">classifier</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;jacoco.version&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></span></code></pre><p>全局plugin</p><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.22.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">systemPropertyVariables</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">jacoco-agent.destfile</span>&gt;</span>target/jacoco.exec<span class="hljs-tag">&lt;/<span class="hljs-name">jacoco-agent.destfile</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">systemPropertyVariables</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><span class="xml">  <span class="hljs-comment">&lt;!-- 生成JaCoCo覆盖率数据插件 --&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.jacoco<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jacoco-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;jacoco.version&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>default-instrument<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span></span><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>instrument<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>default-restore-instrumented-classes<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span></span><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>restore-instrumented-classes<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span></span><span class="xml">      <span class="hljs-comment">&lt;!-- attached to Maven test phase --&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>default-report<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span></span><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>report<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span></span></code></pre><h2 id="在IDEA中统计单元测试覆盖率"><a href="#在IDEA中统计单元测试覆盖率" class="headerlink" title="在IDEA中统计单元测试覆盖率"></a>在IDEA中统计单元测试覆盖率</h2><ol><li>在执行测试方法时，选择 <strong>Run with Converage</strong></li></ol><p>![img](/Users/kexianming1/Desktop/GitHub/super-kerwin/Best Coder/质量保障篇/单测实践/link.png)</p><ol start="2"><li>在执行完成后，会出现单元测试覆盖率统计界面</li></ol><p>![image-20230303140406664](/Users/kexianming1/Desktop/GitHub/super-kerwin/Best Coder/质量保障篇/单测实践/image-20230303140406664.png)</p><h2 id="PowerMock-编码"><a href="#PowerMock-编码" class="headerlink" title="PowerMock 编码"></a>PowerMock 编码</h2><h3 id="maven接入"><a href="#maven接入" class="headerlink" title="maven接入"></a>maven接入</h3><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">mockito.version</span>&gt;</span>3.12.4<span class="hljs-tag">&lt;/<span class="hljs-name">mockito.version</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">powermock.version</span>&gt;</span>2.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">powermock.version</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mockito<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mockito-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;mockito.version&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.powermock<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>powermock-module-junit4<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;powermock.version&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.powermock<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>powermock-api-mockito2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;powermock.version&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span></code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><a href="https://github.com/powermock/powermock/wiki/Mockito" target="_blank" rel="noopener">https://github.com/powermock/powermock/wiki/Mockito</a></p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><pre><code class="hljs java"><span class="hljs-meta">@RunWith</span>(MockitoJUnitRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">OrderServiceImplTest</span> </span>&#123;    <span class="hljs-meta">@Mock</span>    <span class="hljs-keyword">private</span> OrderQueryServiceRpc mockOrderQueryServiceRpc;    <span class="hljs-meta">@InjectMocks</span>    <span class="hljs-keyword">private</span> OrderServiceImpl orderServiceImplUnderTest;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetOrderInfoByOrderId4OrderSystemCancel</span> <span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// Setup</span>        <span class="hljs-comment">// Configure OrderQueryServiceRpc.getOrderByOrderId(...).</span>        <span class="hljs-keyword">final</span> OrderDTO orderDTO = <span class="hljs-keyword">new</span> OrderDTO();        orderDTO.setOrderId(<span class="hljs-number">0L</span>);        orderDTO.setSrcOrderId(<span class="hljs-string">"srcOrderId"</span>);        orderDTO.setSrcPlatId(<span class="hljs-number">0</span>);        orderDTO.setSrcOrderType(<span class="hljs-number">0</span>);        orderDTO.setSrcInnerType(<span class="hljs-number">0</span>);        orderDTO.setSrcInnerOrderId(<span class="hljs-number">0L</span>);        orderDTO.setOrderType(<span class="hljs-number">0</span>);        orderDTO.setOrderStatus(<span class="hljs-number">0</span>);        orderDTO.setOrderStatusTime(<span class="hljs-keyword">new</span> GregorianCalendar(<span class="hljs-number">2020</span>, Calendar.JANUARY, <span class="hljs-number">1</span>).getTime());        orderDTO.setOrderStartTime(<span class="hljs-keyword">new</span> GregorianCalendar(<span class="hljs-number">2020</span>, Calendar.JANUARY, <span class="hljs-number">1</span>).getTime());        <span class="hljs-keyword">final</span> ServiceResponse&lt;OrderDTO&gt; orderDTOServiceResponse = <span class="hljs-keyword">new</span> ServiceResponse&lt;&gt;(orderDTO);        when(mockOrderQueryServiceRpc.getOrderByOrderId(eq(<span class="hljs-number">0L</span>), any(String[]<span class="hljs-class">.<span class="hljs-keyword">class</span>))).<span class="hljs-title">thenReturn</span>(<span class="hljs-title">orderDTOServiceResponse</span>)</span>;        <span class="hljs-comment">// Run the test</span>        <span class="hljs-keyword">final</span> List&lt;SystemCancelOrderDto&gt; result = orderServiceImplUnderTest.getOrderInfoByOrderId4OrderSystemCancel(<span class="hljs-number">0L</span>);        <span class="hljs-comment">// Verify the results</span>    &#125;&#125;</code></pre><h3 id="插件-快速自动化"><a href="#插件-快速自动化" class="headerlink" title="插件 快速自动化"></a>插件 快速自动化</h3><p>Squaretest</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><strong>JUnit5</strong> 要引入 <strong>mockito-junit-jupiter</strong> 包，并使用 <strong>@ExtendWith</strong> 注解来引入</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- mockito for junit5 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mockito<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mockito-junit-jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.23.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h1 id="单元测试准则"><a href="#单元测试准则" class="headerlink" title="单元测试准则"></a>单元测试准则</h1><h3 id="1-保持单元测试小巧-快速"><a href="#1-保持单元测试小巧-快速" class="headerlink" title="1. 保持单元测试小巧, 快速"></a>1. 保持单元测试小巧, 快速</h3><p>理论上, 任何代码提交前都应该完整跑一遍所有测试套件. 保持测试代码执行迅捷能够缩短迭代开发周期.</p><h3 id="2-单元测试应该是全自动且无交互"><a href="#2-单元测试应该是全自动且无交互" class="headerlink" title="2. 单元测试应该是全自动且无交互"></a>2. 单元测试应该是全自动且无交互</h3><p>测试套件通常是定期执行的, 执行过程必须完全自动化才有意义. 需要人工检查输出结果的测试不是一个好的单元测试.</p><h3 id="3-让单元测试很容易跑起来"><a href="#3-让单元测试很容易跑起来" class="headerlink" title="3. 让单元测试很容易跑起来"></a>3. 让单元测试很容易跑起来</h3><p>对开发环境进行配置, 最好是敲条命令或是点个按钮就能把单个测试用例或测试套件跑起来.</p><h3 id="4-对测试进行评估"><a href="#4-对测试进行评估" class="headerlink" title="4. 对测试进行评估"></a>4. 对测试进行评估</h3><p>对执行的测试进行覆盖率分析, 得到精确的代码执行覆盖率, 并调查哪些代码未被执行.</p><h3 id="5-立即修正失败的测试"><a href="#5-立即修正失败的测试" class="headerlink" title="5. 立即修正失败的测试"></a>5. 立即修正失败的测试</h3><p>每个开发人员在提交前都应该保证新的测试用例执行成功, 当有代码提交时, 现有测试用例也都能跑通.</p><p>如果一个定期执行的测试用例执行失败, 整个团队应该放下手上的工作优先解决这个问题.</p><h3 id="6-把测试维持在单元级别"><a href="#6-把测试维持在单元级别" class="headerlink" title="6. 把测试维持在单元级别"></a>6. 把测试维持在单元级别</h3><p>单元测试即类 (Class) 的测试. 一个 “测试类” 应该只对应于一个 “被测类”, 并且 “被测类” 的行为应该被隔离测试. 必须谨慎避免使用单元测试框架来测试整个程序的工作流, 这样的测试既低效又难维护. 工作流测试 (译注: 指跨模块/类的数据流测试) 有它自己的地盘, 但它绝不是单元测试, 必须单独建立和执行.</p><h3 id="7-由简入繁"><a href="#7-由简入繁" class="headerlink" title="7. 由简入繁"></a>7. 由简入繁</h3><p>最简单的测试也远远胜过完全没有测试. 一个简单的 “测试类” 会促使建立 “被测类” 基本的测试骨架, 可以对构建环境, 单元测试环境, 执行环境以及覆盖率分析工具等有效性进行检查, 同时也可以证明 “被测类” 能够被整合和调用.</p><p>下面便是单元测试版的<em>Hello, world!</em>:</p><pre><code class="hljs reasonml">void test<span class="hljs-constructor">DefaultConstruction()</span>&#123;   Foo foo = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Foo()</span>;   <span class="hljs-keyword">assert</span><span class="hljs-constructor">NotNull(<span class="hljs-params">foo</span>)</span>;&#125;</code></pre><h3 id="8-保持测试的独立性"><a href="#8-保持测试的独立性" class="headerlink" title="8. 保持测试的独立性"></a>8. 保持测试的独立性</h3><p>为了保证测试稳定可靠且便于维护, 测试用例之间决不能有相互依赖, 也不能依赖执行的先后次序.</p><h3 id="9-Keep-tests-close-to-the-class-being-tested"><a href="#9-Keep-tests-close-to-the-class-being-tested" class="headerlink" title="9. Keep tests close to the class being tested"></a>9. Keep tests close to the class being tested</h3><p>[译注: 有意翻译该规则, 个人认为本条规则值得商榷, 大部分 C++, Objective-C和 Python 库均把测试代码从功能代码目录中独立出来, 通常是创建一个和<code>src</code>目录同级的<code>tests</code>目录, 被测模块/类名之前也常常<em>不加</em><code>Test</code>前缀. 这么做保证功能代码和测试代码隔离, 目录结构清晰, 并且发布源码的时候更容易排除测试用例.]</p><p>If the class to test is Foo the test class should be called FooTest (not TestFoo) and kept in the same package (directory) as Foo. Keeping test classes in separate directory trees makes them harder to access and maintain.</p><p>Make sure the build environment is configured so that the test classes doesn’t make its way into production libraries or executables.</p><h3 id="10-合理的命名测试用例"><a href="#10-合理的命名测试用例" class="headerlink" title="10. 合理的命名测试用例"></a>10. 合理的命名测试用例</h3><p>确保每个方法只测试 “被测类” 的一个明确特性, 并相应的命名测试方法. 典型的命名俗定是<code>test[what]</code>, 比如<code>testSaveAs()</code>,<code>testAddListener()</code>,<code>testDeleteProperty()</code>等.</p><h3 id="11-只测公有接口"><a href="#11-只测公有接口" class="headerlink" title="11. 只测公有接口"></a>11. 只测公有接口</h3><p>单元测试可以被定义为<em>通过类的公有 API 对类进行测试</em>. 一些测试工具允许测试一个类的私有成员, 但这种做法应该避免, 它让测试变得繁琐而且更难维护. 如果有私有成员确实需要进行直接测试, 可以考虑把它重构到工具类的公有方法中. 但要注意这么做是为了改善设计, 而不是帮助测试.</p><h3 id="12-看成是黑盒"><a href="#12-看成是黑盒" class="headerlink" title="12. 看成是黑盒"></a>12. 看成是黑盒</h3><p>站在第三方使用者的角度, 测试一个类是否满足规定的需求. 并设法让它出问题.</p><h3 id="13-看成是白盒"><a href="#13-看成是白盒" class="headerlink" title="13. 看成是白盒"></a>13. 看成是白盒</h3><p>毕竟被测试类是程序员自写自测的, 应该在最复杂的逻辑部分多花些精力测试.</p><h3 id="14-芝麻函数也要测试"><a href="#14-芝麻函数也要测试" class="headerlink" title="14. 芝麻函数也要测试"></a>14. 芝麻函数也要测试</h3><p>通常建议所有重要的函数都应该被测试到, 一些芝麻方法比如简单的<code>setter</code>和<code>getter</code>都可以忽略. 但是仍然有充分的理由支持测试芝麻函数:</p><ul><li><em>芝麻</em>很难定义. 对于不同的人有不同的理解.</li><li>从黑盒测试的观点看, 是无法知道哪些代码是芝麻级别的.</li><li>即便是再芝麻的函数, 也可能包含错误, 通常是 “复制粘贴” 代码的后果:</li></ul><pre><code class="hljs cpp"><span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> weight_;<span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> x_, y_;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> weight)</span></span><span class="hljs-function"></span>&#123;  weight = weight_;  <span class="hljs-comment">// error</span>&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getX</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">return</span> x_;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getY</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">return</span> x_;  <span class="hljs-comment">// error</span>&#125;</code></pre><p>因此建议测试所有方法. 毕竟芝麻用例也容易测试.</p><h3 id="15-先关注执行覆盖率"><a href="#15-先关注执行覆盖率" class="headerlink" title="15. 先关注执行覆盖率"></a><a href="https://github.com/yangyubo/zh-unit-testing-guidelines#15-先关注执行覆盖率" target="_blank" rel="noopener">1</a>5. 先关注执行覆盖率</h3><p>区别对待<em>执行覆盖率<em>和</em>实际测试覆盖率</em>. 测试的最初目标应该是确保较高的执行覆盖率. 这样能保证代码在<em>少量</em>参数值输入时能执行成功. 一旦执行覆盖率就绪, 就应该开始改进测试覆盖率了. 注意, 实际的测试覆盖率很难衡量 (而且往往趋近于 0%).</p><p>思考以下公有方法:</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setLength</span><span class="hljs-params">(<span class="hljs-keyword">double</span> length)</span></span>;</code></pre><p>调用<code>setLength(1.0)</code>你可能会得到 100% 的执行覆盖率. 但要达到 100% 的实际测试覆盖率, 有多少个<code>double</code>浮点数这个方法就必须被调用多少次, 并且要一一验证行为的正确性. 这无疑是不可能的任务.</p><h3 id="16-覆盖边界值"><a href="#16-覆盖边界值" class="headerlink" title="16. 覆盖边界值"></a>16. 覆盖边界值</h3><p>确保参数边界值均被覆盖. 对于数字, 测试负数, 0, 正数, 最小值, 最大值, NaN (非数字), 无穷大等. 对于字符串, 测试空字符串, 单字符, 非 ASCII 字符串, 多字节字符串等. 对于集合类型, 测试空, 1, 第一个, 最后一个等. 对于日期, 测试 1月1号, 2月29号, 12月31号等. 被测试的类本身也会暗示一些特定情况下的边界值. 要点是尽可能彻底的测试这些边界值, 因为它们都是主要 “疑犯”.</p><h3 id="17-提供一个随机值生成器"><a href="#17-提供一个随机值生成器" class="headerlink" title="17. 提供一个随机值生成器"></a>17. 提供一个随机值生成器</h3><p>当边界值都覆盖了, 另一个能进一步改善测试覆盖率的简单方法就是生成随机参数, 这样每次执行测试都会有不同的输入.</p><p>想要做到这点, 需要提供一个用来生成基本类型 (如: 浮点数, 整型, 字符串, 日期等) 随机值的工具类. 生成器应该覆盖各种类型的所有取值范围.</p><p>如果测试时间比较短, 可以考虑再裹上一层循环, 覆盖尽可能多的输入组合. 下面的例子是验证两次转换 little endian 和 big endian 字节序后是否返回原值. 由于测试过程很快, 可以让它跑上个一百万次.</p><pre><code class="hljs reasonml">void test<span class="hljs-constructor">ByteSwapper()</span>&#123;  for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++) &#123;    double v0 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Random</span>.</span></span>get<span class="hljs-constructor">Double()</span>;    double v1 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteSwapper</span>.</span></span>swap(v0);    double v2 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteSwapper</span>.</span></span>swap(v1);    <span class="hljs-keyword">assert</span><span class="hljs-constructor">Equals(<span class="hljs-params">v0</span>, <span class="hljs-params">v2</span>)</span>;  &#125;&#125;</code></pre><h3 id="18-每个特性只测一次"><a href="#18-每个特性只测一次" class="headerlink" title="18. 每个特性只测一次"></a>18. 每个特性只测一次</h3><p>在测试模式下, 有时会情不自禁的滥用断言. 这种做法会导致维护更困难, 需要极力避免. 仅对测试方法名指示的特性进行明确测试.</p><p>因为对于一般性代码而言, 保证测试代码尽可能少是一个重要目标.</p><h3 id="19-使用显式断言"><a href="#19-使用显式断言" class="headerlink" title="19. 使用显式断言"></a>19. 使用显式断言</h3><p>应该总是优先使用<code>assertEquals(a, b)</code>而不是<code>assertTrue(a == b)</code>, 因为前者会给出更有意义的测试失败信息. 在事先不确定输入值的情况下, 这条规则尤为重要, 比如之前使用随机参数值组合的例子.</p><h3 id="20-提供反向测试"><a href="#20-提供反向测试" class="headerlink" title="20. 提供反向测试"></a>20. 提供反向测试</h3><p>反向测试是指刻意编写问题代码, 来验证鲁棒性和能否正确的处理错误.</p><p>假设如下方法的参数如果传进去的是负数, 会立马抛出异常:</p><pre><code class="hljs aspectj"><span class="hljs-keyword">void</span> setLength(<span class="hljs-keyword">double</span> length) <span class="hljs-keyword">throws</span> IllegalArgumentExcepti</code></pre><p>可以用下面的方法来测试这个特例是否被正确处理:</p><pre><code class="hljs angelscript"><span class="hljs-keyword">try</span> &#123;  setLength(<span class="hljs-number">-1.0</span>);  fail();  <span class="hljs-comment">// If we get here, something went wrong</span>&#125;<span class="hljs-keyword">catch</span> (IllegalArgumentException exception) &#123;  <span class="hljs-comment">// If we get here, all is fine</span>&#125;</code></pre><h3 id="21-代码设计时谨记测试"><a href="#21-代码设计时谨记测试" class="headerlink" title="21. 代码设计时谨记测试"></a>21. 代码设计时谨记测试</h3><p>编写和维护单元测试的代价是很高的, 减少代码中的公有接口和循环复杂度是降低成本, 使高覆盖率测试代码更易于编写和维护的有效方法.</p><p>一些建议:</p><blockquote><ul><li>使类成员常量化, 在构造函数中进行初始化. 减少<code>setter</code>方法的数量.</li><li>限制过度使用继承和公有虚函数.</li><li>通过使用友元类 (C++) 或包作用域 (Java) 来减少公有接口.</li><li>避免不必要的逻辑分支.</li><li>在逻辑分支中编写尽可能少的代码.</li><li>在公有和私有接口中尽量多用异常和断言验证参数参数的有效性.</li><li>限制使用快捷函数. 对于黑箱而言, 所有方法都必须一视同仁的进行测试. 思考以下简短的例子:</li></ul><pre><code class="hljs processing"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">scale</span>(<span class="hljs-keyword">double</span> x0, <span class="hljs-keyword">double</span> y0, <span class="hljs-keyword">double</span> scaleFactor)&#123;  <span class="hljs-comment">// scaling logic</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">scale</span>(<span class="hljs-keyword">double</span> x0, <span class="hljs-keyword">double</span> y0)&#123;  <span class="hljs-built_in">scale</span>(x0, y0, <span class="hljs-number">1.0</span>);&#125;</code></pre><ul><li>删除后者可以简化测试, 但用户代码的工作量也将略微增加.</li></ul></blockquote><h3 id="22-不要访问预设的外部资源"><a href="#22-不要访问预设的外部资源" class="headerlink" title="22. 不要访问预设的外部资源"></a>22. 不要访问预设的外部资源</h3><p>单元测试代码不应该假定外部的执行环境, 以便在任何时候/任何地方都能执行. 为了向测试提供必需的资源, 这些资源应该由测试本身提供.</p><p>比如一个解析某类型文件的类, 可以把文件内容嵌入到测试代码里, 在测试的时候写入到临时文件, 测试结束再删除, 而不是从预定的地址直接读取.</p><h3 id="23-权衡测试成本"><a href="#23-权衡测试成本" class="headerlink" title="23. 权衡测试成本"></a>23. 权衡测试成本</h3><p>不写单元测试的代价很高, 但是写单元测试的代价同样很高. 要在这两者之间做适当的权衡, 如果用执行覆盖率来衡量, 业界标准通常在 80% 左右.</p><p>很典型的, 读写外部资源的错误处理和异常处理就很难达到百分百的执行覆盖率. 模拟数据库在事务处理到一半时发生故障并不是办不到, 但相对于进行大范围的代码审查, 代价可能太大了.</p><h3 id="24-安排测试优先次序"><a href="#24-安排测试优先次序" class="headerlink" title="24. 安排测试优先次序"></a>24. 安排测试优先次序</h3><p>单元测试是典型的自底向上过程, 如果没有足够的资源测试一个系统的所有模块, 就应该先把重点放在较底层的模块.</p><h3 id="25-测试代码要考虑错误处理"><a href="#25-测试代码要考虑错误处理" class="headerlink" title="25. 测试代码要考虑错误处理"></a>25. 测试代码要考虑错误处理</h3><p>考虑下面的这个例子:</p><pre><code class="hljs reasonml">Handle handle = manager.get<span class="hljs-constructor">Handle()</span>;<span class="hljs-keyword">assert</span><span class="hljs-constructor">NotNull(<span class="hljs-params">handle</span>)</span>;String handleName = handle.get<span class="hljs-constructor">Name()</span>;<span class="hljs-keyword">assert</span><span class="hljs-constructor">Equals(<span class="hljs-params">handleName</span>, <span class="hljs-string">"handle-01"</span>)</span>;</code></pre><p>如果第一个断言失败, 后续语句会导致代码崩溃, 剩下的测试都无法执行. 任何时候都要为测试失败做好准备, 避免单个失败的测试项中断整个测试套件的执行. 上面的例子可以重写成:</p><pre><code class="hljs lasso"><span class="hljs-keyword">Handle</span> <span class="hljs-keyword">handle</span> = manager.getHandle();assertNotNull(<span class="hljs-keyword">handle</span>);<span class="hljs-keyword">if</span> (<span class="hljs-keyword">handle</span> == <span class="hljs-built_in">null</span>) <span class="hljs-keyword">return</span>;<span class="hljs-built_in">String</span> handleName = <span class="hljs-keyword">handle</span>.getName();assertEquals(handleName, <span class="hljs-string">"handle-01"</span>);</code></pre><h3 id="26-写测试用例重现-bug"><a href="#26-写测试用例重现-bug" class="headerlink" title="26. 写测试用例重现 bug"></a>26. 写测试用例重现 bug</h3><p>每上报一个 bug, 都要写一个测试用例来重现这个 bug (即无法通过测试), 并用它作为成功修正代码的检验标准.</p><h3 id="27-了解局限"><a href="#27-了解局限" class="headerlink" title="27. 了解局限"></a>27. 了解局限</h3><p><em>单元测试永远无法证明代码的正确性!!</em></p><p>一个跑失败的测试可能表明代码有错误, 但一个跑成功的测试什么也证明不了.</p><p>单元测试最有效的使用场合是在一个较低的层级验证并文档化需求, 以及<em>回归测试</em>: 开发或重构代码时，不会破坏已有功能的正确性.</p>]]></content>
    
    
    <categories>
      
      <category>质量保障篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单测实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>命令模式</title>
    <link href="/2023/09/12/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/09/12/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="命令模式篇"><a href="#命令模式篇" class="headerlink" title="命令模式篇"></a>命令模式篇</h1><h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p><font color="red">将一个请求封装为一个对象</font>，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。</p><h2 id="命令模式的诞生"><a href="#命令模式的诞生" class="headerlink" title="命令模式的诞生"></a>命令模式的诞生</h2><p>【<font color="orange">产品</font>】：开发小哥，来活啦，咱们需要设计一款遥控器，核心功能就是几个按键，但是可能要控制很多不同品牌的设备，你们构思构思吧~</p><p>【<font color="blue">开发</font>】：按键？不存在的，对我来说就是请求罢了，Boss，帮我想一下怎么适配不同的品牌的设备啊？</p><p>【<font color="red">BOSS</font>】：适配设备这个事，仅仅靠我们是不行的，这都是配合的结果，你既然也说了什么按钮只不过是请求而已，那可以考虑使用命令模式，把请求封装为对象，由我们主动去绑定不同品牌对应的执行者，懂了吗？</p><p>【<font color="blue">开发</font>】：哈？哦，懂了懂了（我懂个鬼！）</p><p><img src="/2023/09/12/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/image-20200601010620507.png" srcset="/img/loading.gif" alt="image-20200601010620507"></p><h2 id="HeadFirst-核心代码"><a href="#HeadFirst-核心代码" class="headerlink" title="HeadFirst 核心代码"></a>HeadFirst 核心代码</h2><p><strong>父级接口</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Command</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p><strong>封装请求为一个对象</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LightOnCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Command</span> </span>&#123;    Light light;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LightOnCommand</span><span class="hljs-params">(Light light)</span> </span>&#123;        <span class="hljs-keyword">this</span>.light = light;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;        light.on();    &#125;&#125;</code></pre><p><strong>请求响应的Api</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Light</span> </span>&#123;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * on方法</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">on</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"On..."</span>);    &#125;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * off方法</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">off</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"Off..."</span>);    &#125;&#125;</code></pre><p><strong>调用方代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleRemoteControl</span> </span>&#123;    Command slot;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SimpleRemoteControl</span><span class="hljs-params">()</span> </span>&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCommand</span><span class="hljs-params">(Command command)</span> </span>&#123;        slot = command;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buttonWasPressed</span><span class="hljs-params">()</span> </span>&#123;        slot.execute();    &#125;&#125;<span class="hljs-comment">//******************************************</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    SimpleRemoteControl remote = <span class="hljs-keyword">new</span> SimpleRemoteControl();    Light light = <span class="hljs-keyword">new</span> Light();    LightOnCommand lightOn = <span class="hljs-keyword">new</span> LightOnCommand(light);    remote.setCommand(lightOn);    remote.buttonWasPressed();    LightOffCommand lightOff = <span class="hljs-keyword">new</span> LightOffCommand(light);    remote.setCommand(lightOff);    remote.buttonWasPressed();&#125;</code></pre><p><font color="red">命令模式的设计思路</font>：</p><ul><li>Command                   声明命令的接口</li><li>ConcreteCommand   具体的动作 | 命令</li><li>Client                          客户端请求</li><li>Invoker                       绑定命令与接收者</li><li>Receiver                     接收者  知道如何实施与执行一个请求相关的操作，任何类都可以是接收者</li></ul><p>代码的核心即：把请求抽象为一个命令，把执行命令的接收者和命令本身分离，交由第三方类（Invoker）去管理，达到解耦的目的</p><h2 id="试试用命令模式封装简单Jedis"><a href="#试试用命令模式封装简单Jedis" class="headerlink" title="试试用命令模式封装简单Jedis"></a>试试用命令模式封装简单Jedis</h2><h3 id="Redis协议Tips"><a href="#Redis协议Tips" class="headerlink" title="Redis协议Tips"></a>Redis协议Tips</h3><p>Redis 即 REmote Dictionary Server (远程字典服务)；</p><p>而Redis的协议规范是 Redis Serialization Protocol (Redis序列化协议)</p><p>RESP 是redis客户端和服务端之前使用的一种通讯协议；</p><p>RESP 的特点：实现简单、快速解析、可读性好</p><p>协议如下：</p><p>客户端以规定格式的形式发送命令给服务器</p><pre><code class="hljs java"><span class="hljs-comment">/***</span><span class="hljs-comment"> * set key value 协议翻译如下：</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * * 3    -&gt;  表示以下有几组命令</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * $ 3    -&gt;  表示命令长度是3</span><span class="hljs-comment"> * SET</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * $6     -&gt;  表示长度是6</span><span class="hljs-comment"> * keykey</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * $5     -&gt;  表示长度是5</span><span class="hljs-comment"> * value</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 完整即：</span><span class="hljs-comment"> * * 3</span><span class="hljs-comment"> * $ 3</span><span class="hljs-comment"> * SET</span><span class="hljs-comment"> * $6</span><span class="hljs-comment"> * keykey</span><span class="hljs-comment"> * $5 </span><span class="hljs-comment"> * value</span><span class="hljs-comment">*/</span></code></pre><blockquote><p>关于Redis相关的RESP协议，我在之后的文章会专门出一篇讲解~</p></blockquote><h3 id="封装Get命令"><a href="#封装Get命令" class="headerlink" title="封装Get命令"></a>封装Get命令</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Command</span> </span>&#123;    <span class="hljs-keyword">private</span> GetReceiver receiver;    <span class="hljs-keyword">private</span> String arg;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;        receiver.doCommand(<span class="hljs-keyword">this</span>.arg);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GetCommand</span><span class="hljs-params">(GetReceiver receiver, String arg)</span> </span>&#123;        <span class="hljs-keyword">this</span>.receiver = receiver;        <span class="hljs-keyword">this</span>.arg = arg;    &#125;&#125;</code></pre><h3 id="封装Get接收者"><a href="#封装Get接收者" class="headerlink" title="封装Get接收者"></a>封装Get接收者</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetReceiver</span> </span>&#123;    OutputStream write;    InputStream read;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doCommand</span> <span class="hljs-params">(String arg)</span> </span>&#123;        String[] strings = arg.split(<span class="hljs-string">" "</span>);        String key = strings[<span class="hljs-number">0</span>];        <span class="hljs-keyword">byte</span>[] bytes;        <span class="hljs-keyword">try</span> &#123;            String sb = <span class="hljs-string">"*2"</span> + SPILT +                    <span class="hljs-string">"$3"</span> + SPILT +                    <span class="hljs-string">"GET"</span> + SPILT +                    <span class="hljs-string">"$"</span> + key.getBytes().length + SPILT +                    key + SPILT;            write.write(sb.getBytes());            bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];            read.read(bytes);            System.out.println(<span class="hljs-string">"Result: "</span> + <span class="hljs-keyword">new</span> String(bytes));        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GetReceiver</span><span class="hljs-params">(OutputStream write, InputStream read)</span> </span>&#123;        <span class="hljs-keyword">this</span>.write = write;        <span class="hljs-keyword">this</span>.read = read;    &#125;    <span class="hljs-keyword">final</span> String SPILT = <span class="hljs-string">"\r\n"</span>;&#125;</code></pre><h3 id="封装Invoker"><a href="#封装Invoker" class="headerlink" title="封装Invoker"></a>封装Invoker</h3><p>利用栈存储命令，可以很好的控制命令的变化等等</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Invoker</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Stack&lt;Command&gt; commands;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Invoker</span><span class="hljs-params">()</span> </span>&#123;        commands = <span class="hljs-keyword">new</span> Stack&lt;&gt;();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCommand</span><span class="hljs-params">(Command command)</span> </span>&#123;        commands.push(command);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">undoCommand</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (!commands.empty()) &#123;            commands.pop();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span> (!commands.empty()) &#123;            Command command = commands.pop();            command.execute();        &#125;    &#125;&#125;</code></pre><h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><pre><code class="hljs java"><span class="hljs-comment">/***</span><span class="hljs-comment">    * 简易Jedis代码, 利用栈存储命令(可根据需求更改数据结构)</span><span class="hljs-comment">    *</span><span class="hljs-comment">    * 推荐阅读顺序：</span><span class="hljs-comment">    * <span class="hljs-doctag">@see</span> Command</span><span class="hljs-comment">    * <span class="hljs-doctag">@see</span> GetCommand | SetCommand</span><span class="hljs-comment">    * <span class="hljs-doctag">@see</span> GetReceiver | SetReceiver</span><span class="hljs-comment">    * <span class="hljs-doctag">@see</span> Invoker</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;       <span class="hljs-comment">// 初始化Socket流</span>       Socket socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">6379</span>);       OutputStream write = socket.getOutputStream();       InputStream read = socket.getInputStream();       Invoker invoker = <span class="hljs-keyword">new</span> Invoker();       <span class="hljs-comment">// 初始化Get | Set任务执行者</span>       GetReceiver getReceiver = <span class="hljs-keyword">new</span> GetReceiver(write, read);       SetReceiver setReceiver = <span class="hljs-keyword">new</span> SetReceiver(write, read);       <span class="hljs-comment">// 测试get命令</span>       invoker.addCommand(<span class="hljs-keyword">new</span> GetCommand(getReceiver, <span class="hljs-string">"key"</span>));       <span class="hljs-comment">// 测试set命令</span>       invoker.addCommand(<span class="hljs-keyword">new</span> SetCommand(setReceiver, <span class="hljs-string">"key xixixi"</span>));       <span class="hljs-comment">// 测试get命令</span>       invoker.addCommand(<span class="hljs-keyword">new</span> GetCommand(getReceiver, <span class="hljs-string">"key"</span>));       <span class="hljs-comment">// 测试get命令</span>       invoker.addCommand(<span class="hljs-keyword">new</span> GetCommand(getReceiver, <span class="hljs-string">"key"</span>));       <span class="hljs-comment">// 测试撤销上一个命令 -&gt; 输出四次则测试失败，三次则成功</span>       invoker.undoCommand();       invoker.execute();   &#125;</code></pre><p>输出结果：</p><pre><code class="hljs java"><span class="hljs-comment">/***</span><span class="hljs-comment"> * Result: $4</span><span class="hljs-comment"> * test</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Result: +OK</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Result: $6</span><span class="hljs-comment"> * xixixi</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * // 测试成功~</span><span class="hljs-comment"> */</span></code></pre><blockquote><p>代码量有点小多，需要看详情的话，请跳转到最下面的相关代码链接吧~</p></blockquote><h2 id="什么场景适用"><a href="#什么场景适用" class="headerlink" title="什么场景适用"></a>什么场景适用</h2><p>在下列情况下可以使用 Command Method模式：</p><ul><li>需要抽象出待执行的动作以参数化某对象</li><li>在不同的时刻指定，排列和执行请求</li><li>支持取消操作</li></ul><h2 id="Code-生活中的实际应用"><a href="#Code-生活中的实际应用" class="headerlink" title="Code/生活中的实际应用"></a>Code/生活中的实际应用</h2><p>在日常生活中都有订单的概念，为什么我们下订单，服务员或者其他工作人员完全明白我们的意图呢？就是因为我们按照他们制定的规则构建起了一个命令，那么在交互过程就不需要层层沟通，方便解耦。</p><h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><p><img src="/2023/09/12/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/image-20200601232728451.png" srcset="/img/loading.gif" alt="image-20200601232728451"></p><h2 id="遵循的设计原则"><a href="#遵循的设计原则" class="headerlink" title="遵循的设计原则"></a>遵循的设计原则</h2><ul><li>针对接口编程，不针对实现编程</li><li>为交互对象松耦合设计而努力</li><li>类应该对拓展开放，对修改关闭</li></ul><h2 id="相关代码链接"><a href="#相关代码链接" class="headerlink" title="相关代码链接"></a>相关代码链接</h2><p><a href="https://github.com/kkzhilu/Kerwin-DesignPattern" target="_blank" rel="noopener">GitHub地址</a></p><ul><li>兼顾了《HeadFirst》以及《GOF》两本经典书籍中的案例</li><li>提供了友好的阅读指导</li></ul><p><img src="/2023/09/12/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/%E5%BE%AE%E4%BF%A1%E4%BA%8C%E7%BB%B4%E7%A0%81.png" srcset="/img/loading.gif" alt></p>]]></content>
    
    
    <categories>
      
      <category>编码及设计模式篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>命令模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>商品治理</title>
    <link href="/2023/09/12/%E5%95%86%E5%93%81%E6%B2%BB%E7%90%86/"/>
    <url>/2023/09/12/%E5%95%86%E5%93%81%E6%B2%BB%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="京东到家商品治理体系的建设"><a href="#京东到家商品治理体系的建设" class="headerlink" title="京东到家商品治理体系的建设"></a>京东到家商品治理体系的建设</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>京东到家作为一个即时零售的电商平台，在提供1小时送达极致服务的同时也力求将万千好物送到消费者的手中。为了不断提高平台露出商品的价值，提高用户的满意度，我们设计并投入使用了京东到家商品治理系统，其主要职责是对商品新建、修改、呈现的全链路流程进行干预及核验，旨在<code>发现</code>并<code>解决</code>商品信息中如：敏感词、虚假宣传、错误信息等不符合平台规范和质量要求的问题，保证商品与实物的匹配度，信息的正确性等。</p><h2 id="系统架构介绍"><a href="#系统架构介绍" class="headerlink" title="系统架构介绍"></a>系统架构介绍</h2><p>京东到家各业务线采用的是标准化的微服务架构设计，各个系统在迭代过程中只用按需申请对应的组件即可，下图为治理系统所用到的技术组件：</p><ul><li>消息中间件：使用京东的MQ中间件，实现业务解耦。</li><li>存储：Redis集群、MySQL集群等。</li><li>Worker：基于TBSchedule分布式调度引擎框架构建的服务，进行定时任务的执行和分发。</li><li>服务监控：采用统一监控与告警服务平台，可以达到秒级监控、多方位监控、服务告警、全链路追踪等能力。</li><li>服务间调用：使用京东的JSF平台，实现服务间注册、服务间调用，服务治理等能力，支持请求超时自动阻断。</li><li>日志服务：日志采集与查询服务。</li></ul><p><img src="/2023/09/12/%E5%95%86%E5%93%81%E6%B2%BB%E7%90%86/image-20220518072116799.png" srcset="/img/loading.gif" alt="image-20220518072116799"></p><h2 id="早期的治理系统"><a href="#早期的治理系统" class="headerlink" title="早期的治理系统"></a>早期的治理系统</h2><p>治理系统的第一个需求与大多数业务系统类似，是基于数据的增删改查，构建一套敏感词管理模块，同时为商品主系统提供敏感词的校验能力。</p><p>它的第二个需求是为运营同学提供一个核验结果的报表，其主要逻辑是通过上传Excel，内部解析完成后调用接口得到相应的数据结果，基于MySQL进行存储，然后提供查询及展示的能力，以便运营使用。</p><p>但由于缺乏设计和长远的思考，因此当时的治理系统与商品主系统耦合严重，图示如下：</p><p><img src="/2023/09/12/%E5%95%86%E5%93%81%E6%B2%BB%E7%90%86/image-20220518064404134.png" srcset="/img/loading.gif" alt="image-20220518064404134"></p><p>而随着平台对商品信息合规性的要求越来越严格，针对商品分类、毛重、图片等等诸多的治理需求也就接踵而来。但在上图的设计之中，我们不难发现，治理系统是以具体的业务来构建对外接口的，那随着业务需求的不断增加，两个系统之间交互的接口个数也会出现暴涨，这是我们不希望看到的。</p><p>另外，治理的最终目的是期望商品上的问题能够得到<code>解决</code>，而不仅仅只是<code>发现</code>，因此将问题暴露给运营或者商家，是势在必行的，但当下存在两个问题：</p><ol><li><p><strong>商品系统在自身的主流程中强依赖治理的核验能力，且随着业务的增加，依赖会越来越多。</strong></p></li><li><p><strong>商品系统只能将前置拦截的核验结果告知商家，业务覆盖面不全。</strong></p></li></ol><p>再加上有诸多问题是属于弱合规性（不需要强制拦截但又需要解决），<strong>因此我们决定将商品治理业务的核心由商品系统转为治理系统</strong>。</p><p>为了实现高效率的商品治理，我们对治理系统的设计要求和定位作出了一点变更，提出了两项基本原则：</p><ul><li><code>治理系统需要完成整个治理业务的闭环，作为商品问题发现及解决的总入口和总出口</code></li><li><code>治理系统需要具备高拓展性，当增加特定化治理需求时能够迅速响应</code></li></ul><h2 id="业务架构升级"><a href="#业务架构升级" class="headerlink" title="业务架构升级"></a>业务架构升级</h2><h3 id="抽象思维显神威"><a href="#抽象思维显神威" class="headerlink" title="抽象思维显神威"></a>抽象思维显神威</h3><p>在理清治理系统的业务架构升级思路之后，我们首先需要确定的一个问题就是：<strong>治理系统最基础的原子能力是什么？</strong></p><p>以各个主系统为例，商品系统最基础的原子能力即：商品的创建、修改和提供查询能力、库存系统最基础的原子能力即：商品库存信息的维护及查询能力。根据治理业务的发展规划，我们也基本确定出治理系统的原子能力，即：<strong>发现商品存在的合规问题，并向外提供查询和辅助解决的能力</strong>。</p><p>对于<code>合规问题</code>的定义，我们做出了如下解释，即：<code>不符合电商平台商品展示规范的如敏感词、虚假渲传等问题。</code></p><p>例如商品名称中包含敏感词，会映射为敏感词问题，另外需要说明的是：在编码阶段中，一种可量化的具体规则可以确定对应的一种合规问题，且同一个商品可能同时存在多个不同的合规问题。</p><p>目前到家治理系统所涉猎的合规问题主要有：</p><table><thead><tr><th>合规问题大类</th><th>对外描述</th><th>问题细节</th></tr></thead><tbody><tr><td>商品毛重问题</td><td>商品毛重不准确</td><td>商品毛重与实际商品不符、商品毛重超过最大运力限制等</td></tr><tr><td>商品信息不正确</td><td>商品信息不正确，请检查具体内容</td><td>商品名称包含敏感词、商品分类与实际商品不符、虚假宣传等</td></tr><tr><td>商家商品经营范围问题</td><td>当前售卖商品超出商家经营范围</td><td>当前售卖商品超出商家经营范围等</td></tr><tr><td>图片信息问题</td><td>商品图片信息存在问题</td><td>商品无主图、商品主图为默认图、商品主图为黑底图等</td></tr><tr><td></td><td></td><td></td></tr><tr><td><strong>未来计划</strong></td><td></td><td></td></tr><tr><td><code>商品价格问题</code></td><td>–</td><td>–</td></tr><tr><td><code>商品画像问题</code></td><td>–</td><td>–</td></tr><tr><td><code>...</code></td><td></td><td></td></tr></tbody></table><p>为了方便理解，我们可以将每一种<strong>合规问题看作是一种策略</strong>，而针对策略的顶层接口又定义了四个核心方法：</p><ul><li>映射关联的枚举：每一个问题都需要关联具体的问题原因</li><li>问题关联的字段：每一个问题都需要关联具体的影响字段或被影响字段</li><li>自定义过滤能力：根据业务特点，减少无用处理</li><li>核验方法：根据业务规则实现的具体核验逻辑</li></ul><p>具体的实现逻辑如下图所示：</p><p><img src="/2023/09/12/%E5%95%86%E5%93%81%E6%B2%BB%E7%90%86/image-20220520113616054.png" srcset="/img/loading.gif" alt="image-20220520113616054"></p><p>下图为<strong>商品毛重信息填写错误</strong>问题处理前后的展示结果：</p><p><img src="/2023/09/12/%E5%95%86%E5%93%81%E6%B2%BB%E7%90%86/image-20220516144949447.png" srcset="/img/loading.gif" alt="image-20220516144949447"></p><p><img src="/2023/09/12/%E5%95%86%E5%93%81%E6%B2%BB%E7%90%86/image-20220516144715540.png" srcset="/img/loading.gif" alt="image-20220516144715540"></p><p>毛重问题有其对应的关联枚举及文案映射，即：商品毛重不准确（问题类型），推荐毛重为 XXX（文案映射），所关联的字段为：商品重量及商品名称，再配合一定的过滤逻辑及核验算法，那么毛重问题的抽象实体也就完成了，以此类推，我们后续在增加新的治理问题时，采用类似的方式即可。</p><p>如果是对设计模式涉猎较多的读者应该已经判断出来，这种设计方案其实就是策略模式及模板方法模式的变种罢了，在编码阶段也肯定少不了工厂的使用，在编码层面整体的变化如下图所示：</p><p><img src="/2023/09/12/%E5%95%86%E5%93%81%E6%B2%BB%E7%90%86/image-20220518082356305.png" srcset="/img/loading.gif" alt="image-20220518082356305"></p><p>上述方案落地之后，产研侧对于治理业务的后续发展达成了基本共识，同时需求的实现也变得简单起来，我们不用再关注其他系统的逻辑，而是着眼于具体合规问题的业务规则实现上。</p><p>业务方和产品可以更好的通过数据分析来确定未来的治理重点和需求规划，研发人员也以优雅的方式解决了系统间耦合、业务代码重复的问题。</p><h3 id="难点问题巧手破"><a href="#难点问题巧手破" class="headerlink" title="难点问题巧手破"></a>难点问题巧手破</h3><p>初步定义好治理系统的业务架构设计后，在后续迭代的过程中，我们遇到了两个较为棘手的问题，一个是业务问题，一个是技术问题。</p><h4 id="业务问题"><a href="#业务问题" class="headerlink" title="业务问题"></a>业务问题</h4><p>业务方要求APP展示的商品主图不能与默认图（例如空白图、品牌商标图等不能体现商品信息的图片）一致，然而商品图片的核验逻辑一直由图片核验系统承接。</p><p>这就引起了一个问题：<strong>治理系统是否需要集成图片核验逻辑，如果不集成，那又该如何将其图片违规问题纳入至治理体系中？</strong></p><p>如果是经验丰富的开发者一定会提出使用MQ的方式由图片核验系统发送核验结果至治理系统，来解决这个问题。实际上我们也是这么做的，只不过做的更彻底一些。</p><p>在设计模式当中，我们通常会将一系列类似业务整合成一个公共接口向外提供能力，我们将它称之为：门面模式或者外观模式。</p><p>对于上述的类似问题，我们找到了公共的处理思路，即：<code>将治理系统作为门面，其他系统作为组件，各系统都可以主动的向治理系统提供需要治理的内容</code>。</p><p>该方案确定之后，各种令人头痛的业务场景也就变得简单起来，而且此举还扩大了治理系统的边界，例如商品无图合规问题，商品差评率高的问题，只需要对应系统将相关数据/结果以MQ的形式发送至治理系统，然后由治理系统为其绑定具体的合规问题即可。</p><p>在编码层面我们采用的是最简单的MQ解耦的方式实现，示意图如下：</p><p><img src="/2023/09/12/%E5%95%86%E5%93%81%E6%B2%BB%E7%90%86/image-20220518084104202.png" srcset="/img/loading.gif" alt="image-20220518084104202"></p><h4 id="技术问题"><a href="#技术问题" class="headerlink" title="技术问题"></a>技术问题</h4><p>在治理迭代的过程中，有一系列的需求是针对平台商品的图片进行治理，以破损图逻辑为例。</p><p>在最开始的处理逻辑中，大家查询资料整合信息，发现平台偶尔出现的破损图是由于图片在下载过程中未下载完整后流中断，触发上传引起的。因此在第一版的逻辑中，我们查阅资料作出了如下逻辑判断：当图片下载完成触发上传前，对比请求体中的<code>ContentLength</code>与实际图片字节大小，问题初步解决。</p><p>但是过了不久问题再次爆发，此时我们发现事情没有那么简单。</p><p>由于到家平台对接众多的商家系统，各个系统的图片服务器与后台逻辑不一，导致我们无法对所有图片都使用文件大小比对的方式，因此我们重新调研并实现了针对破损图的核验能力。</p><p><img src="/2023/09/12/%E5%95%86%E5%93%81%E6%B2%BB%E7%90%86/0.png" srcset="/img/loading.gif" alt="img"></p><p>即通过下载后的图片内容进行处理和分析，利用算法与目标问题的业务特征来进行识别，至此，问题基本解决。</p><p>同时，基于该思路我们也衍生出针对<strong>黑底图</strong>、<strong>默认图</strong>的处理方式，在图片问题的治理上更进一步。</p><h3 id="治理触达终落地"><a href="#治理触达终落地" class="headerlink" title="治理触达终落地"></a>治理触达终落地</h3><p>基于上述的方案和设计，治理系统在<code>问题发现</code>的流程上已经趋于完善，接下来，产品提出了新的要求，即：<code>部分问题实现自动治理及问题触达商家</code>。</p><p>笔者在之前了解机器学习方面的知识时，注意到这样一个特点，在机器学习中，模型可以分为两种：判别模型和生成模型。忽略掉其具体含义，吸收其设计思想，我们也可以将治理系统分为两个阶段，即：<code>发现</code>和<code>解决</code>。</p><p>上述的业务抽象以及技术问题、业务问题都是在用以<code>发现</code>问题，当我们将<code>解决</code>问题的目标纳入到整个治理体系时，只需要对现有结构进行一定程度的拓展即可满足。</p><p>仍然以商品毛重信息填写错误问题举例，我们只需要在上文的抽象中增加两个待实现方法：</p><ul><li>是否需要自动处理：毛重问题需要自动处理</li><li>自动处理的具体实现规则：当实际毛重大于某一阈值时，将商品系统下架处理（依托于商品对外接口能力）</li></ul><p>在核验结果入库前，根据具体的实现逻辑以及数据反馈结果来判断需要人工处理还是系统处理即可。</p><p>而对于触达需求，其实现就更简单了，因为我们在最初就定义好了治理业务沟通的基本要素是一个个具体的治理问题，我们只需要将存储好的数据以接口亦或是MQ的形式露出即可。</p><p>至此，整个治理体系从编码层面也就建设完成，其核心逻辑在三个环节：</p><ol><li>商品变动MQ/其他系统治理内容通知触发具体合规问题核验。</li><li>针对核验结果进行判断：人工处理或系统自动处理（处理的能力需借助于商品对外接口）。</li><li>核验结果对外露出。</li></ol><p>下图为治理系统当前整体业务结构图：</p><p><img src="/2023/09/12/%E5%95%86%E5%93%81%E6%B2%BB%E7%90%86/image-20220516163306748.png" srcset="/img/loading.gif" alt="image-20220516163306748"></p><h2 id="治理业务全景图"><a href="#治理业务全景图" class="headerlink" title="治理业务全景图"></a>治理业务全景图</h2><p>从治理平台业务架构升级至今，已经稳定运行9个多月，在业务发展过程当中，已经累计治理平台商品480W+，构建出了8种识别能力，3种处理方式及两种触达方式。同时立足于商品、标品系统为商品的快速建品、基础信息建设、治理审核等保驾护航，下图为到家治理全景图：</p><p><img src="/2023/09/12/%E5%95%86%E5%93%81%E6%B2%BB%E7%90%86/image-20220516181111121.png" srcset="/img/loading.gif" alt="image-20220516181111121"></p><h2 id="未来规划"><a href="#未来规划" class="headerlink" title="未来规划"></a>未来规划</h2><p>目前的治理体系是围绕商品系统的主环节来设计和搭建的，其影响范围较窄，我们完全可以将商品治理的成果运用于商品体系之外的其他系统。</p><p>例如下图中的各个业务场景：</p><p><img src="/2023/09/12/%E5%95%86%E5%93%81%E6%B2%BB%E7%90%86/image-20220321091329235.png" srcset="/img/loading.gif" alt="image-20220321091329235"></p><p>以搜索推荐为例，我们可以为各个合规问题制定相应的扣减分数，搜索侧在构建数据时将当前商品的合规分数纳入至自身体系中，在满足搜索条件后按分值大小进行排序。</p><p>另外，也有很多用算法无法识别的问题需要纳入至治理体系中，例如：商品差评率高、退货率高等等。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>随着业务的不断发展，对于商品信息的质量要求也会越来越高，到家治理系统还需要和各个上下游系统一起联动，提供更精细化的商品管控能力，期待未来我们的治理能力越来越出色，为用户提供更加真实、贴合实际的商品数据以及更加优质的服务。</p>]]></content>
    
    
    <categories>
      
      <category>编码及设计模式篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>商品治理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>建造者&amp;责任链&amp;备忘录</title>
    <link href="/2023/09/12/%E5%BB%BA%E9%80%A0%E8%80%85&amp;%E8%B4%A3%E4%BB%BB%E9%93%BE&amp;%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    <url>/2023/09/12/%E5%BB%BA%E9%80%A0%E8%80%85&amp;%E8%B4%A3%E4%BB%BB%E9%93%BE&amp;%E5%A4%87%E5%BF%98%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="建造者-责任链-备忘录三连"><a href="#建造者-责任链-备忘录三连" class="headerlink" title="建造者 + 责任链 + 备忘录三连"></a>建造者 + 责任链 + 备忘录三连</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>【<font color="blue">开发</font>】：老大，你教了我挺多设计模式的，已经全部教完了吗？</p><p>【<font color="red">BOSS</font>】：没呢，还有好几个设计模式没说过呢，今天再传授你三个吧，分别是建造者模式，责任链模式，备忘录模式，如何？</p><p>【<font color="blue">开发</font>】：好啊，我最喜欢学习了！</p><p><img src="/2023/09/12/%E5%BB%BA%E9%80%A0%E8%80%85&%E8%B4%A3%E4%BB%BB%E9%93%BE&%E5%A4%87%E5%BF%98%E5%BD%95/de80a5abgy1gg081efphlg208c02xq8z.gif" srcset="/img/loading.gif" alt="抖音猫咪摇头 GIF 动图"></p><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p><h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><p><strong><em>定义建造接口</em></strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Builder</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildPartOne</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildPartTwo</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildPartThr</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 一般情况肯定是一个复杂的对象</span><span class="hljs-comment">     */</span>    <span class="hljs-function">String <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p><strong><em>定义实际建造工人</em></strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteBuilder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Builder</span> </span>&#123;    <span class="hljs-keyword">private</span> StringBuffer buffer = <span class="hljs-keyword">new</span> StringBuffer();    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPartOne</span><span class="hljs-params">()</span> </span>&#123;        buffer.append(<span class="hljs-string">"i am part one\n"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPartTwo</span><span class="hljs-params">()</span> </span>&#123;        buffer.append(<span class="hljs-string">"i am part two\n"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPartThr</span><span class="hljs-params">()</span> </span>&#123;        buffer.append(<span class="hljs-string">"i am part Thr\n"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getResult</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> buffer.toString();    &#125;&#125;</code></pre><h3 id="如何创建不同的表示？"><a href="#如何创建不同的表示？" class="headerlink" title="如何创建不同的表示？"></a>如何创建不同的表示？</h3><p><strong><em>定义督公</em></strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Director</span> </span>&#123;    <span class="hljs-keyword">private</span> Builder builder;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Director</span><span class="hljs-params">(Builder builder)</span> </span>&#123;        <span class="hljs-keyword">this</span>.builder = builder;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBuilder</span><span class="hljs-params">(Builder builder)</span> </span>&#123;        <span class="hljs-keyword">this</span>.builder = builder;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">construct</span><span class="hljs-params">()</span> </span>&#123;        builder.buildPartOne();        builder.buildPartTwo();        builder.buildPartThr();    &#125;&#125;</code></pre><p><strong><em>模拟调用</em></strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 建造者模式</span><span class="hljs-comment">     *     建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象，这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * 主要解决</span><span class="hljs-comment">     *     主要解决在软件系统中，有时候面临着"一个复杂对象"的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * 何时使用</span><span class="hljs-comment">     *      一些基本部件不会变，而其组合经常变化的时候。</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * 如何解决</span><span class="hljs-comment">     *     将变与不变分离开。</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * 关键代码</span><span class="hljs-comment">     *     建造者：创建和提供实例</span><span class="hljs-comment">     *     建造者接口：依赖接口编程</span><span class="hljs-comment">     *     指导者：管理建造出来的实例的依赖关系</span><span class="hljs-comment">     *     产品：建造者所生产的产品</span><span class="hljs-comment">     * 建造者作为参数进入指导者构造方法，通过特定普遍的构造顺序或算法执行，得到产品</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * 应用实例：</span><span class="hljs-comment">     *     1.去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的"套餐"</span><span class="hljs-comment">     *     2.StringBuilder</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        <span class="hljs-comment">// 创建建造者接口并指向具体建造者 - 包含最终产品</span>        Builder concreteBuilder = <span class="hljs-keyword">new</span> ConcreteBuilder();        <span class="hljs-comment">// 创建指导者, 把具体建造者即工人作为参数传入, 通过统一方法执行相应的构建命令</span>        Director director = <span class="hljs-keyword">new</span> Director(concreteBuilder);        director.construct();        <span class="hljs-comment">// 从工人即具体建造者获取产品</span>        String result = concreteBuilder.getResult();        System.out.println(result);    &#125;&#125;</code></pre><h3 id="建造者的延展思考：链式调用"><a href="#建造者的延展思考：链式调用" class="headerlink" title="建造者的延展思考：链式调用"></a>建造者的延展思考：链式调用</h3><p>链式调用让代码更优雅~</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBuilder</span> </span>&#123;    <span class="hljs-comment">// 省略不必要的代码</span>    <span class="hljs-function">MyBuilder <span class="hljs-title">withName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.setName(name);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function">MyBuilder <span class="hljs-title">withYear</span><span class="hljs-params">(String year)</span> </span>&#123;        <span class="hljs-keyword">this</span>.setYear(year);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function">MyBuilder <span class="hljs-title">withSex</span><span class="hljs-params">(String sex)</span> </span>&#123;        <span class="hljs-keyword">this</span>.setSex(sex);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;&#125;</code></pre><h3 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h3><p><img src="/2023/09/12/%E5%BB%BA%E9%80%A0%E8%80%85&%E8%B4%A3%E4%BB%BB%E9%93%BE&%E5%A4%87%E5%BF%98%E5%BD%95/image-20200702233606240.png" srcset="/img/loading.gif" alt="image-20200702233606240"></p><blockquote><p>代码见下方~</p></blockquote><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><h3 id="意图-1"><a href="#意图-1" class="headerlink" title="意图"></a>意图</h3><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连城一条链，并沿着这条链传递该请求，直到有一个对象处理它为止</p><h3 id="典型应用"><a href="#典型应用" class="headerlink" title="典型应用"></a>典型应用</h3><p>Log4J 日志系统即是使用了责任链的思想，通过不同日志级别的传递，按级别处理日志</p><h3 id="简单实现一个Log等级系统"><a href="#简单实现一个Log等级系统" class="headerlink" title="简单实现一个Log等级系统"></a>简单实现一个Log等级系统</h3><p><strong><em>抽象类</em></strong></p><p>定义日志等级，设置下一个处理器，抽象出写入方法</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractLogger</span> </span>&#123;    <span class="hljs-comment">// 责任级别</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> INFO = <span class="hljs-number">1</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> DEBUG = <span class="hljs-number">2</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> ERROR = <span class="hljs-number">3</span>;    <span class="hljs-comment">// 当前级别</span>    <span class="hljs-keyword">int</span> level;    <span class="hljs-comment">//责任链中的下一个元素</span>    AbstractLogger nextLogger;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNextLogger</span><span class="hljs-params">(AbstractLogger nextLogger)</span></span>&#123;        <span class="hljs-keyword">this</span>.nextLogger = nextLogger;    &#125;    <span class="hljs-comment">// 记录日志</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">logMessage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> level, String message)</span></span>&#123;        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.level &lt;= level)&#123;            write(message);        &#125;        <span class="hljs-keyword">if</span>(nextLogger != <span class="hljs-keyword">null</span>)&#123;            nextLogger.logMessage(level, message);        &#125;    &#125;    <span class="hljs-comment">// 抽象方法 -&gt; 重写具体日志输出类型</span>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(String message)</span></span>;&#125;</code></pre><p><strong><em>具体日志类</em></strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InfoLoger</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractLogger</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InfoLoger</span><span class="hljs-params">(<span class="hljs-keyword">int</span> level)</span></span>&#123;        <span class="hljs-keyword">this</span>.level = level;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(String message)</span> </span>&#123;        System.out.println(<span class="hljs-string">"InfoLoger Console::Logger: "</span> + message);    &#125;&#125;</code></pre><blockquote><p>为了避免重复，只展示一个类</p></blockquote><p><strong><em>实际调用</em></strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        AbstractLogger log = getChainOfLoggers();        log.logMessage(AbstractLogger.INFO, <span class="hljs-string">"i am info"</span>);        log.logMessage(AbstractLogger.DEBUG, <span class="hljs-string">"i am debug"</span>);        log.logMessage(AbstractLogger.ERROR, <span class="hljs-string">"i am error"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AbstractLogger <span class="hljs-title">getChainOfLoggers</span><span class="hljs-params">()</span></span>&#123;        AbstractLogger error = <span class="hljs-keyword">new</span> ErrorLoger(AbstractLogger.ERROR);        AbstractLogger debug = <span class="hljs-keyword">new</span> DebugLoger(AbstractLogger.DEBUG);        AbstractLogger info = <span class="hljs-keyword">new</span> InfoLoger(AbstractLogger.INFO);        error.setNextLogger(debug);        debug.setNextLogger(info);        <span class="hljs-keyword">return</span> error;    &#125;&#125;<span class="hljs-comment">// 输出结果：</span><span class="hljs-comment">// InfoLoger Console::Logger: i am info</span><span class="hljs-comment">//</span><span class="hljs-comment">// </span><span class="hljs-comment">//</span><span class="hljs-comment">// DebugLoger Console::Logger: i am debug</span><span class="hljs-comment">// InfoLoger Console::Logger: i am debug</span><span class="hljs-comment">//</span><span class="hljs-comment">// </span><span class="hljs-comment">//</span><span class="hljs-comment">// ErrorLoger Console::Logger: i am error</span><span class="hljs-comment">// DebugLoger Console::Logger: i am error</span><span class="hljs-comment">// InfoLoger Console::Logger: i am error</span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="多种形式"><a href="#多种形式" class="headerlink" title="多种形式"></a>多种形式</h4><ul><li>当前pattern下类似日志级别形式, 只要等级比A大，那B,C都会处理</li><li>如A-&gt;B-&gt;C 由低到高级别执行，只要执行就返回等</li><li>最高级形式: 低级发起请求后, 高级任一处理后，请求反馈即可(涉及到异步相关,线程通信)</li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>降低耦合度。它将请求的发送者和接收者解耦</li><li>简化了对象。使得对象不需要知道链的结构</li><li>增强给对象指派职责的灵活性，通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任</li><li>增加新的请求处理类很方便</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>不能保证请求一定被接收</li><li>系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用</li><li>可能不容易观察运行时的特征，有碍于除错</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定</li><li>在不明确指定接收者的情况下，向多个对象中的一个提交一个请求</li><li>可动态指定一组对象处理请求</li></ul><h3 id="UML图-1"><a href="#UML图-1" class="headerlink" title="UML图"></a>UML图</h3><p><img src="/2023/09/12/%E5%BB%BA%E9%80%A0%E8%80%85&%E8%B4%A3%E4%BB%BB%E9%93%BE&%E5%A4%87%E5%BF%98%E5%BD%95/image-20200702234746444.png" srcset="/img/loading.gif" alt="image-20200702234746444"></p><blockquote><p>代码见下方~</p></blockquote><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><h3 id="意图-2"><a href="#意图-2" class="headerlink" title="意图"></a>意图</h3><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后可将对象恢复到原先保存的状态</p><h3 id="核心代码-1"><a href="#核心代码-1" class="headerlink" title="核心代码"></a>核心代码</h3><p><strong><em>备忘录</em></strong></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * ******************************</span><span class="hljs-comment"> * description:  备忘录，确定数据结构即可</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Memento</span> </span>&#123;    Map&lt;String, String&gt; data;&#125;</code></pre><p><strong><em>模拟短信场景</em></strong></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * ******************************</span><span class="hljs-comment"> * description:  模拟短信场景</span><span class="hljs-comment"> * ******************************</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageData</span> </span>&#123;    <span class="hljs-keyword">private</span> String time;    <span class="hljs-keyword">private</span> String message;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 存储数据</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Memento <span class="hljs-title">saveMemento</span> <span class="hljs-params">()</span> </span>&#123;        Map&lt;String, String&gt; map = Maps.newHashMap();        map.put(<span class="hljs-string">"TIME"</span>,    time);        map.put(<span class="hljs-string">"MESSAGE"</span>, message);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Memento(map);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 取出数据</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getFromMemento</span><span class="hljs-params">(Memento memento)</span></span>&#123;        time    = memento.getData().get(<span class="hljs-string">"TIME"</span>);        message = memento.getData().get(<span class="hljs-string">"MESSAGE"</span>);    &#125;    <span class="hljs-comment">// 省略部分代码</span>&#125;</code></pre><p><strong><em>备忘录存储容器</em></strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MementoTaker</span> </span>&#123;    <span class="hljs-keyword">private</span> List&lt;Memento&gt; mementoList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Memento state)</span></span>&#123;        mementoList.add(state);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Memento <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>&#123;        <span class="hljs-keyword">return</span> mementoList.get(index);    &#125;&#125;</code></pre><p><strong><em>核心调用代码</em></strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-comment">// 创建备忘录管理者</span>        MementoTaker mementoTaker = <span class="hljs-keyword">new</span> MementoTaker();        MessageData messageData = <span class="hljs-keyword">new</span> MessageData();        messageData.setTime(System.currentTimeMillis() + <span class="hljs-string">""</span>);        messageData.setMessage(<span class="hljs-string">"This is messgae first."</span>);        mementoTaker.add(messageData.saveMemento());        System.out.println(<span class="hljs-string">"First: -&gt; "</span> + messageData);        Thread.sleep(<span class="hljs-number">2000</span>);        messageData.setTime(System.currentTimeMillis() + <span class="hljs-string">""</span>);        messageData.setMessage(<span class="hljs-string">"This is messgae second."</span>);        mementoTaker.add(messageData.saveMemento());        System.out.println(<span class="hljs-string">"Second: -&gt; "</span> + messageData);        Thread.sleep(<span class="hljs-number">2000</span>);        <span class="hljs-comment">// 回复初次状态</span>        messageData.getFromMemento(mementoTaker.get(<span class="hljs-number">0</span>));        System.out.println(<span class="hljs-string">"********************检测数据是否回到初始状态******************"</span>);        System.out.println(messageData);    &#125;&#125;</code></pre><p>模式总结：<font color="red">其实该模式非常简单，即确定好数据结构在容器中存储一份，以便后续恢复，或者重新使用等等</font></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><h4 id="主要解决"><a href="#主要解决" class="headerlink" title="主要解决"></a>主要解决</h4><p>所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态</p><h4 id="备忘录思想的实践"><a href="#备忘录思想的实践" class="headerlink" title="备忘录思想的实践"></a>备忘录思想的实践</h4><ul><li>打游戏时的存档</li><li>Windows 里的 ctri + z</li><li>数据库的事务管理</li></ul><h3 id="UML图-2"><a href="#UML图-2" class="headerlink" title="UML图"></a>UML图</h3><p><img src="/2023/09/12/%E5%BB%BA%E9%80%A0%E8%80%85&%E8%B4%A3%E4%BB%BB%E9%93%BE&%E5%A4%87%E5%BF%98%E5%BD%95/image-20200702235930286.png" srcset="/img/loading.gif" alt="image-20200702235930286"></p><h2 id="相关代码链接"><a href="#相关代码链接" class="headerlink" title="相关代码链接"></a>相关代码链接</h2><p><a href="https://github.com/kkzhilu/Kerwin-DesignPattern" target="_blank" rel="noopener">GitHub地址</a></p><ul><li>兼顾了《HeadFirst》以及《GOF》两本经典书籍中的案例</li><li>提供了友好的阅读指导</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/5/18/172284a1c8caf324?w=487&h=185&f=png&s=17561" srcset="/img/loading.gif" alt></p>]]></content>
    
    
    <categories>
      
      <category>编码及设计模式篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>建造者&amp;责任链&amp;备忘录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工厂模式</title>
    <link href="/2023/09/12/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/09/12/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="工厂模式篇"><a href="#工厂模式篇" class="headerlink" title="工厂模式篇"></a>工厂模式篇</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在设计模式中关于工厂模式有一点特殊，就标准意义而言我们一般提到的工厂模式一般包括三种：</p><ul><li>简单工厂</li><li>工厂方法模式</li><li>抽象工厂模式</li></ul><blockquote><p><strong><em>其实简单工厂不属于设计模式，由于它的使用场景还是比较多的，因此本篇将会一起介绍一下~</em></strong></p></blockquote><h2 id="工厂模式意图"><a href="#工厂模式意图" class="headerlink" title="工厂模式意图"></a>工厂模式意图</h2><p>工厂模式属于对象创建型模式，无论是上述三种的哪一种都是为了同一个设计原则即<font color="red">依赖抽象，不要依赖具体</font></p><p>简单来说就是把<font color="blue">复杂对象创建（初始化）的细节</font>或者<font color="blue">依赖关系经常可能发生变化的细节</font>交给一个第三方类（工厂类），避免在业务逻辑中书写不必要的内容</p><h2 id="简单工厂模式的简单写法"><a href="#简单工厂模式的简单写法" class="headerlink" title="简单工厂模式的简单写法"></a>简单工厂模式的简单写法</h2><p>简单工厂在实际应用中非常的频繁，假设我们现在需要生产Intel和AMD相关的产品，来看看代码</p><h3 id="静态方法无脑IF-Switch"><a href="#静态方法无脑IF-Switch" class="headerlink" title="静态方法无脑IF | Switch"></a>静态方法无脑IF | Switch</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleFactory</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AbstractCPU <span class="hljs-title">createCpu</span> <span class="hljs-params">(String type)</span> </span>&#123;        <span class="hljs-keyword">switch</span> (type) &#123;            <span class="hljs-keyword">case</span> <span class="hljs-string">"INTEL"</span>:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IntelCpu();            <span class="hljs-keyword">default</span>:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AMDCpu();        &#125;       <span class="hljs-comment">/* if ("INTEL".equals(type)) &#123;</span><span class="hljs-comment">            return new IntelCpu();</span><span class="hljs-comment">        &#125; else if ("AMD".equals(type))&#123;</span><span class="hljs-comment">            return new AMDCpu();</span><span class="hljs-comment">        &#125;</span><span class="hljs-comment">        return null;*/</span>    &#125;&#125;</code></pre><blockquote><p><strong><em>此种方式适合非常单一的场景，快速构建工厂代码，不用过多的思考</em></strong></p></blockquote><p>值得注意的是静态方法和普通方法的区别，静态工厂让它不具备继承性，在某些场合可能导致无法扩展的问题，在代码优化层面可以配合枚举，Map等方式继续让代码变得更清爽一些</p><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类，Factory Mehod使一个类的实例化延迟到其子类</p><h3 id="工厂方法模式的诞生"><a href="#工厂方法模式的诞生" class="headerlink" title="工厂方法模式的诞生"></a>工厂方法模式的诞生</h3><p>工厂方法用来处理对象的创建，并将这样的行为封装在子类中，这样，客户程序中关于超类的代码就和子类对象创建代码解耦了。</p><p>咱们还是一样，说说人话：</p><p>【<font color="orange">产品</font>】：最近我们有<font color="red">英特尔和AMD的CPU</font>产品订购方案，您看能不能实现一下相关的代码？</p><p>【<font color="red">BOSS</font>】：它们的装配啊，生产啊等等的<font color="red">细节一样</font>吗？</p><p>【<font color="orange">产品</font>】：嗯嗯，细节流程都是一样的！</p><p>【<font color="red">BOSS</font>】：那个谁，小柯啊，工厂方法模式懂吗，去做吧，给你半天时间，好好设计设计。</p><p><img src="/2023/09/12/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/image-20200524105721242.png" srcset="/img/loading.gif" alt="image-20200524105721242"></p><p>【<font color="blue">开发</font>】：好的！（内心OS：我不会啊！！！）</p><h3 id="HeadFirst-核心代码"><a href="#HeadFirst-核心代码" class="headerlink" title="HeadFirst 核心代码"></a>HeadFirst 核心代码</h3><p>不会的话，只能看书学习啦~</p><p><strong>父级接口</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Factory</span> </span>&#123;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 产品订购方案</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractCPU <span class="hljs-title">orderCpu</span> <span class="hljs-params">()</span> </span>&#123;        AbstractCPU cpu = generateCpu();        cpu.show();        cpu.prepare();        cpu.box();        <span class="hljs-comment">// 假设有相同的业务处理逻辑...</span>        <span class="hljs-keyword">return</span> cpu;    &#125;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> AbstractCPU <span class="hljs-title">generateCpu</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p><strong>具体实现</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntelCpuFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Factory</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractCPU <span class="hljs-title">generateCpu</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IntelCpu();    &#125;&#125;<span class="hljs-comment">// ****************************************************************</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AMDCpuFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Factory</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractCPU <span class="hljs-title">generateCpu</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AMDCpu();    &#125;&#125;</code></pre><p><font color="red">工厂方法模式的设计思路</font>：</p><ul><li>Product（Document） 定义工厂方法所创建对象的接口</li><li>ConcreteProduct（MyDocument）实现Product接口</li><li>Creator（Factory）声明工厂方法</li><li>ConcreteCreator（MyFactory）具体的工厂类</li></ul><h3 id="什么场景适用"><a href="#什么场景适用" class="headerlink" title="什么场景适用"></a>什么场景适用</h3><p>在下列情况下可以使用 Factory Method模式：</p><ul><li>当一个类不知道它所必须创建的对象的类的时候</li><li>当一个类希望由它的子类来指定它所创建的对象的时候</li><li>当类将创建对象的职责委托给多个子类中的某一个，并且你希望控制哪一个子类实现的时候</li></ul><h3 id="Code-生活中的实际应用"><a href="#Code-生活中的实际应用" class="headerlink" title="Code/生活中的实际应用"></a>Code/生活中的实际应用</h3><p>例如在工厂生产电池时，对于电池的保管，订货，输送的方式可能完全一致，但是仅型号不一致，因此分别交给A流水线，B流水线进行生产，但是后续的其他流程又是重合的</p><h3 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h3><p><img src="/2023/09/12/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/image-20200524112807802.png" srcset="/img/loading.gif" alt="image-20200524112807802"></p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><h3 id="意图-1"><a href="#意图-1" class="headerlink" title="意图"></a>意图</h3><p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类</p><h3 id="抽象工厂模式的诞生"><a href="#抽象工厂模式的诞生" class="headerlink" title="抽象工厂模式的诞生"></a>抽象工厂模式的诞生</h3><p>PS：故事内容承接工厂方法模式的诞生~</p><p>【<font color="orange">产品</font>】：我…  我好像搞错需求了…</p><p>【<font color="red">BOSS</font>】：什么意思？？？</p><p>【<font color="orange">产品</font>】：咱们的订单不是仅仅只生成CPU产品，而是要生成<font color="red">英特尔还有AMD的全系列产品…</font></p><p><img src="/2023/09/12/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/image-20200524113603606.png" srcset="/img/loading.gif" alt="image-20200524113603606"></p><p>【<font color="red">BOSS</font>】：你你你你…   之前的功夫都白费了啊！</p><p>【<font color="orange">产品</font>】：不就是生产东西嘛，反正都是生产，我不管，你要给我实现！</p><p>【<font color="red">BOSS</font>】：小柯，委屈你了。</p><p>【<font color="blue">开发</font>】：好吧，那我能问一个问题吗？<font color="red">未来是不是还有可能要生产华为的，联想的？</font></p><p>【<font color="orange">产品</font>】：对！很有可能！如果我们生意做大了！</p><h3 id="HeadFirst-核心代码-1"><a href="#HeadFirst-核心代码-1" class="headerlink" title="HeadFirst 核心代码"></a>HeadFirst 核心代码</h3><p>抽象工厂模式着重点在<font color="red">产品族</font>上，开始撸代码吧~</p><p><strong>父级抽象类</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractFactory</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 创建CPU对象</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> CPU对象</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> AbstractCPU <span class="hljs-title">createCpu</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 创建主板对象</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 主板对象</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> AbstractMotherboard <span class="hljs-title">createMainboard</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p><strong>子类实现</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntelFactory</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title">AbstractFactory</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractCPU <span class="hljs-title">createCpu</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IntelCpu();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractMotherboard <span class="hljs-title">createMainboard</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IntelMotherboard();    &#125;&#125;<span class="hljs-comment">// *************************************************************</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AMDFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractFactory</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractCPU <span class="hljs-title">createCpu</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AMDCpu();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractMotherboard <span class="hljs-title">createMainboard</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AMDMotherboard();    &#125;&#125;</code></pre><p><font color="red">抽象工厂模式的设计思路</font>：</p><ul><li>AbstractProduct    为一类产品对象声明一个接口</li><li>ConcreteProduct   具体对象</li><li>AbstractFactory     声明一个创建抽象产品对象的接口</li><li>ConcreteFactory   具体的产品族工厂</li></ul><p><font color="red">思路示意图</font>：</p><p><img src="/2023/09/12/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/image-20191223174111618.png" srcset="/img/loading.gif" alt="image-20191223174111618"></p><h3 id="工厂方法是不是潜伏在抽象工厂中？"><a href="#工厂方法是不是潜伏在抽象工厂中？" class="headerlink" title="工厂方法是不是潜伏在抽象工厂中？"></a>工厂方法是不是潜伏在抽象工厂中？</h3><p>没错，抽象工厂的方法经常以工厂方法的方式实现，因为抽象工厂的任务通常是定义一个负责创建一组产品的接口，在这个接口内的每个方法都负责创建一个具体的产品，<strong><em>而这种某一个具体的产品的实质就是工厂方法模式的实践</em></strong></p><h3 id="什么场景适用-1"><a href="#什么场景适用-1" class="headerlink" title="什么场景适用"></a>什么场景适用</h3><p>在以下情况可以使用 Abstract Factory 模式：</p><ul><li>系统要独立于它的产品的创建、组合和表示时</li><li>系统要由多个产品系列中的一个来配置时</li><li>当你要强调一系列相关的产品对象的设计以便进行联合使用时</li><li>当你提供一个产品类库，而只想显示它们的接口而不是实现时</li></ul><h3 id="Code-生活中的实际应用-1"><a href="#Code-生活中的实际应用-1" class="headerlink" title="Code/生活中的实际应用"></a>Code/生活中的实际应用</h3><p>比如上述的情况，观察代码我们可以发现我们其实是把一个产品族进行了封装，如果这个时候要引入华为系列产品，我们完全不用动任何代码，只需要增加一个类即可，非常符合开闭原则</p><h3 id="UML图-1"><a href="#UML图-1" class="headerlink" title="UML图"></a>UML图</h3><p><img src="/2023/09/12/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/image-20200524114955227.png" srcset="/img/loading.gif" alt="image-20200524114955227"></p><h2 id="遵循的设计原则"><a href="#遵循的设计原则" class="headerlink" title="遵循的设计原则"></a>遵循的设计原则</h2><p><strong>依赖抽象，而不是依赖具体</strong></p><ul><li>无论是简单工厂还是工厂方法，亦或是抽象工厂，都是强调解耦，依赖抽象，不依赖具体</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>相同点：</strong></p><ul><li>所有的工厂都是用来封装对象的创建</li><li>简单工厂，虽然不是真正的设计模式，但仍不失为一个简单的方法，可以进行解耦</li><li>所有工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合</li><li>依赖倒置原则，指导我们避免依赖具体类型，而要尽量依赖抽象</li><li>工厂是很有威力的技巧，帮助我们针对抽象编程，而不是具体类编程</li></ul><p><strong>工厂方法：</strong></p><ul><li>工厂方法利用继承：把对象的创建委托给子类，子类实现工厂方法来创建对象</li><li>工厂方法允许类将实例化延迟到子类实现</li></ul><p><strong>抽象工厂：</strong></p><ul><li>抽象工厂使用对象组合：对象的创建被实现在工厂接口所暴露出来的方法中</li><li>抽象工厂创建相关的<font color="red">对象家族</font>，而不需要依赖它们的具体类</li></ul><h2 id="相关代码链接"><a href="#相关代码链接" class="headerlink" title="相关代码链接"></a>相关代码链接</h2><p><a href="https://github.com/kkzhilu/Kerwin-DesignPattern" target="_blank" rel="noopener">GitHub地址</a></p><ul><li>兼顾了《HeadFirst》以及《GOF》两本经典书籍中的案例</li><li>提供了友好的阅读指导</li></ul><p><img src="/2023/09/12/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/%E5%BE%AE%E4%BF%A1%E4%BA%8C%E7%BB%B4%E7%A0%81.png" srcset="/img/loading.gif" alt></p>]]></content>
    
    
    <categories>
      
      <category>编码及设计模式篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工厂模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>悄咪咪提高团队幸福感 &amp; Surprise！</title>
    <link href="/2023/09/12/%E6%82%84%E5%92%AA%E5%92%AA%E6%8F%90%E9%AB%98%E5%9B%A2%E9%98%9F%E5%B9%B8%E7%A6%8F%E6%84%9F%20&amp;%20Surprise%EF%BC%81/"/>
    <url>/2023/09/12/%E6%82%84%E5%92%AA%E5%92%AA%E6%8F%90%E9%AB%98%E5%9B%A2%E9%98%9F%E5%B9%B8%E7%A6%8F%E6%84%9F%20&amp;%20Surprise%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文的灵感是在几个月以前工作不忙（摸鱼）时想到的，老是自己一个人往前冲冲冲也没啥意思，需要想一点办法，来提高团队的效率，提高团队的幸福感（效率起来了，单位时间内代码写的更多，那不就幸福啦 😜），经过几个月的摸索，总结出了几个小点，如果大家有更好的方式，欢迎一起讨论~</p><br><h2 id="永久解决不知道是什么版本"><a href="#永久解决不知道是什么版本" class="headerlink" title="永久解决不知道是什么版本"></a>永久解决不知道是什么版本</h2><p>我司的产品主要分为Saas端和私有平台，分别部署在公网和客户的私有环境，先来说说私有环境的问题：<code>不知道真正部署的项目版本</code>，说来很可笑，运维同学在部署的时候肯定是记录过各个客户的代码版本的，但也就是这么可笑，有时候就是会弄错，可能是由于升级流程不够完善，或者工作失误等等，总之，想个办法解决。</p><br><p>人靠不住，但还有代码。<code>Git</code>已经成为代码管理的事实标准，这就不多说了，即然人管理不好版本，那还是从<code>Git</code>本身入手吧，悄咪咪的给所有项目依赖（<code>POM.XML</code>）增加一个插件：</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Git Version插件 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>pl.project13.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>git-commit-id-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>get-the-git-infos<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>initialize<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>revision<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dotGitDirectory</span>&gt;</span>$&#123;project.basedir&#125;/.git<span class="hljs-tag">&lt;/<span class="hljs-name">dotGitDirectory</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">verbose</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">verbose</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dateFormat</span>&gt;</span>yyyy-MM-dd HH:mm:ss<span class="hljs-tag">&lt;/<span class="hljs-name">dateFormat</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">prefix</span>&gt;</span>git<span class="hljs-tag">&lt;/<span class="hljs-name">prefix</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">generateGitPropertiesFile</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">generateGitPropertiesFile</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">generateGitPropertiesFilename</span>&gt;</span>$&#123;project.build.outputDirectory&#125;/$&#123;project.name&#125;.build.json<span class="hljs-tag">&lt;/<span class="hljs-name">generateGitPropertiesFilename</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">format</span>&gt;</span>json<span class="hljs-tag">&lt;/<span class="hljs-name">format</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">gitDescribe</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">skip</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">skip</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">always</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">always</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">dirty</span>&gt;</span>-dirty<span class="hljs-tag">&lt;/<span class="hljs-name">dirty</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">gitDescribe</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></code></pre><p>插件将会在每次构建时生成一个版本相关文件，内容如下：</p><pre><code class="hljs json">&#123;  <span class="hljs-attr">"git.branch"</span> : <span class="hljs-string">"master"</span>,  <span class="hljs-attr">"git.build.host"</span> : <span class="hljs-string">"Kerwin"</span>,  <span class="hljs-attr">"git.build.time"</span> : <span class="hljs-string">"2020-08-12 23:24:59"</span>,  <span class="hljs-attr">"git.build.user.email"</span> : <span class="hljs-string">"34807944+kkzhilu@users.noreply.github.com"</span>,  <span class="hljs-attr">"git.build.user.name"</span> : <span class="hljs-string">"kkzhilu"</span>,  <span class="hljs-attr">"git.build.version"</span> : <span class="hljs-string">"1.0.0-SNAPSHOT"</span>,  <span class="hljs-attr">"git.closest.tag.commit.count"</span> : <span class="hljs-string">""</span>,  <span class="hljs-attr">"git.closest.tag.name"</span> : <span class="hljs-string">""</span>,  <span class="hljs-attr">"git.commit.id"</span> : <span class="hljs-string">"4981afb5dfeee6f835dcf9a7a135083d8e973090"</span>,  <span class="hljs-attr">"git.commit.id.abbrev"</span> : <span class="hljs-string">"4981afb"</span>,  <span class="hljs-attr">"git.commit.id.describe"</span> : <span class="hljs-string">"4981afb"</span>,  <span class="hljs-attr">"git.commit.id.describe-short"</span> : <span class="hljs-string">"4981afb"</span>,  <span class="hljs-attr">"git.commit.message.full"</span> : <span class="hljs-string">"Commit git-version"</span>,  <span class="hljs-attr">"git.commit.message.short"</span> : <span class="hljs-string">"Commit git-version"</span>,  <span class="hljs-attr">"git.commit.time"</span> : <span class="hljs-string">"2020-08-04 18:18:47"</span>,  <span class="hljs-attr">"git.commit.user.email"</span> : <span class="hljs-string">"34807944+kkzhilu@users.noreply.github.com"</span>,  <span class="hljs-attr">"git.commit.user.name"</span> : <span class="hljs-string">"kexianming"</span>,  <span class="hljs-attr">"git.dirty"</span> : <span class="hljs-string">"false"</span>,  <span class="hljs-attr">"git.local.branch.ahead"</span> : <span class="hljs-string">"0"</span>,  <span class="hljs-attr">"git.local.branch.behind"</span> : <span class="hljs-string">"0"</span>,  <span class="hljs-attr">"git.remote.origin.url"</span> : <span class="hljs-string">"https://github.com/kkzhilu/KerwinBoots.git"</span>,  <span class="hljs-attr">"git.tags"</span> : <span class="hljs-string">""</span>,  <span class="hljs-attr">"git.total.commit.count"</span> : <span class="hljs-string">"9"</span>&#125;</code></pre><p>插件名字叫：<code>git-commit-id-plugin</code>，至于细节使用就自己去搜索啦，它可以实现的效果即在每次打包时生成相应的Git相关信息，这样无论运维同学是否把代码升错，我们都可以知道<code>代码到底是什么版本</code></p><p>以后终于听不到同事之间因为代码版本扯皮的事情了🤪</p><br><h2 id="永久解决没打日志怎么办的问题"><a href="#永久解决没打日志怎么办的问题" class="headerlink" title="永久解决没打日志怎么办的问题"></a>永久解决没打日志怎么办的问题</h2><p>回到刚刚说的Saas端生产环境，由于各种原因，我们团队经常需要维护不是自己写的项目，很多时候一些细节逻辑完全摸不着头脑，而且没有日志，最要命的是在测试环境还不复现，肿么办？</p><br><p>以前的解决方案是各种喊人，然后硬看代码寻找上下文，尽可能的找到蛛丝马迹，总之效率非常感人，处理的慢了就是一个事故，全员挨批评，咋办呢？我就一直在寻找这种问题的解决办法，终于我发现了一个神器：<code>Arthas</code></p><br><p>用过这个工具的人就知道它有多强大，阿里出品，官方文档链接：<a href="https://arthas.gitee.io/commands.html" target="_blank" rel="noopener">https://arthas.gitee.io/commands.html</a></p><p>我们可以通过其提供的部分命令，如：<code>tt</code>，<strong>获取方法执行数据的时空隧道，它可以记录下指定方法每次调用的入参和返回信息</strong>，想想它的帮助有多大，<code>记录每一个方法的入参和出参</code>，如果真遇上没日志的情况，知道这些信息其实配合代码就可以很快定位问题了，所以，听过没用过的朋友，都去试试吧，真的很无敌。</p><p>下次同事有难时，你就用这个工具去帮他，他说不定会请你吃顿饭🍗</p><br><h2 id="永久解决哪里耗时这么长的问题"><a href="#永久解决哪里耗时这么长的问题" class="headerlink" title="永久解决哪里耗时这么长的问题"></a>永久解决哪里耗时这么长的问题</h2><p>这个问题是由于之前同事重写了一块业务逻辑，结果线上展现层耗时大概30s，oh，天哪！在测试环境明明是一瞬间的，咋办？</p><p>造成这种问题的原因，肯定是SQL写的不好，或者业务处理哪里做了很多不必要的动作（我们没有灰度测试），但是生产环境又不能随便动，也不能断点调试，从日志也只能看到耗时很长，但是慢在哪里不知道。</p><br><p>当一个方法里面经过了N个内部方法后，你不知道到底是哪一个导致这么长的耗时，当无法复现的时候怎么办呢？其实还是利用上面的那个工具<code>Arthas</code>，还是一样的命令<code>tt</code>，它不仅可以记录入参和出参信息，<strong>还可以记录每一个方法的耗时</strong>，多么的强大。</p><br><p>所以我是为了再次提醒，这些功能只是<code>Arthas</code>的一点皮毛，咱们要学会合理使用开源工具</p><br><h2 id="注释无法表达流程图效果的解决方案"><a href="#注释无法表达流程图效果的解决方案" class="headerlink" title="注释无法表达流程图效果的解决方案"></a>注释无法表达流程图效果的解决方案</h2><p>注释是文字，难以表达如流程图一般的效果，所以该怎么办呢？我找到了两种解决方案，目前在项目中使用效果非常之好，第一种是利用<code>ASCII注释工具</code>，该工具的地址：<a href="http://asciiflow.com/" target="_blank" rel="noopener">http://asciiflow.com/</a></p><p>效果如下：</p><p>![image-20200813002015129](悄咪咪提高团队幸福感 &amp; Surprise！/image-20200813002015129.png)</p><p>注释如下：</p><pre><code class="hljs bash">+-+|                               ||  +-+  ||  |                         |  ||  |           Demo          |  ||  |                         |  ||  |                         |  ||  +++  ||               |               ||               |               ||               |               ||               |               ||               |               ||               |               ||               |               ||               |               ||               |               ||               +&gt; False  ||               |               ||               |               ||    True   &lt;---+               ||                               |+-+</code></pre><p>这玩意画出来的图是可以直接复制成文本的，控制好尺寸就可以解决大部分情况，也可以想象之前网上有一些很奇葩的注释是不是就是用这个工具或者同样的原理画出来的，附上一副之前文章缺的一张图：</p><p><strong>上亿数据怎么玩深度分页？兼容MySQL + ES + MongoDB：</strong><a href="https://juejin.im/post/6850037275456339975" target="_blank" rel="noopener">https://juejin.im/post/6850037275456339975</a></p><p>这篇文章写完的时候，我自己方案的图还没画好，所以很多朋友问我用id实现不了什么的，这次就顺便展示一下我的方案</p><p>![](悄咪咪提高团队幸福感 &amp; Surprise！/image-20200723163317073.png)</p><p>解决方案之二，利用<code>MarkDown</code>的原生画图功能，我不知道要发布文章的平台支不支持，所以用截图来代替了（<code>Typora支持</code>）</p><p>![image-20200813002527878](悄咪咪提高团队幸福感 &amp; Surprise！/image-20200813002527878.png)</p><p>不知道的同学搜一下，<code>MarkDown</code>绘图语法，拿一个适合的改就好了，没必要专门去学，放到代码里看看效果：</p><p>![image-20200813002708209](悄咪咪提高团队幸福感 &amp; Surprise！/image-20200813002708209.png)</p><p>有一个小<code>Tips</code>，使用IDEA的时候，<strong>利用鼠标滚动键可以按块复制，这样一来可以直接复制到指定的注释内容</strong>，然后把它复制到任何一个正常的<code>MarkDown</code>工具里，就可以展示流程图了，简直不要太完美，想测试的朋友可以复制以下代码去一些工具里试试，需要设置代码种类为：<code>mermaid</code></p><pre><code class="hljs bash">sequenceDiagram   Note over Boot: 启动类   Note over PDFThread: 线程类   Note over PDFWorker: 执行类 Boot-&gt;&gt;PDFThread: Boot类启动线程   PDFThread-&gt;&gt;PDFWorker: 线程类调用真正工作Worker   loop 队列处理       PDFThread-&gt;PDFThread: 考虑成功与失败情况处理方案   end      PDFWorker--&gt;&gt;PDFThread: Worker响应执行结果Note right of PDFWorker: 注意参数校验 &lt;br/&gt;文件格式校验</code></pre><p>你未来的同事维护代码的时候会爱上你，如果是女生，可能还会嫁给你🧡</p><p>幻想有一天你老大跑过来问你，你这写的注释都是些什么玩意，然后你一复制一粘贴，一张图就出来了！下次涨薪会没有你？</p><p>（反正我涨了，还不少😎）</p><br><p>PS：我考虑写一个支持直接复制然后渲染成流程图的<code>IDEA插件</code>，如果有现成的请联系我，就省的我去写了，嘿嘿✌</p><br><h2 id="垃圾SQL的解决方案"><a href="#垃圾SQL的解决方案" class="headerlink" title="垃圾SQL的解决方案"></a>垃圾SQL的解决方案</h2><p>我们公司没有专门的<code>DBA</code>，所以<code>SQL</code>语句的质量只掌握在开发和开发组长的手上，有时候事情多，或者不细心，或者模块不是很重要就容易粗心，到了生产环境出大问题，针对这种情况的解决方案依然是寻找工具，比如，我盯上了<code>小米</code>的<code>Soar</code></p><p>项目地址：<a href="https://github.com/XiaoMi/soar" target="_blank" rel="noopener">https://github.com/XiaoMi/soar</a></p><p>官方的介绍：</p><ul><li>跨平台支持</li><li>目前只支持 MySQL 语法族协议的 SQL 优化</li><li>支持基于启发式算法的语句优化</li><li>支持复杂查询的多列索引优化（UPDATE、INSERT、DELETE、SELECT）</li></ul><p>贴个图片展示一下效果：</p><p>![](悄咪咪提高团队幸福感 &amp; Surprise！/Soar-Web效果图.jpg)</p><p>这款工具可以进行对<code>SQL</code>进行打分，同时提供一些建议，它的能力上限我们还没有摸索出来，但是下限还是可以肯定的，因此之后只需要关注<code>索引</code>是否正确使用，其他的就交给这个工具吧，低于90分，就改！</p><p>PS：这个开源项目推荐使用<code>docker</code>安装，简单粗暴无脑省时间，命令如下：</p><pre><code class="hljs bash"><span class="hljs-comment"># 安装镜像</span>docker pull becivells/soar-web<span class="hljs-comment"># 运行</span>docker run -d --name Soar-web -p 5077:5077 becivells/soar-web</code></pre><p>想着有个工具会检查SQL质量了，是不是写的时候也认真多啦，幸福感提示满满，哈哈~😁</p><br><h2 id="懒得写文档的解决方案"><a href="#懒得写文档的解决方案" class="headerlink" title="懒得写文档的解决方案"></a>懒得写文档的解决方案</h2><p>方案设计的文档不可能由工具去写，但是简单的数据库字段映射，或者接口文档总不需要开发去写吧？也是一样摸索摸索，找到了几个不太适合但是靠边的开源项目，如：</p><p><strong>apidoc：</strong><a href="https://github.com/apidoc/apidoc" target="_blank" rel="noopener">https://github.com/apidoc/apidoc</a></p><blockquote><p>RESTful web API Documentation Generator.</p></blockquote><p><strong>JApiDocs：</strong><a href="https://github.com/YeDaxia/JApiDocs" target="_blank" rel="noopener">https://github.com/YeDaxia/JApiDocs</a></p><blockquote><p>A magical api documentation generator without annotation for springboot.</p></blockquote><p><strong>APIAuto：</strong><a href="https://github.com/TommyLemon/APIAuto" target="_blank" rel="noopener">https://github.com/TommyLemon/APIAuto</a></p><blockquote><p>机器学习测试、自动生成代码、自动静态检查、自动生成文档与注释等，做最先进的接口管理工具</p></blockquote><p>因为每个项目的情况不同，但是我又不想做大的改动，所以只能说是靠边，不能百分百适合，但有了这些开源项目，我就可以改写其中的代码，让它适应当前项目的注释方案等等，总是，能节省相当一部分的编写文档的时间</p><br><h2 id="重复性代码的解决方案"><a href="#重复性代码的解决方案" class="headerlink" title="重复性代码的解决方案"></a>重复性代码的解决方案</h2><p>这个的确是个大坑，谁让咱们是CRUD程序员呢，经常需要写重复性相当高，但是又有一点不同的代码，这里我的解决方案是利用模板 + 更合适的工具解决，如果只是数据库操作层重复代码多，我们完全可以利用<code>mybatis-plus</code>工具减少重复代码，又或者写出<code>公共的操作层</code>减少重复代码。</p><br><p>当用工具完不成的时候，我就会用上模板了，比如直接我写过一个简单的开源项目：</p><p><strong>好像很厉害的生成器！一秒钟搞定一个项目：</strong><a href="https://juejin.im/post/6844904148417118215" target="_blank" rel="noopener">https://juejin.im/post/6844904148417118215</a></p><p>核心思路和要求如下：</p><ul><li>基于数据库获取原始数据</li><li>基于模板 + 原始数据生成可运行的SpringBoot项目，支持界面 + 基本增删改查</li><li>提供拓展式接口，可以实现不修改代码生成全新的文件</li></ul><br><p>那利用这种思路，其实完全可以写一套更开放的代码生成模板，比如根据传递的<code>JSON</code>报文去解析数据，根据传递的<code>模板</code>去生成数据，这样的话又可以解决相当大一部分的重复工具，你，值得拥有。</p><p>PS：同理，其实数据库字段映射文档也可以用这种方式，只需要一秒钟，简直不要太舒服🤷‍♂️</p><br><h2 id="重复性的操作用脚本代码"><a href="#重复性的操作用脚本代码" class="headerlink" title="重复性的操作用脚本代码"></a>重复性的操作用脚本代码</h2><p>这个其实大家都有意识，但是有时候就是感觉可能用的不多，真要用起来的时候又没功夫去写脚本，比如进入一个<code>docker</code>容器，如果用命令行的话，至少要经历两步代码，十几秒的时间，如果写一个脚本呢，以后进入容器只需要一秒钟，所以我给团队写了不少这种脚本，其实我一开始也不会，反正就复制来一个改一改就行，如下是进入<code>docker容器</code>的</p><pre><code class="hljs bash"><span class="hljs-comment">#使用说明，用来提示输入参数</span><span class="hljs-function"><span class="hljs-title">usage</span></span>() &#123;    <span class="hljs-built_in">echo</span> <span class="hljs-string">"Usage: sh 执行脚本.sh [rpcapp|tomcat|nginx|mysql]"</span>    <span class="hljs-built_in">exit</span> 1&#125;<span class="hljs-function"><span class="hljs-title">rpcapp</span></span>()&#123;  DOCKER_ID=$(docker ps | grep <span class="hljs-string">"rpcapp"</span> | awk <span class="hljs-string">'&#123;print $1&#125;'</span>)  docker <span class="hljs-built_in">exec</span> -it <span class="hljs-variable">$DOCKER_ID</span> bash&#125;<span class="hljs-function"><span class="hljs-title">tomcat</span></span>()&#123;  DOCKER_ID=$(docker ps | grep <span class="hljs-string">"tomcat"</span> | awk <span class="hljs-string">'&#123;print $1&#125;'</span>)  docker <span class="hljs-built_in">exec</span> -it <span class="hljs-variable">$DOCKER_ID</span> bash&#125;<span class="hljs-function"><span class="hljs-title">nginx</span></span>()&#123;  DOCKER_ID=$(docker ps | grep <span class="hljs-string">"nginx"</span> | awk <span class="hljs-string">'&#123;print $1&#125;'</span>)  docker <span class="hljs-built_in">exec</span> -it <span class="hljs-variable">$DOCKER_ID</span> bash&#125;<span class="hljs-function"><span class="hljs-title">mysql</span></span>()&#123;  DOCKER_ID=$(docker ps | grep <span class="hljs-string">"mysql"</span> | awk <span class="hljs-string">'&#123;print $1&#125;'</span>)  docker <span class="hljs-built_in">exec</span> -it <span class="hljs-variable">$DOCKER_ID</span> bash&#125;<span class="hljs-comment">#根据输入参数，选择执行对应方法，不输入则执行使用说明</span><span class="hljs-keyword">case</span> <span class="hljs-string">"<span class="hljs-variable">$1</span>"</span> <span class="hljs-keyword">in</span>  <span class="hljs-string">"rpcapp"</span>)    rpcapp    ;;  <span class="hljs-string">"tomcat"</span>)    tomcat    ;;  <span class="hljs-string">"nginx"</span>)    nginx    ;;  <span class="hljs-string">"mysql"</span>)    mysql    ;;  *)    usage    ;;<span class="hljs-keyword">esac</span></code></pre><br><p>从网上找了找，又找到一个开源项目用以记录常用的脚本</p><p><strong>useful-scripts：</strong><a href="https://github.com/oldratlee/useful-scripts" target="_blank" rel="noopener">https://github.com/oldratlee/useful-scripts</a></p><p>![image-20200813003842859](悄咪咪提高团队幸福感 &amp; Surprise！/image-20200813003842859.png)</p><p>能自动的就不要每次都手写啦，节约时间去摸鱼不快乐吗👏</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这可是我这么久以来总结的时间管理神器，节省的时间拿去摸鱼学习，循环促进效率和能力，形成良性正反馈</p><p>这还不值得<code>来个赞</code>👍👍👍吗？嘿嘿~</p><blockquote><p>另外可以搜索公众号「<strong>是Kerwin啊</strong>」，一起进步！</p><p>也可以查看<a href="https://github.com/kkzhilu" target="_blank" rel="noopener">Kerwin的GitHub主页</a>，关注一个小白程序员的进步，这货最近在折腾Go~</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>杂文篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>悄咪咪提高团队幸福感 &amp; Surprise！</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写简易MyBatis</title>
    <link href="/2023/09/12/%E6%89%8B%E5%86%99%E7%AE%80%E6%98%93MyBatis/"/>
    <url>/2023/09/12/%E6%89%8B%E5%86%99%E7%AE%80%E6%98%93MyBatis/</url>
    
    <content type="html"><![CDATA[<h1 id="手写简易的Mybatis"><a href="#手写简易的Mybatis" class="headerlink" title="手写简易的Mybatis"></a>手写简易的Mybatis</h1><p>此篇文章用来记录今天花个五个小时写出来的简易版mybatis，主要实现了基于注解方式的增删查改，目前支持List，Object类型的查找，参数都是基于Map集合的，可以先看一下接口：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StudentInterface</span> </span>&#123;    <span class="hljs-meta">@Select</span>(value = <span class="hljs-string">" select * from student where age &gt; #&#123;age&#125;"</span>)    <span class="hljs-function">List&lt;StudentMeBatis&gt; <span class="hljs-title">getList</span><span class="hljs-params">(Map&lt;String, Object&gt; map)</span></span>;    <span class="hljs-meta">@Select</span>(value = <span class="hljs-string">" select * from student where age = #&#123;age&#125;"</span>)    <span class="hljs-function">StudentMeBatis <span class="hljs-title">get</span><span class="hljs-params">(Map&lt;String, Object&gt; map)</span></span>;    <span class="hljs-meta">@Insert</span>(value = <span class="hljs-string">" insert into student values (#&#123;age&#125;, #&#123;name&#125;, #&#123;year&#125;)"</span>)    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">insert</span> <span class="hljs-params">(Map&lt;String, Object&gt; map)</span></span>;    <span class="hljs-meta">@Delete</span>(value = <span class="hljs-string">" delete from student where name = #&#123;name&#125; "</span>)    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">delete</span> <span class="hljs-params">(Map&lt;String, Object&gt; map)</span></span>;    <span class="hljs-meta">@Update</span>(value = <span class="hljs-string">" update student set age = #&#123;age&#125;, year = #&#123;year&#125; where name = #&#123;name&#125; "</span>)    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">update</span> <span class="hljs-params">(Map&lt;String, Object&gt; map)</span></span>;&#125;</code></pre><p>测试效果：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;    StudentInterface studentInterface = MapperProxyUtil.newProxyInstance(StudentInterface<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    Map&lt;String, Object&gt; params = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    params.put(<span class="hljs-string">"age"</span>,  <span class="hljs-number">15</span>);    params.put(<span class="hljs-string">"name"</span>, <span class="hljs-number">15</span>);    params.put(<span class="hljs-string">"year"</span>, <span class="hljs-number">1996</span>);    System.out.println(studentInterface.getList(params));    System.out.println(studentInterface.insert(params));    Map&lt;String, Object&gt; selectParams = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    selectParams.put(<span class="hljs-string">"age"</span>,  <span class="hljs-number">1</span>);    System.out.println(studentInterface.get(selectParams));&#125;响应数据：<span class="hljs-number">2020</span>-<span class="hljs-number">01</span>-<span class="hljs-number">09</span> <span class="hljs-number">15</span>:<span class="hljs-number">02</span>:<span class="hljs-number">28.286</span> INFO  [main] mebatis.execute.SqlRunner (<span class="hljs-number">105</span>) select - SQL Execute successful, sql is:  select * from student where age &gt; ?, params is: [<span class="hljs-number">15</span>][StudentMeBatis(age=<span class="hljs-number">24</span>, name=李四, year=<span class="hljs-number">1995</span>), StudentMeBatis(age=<span class="hljs-number">22</span>, name=王五, year=<span class="hljs-number">1994</span>)]<span class="hljs-keyword">true</span><span class="hljs-number">2020</span>-<span class="hljs-number">01</span>-<span class="hljs-number">09</span> <span class="hljs-number">15</span>:<span class="hljs-number">02</span>:<span class="hljs-number">28.376</span> INFO  [main] mebatis.execute.SqlRunner (<span class="hljs-number">122</span>) baseMethod - SQL Execute successful, sql is:  <span class="hljs-function">insert into student <span class="hljs-title">values</span> <span class="hljs-params">(?, ?, ?)</span>, params is: [15, 15, 1996], result is: <span class="hljs-keyword">true</span></span><span class="hljs-function">2020-01-09 15:02:28.377 INFO  [main] mebatis.execute.<span class="hljs-title">SqlRunner</span> <span class="hljs-params">(<span class="hljs-number">105</span>)</span> select - SQL Execute successful, sql is:  select * from student where age </span>= ?, params is: [<span class="hljs-number">1</span>]StudentMeBatis(age=<span class="hljs-number">1</span>, name=<span class="hljs-number">1</span>, year=<span class="hljs-number">1</span>)</code></pre><blockquote><p>必要知识储备：</p><ol><li>基于Java的Mysql应用 -&gt; JDBC</li><li>JDK 动态代理技术</li><li>Java 自定义注解的使用</li><li>Java 正则表达式</li><li>Java 反射相关知识</li><li>FastJson</li></ol></blockquote><p>先来梳理结构，如果我们想做一个类似mybatis，基于注解实现的增删查改，需要有哪些步骤呢？</p><p>第一步：肯定需要增删查改四个注解</p><p>第二步：接口是没有方法体，无法执行的，我们怎么让它可以执行呢？动态代理技术，即第二步的核心就是让接口可以被代理</p><p>第三步：接口代理之后，可以拿到一个个方法的注解，拿到里面的value 和 方法参数，但是如何把参数和sql合起来呢，毕竟什么#{name} 什么的，sql是不认的，因此我们需要根据sql字符串（包含特殊字符），和方法的参数进行解析构建最终的执行语句</p><p>第四步：语句拿到了，参数拿到了，也可以执行了，怎么确定返回结果呢？这时候需要对方法的返回值做一个处理，拿到方法的返回结果，根据其返回值动态的构建到底是什么类型的返回结果，通过JDBC和FastJson去处理类型</p><p>第五步：万事俱备，只欠东风，构建最终的执行单元，去执行即可，到了这一步基本就是水到渠成（其实到第三步的时候所有思路就已经很清晰了）</p><h2 id="第一步：构建注解"><a href="#第一步：构建注解" class="headerlink" title="第一步：构建注解"></a>第一步：构建注解</h2><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-meta">@Target</span>(ElementType.METHOD)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Select &#123;    <span class="hljs-comment">// sql</span>    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span></span>;&#125;</code></pre><h2 id="第二步：代理接口"><a href="#第二步：代理接口" class="headerlink" title="第二步：代理接口"></a>第二步：代理接口</h2><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * ******************************</span><span class="hljs-comment"> * author：      柯贤铭</span><span class="hljs-comment"> * createTime:   2019/8/28 10:31</span><span class="hljs-comment"> * description:  MapperProxyUtil 核心代理类</span><span class="hljs-comment"> * version:      V1.0</span><span class="hljs-comment"> * ******************************</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapperProxyUtil</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 代理指定的接口</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> tClass 接口class</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt;    接口类型</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">newProxyInstance</span><span class="hljs-params">(Class&lt;T&gt; tClass)</span> </span>&#123;        <span class="hljs-keyword">return</span> (T) Proxy.newProxyInstance(tClass.getClassLoader(), <span class="hljs-keyword">new</span> Class[]&#123;tClass&#125;, <span class="hljs-keyword">new</span> MapperProxyUtil());    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        <span class="hljs-comment">// 获取CRUD方法对应的基本SQL及参数,返回结果           (初始化版本)</span>        MappedStatement detail = MappedStatement.parseAnotationMsg(method, args);        <span class="hljs-comment">// sql 解析,参数替换等 -&gt; SQL | PARAMS | RESULT_TYPE (可运行版本)</span>        SqlFactoryUtil.Runner sqlRunner = SqlFactoryUtil.executeRunner(detail);        <span class="hljs-comment">// 返回执行结果</span>        <span class="hljs-keyword">return</span> SqlRunner.execute(sqlRunner);    &#125;&#125;<span class="hljs-comment">// 调用</span>StudentInterface studentInterface = MapperProxyUtil.newProxyInstance(StudentInterface<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;</code></pre><h2 id="第三步：解析原始SQL及参数"><a href="#第三步：解析原始SQL及参数" class="headerlink" title="第三步：解析原始SQL及参数"></a>第三步：解析原始SQL及参数</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlFactoryUtil</span> </span>&#123;    <span class="hljs-comment">// 组装最终执行单元 -&gt; SQL | PARAMS | RESULT_TYPE</span>    <span class="hljs-comment">//******************************************************</span>    <span class="hljs-comment">// SQL         -&gt;  "SQL";</span>    <span class="hljs-comment">// PARAMS      -&gt;  "PARAMS";</span>    <span class="hljs-comment">// RESULT_TYPE -&gt;  "RESULT_TYPE";</span>    <span class="hljs-comment">//******************************************************</span>    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 生成执行单元</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Runner <span class="hljs-title">executeRunner</span> <span class="hljs-params">(MappedStatement mappedStatement)</span> <span class="hljs-keyword">throws</span> MapperExeception </span>&#123;        <span class="hljs-keyword">if</span> (mappedStatement == <span class="hljs-keyword">null</span> || StringUtils.isBlank(mappedStatement.getSql()) || mappedStatement.getMap() == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> MapperExeception.errorSql(<span class="hljs-string">" -&gt; "</span> + mappedStatement);        &#125;        <span class="hljs-comment">// 参数集合</span>        List&lt;Object&gt; params = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-comment">// 转换参数 - 获取值</span>        Pattern p = compile(<span class="hljs-string">"#\\&#123;.+?&#125;"</span>);        Matcher m = p.matcher(mappedStatement.getSql());        <span class="hljs-keyword">while</span>(m.find())&#123;            String key = m.group();            key = key.replaceAll(<span class="hljs-string">"#\\&#123;"</span>, <span class="hljs-string">""</span>);            key = key.replaceAll(<span class="hljs-string">"&#125;"</span>, <span class="hljs-string">""</span>);            <span class="hljs-keyword">if</span> (!mappedStatement.getMap().containsKey(key)) &#123;                <span class="hljs-keyword">throw</span> MapperExeception.errorParams(<span class="hljs-string">"do not have key -&gt; "</span> + key);            &#125;            <span class="hljs-comment">// 添加参数</span>            params.add(mappedStatement.getMap().get(key));        &#125;        <span class="hljs-comment">// 执行sql</span>        String finalSQL = m.replaceAll(<span class="hljs-string">"?"</span>);        <span class="hljs-comment">// 返回 runner</span>        Runner result = <span class="hljs-keyword">new</span> Runner();        result.setSql(finalSQL);        result.setParams(params);        result.setResultType(mappedStatement.getResultType());        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-meta">@Data</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Runner</span> </span>&#123;        <span class="hljs-comment">// 执行sql</span>        <span class="hljs-keyword">private</span> String       sql;        <span class="hljs-comment">// 参数</span>        <span class="hljs-keyword">private</span> List&lt;Object&gt; params;        <span class="hljs-comment">// 返回参数</span>        <span class="hljs-keyword">private</span> Type         resultType;    &#125;&#125;</code></pre><h2 id="第四步：执行JDBC"><a href="#第四步：执行JDBC" class="headerlink" title="第四步：执行JDBC"></a>第四步：执行JDBC</h2><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">execute</span><span class="hljs-params">(SqlFactoryUtil.Runner runner)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-comment">// 返回值类型</span>    Type resultType = runner.getResultType();    <span class="hljs-comment">// 返回值类型为 boolean</span>    <span class="hljs-keyword">if</span> (resultType.getTypeName().toLowerCase().equals(BOOLEAN)) &#123;        <span class="hljs-keyword">return</span> baseMethod(runner.getSql(), runner.getParams());    &#125;    <span class="hljs-comment">// 查询类型需要特殊处理</span>    ResultSet resultSet = select(runner.getSql(), runner.getParams());    <span class="hljs-comment">// 返回值</span>    Class type = getResultType(resultType);    <span class="hljs-comment">// 集合返回值</span>    List listHandle = listHandle(resultSet, type);    <span class="hljs-keyword">if</span> (resultType.getTypeName().contains(<span class="hljs-string">"java.util.List"</span>)) &#123;        <span class="hljs-keyword">return</span> listHandle;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> listHandle.get(<span class="hljs-number">0</span>);    &#125;&#125;</code></pre><h2 id="第五步：根据返回值类型构建最终结果"><a href="#第五步：根据返回值类型构建最终结果" class="headerlink" title="第五步：根据返回值类型构建最终结果"></a>第五步：根据返回值类型构建最终结果</h2><pre><code class="hljs java"><span class="hljs-comment">/***</span><span class="hljs-comment"> * List 类型handle</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> resultSet     resultSet</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> resultType    返回值类型</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span>              List</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> SQLException SQLException</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List <span class="hljs-title">listHandle</span> <span class="hljs-params">(ResultSet resultSet, Class resultType)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;    <span class="hljs-comment">// 返回结果</span>    List result = <span class="hljs-keyword">new</span> ArrayList();    ResultSetMetaData metaData = resultSet.getMetaData();    <span class="hljs-keyword">int</span> columnCount = metaData.getColumnCount();    String[] columnNames = <span class="hljs-keyword">new</span> String[columnCount];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; columnCount; i++) &#123;        columnNames[i] = metaData.getColumnName(i + <span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">while</span> (resultSet.next()) &#123;        JSONObject object = <span class="hljs-keyword">new</span> JSONObject();        <span class="hljs-keyword">for</span> (String columnName : columnNames) &#123;            Object columnValue = resultSet.getObject(columnName);            object.put(columnName, columnValue);        &#125;        result.add(object.toJavaObject(resultType));    &#125;    <span class="hljs-keyword">return</span> result;&#125;</code></pre><blockquote><p>总结：以上代码都是按照此思路截取的一部分，其实按照思路来，自己攻略到第二步，第三步，慢慢的就都摸清了，关键就是如何让接口被代理，剩下的都是水到渠成，遇到一个问题解决一个问题即可.</p><p>全部代码可见GitHub： <a href="https://github.com/kkzhilu/KerwinTools" target="_blank" rel="noopener">https://github.com/kkzhilu/KerwinTools</a><br>mebatis包下内容</p></blockquote><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ul><li>FastJson  Api ：public <T> T toJavaObject(Class<T> clazz)</T></T></li><li>Final 关键字：性能的略微提高，更重要的是可以表明参数的意义，设计内涵</li><li>JDK动态代理的两个好基友</li></ul><blockquote><p>InvocationHandler接口 ,  Proxy.newProxyInstance</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 代理指定的接口</span><span class="hljs-comment"> * param tClass 接口class</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;T&gt;    接口类型</span><span class="hljs-comment"> */</span><span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">newProxyInstance</span><span class="hljs-params">(Class&lt;T&gt; tClass)</span> </span>&#123;    <span class="hljs-keyword">return</span> (T) Proxy.newProxyInstance(tClass.getClassLoader(), <span class="hljs-keyword">new</span> Class[]&#123;tClass&#125;, InvocationHandler);&#125;</code></pre></blockquote>]]></content>
    
    
    <categories>
      
      <category>框架篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>手写简易MyBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写简易SpringMVC</title>
    <link href="/2023/09/12/%E6%89%8B%E5%86%99%E7%AE%80%E6%98%93SpringMVC/"/>
    <url>/2023/09/12/%E6%89%8B%E5%86%99%E7%AE%80%E6%98%93SpringMVC/</url>
    
    <content type="html"><![CDATA[<h1 id="手写简易SpringMVC"><a href="#手写简易SpringMVC" class="headerlink" title="手写简易SpringMVC"></a>手写简易SpringMVC</h1><blockquote><p>手写系列框架代码基于普通Maven构建，因此在手写SpringMVC的过程中，需要手动的集成Tomcat容器</p><p>必备知识：<br>Servlet相关理解和使用，Maven，Java 反射，Java自定义注解</p></blockquote><h2 id="配置Web类型结构"><a href="#配置Web类型结构" class="headerlink" title="配置Web类型结构"></a>配置Web类型结构</h2><pre><code class="hljs 结构如图所示：```">![1567700174356](手写简易SpringMVC&#x2F;1567700174356.png)注意 要设置 webapp为web moudle -&gt; IDEA 有蓝色小圈圈为准，resource 配置为资源文件## 配置Web.xml，配置Artifacts，配置文件![1567700286694](手写简易SpringMVC&#x2F;1567700286694.png)![1567700301717](手写简易SpringMVC&#x2F;1567700301717.png)&#96;&#96;&#96;xml&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;         xmlns&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&quot; xmlns:web&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_2_5.xsd&quot;         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_3_0.xsd&quot;         version&#x3D;&quot;3.0&quot;&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;KerwinCodes&lt;&#x2F;servlet-name&gt;        &lt;servlet-class&gt;com.mycode.servlet.MyDispatcherServlet&lt;&#x2F;servlet-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;            &lt;param-value&gt;application.properties&lt;&#x2F;param-value&gt;        &lt;&#x2F;init-param&gt;        &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;    &lt;&#x2F;servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;KerwinCodes&lt;&#x2F;servlet-name&gt;        &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;    &lt;&#x2F;servlet-mapping&gt;&lt;&#x2F;web-app&gt;</code></pre><pre><code class="hljs properties"><span class="hljs-meta">//</span> <span class="hljs-string">配置包扫描的路径</span><span class="hljs-attr">scanPackage</span>=<span class="hljs-string">com.mycode</span></code></pre><h2 id="编码阶段"><a href="#编码阶段" class="headerlink" title="编码阶段"></a>编码阶段</h2><ol><li>第一步毋庸置疑，我们需要创建必要的注解，如MyController,MyRequestMapping等等</li></ol><pre><code class="hljs java"><span class="hljs-meta">@Target</span>(ElementType.TYPE)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-meta">@Documented</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyController &#123;    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;&#125;<span class="hljs-meta">@Target</span>(&#123;ElementType.TYPE,ElementType.METHOD&#125;)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-meta">@Documented</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyRequestMapping &#123;    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;&#125;<span class="hljs-meta">@Target</span>(ElementType.PARAMETER)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-meta">@Documented</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyRequestParam &#123;    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span></span>;&#125;</code></pre><ol start="2"><li>需要思考我们如何才能实现SpringMVC</li></ol><pre><code class="hljs java">A.参考真正的SpringMVC， 它是基于Spring的基础上，因此我们需要自行实现IOC容器B.想要实现IOC容易，管理Bean，我们就需要根据包扫描的路径进行全项目扫描C.全项目扫描后，利用反射，同时根据注解判断是否是Bean，然后注入到Map容器中即可D.遍历容器，获取存储的Bean中的方法，配合RequestMapping注解，得到 url - method映射，同时得到 url - object映射，存储到新的Map集合总，便于后续反射调用E.页面请求时候，判断request.url 映射的到底是哪一个bean，哪一个方法 同时获取方法的参数，解析request的参数，即可匹配路径调用方法F.万事俱备，到底如何运行？Servlet -&gt; init方法，doGet方法，doPost方法  实质就是Servlet生命周期中初始化和真正执行策略的方法，我们只需要重写方法，然后让doGet，doPost 都调用我们的方法即可</code></pre><ol start="3"><li>核心代码如下：</li></ol><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mycode.servlet;<span class="hljs-keyword">import</span> com.mycode.annotation.MyController;<span class="hljs-keyword">import</span> com.mycode.annotation.MyRequestMapping;<span class="hljs-keyword">import</span> javax.servlet.ServletConfig;<span class="hljs-keyword">import</span> javax.servlet.ServletException;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServlet;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<span class="hljs-keyword">import</span> java.io.*;<span class="hljs-keyword">import</span> java.lang.reflect.Member;<span class="hljs-keyword">import</span> java.lang.reflect.Method;<span class="hljs-keyword">import</span> java.net.URL;<span class="hljs-keyword">import</span> java.util.*;<span class="hljs-comment">/**</span><span class="hljs-comment"> * ******************************</span><span class="hljs-comment"> * author：      柯贤铭</span><span class="hljs-comment"> * createTime:   2019/9/5 11:53</span><span class="hljs-comment"> * description:  MyDispatcherServlet</span><span class="hljs-comment"> * version:      V1.0</span><span class="hljs-comment"> * ******************************</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyDispatcherServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span></span>&#123;    <span class="hljs-comment">/** 配置信息 **/</span>    <span class="hljs-keyword">private</span> Properties properties = <span class="hljs-keyword">new</span> Properties();    <span class="hljs-comment">/** 所有类的Class地址 **/</span>    <span class="hljs-keyword">private</span> List&lt;String&gt; classNames = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-comment">/** Bean容器 **/</span>    <span class="hljs-keyword">private</span> Map&lt;String, Object&gt; iocFactory = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-comment">/** HandlerMapping - 方法**/</span>    <span class="hljs-keyword">private</span> Map&lt;String, Method&gt; handleMapping = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-comment">/** HandlerMapping - 对象**/</span>    <span class="hljs-keyword">private</span> Map&lt;String, Object&gt; controllers = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ServletConfig config)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;        <span class="hljs-comment">// 1.加载配置文件</span>        doLoadConfig(config.getInitParameter(<span class="hljs-string">"contextConfigLocation"</span>));        <span class="hljs-comment">// 2.初始化所有相关联的类,扫描用户设定的包下面所有的类</span>        doScanner(properties.getProperty(<span class="hljs-string">"scanPackage"</span>));        <span class="hljs-comment">// 3.拿到扫描到的类,通过反射机制,实例化,并且放到ioc容器中(k-v  beanName-bean)</span>        doInstance();        <span class="hljs-comment">// 4.初始化HandlerMapping(将url和method对应上)</span>        initHandlerMapping();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        <span class="hljs-keyword">this</span>.doPost(req,resp);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        <span class="hljs-keyword">try</span> &#123;            doDispatch(req, resp);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-comment">// 加载配置文件索取包扫描路径</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doLoadConfig</span> <span class="hljs-params">(String fileUrl)</span>  </span>&#123;        <span class="hljs-keyword">try</span> &#123;            properties.load(<span class="hljs-keyword">this</span>.getClass().getClassLoader().getResourceAsStream(fileUrl));        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-comment">// 扫描目录下所有的类</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doScanner</span> <span class="hljs-params">(String rootPath)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;        URL url = <span class="hljs-keyword">this</span>.getClass().getClassLoader().getResource( <span class="hljs-string">"/"</span> + rootPath.replaceAll(<span class="hljs-string">"\\."</span>, <span class="hljs-string">"/"</span>));        File file = <span class="hljs-keyword">new</span> File(Objects.requireNonNull(url).getFile());        <span class="hljs-keyword">if</span> (!file.isDirectory()) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ServletException(<span class="hljs-string">"Base Package is wrong."</span>);        &#125;        <span class="hljs-keyword">for</span> (File current : Objects.requireNonNull(file.listFiles())) &#123;            <span class="hljs-keyword">if</span> (current.isDirectory()) &#123;                doScanner(rootPath + <span class="hljs-string">"."</span> + current.getName());            &#125; <span class="hljs-keyword">else</span> &#123;                String className = rootPath + <span class="hljs-string">"."</span> + current.getName().replace(<span class="hljs-string">".class"</span>, <span class="hljs-string">""</span>);                classNames.add(className);            &#125;        &#125;    &#125;    <span class="hljs-comment">// 拿到所有的classNames 通过反射创建其对象 - 放入ioc容器中</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doInstance</span> <span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (classNames.isEmpty()) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">for</span> (String className : classNames) &#123;                Class&lt;?&gt; clazz = Class.forName(className);                <span class="hljs-keyword">if</span> (clazz.isAnnotationPresent(MyController<span class="hljs-class">.<span class="hljs-keyword">class</span>)) </span>&#123;                    iocFactory.put(clazz.getSimpleName(), clazz.newInstance());                &#125;            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-comment">// 初始化HandlerMapping(将url和method对应上)</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initHandlerMapping</span> <span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (iocFactory.isEmpty()) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (String key : iocFactory.keySet()) &#123;            Class&lt;? extends Object&gt; clazz = iocFactory.get(key).getClass();            <span class="hljs-keyword">if</span> (!clazz.isAnnotationPresent(MyController<span class="hljs-class">.<span class="hljs-keyword">class</span>)) </span>&#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">// 类 url</span>            MyRequestMapping annotation = clazz.getAnnotation(MyRequestMapping<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            String baseUrl = annotation.value();            Method[] methods = clazz.getMethods();            <span class="hljs-keyword">for</span> (Method method : methods) &#123;                <span class="hljs-keyword">if</span> (method.isAnnotationPresent(MyRequestMapping<span class="hljs-class">.<span class="hljs-keyword">class</span>)) </span>&#123;                    String mappingUrl = method.getAnnotation(MyRequestMapping<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">value</span>()</span>;                    <span class="hljs-comment">// 获取匹配方法及对象 方便之后通过反射调用</span>                    handleMapping.put(baseUrl + mappingUrl, method);                    controllers.put(baseUrl + mappingUrl, iocFactory.get(key));                &#125;            &#125;        &#125;    &#125;    <span class="hljs-comment">// 中央处理器</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doDispatch</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">if</span> (iocFactory.isEmpty() || handleMapping.isEmpty() || controllers.isEmpty()) &#123;            <span class="hljs-keyword">return</span>;        &#125;        String url = request.getRequestURI();        <span class="hljs-comment">// 如果不存在url</span>        <span class="hljs-keyword">if</span> (!handleMapping.containsKey(url)) &#123;            response.getWriter().write(<span class="hljs-string">"Do Not Get Url : 404 ERROR"</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// HandleMapping 的方法</span>        Method method = handleMapping.get(url);        <span class="hljs-comment">// 获取方法的参数列表</span>        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();        <span class="hljs-comment">//获取请求的参数</span>        Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();        <span class="hljs-comment">//保存参数值</span>        Object [] paramValues= <span class="hljs-keyword">new</span> Object[parameterTypes.length];        <span class="hljs-comment">// 方法的参数列表</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt; parameterTypes.length; i++)&#123;            <span class="hljs-comment">//根据参数名称，做某些处理</span>            String requestParam = parameterTypes[i].getSimpleName();            <span class="hljs-keyword">if</span> (requestParam.equals(<span class="hljs-string">"HttpServletRequest"</span>))&#123;                <span class="hljs-comment">//参数类型已明确，这边强转类型</span>                paramValues[i] = request;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">if</span> (requestParam.equals(<span class="hljs-string">"HttpServletResponse"</span>))&#123;                paramValues[i] = response;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">if</span>(requestParam.equals(<span class="hljs-string">"String"</span>))&#123;                <span class="hljs-keyword">for</span> (Map.Entry&lt;String, String[]&gt; param : parameterMap.entrySet()) &#123;                    String value = Arrays.toString(param.getValue()).replaceAll(<span class="hljs-string">"\\[|\\]"</span>, <span class="hljs-string">""</span>).replaceAll(<span class="hljs-string">",\\s"</span>, <span class="hljs-string">","</span>);                    paramValues[i] = value;                &#125;            &#125;        &#125;        method.invoke(controllers.get(url), paramValues);    &#125;&#125;</code></pre><ol start="4"><li>测试代码：</li></ol><pre><code class="hljs java"><span class="hljs-meta">@MyController</span><span class="hljs-meta">@MyRequestMapping</span>(<span class="hljs-string">"/test"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>&#123;    <span class="hljs-meta">@MyRequestMapping</span>(<span class="hljs-string">"/doTest"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span> <span class="hljs-params">( HttpServletRequest request, HttpServletResponse response,</span></span><span class="hljs-function"><span class="hljs-params">                        @MyRequestParam(<span class="hljs-string">"param"</span>)</span> String param)</span>&#123;        System.out.println(param);        <span class="hljs-keyword">try</span> &#123;            response.getWriter().write( <span class="hljs-string">"doTest method success! param:"</span>+param);        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-meta">@MyRequestMapping</span>(<span class="hljs-string">"/doTest2"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span>&#123;        <span class="hljs-keyword">try</span> &#123;            response.getWriter().println(<span class="hljs-string">"doTest2 method success!"</span>);        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>测试结果：</p><p><a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a>                                                   -&gt; Do Not Get Url : 404 ERROR</p><p><a href="http://localhost:8080/test/doTest2" target="_blank" rel="noopener">http://localhost:8080/test/doTest2</a>                              -&gt; doTest2 method success!</p><p><a href="http://localhost:8080/test/doTest?param=asdasdad" target="_blank" rel="noopener">http://localhost:8080/test/doTest?param=asdasdad</a> -&gt; doTest method success! param:asdasdad</p><blockquote><p>源码地址：<a href="https://github.com/kkzhilu/KerwinCodes" target="_blank" rel="noopener">https://github.com/kkzhilu/KerwinCodes</a>  code_springmvc分支</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>框架篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>手写简易SpringMVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板方法模式</title>
    <link href="/2023/09/12/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/09/12/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="模板方法模式篇"><a href="#模板方法模式篇" class="headerlink" title="模板方法模式篇"></a>模板方法模式篇</h1><h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>定义一个操作中的算法的骨架，将一些步骤延迟到子类中。 Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤</p><h2 id="模板方法模式的诞生"><a href="#模板方法模式的诞生" class="headerlink" title="模板方法模式的诞生"></a>模板方法模式的诞生</h2><p>模板方法模式为我们提供了一种代码复用的重要技巧，它定义了算法的步骤，把这些步骤的实现延迟到子类</p><p>说人话就是：</p><p>【<font color="orange">产品</font>】：开发小哥，你会做饭吗？</p><p>【<font color="blue">开发</font>】：不会啊，怎么了？难道你要做给我吃？</p><p>【<font color="orange">产品</font>】：你想太多了，我就准备教你做一道炒包菜~，用你们写代码思路，我也来试试写写伪代码</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cookie</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// 第一步：倒油</span>    <span class="hljs-keyword">this</span>.pourOil();    <span class="hljs-comment">// 第二步：热油</span>    <span class="hljs-keyword">this</span>.HeatOil();    <span class="hljs-comment">// 第三步：倒入包菜</span>    <span class="hljs-keyword">this</span>.pourVegetable();    <span class="hljs-comment">// 第四步：倒入调味料</span>    <span class="hljs-keyword">this</span>.pourSauce();    <span class="hljs-comment">// 第五步：翻炒</span>    <span class="hljs-keyword">this</span>.fry();&#125;</code></pre><p>【<font color="blue">开发</font>】：我懂了，小姐姐，你要不来我家？我给你做一道炒蒜蓉~</p><p>【<font color="orange">产品</font>】：？？？你不是说你不会做饭吗？</p><p><img src="/2023/09/12/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/image-20200608234717306.png" srcset="/img/loading.gif" alt="image-20200608234717306"></p><p>【<font color="blue">开发</font>】：你不是写出来步骤了嘛，我已经会了，嘿嘿嘿~</p><blockquote><p>你要是还没会，那咱们就一起看看核心代码吧~<br>你如果会了，那直接跳到SSO实战吧~</p></blockquote><h2 id="HeadFirst-核心代码"><a href="#HeadFirst-核心代码" class="headerlink" title="HeadFirst 核心代码"></a>HeadFirst 核心代码</h2><p><strong><em>抽象类</em></strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TemplateClass</span> </span>&#123;<span class="hljs-comment">/***</span><span class="hljs-comment"> * 模板方法，用来控制炒菜的流程 （炒菜的流程是一样的-复用）</span><span class="hljs-comment"> * 可根据需求申明为final，防止子类覆盖这个方法，导致流程的执行顺序</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cookProcess</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// 第一步：倒油</span><span class="hljs-keyword">this</span>.pourOil();<span class="hljs-comment">// 第二步：热油</span><span class="hljs-keyword">this</span>.heatOil();<span class="hljs-comment">// 第三步：倒蔬菜</span><span class="hljs-keyword">this</span>.pourVegetable();<span class="hljs-comment">// 配合钩子函数, 确定是否需要倒调味料</span><span class="hljs-keyword">if</span> (needSauce()) &#123;<span class="hljs-keyword">this</span>.pourSauce();&#125;<span class="hljs-comment">// 第五步：翻炒</span><span class="hljs-keyword">this</span>.fry();&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pourOil</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"倒油"</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heatOil</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"热油"</span>);&#125;<span class="hljs-comment">/***</span><span class="hljs-comment"> * 需要变化的部分就定义为抽象</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pourVegetable</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pourSauce</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">/***</span><span class="hljs-comment"> * 钩子函数, 影响方法调用逻辑</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">needSauce</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fry</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"炒啊炒啊炒到熟啊"</span>);&#125;&#125;</code></pre><p><strong><em>子类实现</em></strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuanRong</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TemplateClass</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">needSauce</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pourVegetable</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"下锅的蔬菜是菜心"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pourSauce</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"下锅的酱料是蒜蓉"</span>);&#125;&#125;</code></pre><p><font color="red">模板方法模式的设计思路：</font></p><ul><li>AbstractClass（抽象类）抽象基类，定义抽象方法，方法调用顺序等等</li><li>ConcreteClass（实现类）继承抽象基类，实现预先定义的方法</li></ul><p>简单来说，</p><ol><li>我们需要一个抽象类或者接口（Java8之后接口也可以提供具体的方法），定义需要实现的方法和方法执行逻辑</li><li>根据业务情况继承抽象类或接口，实现特定方法，使多种情况互相隔离</li><li>配合如策略或其他的方式合理的构建需要的实现类即可</li></ol><blockquote><p>如果看着有点模棱两可，建议看完本文后，访问专题设计模式开源项目，里面有具体的代码示例，链接在最下面</p></blockquote><h2 id="模板的力量：5分钟一个SSO"><a href="#模板的力量：5分钟一个SSO" class="headerlink" title="模板的力量：5分钟一个SSO"></a>模板的力量：5分钟一个SSO</h2><p>要说到用模板方法模式去使用SSO时，咱们先需要知道<font color="blue">什么是SSO</font>（知道的同学直接略过啦~）</p><h3 id="SSO"><a href="#SSO" class="headerlink" title="SSO"></a>SSO</h3><p>SSO即<font color="blue">单点登录</font>，即<strong>在多个系统中，用户只需一次登录，各个系统即可感知该用户已经登录</strong></p><h3 id="用户鉴权的几种常见方式"><a href="#用户鉴权的几种常见方式" class="headerlink" title="用户鉴权的几种常见方式"></a>用户鉴权的几种常见方式</h3><p>本文主要还是侧重设计模式的实战，所以就简单说几句，常见方式如：</p><ul><li>oauth 2.0</li><li>cookie</li><li>………..</li></ul><h3 id="第一个SSO"><a href="#第一个SSO" class="headerlink" title="第一个SSO"></a>第一个SSO</h3><p>我们在编写第一个SSO的时候，还是有那么一点费劲的，需要考虑各种流程，细节等等</p><p><font color="blue">（这里指的是我们集成其他公司的鉴权系统）</font></p><p>我所在的公司客户技术水平五花八门，技术栈也是五花八门，所以不是标准的oauth2.0结构，大致抽象出以下核心环节，如：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SSOContextAnalysis</span> </span>&#123;    <span class="hljs-comment">/** 跳转登录*/</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">toLogin</span><span class="hljs-params">(SSOConfig ssoConfig, HttpServletResponse httpServletResponse)</span></span>;    <span class="hljs-comment">/** 获取token */</span>    <span class="hljs-function">Object <span class="hljs-title">getToken</span><span class="hljs-params">(SSOConfig ssoConfig, HttpServletRequest httpServletRequest)</span></span>;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 获取用户信息</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ssoConfig 配置</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 用户信息加密串</span><span class="hljs-comment">     */</span>    <span class="hljs-function">String <span class="hljs-title">getUserInfo</span><span class="hljs-params">(SSOConfig ssoConfig, Object arg)</span></span>;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 解析sso context</span><span class="hljs-comment">     */</span>    <span class="hljs-function">String <span class="hljs-title">getAccount</span><span class="hljs-params">(SSOConfig ssoConfig, Object userInfo)</span></span>;    <span class="hljs-comment">/** 进行退出 */</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">tologout</span><span class="hljs-params">(SSOConfig ssoConfig, UserOnline userOnline, HttpServletResponse httpServletResponse)</span></span>;&#125;</code></pre><p><strong><em>龙图SSO Demo</em></strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LongTuSSOHandle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SSOContextAnalysis</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">toLogin</span><span class="hljs-params">(SSOConfig ssoConfig)</span> </span>&#123;        <span class="hljs-comment">// 跳转SSO鉴权地址, 配置回调地址</span>    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getToken</span><span class="hljs-params">(SSOConfig ssoConfig)</span> </span>&#123;        <span class="hljs-comment">// 根据客户的加密算法等获取Token信息</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUserInfo</span><span class="hljs-params">(SSOConfig ssoConfig, Object arg)</span> </span>&#123;        <span class="hljs-comment">// 组装报文, 发起用户请求, 获取用户数据</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAccount</span><span class="hljs-params">(SSOConfig ssoConfig, Object userInfo)</span> </span>&#123;        <span class="hljs-comment">// 基于用户数据, 获取本平台用户数据, 完成SSO流程</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tologout</span><span class="hljs-params">(SSOConfig ssoConfig)</span> </span>&#123;        <span class="hljs-comment">// 根据退出地址进行退出操作等等</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre><p><font color="red">我们在编写业务代码的时候，完全依赖于顶层抽象类，彼时再动态的更改具体的实现类即可</font></p><h3 id="如何动态指定实现类"><a href="#如何动态指定实现类" class="headerlink" title="如何动态指定实现类"></a>如何动态指定实现类</h3><p>动态指定实现类的最好方式无非这么几种，大家可以根据需求选择：</p><ul><li>配置文件 + 反射构建实现类</li><li>配置文件 + 预先加载所有实现类，根据配置动态选择</li><li>数据库配置 + 反射（可以使用CGLIB代理）</li><li>数据库配置 + 预先加载所有实现类，根据配置动态选择</li></ul><h3 id="第二个SSO要多久？"><a href="#第二个SSO要多久？" class="headerlink" title="第二个SSO要多久？"></a>第二个SSO要多久？</h3><p>当我们使用模板方法模式，对整个SSO的流程已经梳理完成之后，第二个SSO只需要实现相应接口，然后根据客户的要求构建不同的加密协议，同时改一下配置即可，反正我只花了5分钟~</p><p><img src="/2023/09/12/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/image-20200609003245682.png" srcset="/img/loading.gif" alt="image-20200609003245682"></p><h2 id="遵循的设计原则"><a href="#遵循的设计原则" class="headerlink" title="遵循的设计原则"></a>遵循的设计原则</h2><ol><li><strong>封装变化</strong><ul><li>在抽象基类中，我们可以有已经实现的方法供子类调用</li><li>在抽象基类中，对于必然不同的方法逻辑，定义为抽象的，供子类自行实现</li></ul></li><li><strong>好莱坞原则</strong><ul><li>别找我，我会找你   指的是底层代码（具体的实现类）不依赖于高层代码，我们在本次的SSO实战中也体现了，直接依赖接口，实现类只是作为真正的执行者而已</li></ul></li></ol><h2 id="什么场景适合使用"><a href="#什么场景适合使用" class="headerlink" title="什么场景适合使用"></a>什么场景适合使用</h2><ul><li>一次性实现一个算法不变的部分，并将可变的行为留给子类来实现</li><li>各子类中公共的行为应该被提取出来并集中到一个公共父类中以避免代码重复</li><li>控制子类扩展（文中提到的钩子方法，控制方法的执行与否）</li></ul><h2 id="Code-生活中的实际应用"><a href="#Code-生活中的实际应用" class="headerlink" title="Code/生活中的实际应用"></a>Code/生活中的实际应用</h2><p>比如我们使用的所有APP，在进行支付的时候大多都可以选择支付宝或者微信支付，其实整个支付步骤中，只有具体支付的步骤是分为多种情况（微信，支付宝，银行卡等）剩下的订单推送，数据扭转等很有可能是一样的，此时我们就可以使用模板方法模式来约束行为，同时减少重复代码</p><p><font color="blue">PS：此种情况也可能使用策略模式处理，需要视情况而定</font></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p><strong>附上GOF一书中对于模板方法模式的UML图：</strong></p><p><img src="/2023/09/12/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/image-20200609004140373.png" srcset="/img/loading.gif" alt="image-20200609004140373"></p><h2 id="相关代码链接"><a href="#相关代码链接" class="headerlink" title="相关代码链接"></a>相关代码链接</h2><p><a href="https://github.com/kkzhilu/Kerwin-DesignPattern" target="_blank" rel="noopener">GitHub地址</a></p><ul><li>兼顾了《HeadFirst》以及《GOF》两本经典书籍中的案例</li><li>提供了友好的阅读指导</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/5/18/172284a1c8caf324?w=487&h=185&f=png&s=17561" srcset="/img/loading.gif" alt></p>]]></content>
    
    
    <categories>
      
      <category>编码及设计模式篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模板方法模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>状态模式</title>
    <link href="/2023/09/12/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/09/12/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="状态模式篇"><a href="#状态模式篇" class="headerlink" title="状态模式篇"></a>状态模式篇</h1><h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>允许一个对象在其内部状态改变时改变它的行为</p><p>说人话：<font color="red">允许对象在改变自身状态时候，更改绑定的特定方法</font></p><h2 id="状态模式的诞生"><a href="#状态模式的诞生" class="headerlink" title="状态模式的诞生"></a>状态模式的诞生</h2><p>【<font color="orange">产品</font>】：Hello，开发小哥，我们需要开发一款 <code>娃娃机</code> ，你可以提前想想怎么设计它啦。</p><p>【<font color="blue">开发</font>】：娃娃机？我想想奥，它需要投币，用户移动，确认抓取，结束这几个动作，好像很好做欸，用一个变量维护它当前的阶段，然后写四个 if 语句就好啦。</p><p>【<font color="red">BOSS</font>】：你准备用一个主方法，四个子方法配合 if 语句外加一个状态变量去做吗？</p><pre><code class="hljs java"><span class="hljs-comment">// 伪代码</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (flag == A) &#123;        a();    &#125;    <span class="hljs-keyword">if</span> (flag == B) &#123;        b();    &#125;&#125;</code></pre><p>【<font color="blue">开发</font>】：对啊，老大，你真是我肚子里的蛔虫！</p><p>【<font color="red">BOSS</font>】：蛔你个头，这样做<font color="red">  大错特错！ </font>，你难道想对 <font color="red">投币口，按钮，摇杆都绑定同一个方法吗？</font></p><p>【<font color="blue">开发</font>】：对哦，它们应该是<font color="red"> 不同的方法，同时暴露给用户，我再思考思考 </font></p><p><img src="/2023/09/12/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/image-20200617004054501.png" srcset="/img/loading.gif" alt="image-20200617004054501"></p><h2 id="HeadFirst-核心代码"><a href="#HeadFirst-核心代码" class="headerlink" title="HeadFirst 核心代码"></a>HeadFirst 核心代码</h2><p><strong><em>定义状态接口，同时封装变化，利用default关键字封装默认方法</em></strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">State</span> </span>&#123;    <span class="hljs-comment">/** 投币 **/</span>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">giveMoney</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"无法投币"</span>);    &#125;    <span class="hljs-comment">/** 移动滑杆 **/</span>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">move</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"无法移动滑杆"</span>);    &#125;    <span class="hljs-comment">/** 抓取 **/</span>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">grab</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"无法抓取"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">changeState</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p><strong><em>投币状态  状态的其中之一</em></strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MoneyState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">State</span></span>&#123;    Context context;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MoneyState</span><span class="hljs-params">(Context context)</span> </span>&#123;        <span class="hljs-keyword">this</span>.context = context;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">giveMoney</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"已投币!"</span>);        changeState();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeState</span><span class="hljs-params">()</span> </span>&#123;        context.setExecute(<span class="hljs-keyword">new</span> MoveState(context));    &#125;&#125;</code></pre><p>为了尽量减少代码，只展示了其中一种状态，我们可以看到在 <font color="blue">MoneyState</font> 状态类执行所属的业务方法时，更改了上下文持有的状态类，这就产生了  <font color="red">状态的变更</font> ，同时上下文更加清晰，即：<font color="red">我只用考虑我下一个状态是什么</font></p><p><font color="red">状态模式的设计思路：</font></p><ul><li>Context  上下文环境，持有状态</li><li>State   状态顶层接口</li><li>ConcreteState   具体的状态</li></ul><p>简单来说，</p><ol><li>必须清晰的认识到共有多少种不同的状态，并通过接口定义其核心方法，封装变化</li><li>状态类持有 <font color="blue">Context</font> 上下文，在核心方法处理后更改其状态</li></ol><blockquote><p>如果看着有点模棱两可，建议看完本文后，访问专题设计模式开源项目，里面有具体的代码示例，链接在最下面</p></blockquote><h2 id="状态模式的关键"><a href="#状态模式的关键" class="headerlink" title="状态模式的关键"></a>状态模式的关键</h2><ul><li>明确所有可能发生的状态，及其转换关系</li><li>明确状态模式中的各个状态是有可能同时暴露给用户的</li></ul><blockquote><p>就好像娃娃机运作的多种状态，<font color="red">  投币，移动摇杆，按下确认按钮等等可能不按先后顺序触发</font></p></blockquote><h2 id="整一个-“流程”-模式"><a href="#整一个-“流程”-模式" class="headerlink" title="整一个 “流程” 模式"></a>整一个 “流程” 模式</h2><h3 id="每个状态的方法名都一样会如何？"><a href="#每个状态的方法名都一样会如何？" class="headerlink" title="每个状态的方法名都一样会如何？"></a>每个状态的方法名都一样会如何？</h3><p>上文中我们大概知道了状态模式的特点，把状态封装成类，在调用状态-核心方法时候更改其状态本身，<font color="red">此时考虑的多种状态方法名可能各不相同，假设我们都起一样的名字会如何？</font></p><p>我们会首先遇到一个问题，我们无法得知它需要调用几次方法（因为可能有重复性 A - B 的情况），但如果无限循环，在适当的地方控制其结束点，和是否继续执行的标识，好像就可以解决了。</p><h3 id="来一个流程案例"><a href="#来一个流程案例" class="headerlink" title="来一个流程案例"></a>来一个流程案例</h3><p><img src="/2023/09/12/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/image-20200617001746490.png" srcset="/img/loading.gif" alt="image-20200617001746490"></p><p>简单描述下即：开始处理订单</p><ul><li>正常则进入成功状态，入库，结束执行</li><li>失败则进入失败状态，检测是否重新执行，扭转状态为处理订单</li></ul><h3 id="上代码"><a href="#上代码" class="headerlink" title="上代码"></a>上代码</h3><p><strong><em>Context 上下文</em></strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 最大执行次数</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer FAIL_NUM = <span class="hljs-number">3</span>;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 失败次数</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> failNum;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 是否继续执行的标识</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isAbandon;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 当前状态</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> StateInterface stateInterface;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Context</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.stateInterface = <span class="hljs-keyword">new</span> HandleOrder();        <span class="hljs-keyword">this</span>.failNum = <span class="hljs-number">1</span>;        <span class="hljs-keyword">this</span>.isAbandon = <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 处理方法</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span> <span class="hljs-params">()</span> </span>&#123;        stateInterface.doAction(<span class="hljs-keyword">this</span>);    &#125;        <span class="hljs-comment">// 省略无用代码...</span>&#125;</code></pre><p><strong><em>处理订单状态</em></strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HandleOrder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">StateInterface</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAction</span><span class="hljs-params">(Context context)</span> </span>&#123;        printCurrentState();        <span class="hljs-comment">// do somethings</span>        <span class="hljs-keyword">int</span> num = (<span class="hljs-keyword">int</span>) (Math.random() * <span class="hljs-number">11</span>);        <span class="hljs-keyword">if</span> (num &gt;= <span class="hljs-number">8</span>) &#123;            System.out.println(<span class="hljs-string">"处理订单完成, 进入成功状态..."</span>);            context.setStateInterface(<span class="hljs-keyword">new</span> SuccessOrder());        &#125; <span class="hljs-keyword">else</span> &#123;            System.out.println(<span class="hljs-string">"处理订单失败, 进入失败状态..."</span>);            context.setStateInterface(<span class="hljs-keyword">new</span> FailOrder());        &#125;        CodeUtils.spilt();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> StateEnums <span class="hljs-title">getCurrentState</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> StateEnums.HANDLE_ORDER;    &#125;&#125;</code></pre><p><strong><em>客户端调用方法</em></strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 模拟从队列中取任务按流程循环执行</span>        Context context = <span class="hljs-keyword">new</span> Context();        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-comment">// 校验是否为废弃 | 已完成任务</span>            <span class="hljs-keyword">if</span> (context.isAbandon()) &#123;                System.out.println(<span class="hljs-string">"此条任务不再执行... "</span>);                <span class="hljs-keyword">break</span>;            &#125;                        context.handle();        &#125;    &#125;&#125;</code></pre><p>测试结果输出：</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 当前状态：订单处理</span><span class="hljs-meta">#</span><span class="bash"> 处理订单失败, 进入失败状态...</span><span class="hljs-meta">#</span><span class="bash"> </span><span class="hljs-meta">#</span><span class="bash"> 当前状态：处理订单失败</span><span class="hljs-meta">#</span><span class="bash"> 订单处理失败... 当前执行次数: 1</span><span class="hljs-meta">#</span><span class="bash"> </span><span class="hljs-meta">#</span><span class="bash"> 当前状态：订单处理</span><span class="hljs-meta">#</span><span class="bash"> 处理订单失败, 进入失败状态...</span><span class="hljs-meta">#</span><span class="bash"> </span><span class="hljs-meta">#</span><span class="bash"> 当前状态：处理订单失败</span><span class="hljs-meta">#</span><span class="bash"> 订单处理失败... 当前执行次数: 2</span><span class="hljs-meta">#</span><span class="bash"> </span><span class="hljs-meta">#</span><span class="bash"> 当前状态：订单处理</span><span class="hljs-meta">#</span><span class="bash"> 处理订单完成, 进入成功状态...</span><span class="hljs-meta">#</span><span class="bash"> </span><span class="hljs-meta">#</span><span class="bash"> 当前状态：处理订单成功</span><span class="hljs-meta">#</span><span class="bash"> 订单处理完成 -&gt; 进入入库逻辑...</span><span class="hljs-meta">#</span><span class="bash"> 入库处理完成</span><span class="hljs-meta">#</span><span class="bash"> </span><span class="hljs-meta">#</span><span class="bash"> 此条任务不再执行...</span></code></pre><blockquote><p>如果看着有点模棱两可，建议看完本文后，访问专题设计模式开源项目，里面有具体的代码示例，链接在最下面</p></blockquote><h3 id="“流程”-模式适用的场景"><a href="#“流程”-模式适用的场景" class="headerlink" title="“流程” 模式适用的场景"></a>“流程” 模式适用的场景</h3><p>在这样的设计中，与其说是状态的变更，不如说是 “流程” 的变更更为贴切，因此它可以作为诸多后台任务的解决方案，尤其是面临很多业务流程场景时，可以极大的提高代码的可维护性： <font color="red">我只用考虑和我有关的 “流程”</font></p><h2 id="遵循的设计原则"><a href="#遵循的设计原则" class="headerlink" title="遵循的设计原则"></a>遵循的设计原则</h2><ul><li>封装变化：在父级接口中提供 default 方法，子类实现其对应的状态方法即可</li><li>多用组合，少用继承：状态模式经常和策略模式做对比，它们都是利用组合而非继承增强其变化和能力</li></ul><h2 id="什么场景适合使用状态模式"><a href="#什么场景适合使用状态模式" class="headerlink" title="什么场景适合使用状态模式"></a>什么场景适合使用状态模式</h2><ul><li>一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变其行为</li><li>一个操作中含有庞大的多分支条件语句，且这些分支依赖于该对象的状态</li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p><strong>附上GOF一书中对于状态模式的UML图：</strong></p><p><img src="/2023/09/12/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/image-20200617003230665.png" srcset="/img/loading.gif" alt="image-20200617003230665"></p><h2 id="相关代码链接"><a href="#相关代码链接" class="headerlink" title="相关代码链接"></a>相关代码链接</h2><p><a href="https://github.com/kkzhilu/Kerwin-DesignPattern" target="_blank" rel="noopener">GitHub地址</a></p><ul><li>兼顾了《HeadFirst》以及《GOF》两本经典书籍中的案例</li><li>提供了友好的阅读指导</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/5/18/172284a1c8caf324?w=487&h=185&f=png&s=17561" srcset="/img/loading.gif" alt></p>]]></content>
    
    
    <categories>
      
      <category>编码及设计模式篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>状态模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第1章  Mysql架构与历史</title>
    <link href="/2023/09/12/%E7%AC%AC1%E7%AB%A0%20%20Mysql%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%8E%86%E5%8F%B2/"/>
    <url>/2023/09/12/%E7%AC%AC1%E7%AB%A0%20%20Mysql%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%8E%86%E5%8F%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="第1章-Mysql架构与历史"><a href="#第1章-Mysql架构与历史" class="headerlink" title="第1章  Mysql架构与历史"></a>第1章  Mysql架构与历史</h1><blockquote><p>MYSQL最重要、最与众不同的特性是它的存储引擎架构，这种架构的设计将查询处理( Query Processing)及其他系统任务( Server Task)和数据的存储/提取相分离。这种处理和存储分离的设计可以在使用时根据性能、特性、以及其他需求来选择数据存储的方式。</p></blockquote><h2 id="MySQL逻辑架构"><a href="#MySQL逻辑架构" class="headerlink" title="MySQL逻辑架构"></a>MySQL逻辑架构</h2><p>![image-20200208231431188](第1章  Mysql架构与历史/image-20200208231431188.png)</p><ul><li>第一层： 大多数基于网络的C/S的工具或服务都是类似的结构，比如连接处理 授权认证 安全 </li><li>第二层： 大多数MySQL 的核心服务功能都在这一层，包括查询解析、分析、优化、缓存以及所有的内置函数（日期、时间、数学和加密），所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图 </li><li>第三层： 存储引擎负责Mysql中数据的存储和提取。和GUN/Linux下的各种文件系统一样，每个存储引擎都有它的优势和劣势。存储引擎不会解析SQL（InnoDB除外，它会解析外键定义，Mysql服务器本身没有实现该功能）不同的存储引擎也不会相互通信，只是响应上层服务器的请求，服务器通过API与存储引擎进行通信，且这些接口屏蔽了不同存储引擎之间的差异 </li></ul><blockquote><pre><code class="hljs 修正认知错误:```读了高性能Mysql才认识到，对于任意一个成熟的版本，它都是由服务端层+核心功能+存储引擎三部分构成，且对于同一个版本而言，选择的存储引擎不同，导致Mysql的性能和特点也大大不同">&#96;&#96;&#96;注: </code></pre></blockquote><ul><li><p>Mysql 主要分为Server层（Server服务层 + 核心功能层）和引擎层，Server层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用 </p></li><li><p>引擎层是插件式的，目前主要包括，MyISAM,InnoDB（默认）,Memory等</p></li><li><p>查询语句的执行流程如下：</p></li></ul><p>查询缓存（命中缓存）   —》权限校验</p><p>查询缓存（未命中缓存）—》分析器—》优化器—》权限校验—》执行器—》引擎 </p><ul><li>更新语句执行流程如下：分析器—-》权限校验—-》执行器—》引擎—redo log(prepare 状态—》binlog—》redo log(commit状态) </li></ul><h3 id="连接管理及安全性"><a href="#连接管理及安全性" class="headerlink" title="连接管理及安全性"></a>连接管理及安全性</h3><p>每个客户端连接都会在服务器进程中拥有一个线程，这个链接的查询只会在这个单独的线程中执行，该线程只能轮流在某个CPU核心或CPU中运行。服务器会缓存线程，因此不需要为每一个新建的连接创建或者销毁线程。 </p><blockquote><p>Mysql服务在运行时即会创建好一个线程池，然后对接客户端请求，因此不需要为每一个新建的连接创建或者销毁线程</p><pre><code class="hljs 线程池的上限也决定了一个Mysql库难以承载高并发的需求```">### 优化与执行MYSQL会解析查询，并创建内部数据结构(解析树)，然后对其进行各种优化，包括重写査询、决定表的读取顺序，以及选择合适的素引等、同时用户可以通过特殊的关键字提示(hint)优化器，影响它的决策过程这里想到了某天开发组长和一个组员争论的问题：聚合索引a、b、c在查询的时候不按照abc的顺序是否可以应用上索引，（explain select * from test where b &#x3D; 1 and c &#x3D; 1 and a &#x3D; 1）答案是肯定的，依然会&#96;&#96;&#96;通过索引查询&#96;&#96;&#96;，即是因为优化器的优化## 并发控制Mysql在解决并发场景下多个查询在同一时刻修改数据问题时，主要从服务层及存储引擎层进行控制### 读写锁和Java层面的读写锁类似，对于Mysql中共享锁及排他锁，即读写锁也是保证了读读之间共享，读写，写写间相互排斥在实际的数据库系统中,每时每刻都在发生锁定,当某个用户在修改某一部分数据时MYSQL会通过锁定防止其他用户读取同一数据，大多数时候, MYSQL锁的内部管理都是透明的### 锁粒度一种提高共享资源并发性的方式就是让锁定对象更有选择性。尽量只锁定需要修改的部分数据,而不是所有的资源。更理想的方式是，只对会修改的数据片进行精确的锁定。任何时候，在给定的资源上，锁定的数据量越少，则系统的并发程度越高，只要相互之间不发生冲突即可。但于此同时，锁本身也是一种开销，如果为了减少锁定的数据量导致锁本身占用资源过多，也是得不偿失。因此大多数商业数据库一般都是在表上施加行级锁（row - level lock），并以各种复杂的方式来实现，以便在锁比较多的情况下尽可能提供更好的性能而Mysql则提供了多种方案选择，每种存储引擎都可以实现自己的锁策略和锁粒度，主要有两种：&#96;&#96;&#96;表锁： </code></pre></blockquote><p>故名意思即锁定整个表，需要注意的是写锁比读锁具有更高的优先级，因此一个写锁请求可以优先于读锁请求执行另外，尽管各个存储引擎可以实现自己的锁机制，但是Mysql服务端会为诸如ALTER，TABLE之类的语句使用表锁，而忽略存储引擎自己的策略</p><pre><code class="hljs 行级锁:```">行级锁策略在Mysql服务端完全没有实现，都是借由存储引擎实现，如：InnoDB## 事务事务具有四个必要特性：原子性（A）：不可分割的最小单位一致性（C）：要么都成功要么都失败隔离性（I）：事务之间不可见持久性（D）：事务提交，永久生效### 隔离级别-  READ UNCIMMITTED（未提交读）：造成脏读，实际很少使用 -  READ COMMITTED（提交读 &#x2F; 不可重复读）： 两次执行同样的查询，可能会得到不一样的结果-  &#96;&#96;&#96;REPEATABLE READ（可重复读）&#96;&#96;&#96;：依然会有幻读（Phantom Read） 的问题，进一步通过多版本并发控制（Multi version Concurrency Control，MVCC）解决，是MySQL的默认隔离级别 - SERIALIZABLE（串行化）：在读取的每一行上都加上锁，可能导致大量的超时和锁争用，实际很少使用 ### 死锁死锁的必要条件：- 互斥：某种资源一次只允许一个进程访问- 占有且等待 ： 一个进程本身占有资源(一种或多种),同时还有资源未得到满足,正在等待其他进程释放该资源 - 不可抢占：无法抢占其他已被占用的资源- 循环等待：存在一个进程链，使得每个进程都占有下一个进程所需的至少一种资源  为了解决这种问题，数据库系统实现了各种死锁检测和死锁超时机制。越复杂的系统，比如 INNODB存储引擎，越能检测到死锁的循环依赖，并立即返回一个错误，且在同一个场景中由于存储引擎不同，A引擎可能产生死锁，B则不会### 事务日志使用事务日志，存储引擎在修改数据时只需要把修改行为记录到硬盘的事务日志中，而不用每次都将修改的数据本身持久到硬盘。事务日志采用的是追加的方式，写日志操作是磁盘上的顺序I&#x2F;O，所以要快很多，事务日志持久以后，内存中被修改的数据可以在后台慢慢刷回到磁盘，称之为预写式日志（Write-Ahead Logging），修改操作需要写两次磁盘### Mysql中的事务 Mysql提供了两种事务性的存储引擎：InnoDB 和 NDB Cluster&#96;&#96;&#96; 自动提交（AUTOCOMMIT）</code></pre><p>Mysql默认采用自动提交（AUTOCOMMIT）的模式，如果不明确开始一个事务，则每个查询都被当做一个事务执行提交操作</p><pre><code class="hljs 在事务中混合使用存储引擎">Mysql服务器不管理事务，事务是由下层存储引擎实现的。混合使用事务型和非事务性的表不会有问题(例如 InnoDB 和 MyISAM)，但是回滚时，非事务的表无法撤回 &#96;&#96;&#96; 隐式和显示锁定</code></pre><p>InnoDB 采用的是两阶段锁定协议（two-phase locking protocol），随时可执行锁定，在执行commit 后者rollback时会释放，这是隐式锁定</p><p><strong>显示锁定（强烈不建议使用）</strong></p><p>SELECT … LOCK IN SHARE MODE</p><p>SELECT … FOR UPDATE</p><h2 id="多版本并发控制"><a href="#多版本并发控制" class="headerlink" title="多版本并发控制"></a>多版本并发控制</h2><p>多版本并发控制，即<code>MVCC</code>，该模块是基于提升并发性能的考虑，它是行级锁的一个变种，但是它在很多的情况避免了加锁的操作，因此开销更低，虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行</p><p>INNODB的MVCC,是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间,一个保存行的过期时间(或删除时间)。当然存储的并不是实际的时间值，而是系统版本号( system version number)。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号,用来和查询到的每行记录的版本号进行比较。</p><blockquote><p>我个人感觉MVCC的策略和Java8中的乐观读写锁- StampedLock 非常相似，通过乐观锁的思路，减少悲观锁的使用和阻塞的情况发生，StampedLock 是通过对比邮戳整数Stamp，而Mysql通过对比系统版本号来决定需不需要完全加锁</p></blockquote><h2 id="Mysql的存储引擎"><a href="#Mysql的存储引擎" class="headerlink" title="Mysql的存储引擎"></a>Mysql的存储引擎</h2><p>Mysql的存储引擎多种多样，远远不是很多面试答案中题到的：MyISAM及 InnoDB两种，通过高性能Mysql书中对于各种存储引擎的介绍，在选择存储引擎时候大概率可以毋庸置疑的选择<code>InnoDB</code></p><blockquote><p>不过新的问题来了，什么是存储引擎：根据较新的Mysql版本，存储引擎早已支持插件化了，即一个Mysql存储引擎是实现了Mysql存储引擎基本接口的程序，可以以插件的形式与Mysql数据库一同工作</p><p>也就是说，如果你能力足够强，你也可以完全自定义一个Mysql存储引擎</p></blockquote><pre><code class="hljs InnoDB概览```">InnoDB采用mvcc来支持高并发，实现了四个标准的隔离级别，默认级别是REPEATABLE READ（可重复读），通过间隙锁（next-key locking）策略防止幻读的出现。间隙锁使得InnoDB不仅仅锁定查询设计的行，还会对索引中的间隙进行锁定，防止幻影行的插入.InnoDB是通过聚簇索引建立的，InnoDB的索引结构和其他存储引擎有很大的不同，聚簇索引对主键查询有很高的性能，但二级索引必须包含主键列，如果主键列很大的话，其他的所有索引都会很大。因此弱表上的索引较多的话，主键应当尽可能的小。InnoDB的存储格式是平台独立的，可以将数据和索引文件从Intel平台复制到PowerPC或者Sun SPARC.InnoDB 内部做了很多优化，包括从磁盘读取数据时采用的可预测性预读，能够自动在内存中创建hash索引以加速读操作的自适应哈希索引，以及能够加入检查入操邹的插入缓冲区(insert buffer)Mysql的其他存储引擎不支持热备份，要获取一致性视图需要停止对所有表的写入。&#96;&#96;&#96;MyISAM引擎</code></pre><p>Mysql 5.1及以前的版本，MyISAM是默认的储存引擎。提供了大量的特性，包括全文索引 压缩 空间函数(GIS)，但MyISAM不支持事务和行级锁，而且有一个大的缺陷，崩溃后无法修复。</p><p>优势：存储数据支持压缩，占用较小</p><p><code>提醒：绝对不要混用存储引擎！！！</code></p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第1章  Mysql架构与历史</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第5章  创建高性能的索引</title>
    <link href="/2023/09/12/%E7%AC%AC5%E7%AB%A0%20%20%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95/"/>
    <url>/2023/09/12/%E7%AC%AC5%E7%AB%A0%20%20%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h1 id="第5章-创建高性能的索引"><a href="#第5章-创建高性能的索引" class="headerlink" title="第5章  创建高性能的索引"></a>第5章  创建高性能的索引</h1><blockquote><p>本文为《高性能Mysql 第三版》第四章读书笔记，Mysql版本为5.5</p></blockquote><h2 id="索引基础"><a href="#索引基础" class="headerlink" title="索引基础"></a>索引基础</h2><p>索引的重要性：找一本800面的书的某一段内容，没有目录也没有页码（页码也可类比是索引）</p><h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><ul><li>B-Tree 索引 ： 可用于全值匹配、最左前缀匹配、列前缀匹配、范围值匹配、精确匹配某一列并范围匹配另外一列、只访问索引的查询 ，原文截图：</li></ul><p>![image-20200223222150784](第5章  创建高性能的索引/image-20200223222150784.png)</p><ul><li>哈希索引 ： 只适用于精确匹配查询，不适用于范围查询 </li><li>空间数据索引 ： 可以有效地使用任意维度来组合查询 </li><li>全文索引 ： 做的事情类似于搜索引擎，而不是简单的 where 条件匹配 </li></ul><h3 id="对于Mysql索引使用的歧义"><a href="#对于Mysql索引使用的歧义" class="headerlink" title="对于Mysql索引使用的歧义"></a>对于Mysql索引使用的歧义</h3><p>对于很早的版本，一直强调：最左前缀匹配，索引使用顺序，不可跳过索引中的列等等，但高性能Mysql一书之后的版本中对于mysql优化器进行了很大程度的优化，使得开发者在使用时候可以不用顾虑太多</p><p>例如：</p><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`mytest`</span>.<span class="hljs-string">`student`</span>  (  <span class="hljs-string">`age`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'age'</span>,  <span class="hljs-string">`name`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'name'</span>,  <span class="hljs-string">`year`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'year'</span>,  <span class="hljs-keyword">INDEX</span> <span class="hljs-string">`demo`</span>(<span class="hljs-string">`age`</span>, <span class="hljs-string">`name`</span>, <span class="hljs-string">`year`</span>) <span class="hljs-keyword">USING</span> BTREE <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'demo'</span>) <span class="hljs-keyword">ENGINE</span> = <span class="hljs-keyword">InnoDB</span> <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> = utf8 <span class="hljs-keyword">COLLATE</span> = utf8_general_ci ROW_FORMAT = <span class="hljs-keyword">Compact</span>;</code></pre><p>故意使用不按索引顺序查询：</p><pre><code class="hljs n1ql">mysql&gt; <span class="hljs-keyword">explain</span> extended  <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-symbol">`student`</span> <span class="hljs-keyword">where</span> <span class="hljs-symbol">`name`</span> = <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-symbol">`age`</span> = <span class="hljs-number">1</span>;实际: key:demo 使用到了索引</code></pre><pre><code class="hljs 如何查看Mysql优化之后的SQL```：">&#96;&#96;&#96;sql# 仅在服务器环境下explain extended  SELECT * FROM &#96;student&#96; where &#96;name&#96; &#x3D; 1 and &#96;age&#96; &#x3D; 1;# 再执行show warnings;# 结果如下：&#x2F;* select#1 *&#x2F; select &#96;mytest&#96;.&#96;student&#96;.&#96;age&#96; AS &#96;age&#96;,&#96;mytest&#96;.&#96;student&#96;.&#96;name&#96; AS &#96;name&#96;,&#96;mytest&#96;.&#96;student&#96;.&#96;year&#96; AS &#96;year&#96; from &#96;mytest&#96;.&#96;student&#96; where ((&#96;mytest&#96;.&#96;student&#96;.&#96;age&#96; &#x3D; 1) and (&#96;mytest&#96;.&#96;student&#96;.&#96;name&#96; &#x3D; 1))</code></pre><p>可以发现真正执行的SQL是 age在前，name在后</p><p>对于仅使用year字段的查询结果呢？依然显示 -&gt; key:demo 使用到了索引</p><p>总结：</p><ul><li>写代码时对于索引顺序不必有<code>太多顾虑</code></li><li>优化SQL时候不仅仅只看 key参数是否使用索引，还需要注意type，ref等等</li><li>Mysql 优化器<code>并不是一定改变SQL的参数查询顺序</code>，而是以它的判定方式选择它认为的最有效的查询</li></ul><h2 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h2><p>正常的索引数据结构可以有其独特的优点，比如哈希索引不支持顺序查询，而B-Tree，或者 B+Tree则可以，总结B-Tree系列索引优</p><p>点如下：</p><ul><li>大大减少了服务器需要扫描的数据量</li><li>可以帮助服务器避免排序和临时表</li><li>可以将随机 I/O 变为顺序 I/O</li></ul><h2 id="高性能的索引策略"><a href="#高性能的索引策略" class="headerlink" title="高性能的索引策略"></a>高性能的索引策略</h2><h3 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h3><p><code>索引在使用中不可嵌入表达式或者方法</code> 错误示范： select * from where eid + 1 &lt; 10;</p><h3 id="前缀索引和索引的选择性"><a href="#前缀索引和索引的选择性" class="headerlink" title="前缀索引和索引的选择性"></a>前缀索引和索引的选择性</h3><p>如果索引很长的字符串列，会导致索引变得很大并且很慢。一个处理策略是模拟哈希索引，另一个办法是索引开始的一部分字符串的值，即前缀索引。</p><p><strong>索引的选择性</strong>指不重复的索引值和数据表中记录总数(#T)的比值。取值在为(1/ #T~1]。选择性越高则查询效率越高。唯一索引的选择性是1，是最好的索引选择性，性能也是最好的。</p><p>前缀索引的<strong>优点</strong>是可以节约索引空间，提高索引效率。<strong>缺点</strong>是降低了索引的选择性，同时也无法使用前缀索引做ORDER BY 或 GROUP BY 操作，无法使用前缀索引做覆盖扫描。</p><p>使用前缀索引时，<strong>确定前缀长度的依据</strong>是：计算前缀索引的选择性，使前缀索引选择性接近完整列的选择性</p><h3 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h3><p>错误做法：为where字段的每一个列创建独立的索引，或者按照错误的顺序创建多列索引</p><p>在explain中，如果发现索引合并，实际上说明了表上的索引建的不够好：</p><ul><li><p>当需要进行AND操作时，其实说明了需要建立一个包含所有相关列的多列索引；</p></li><li><p>当需要进行OR操作时，通常需要耗费大量CPU和内存资源在算法的缓存、排序和合并操作上；</p></li><li><p>优化器不会把这些计算到”查询成本“中，这会使得查询成本被低估，可能还不如全表扫描然后union。</p></li></ul><h3 id="选择合适的索引顺序"><a href="#选择合适的索引顺序" class="headerlink" title="选择合适的索引顺序"></a>选择合适的索引顺序</h3><p>不考虑排序和分组时：将选择性最高的列放在前面通常是很好的（选择性即有效区分数据）</p><p>但，性能不只是依赖于所有索引列的选择性，也和查询条件的具体值有关，也就是和值的分布有关，这就意味着可能需要根据那些运行频率最高的查询来调整索引列的顺序</p><p>例如：一张订单表，需要查询的字段有两个，一个是地区ID，一个是用户ID，简单思考就一定能发现用户ID的区分度应该是比地区ID要高的多（相同用户ID的数据要远远少于相同地区ID），因此建立索引应该是（用户ID，地区ID）</p><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a><strong>聚簇索引</strong></h3><p><strong>聚簇索引：</strong>将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据</p><p><strong>非聚簇索引：</strong>将数据与索引分开存储，索引结构的叶子节点指向了数据对应的位置</p><p><strong>在innodb中</strong>，在聚簇索引之上创建的索引称之为辅助索引，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引。<strong>辅助</strong></p><p><strong>索引叶子节点存储的不再是行的物理位置，而是主键值，辅助索引访问数据总是需要二次查找</strong> </p><p><strong>聚簇索引具有唯一性</strong>，由于聚簇索引是将数据跟索引结构放到一块，因此一个表仅有一个聚簇索引， <strong>聚簇索引默认是主键</strong>，如果表中没有定义主键，InnoDB 会选择一个<strong>唯一且非空的索引</strong>代替。如果没有这样的索引，InnoDB 会<strong>隐式定义一个主键（类似**</strong>oracle中的RowId）**来作为聚簇索引。如果已经设置了主键为聚簇索引又希望再单独设置聚簇索引，必须先删除主键，然后添加我们想要的聚簇索引，最后恢复设置主键即可 </p><p>聚簇的数据的优点：</p><ul><li><p>可以把相关的数据保存在一起。如电子邮箱中，根据用户ID来聚簇数据，这样只要读取少数的数据页就可以获取某个用户的全部邮件。如果没有使用聚簇索引，可能每一封邮件导致一次磁盘I/O；</p></li><li><p>访问数据更快。聚簇索引将索引和数据报错在同一个B-Tree中，因此获取数据通常比非聚簇索引更快；</p></li><li><p>使用覆盖索引扫描的查询可以直接使用页节点的主键值</p></li></ul><p>聚簇索引的缺点：</p><ul><li><p>聚簇索引能够提高I/O的密集程度，但如果所有的数据全都放在内存中，那么访问顺序就没那么重要了，聚簇索引也就没什么优势了</p></li><li><p>插入速度严重依赖于插入顺序。按照主键顺序插入是最快的。如果不是先找主键顺序加载数据，那么加载完成后最好用OPTIMIZE TABLE命令重新组织一下表</p></li><li><p>更新聚簇索引列的代价很高</p></li><li><p>基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行时，可能面临”页分裂”的问题</p></li><li><p>举措索引可能导致全表扫描变慢，尤其是行比较稀疏，或者页分裂导致数据存储不连续的时候</p></li><li><p>二级索引（非聚簇索引）可能比想象的大，因为二级索引的叶子节点包含了引用行的主键列</p></li><li><p>二级索引访问需要两次索引查找，而不是一次（第一次获得主键，第二次根据主键值去聚簇索引中查找对应的行）</p></li></ul><h4 id="在InnoDB表中按主键顺序插入行"><a href="#在InnoDB表中按主键顺序插入行" class="headerlink" title="在InnoDB表中按主键顺序插入行"></a>在InnoDB表中按主键顺序插入行</h4><p> 如果正在使用InnoDB表并且没有什么数据需要聚集，那么可以定义一个代理健作为主键。最简单的是使用AUTO INCREMENT自增列，这样可以保证数据行是顺序写入的，对于主键做关联操作也是最好的 </p><p>最好避免随机的（不连续且值的分布范围非常大）聚簇索引，特别是对于I/O密集型的应用，例如UUID</p><p>用UUID作为主键的坏处：</p><ul><li><p>写入的目标也可能已经疏导磁盘并从缓存中移除，或者还没有被加载到缓存中。InnoDB不得不先找到并且从磁盘读取目标页到内存，这导致了大量的随机I/O</p></li><li><p>因为写入是乱序的，InnoDB不得不频繁地做页分裂操作，会导致移动大量数据，一次插入最少需要修改三个页而不是一个页</p></li><li><p>由于频繁的页分裂，页会变的稀疏并被不规则填充，所以最终数据会有碎片</p></li><li><p>UUID较长，不利于作为索引</p></li></ul><p><code>字符类型作为主键的通用替代方案</code>：<a href="https://tech.meituan.com/2019/03/07/open-source-project-leaf.html" target="_blank" rel="noopener">美团分布式ID生成项目</a>， 雪花ID</p><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为：覆盖索引</p><p>覆盖索引的好处：</p><ul><li><p>索引条目远小于数据行大小，能够极大地提高性能，所以如果只需要读取索引，那么MySQL就会极大地减少数据访问量</p></li><li><p>因为索引是按照值顺序存储的，所以对于I/O密集型的范围查询会比随机从磁盘中读取每一行数据的I/O要少的多</p></li></ul><p>如果不覆盖索引，则会产生<code>回表查询</code>， 先定位主键值，再定位行记录，它的性能较扫一遍索引树更低 </p><h3 id="使用索引扫描来做排序"><a href="#使用索引扫描来做排序" class="headerlink" title="使用索引扫描来做排序"></a>使用索引扫描来做排序</h3><p>MySQL有两种方式可以生成有序的结果：通过排序操作；或者按索引顺序扫描如果EXPLAIN出来的type列的值为index，则说明使用了索引扫描排序 </p><p>扫描索引本身是很快的，因为只需要从一条索引记录移动到紧接着的下一条记录。但如果索引无法覆盖所有的列，那就不得不扫描一条索引记录就回表查询一次对应的行，这基本上属于随机I/O，因此按索引顺序读取数据的速度通常比顺序地全表扫描要慢</p><h3 id="压缩（前缀压缩）索引"><a href="#压缩（前缀压缩）索引" class="headerlink" title="压缩（前缀压缩）索引"></a>压缩（前缀压缩）索引</h3><p> MyISAM使用前缀压缩来减少索引的大小，从而让更多的索引可以放入内存中，这在某种情况下可以极大地提高性能。默认只压缩字符串，但通过参数设置也可以对整数压缩 ， MyISAM存储引擎不过多深究</p><h3 id="冗余和重复索引"><a href="#冗余和重复索引" class="headerlink" title="冗余和重复索引"></a><strong>冗余和重复索引</strong></h3><p><strong>重复索引</strong>：</p><ul><li>MySQL允许在相同列上创建多个索引，但这样需要单独维护重复的索引，并且优化查询的时候也需要逐个进行考虑，会影响性能，应该避免这么做</li></ul><p><strong>冗余索引</strong></p><ul><li><p>如果已经创建了索引（A, B），在创建索引（A），那么就是冗余索引，因为它只是前一个索引的前缀</p></li><li><p>冗余索引通常发生在表添加新索引的时候。如增加一个新的索引(A, B)，而没有扩展已有索引(A)，导致(A)成为冗余索引。或者将索引扩展为(A, 主键ID)，对InnoDB来说，主键已经包含在二级索引中了，因此也是冗余的</p></li></ul><h3 id="索引和锁"><a href="#索引和锁" class="headerlink" title="索引和锁"></a>索引和锁</h3><p>索引可以让查询锁定更少的行，如果你的查询从不访问那些不需要的行，那么就会锁定更少的行，从两个方面来看这对性能都有好处：</p><ul><li><p>虽然InnoDB的行锁的效率很高，内存使用也很少，但是锁定行的时候依然会带来额外开销</p></li><li><p>锁定需要的行会增加所争用并减少并发性</p></li></ul><p>InnoDB只有在访问行的时候才会对其加锁。而索引能够减少InnoDB访问的行数，从而减少锁的数量。但这只有当InnoDB在存储引擎能够过滤掉不需要的行时才有效，如果索引无法过滤掉无效的行，那么在InnoDB检索到数据并返回给服务器层之后，MySQL服务器才能应用Where子句，这时已经无法避免锁定行了：InnoDB已经锁住了这些行，到适当的时候才释放。</p><p>Explain的Extra列显示“Using Where”，说明MySQL服务器将存储引擎返回行之后再应用where过滤条件。此时where子句以前的数据全都被加锁</p><p>InnoDB在二级索引上使用共享锁（读锁），但访问主键索引需要排它锁（写锁）</p><p><strong>InnoDB的行锁是建立在索引的基础之上的</strong>，行锁锁的是索引，不是数据，所以提高并发写的能力要在查询字段添加索引</p><h2 id="维护索引和表"><a href="#维护索引和表" class="headerlink" title="维护索引和表"></a>维护索引和表</h2><p>使用正确的类型创建了表并加上了合适的索引后，还需要维护表和索引来确保它们正常工作，目的如下：</p><ul><li><p>找到并修复损坏的表</p></li><li><p>维护准确的索引统计信息</p></li><li><p>减少碎片</p></li></ul><h3 id="找到并修复损坏的表"><a href="#找到并修复损坏的表" class="headerlink" title="找到并修复损坏的表"></a>找到并修复损坏的表</h3><p>可以通过CHECK TABLE检查是否发生了表错误</p><p>可以用REPAIR TABLE或者一个不作任何操作的ALTER操作来修复表</p><h3 id="更新索引统计信息"><a href="#更新索引统计信息" class="headerlink" title="更新索引统计信息"></a><strong>更新索引统计信息</strong></h3><ul><li><p>records_in_range()，通过向存储引擎传入两个边界值获取在这个范围大概有多少条记录</p></li><li><p>info()，返回各种类型的数据，包括索引的基数（每个键值有多少条记录）</p></li></ul><h3 id="减少索引和数据的碎片"><a href="#减少索引和数据的碎片" class="headerlink" title="减少索引和数据的碎片"></a>减少索引和数据的碎片</h3><p>B-Tree索引可能导致碎片化，会导致查询效率降低。有三类数据碎片</p><ul><li><p>行碎片：数据行被存储在多个片段中</p></li><li><p>行间碎片：逻辑上顺序的页，或者行在磁盘上不是顺序存储的</p></li><li><p>剩余空间碎片化：数据也中有大量的空余空间</p></li></ul><p>对于MyISAM表，三类碎片都可能发生，InnoDB不会出现短小的碎片行，会移动短小的行并重写到一个片段中</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>选择索引以及利用索引查询时的三个原则：</p><ul><li><p>单行访问是很慢的。最好读取的块中包含尽可能多需要的行，使用索引可以创建位置引用以提升效率</p></li><li><p>按顺序访问范围数据是很快的，原因如下：</p><ol><li><p>顺序I/O不需要多次磁盘寻道，比随机I/O快</p></li><li><p>如果服务器能够按顺序读取数据，那么就不再需要额外的排序操作，并且GROUP BY查询也无须再做排序和将行按组进行聚合计算了</p></li></ol></li><li><p>索引覆盖查询是很快的</p></li></ul><p>现实使用中，很难做到每一个查询都有完美的索引，这时候需要根据需求有所取舍地创建合适的索引，而非根据惯例一刀切</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第5章  创建高性能的索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>观察者模式</title>
    <link href="/2023/09/12/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/09/12/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="观察者模式篇"><a href="#观察者模式篇" class="headerlink" title="观察者模式篇"></a>观察者模式篇</h1><h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新</p><p><font color="red">别名：</font>发布-订阅模式</p><h2 id="观察者模式的诞生"><a href="#观察者模式的诞生" class="headerlink" title="观察者模式的诞生"></a>观察者模式的诞生</h2><p>将一个系统分割成一系列相互协作的类有一个常见的副作用：需要维护相关对象间的致性，我们不希望为了维持一致性而使各类紧密耦合，因为这样降低了它们的可重用性。</p><p>说人话就是：</p><p>【<font color="orange">产品</font>】：开发小哥，我需要你设计一个天气预报显示大屏，气象站会给你发送数据，你需要把它展示到大屏里，OK吗？</p><p>【<font color="blue">开发</font>】：OJBK！秒秒钟搞定一切！代码立马出来！</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getTemperature</span> <span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 从气象站获取发送过来的温度数据</span>    <span class="hljs-comment">// getData();</span>            <span class="hljs-comment">// ................................</span>    <span class="hljs-comment">// 显示到大屏里面去</span>    <span class="hljs-comment">// showDataToScreen();</span>    <span class="hljs-comment">// ................................</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getMisture</span> <span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 从气象站获取发送过来的湿度数据</span>    <span class="hljs-comment">// getData();</span>            <span class="hljs-comment">// ................................</span>    <span class="hljs-comment">// 显示到大屏里面去</span>    <span class="hljs-comment">// showDataToScreen();</span>    <span class="hljs-comment">// ................................</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getAirindex</span> <span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 从气象站获取发送过来的空气指数数据</span>    <span class="hljs-comment">// getData();</span>            <span class="hljs-comment">// ................................</span>    <span class="hljs-comment">// 显示到大屏里面去</span>    <span class="hljs-comment">// showDataToScreen();</span>    <span class="hljs-comment">// ................................</span>&#125;</code></pre><p>【<font color="red">BOSS</font>】：磕大头！宁是准备每获取一次数据就把代码CV一遍吗？你不累吗？</p><p>【<font color="blue">开发</font>】：老大，我一点都不累！就是复制粘贴一下呀！</p><p>【<font color="red">BOSS</font>】：如果我现在不需要同步更新天气指数呢？删代码吗？</p><p>【<font color="blue">开发</font>】：对啊！一秒钟就能删掉！( •̀ ω •́ )✧</p><p>【<font color="red">BOSS</font>】：重写😃</p><p><img src="/2023/09/12/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/972352-07e55e231b95023f.webp" srcset="/img/loading.gif" alt="img"></p><h2 id="HeadFirst-核心代码"><a href="#HeadFirst-核心代码" class="headerlink" title="HeadFirst 核心代码"></a>HeadFirst 核心代码</h2><p>于是乎，我们开启了关于设计模式的经典书籍阅读之旅</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 观察主题接口</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Observable</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addObserver</span><span class="hljs-params">(Observer observer)</span></span>;     <span class="hljs-comment">// 添加观察者</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeObserver</span><span class="hljs-params">(Observer observer)</span></span>;  <span class="hljs-comment">// 移除观察者</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObservers</span><span class="hljs-params">(WeatherData data)</span></span>;  <span class="hljs-comment">// 通知所有观察者</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 观察者</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Observer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(WeatherData data)</span></span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 天气主题</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Weather</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observable</span> </span>&#123;    <span class="hljs-keyword">private</span> List&lt;Observer&gt; observers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addObserver</span><span class="hljs-params">(Observer observer)</span> </span>&#123;        observers.add(observer);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeObserver</span><span class="hljs-params">(Observer observer)</span> </span>&#123;        observers.remove(observer);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObservers</span><span class="hljs-params">(WeatherData data)</span> </span>&#123;        <span class="hljs-keyword">for</span> (Observer observer : observers)            observer.update(data);    &#125;&#125;</code></pre><p><font color="red">观察者模式的设计思路：</font></p><ul><li>Subject 目标（容器）提供注册和删除观察者的接口以及更新接口</li><li>Observer（观察者）为那些在目标发生改变时需获得通知的对象定义一个更新接口</li><li>ConcreteSubject（具体目标）状态发生改变时，向各个观察者发出通知</li><li>ConcreteObserver（具体观察者）实现Observer的更新接口</li></ul><p>简单来说，</p><ol><li>我们需要一个接口来定义注册，删除和更新接口</li><li>然后由具体的目标（类）实现该接口，并且在类中创建一个容器，存储需要被通知的对象</li><li>需要被通知的对象，需要实现Observer接口中的update更新方法</li><li>将观察者对象注册进容器中，当具体目标更新时，调用所有容器类对象的update方法</li></ol><blockquote><p>如果看着有点模棱两可，就看完本文后，访问专题设计模式开源项目，里面有具体的代码示例，链接在最下面</p></blockquote><h2 id="JDK中的观察者模式"><a href="#JDK中的观察者模式" class="headerlink" title="JDK中的观察者模式"></a>JDK中的观察者模式</h2><p>JDK中已经对观察者模式有具体的实现，代码非常简单，如下所示：</p><p>具体目标：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObservableApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Observable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> curr;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ObservableApp</span><span class="hljs-params">(<span class="hljs-keyword">long</span> curr)</span> </span>&#123;        <span class="hljs-keyword">this</span>.curr = curr;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">long</span> newStr)</span> </span>&#123;        <span class="hljs-keyword">this</span>.curr = newStr;                <span class="hljs-comment">// 更改状态，发送通知</span>        setChanged();        notifyObservers(newStr);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setChanged</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">super</span>.setChanged();    &#125;&#125;</code></pre><p>具体观察者：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObserverA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Observable o, Object arg)</span> </span>&#123;        System.out.println(MessageFormat.format(<span class="hljs-string">"ObserverA -&gt; &#123;0&#125; changed, Begin to Work. agr is:&#123;1&#125;"</span>, o.getClass().getSimpleName(), arg));    &#125;&#125;</code></pre><p>Main方法：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        ObservableApp app = <span class="hljs-keyword">new</span> ObservableApp(System.currentTimeMillis());        System.out.println(app.getCurr());        app.addObserver(<span class="hljs-keyword">new</span> ObserverA());        app.addObserver(<span class="hljs-keyword">new</span> ObserverB());        Thread.sleep(<span class="hljs-number">1000</span>);                <span class="hljs-keyword">long</span> curr = System.currentTimeMillis();        app.change(curr);        System.out.println(app.getCurr());    &#125;&#125;<span class="hljs-comment">// 输出如下：</span><span class="hljs-comment">// 1589688733464</span><span class="hljs-comment">// ObserverB -&gt; ObservableApp changed, Begin to Work. agr is:1,589,688,734,469</span><span class="hljs-comment">// ObserverA -&gt; ObservableApp changed, Begin to Work. agr is:1,589,688,734,469</span><span class="hljs-comment">// 1589688734469</span></code></pre><h3 id="推模式"><a href="#推模式" class="headerlink" title="推模式"></a>推模式</h3><p>通知发给观察者，通知携带参数，这就是推，对应JDK方法中的：notifyObservers(Object arg) </p><h3 id="拉模式"><a href="#拉模式" class="headerlink" title="拉模式"></a>拉模式</h3><p>通知发给观察者，通知不携带参数，需要观察者自己去主动调用get方法获取数据，这就是拉</p><p>对应JDK方法中的：notifyObservers()，仅告知观察者数据发生了变化，至于数据的详情需要观察者主动到主题中pull数据</p><p>拉模型强调的是目标不知道它的观察者,而推模型假定目标知道一些观察者的需要的信息。推模型可能使得观察者相对难以复用，因为目标对观察者的假定可能并不总是正确的。另一方面。拉模型可能效率较差，因为观察者对象需在没有目标对象帮助的情况下确定什么改变了。</p><h2 id="遵循的设计原则"><a href="#遵循的设计原则" class="headerlink" title="遵循的设计原则"></a>遵循的设计原则</h2><ol><li><strong>封装变化</strong><ul><li>在观察者模式中会经常改变的是主题的状态，以及观察者的数目和类型</li><li>我们可以改变依赖于主题状态的对象，但是不必改变主题本身，这便是提前规划</li></ul></li><li><strong>针对接口编程</strong><ul><li>主题和观察者都使用了接口</li><li>观察者利用主题的接口向主题注册</li><li>主题利用观察者接口通知观察者，可以使两者之间正常交互，同时又具有松耦合的特性</li></ul></li><li><strong>多使用组合</strong><ul><li>观察者模式利用组合将许多观察者组合进主题中</li><li>它们之间的关系并不是通过继承得到，而是在运行时动态改变</li></ul></li></ol><h2 id="什么场景适合使用"><a href="#什么场景适合使用" class="headerlink" title="什么场景适合使用"></a>什么场景适合使用</h2><p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern），比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式</p><h2 id="Code-生活中的实际应用"><a href="#Code-生活中的实际应用" class="headerlink" title="Code/生活中的实际应用"></a>Code/生活中的实际应用</h2><ul><li>比如微信公众号中的订阅关注，订阅后，公众号发布文章会实时分发给各个账号</li><li>又如，我们使用Keep跑步时，如果你跑的足够激情，它会提示你，<font color="red">恭喜你，你已经打破了五公里的最好记录！</font>这样的语音提醒一定是触发式，而不是实时去检测吧？（实时检测没有意义，浪费性能）这里就可以利用观察者模式进行设计和解耦</li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p><strong>附上GOF一书中对于观察者模式的UML图：</strong></p><p><img src="/2023/09/12/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/image-20200517141746282.png" srcset="/img/loading.gif" alt="image-20200517141746282"></p><h2 id="相关代码链接"><a href="#相关代码链接" class="headerlink" title="相关代码链接"></a>相关代码链接</h2><p><a href="https://github.com/kkzhilu/Kerwin-DesignPattern" target="_blank" rel="noopener">GitHub地址</a></p><ul><li>兼顾了《HeadFirst》以及《GOF》两本经典书籍中的案例</li><li>提供了友好的阅读指导</li></ul><p><img src="/2023/09/12/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/%E5%BE%AE%E4%BF%A1%E4%BA%8C%E7%BB%B4%E7%A0%81.png" srcset="/img/loading.gif" alt></p>]]></content>
    
    
    <categories>
      
      <category>编码及设计模式篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>观察者模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式总篇：剖析七大原则</title>
    <link href="/2023/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%AF%87%EF%BC%9A%E5%89%96%E6%9E%90%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    <url>/2023/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%AF%87%EF%BC%9A%E5%89%96%E6%9E%90%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式总篇：剖析七大原则"><a href="#设计模式总篇：剖析七大原则" class="headerlink" title="设计模式总篇：剖析七大原则"></a>设计模式总篇：剖析七大原则</h1><h2 id="聊聊为什么需要原则"><a href="#聊聊为什么需要原则" class="headerlink" title="聊聊为什么需要原则"></a>聊聊为什么需要<code>原则</code></h2><p>我们所有人都看过科幻电影，都看到过未来场景中人类和机器人和平相处的场景</p><p><img src="/2023/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%AF%87%EF%BC%9A%E5%89%96%E6%9E%90%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/image-20200704115010265.png" srcset="/img/loading.gif" alt="image-20200704115010265"></p><p>为了让拥有<code>自主智能</code>的机器人不失控，人类为机器人制定了三大定律：</p><ul><li><font color="red">第一定律：机器人不得伤害人类个体，或者目睹人类个体将遭受危险而袖手不管</font></li><li><font color="red">第二定律：机器人必须服从人给予它的命令，当该命令与第一定律冲突时例外</font></li><li><font color="red">第三定律：机器人在不违反第一、第二定律的情况下要尽可能保护自己的生存</font></li></ul><p>当然有时也会出现下面的情况，机器人和人类开始互为阵营，各自为敌</p><p><img src="/2023/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%AF%87%EF%BC%9A%E5%89%96%E6%9E%90%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/image-20200704115126779.png" srcset="/img/loading.gif" alt="image-20200704115126779"></p><p>但是各自为敌的情况出现，一般都是机器人觉醒了自我意识，不再遵守<code>三大定律</code></p><p>从逻辑学来说，如果机器人完全遵守<code>三大定律及其衍生的条约</code>，那么机器人就可以和人类和平相处，当然也会有意外发生。</p><h2 id="写代码为什么需要设计原则"><a href="#写代码为什么需要设计原则" class="headerlink" title="写代码为什么需要设计原则"></a>写代码为什么需要设计原则</h2><p>和机器人的<code>三大定律</code>相仿，几十年的编程经验，让几代人总结出来了一些代码设计上的<code>定律</code>，这就是<code>设计模式的七大原则</code></p><p><strong><em>我们遵循七大原则，一定会写出最完美的代码吗？</em></strong></p><p>答案当然是不一定，毕竟没有人能保证自己可以完全遵循七大原则，同时个人的编程能力也会起到决定性因素。</p><p><strong><em>那我们为什么还要遵守？</em></strong></p><p>我自己想到的一句名言（以后或许可以成为名言~）</p><blockquote><p>向着最好的方向去努力，总不会是最差的结果。</p></blockquote><h2 id="七大原则详解"><a href="#七大原则详解" class="headerlink" title="七大原则详解"></a>七大原则详解</h2><h3 id="开闭原则-★★★★★"><a href="#开闭原则-★★★★★" class="headerlink" title="开闭原则 ★★★★★"></a>开闭原则 ★★★★★</h3><blockquote><p>软件实体对扩展是开放的，但对修改是关闭的，即在不修改一个软件实体的基础上去扩展其功能</p></blockquote><p><strong><em>例如：</em></strong></p><p>以策略模式为例，当我们新增一种策略的时候，只需要实现策略顶层接口，在调用的时指向新的策略即可</p><p>针对这一条原则，在实现难度上要比单一职责更难，在编码期间，我们需要充分考虑未来的拓展性，规范接口，依赖抽象，这样才能在需要拓展的时候，非常方便的实现其效果</p><p>最佳实践案例：<a href="https://juejin.im/post/5ede6ce151882543485772ea" target="_blank" rel="noopener">【一起学系列】之模板方法：写SSO我只要5分钟</a></p><p>说明：在接入第三方SSO时，如果需要新增接入方，基于文中的案例，只需实现固定接口，即可优雅的实现相应需求</p><h3 id="依赖倒置原则-★★★★★"><a href="#依赖倒置原则-★★★★★" class="headerlink" title="依赖倒置原则  ★★★★★"></a>依赖倒置原则  ★★★★★</h3><blockquote><p>要针对抽象层编程，而不要针对具体类编程</p></blockquote><p><strong><em>例如：</em></strong></p><p>以适配器模式为例，将一个类的接口转换成客户希望的另外一个接口，以此实现的前提便是代码中所依赖的都是抽象的，因为只有依赖抽象，才能在代码运行期间改变其实体，利用<code>多态</code>实现需要的效果</p><p>针对该条原则，其实有一定编程经验的人一定会在无形中注意到，而且了解设计模式的话，会发现所有涉及接口和实现的设计模式都会遵从这一条原则</p><p>最佳实践案例：<a href="https://juejin.im/post/5ede6ce151882543485772ea" target="_blank" rel="noopener">【一起学系列】之模板方法：写SSO我只要5分钟</a></p><p>说明：和上一条原则的侧重点不同，在SSO中必然有其固定的流程，如登录-获取Token-获取用户信息-解析-退出等等，在代码的编写阶段，需要我们定义出接口/抽象类，然后依赖于抽象层，最终改变具体类，以此达到无缝切换的效果</p><h3 id="合成复用原则-★★★★☆"><a href="#合成复用原则-★★★★☆" class="headerlink" title="合成复用原则  ★★★★☆"></a>合成复用原则  ★★★★☆</h3><blockquote><p>总结一句话就是：多用组合，少用继承</p></blockquote><p><strong><em>例如：</em></strong></p><p>以单例模式和代理模式为例，它们都是该模式的最佳实践者，单例模式是把不同的策略接口通过<code>组合</code>的方式嵌入到<code>Context</code>类中，如代码所示：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Duck</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 飞行行为是动态的，可能会变的，因此抽成多个接口的组合，而不是让Duck类继承</span><span class="hljs-comment">     */</span>    FlyBehavior flyBehavior;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 每个鸭子的叫声不同，抽象成接口</span><span class="hljs-comment">     */</span>    QuackBehavior quackBehavior;&#125;</code></pre><p>同理，代理模式也是如此，这里就考虑到一个问题，<code>为什么要多用组合而非继承？</code></p><p>其实还是Java中单继承引发的问题，同时继承的<code>语义</code>过于苛刻，因此更多的时候建议<code>善用组合</code></p><p>最佳实践案例：<a href="https://juejin.im/post/5eb67fc46fb9a043830f597a" target="_blank" rel="noopener">【一起学系列】之策略模式：好多鸭子啊</a></p><p>说明：策略模式就是合成复用原则的最佳实践者，没有之一</p><h3 id="单一职责原则-★★★★☆"><a href="#单一职责原则-★★★★☆" class="headerlink" title="单一职责原则   ★★★★☆"></a>单一职责原则   ★★★★☆</h3><blockquote><p>类的职责要单一，不能将太多的职责放在一个类中</p></blockquote><p><strong><em>例如：</em></strong></p><p>在代码设计中某种场景可能存在多种不同的状态，很可能就把代码混在一起了，这时我们利用<code>状态模式</code>进行设计，把各种状态对应的实现细节都用类的级别单独划分，即体现了<code>单一职则原则</code></p><p>针对这一条原则，其实绝大多数人在设计之初都会考虑到，但问题就在于随着工作中人员职责的交叉，很有可能会破坏他人设计的最初目的，为了方便，让一个类拥有五花八门的功能</p><p>最佳实践案例：<a href="https://juejin.im/post/5ee8f64be51d452f9c27e66a" target="_blank" rel="noopener">【一起学系列】之状态模式：你听过“流程”模式吗？</a></p><p>说明：在状态模式中，每一种状态的处理都是独立的一个类，每个类只需要处理自身的核心逻辑，完美体现了<code>单一职责原则</code></p><h3 id="里氏替换原则-★★★★☆"><a href="#里氏替换原则-★★★★☆" class="headerlink" title="里氏替换原则  ★★★★☆"></a>里氏替换原则  ★★★★☆</h3><blockquote><p>在软件系统中，一个可以接受基类对象的地方必然可以接受一个子类对象</p></blockquote><p>当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法</p><p>继承包含这样一层含义：父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义</p><p><strong><em>例如：</em></strong></p><p>我们都用过<code>ArrayList</code>，有谁看过 <code>forEach</code>方法的源码？</p><pre><code class="hljs java"><span class="hljs-comment">// ArrayList 的父级接口 Iterable  定义的默认方法</span><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> T&gt; action)</span> </span>&#123;    Objects.requireNonNull(action);    <span class="hljs-keyword">for</span> (T t : <span class="hljs-keyword">this</span>) &#123;        action.accept(t);    &#125;&#125;</code></pre><p><code>ArrayList</code>重写的方法：</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> E&gt; action)</span> </span>&#123;    Objects.requireNonNull(action);    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> expectedModCount = modCount;    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)    <span class="hljs-keyword">final</span> E[] elementData = (E[]) <span class="hljs-keyword">this</span>.elementData;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size = <span class="hljs-keyword">this</span>.size;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;        action.accept(elementData[i]);    &#125;    <span class="hljs-keyword">if</span> (modCount != expectedModCount) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();    &#125;&#125;</code></pre><p>我们看到，<code>ArrayList</code>的重写只是针对数组这种结构优化了性能，其目的性和<code>Iterable</code>接口中的完全一致，因此这种方式的重写不会引起任何问题，反而可以提高效率，我们需要学习这样的方式</p><h3 id="迪米特原则-★★★☆☆"><a href="#迪米特原则-★★★☆☆" class="headerlink" title="迪米特原则  ★★★☆☆"></a>迪米特原则  ★★★☆☆</h3><blockquote><p>一个对象应该对其他对象保持最少的了解，又名：最少知道原则</p></blockquote><p><strong><em>例如：</em></strong></p><p>在代码设计场景中，某一个类的调用都会固定使用三个方法，是否可以考虑把三个方法抽取出来，提供一个公共的对外方法？这种思路就是<code>外观模式</code>，外观模式也是迪米特原则的最佳实践</p><p>最佳实践案例：<a href="https://juejin.im/post/5ed688c051882543413c1168" target="_blank" rel="noopener">【一起学系列】之适配器模式：还有外观模式呢</a></p><p>说明：利用<code>外观模式</code>构建统一的对外方法，屏蔽其内部实现，这样一旦内部实现需要更改，完全不会影响调用方，你Get了吗？</p><h3 id="接口隔离原则-★★☆☆☆"><a href="#接口隔离原则-★★☆☆☆" class="headerlink" title="接口隔离原则  ★★☆☆☆"></a>接口隔离原则  ★★☆☆☆</h3><blockquote><p>使用多个专门的接口来取代一个统一的接口</p></blockquote><p>这个模式其实也很好理解，比如我们定义了接口A，接口B实现了接口A，接口C实现了接口B，基类D其实只需要接口C的方法，但是此时不得不实现所有的方法</p><p><font color="red">其实造成这个根本原因：对接口的抽象，设计出现了偏差</font></p><p>毕竟看过JDK源码或者Spring源码的同学，可以经常发现某一个接口可能实现了一大堆的接口，但是对于普通开发者而言，没有这种强大的设计能力，就需要在设计的时候多思考，如果发现违背了<code>接口隔离原则</code>的情况，就应该对接口进行拆分</p><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="/2023/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%AF%87%EF%BC%9A%E5%89%96%E6%9E%90%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/Kerwin-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%8E%9F%E5%88%99.png" srcset="/img/loading.gif" alt></p><blockquote><p>Processon分享地址：<a href="https://www.processon.com/view/link/5f0210aa7d9c0844204b4845" target="_blank" rel="noopener">https://www.processon.com/view/link/5f0210aa7d9c0844204b4845</a></p><p>PS：需要源文件的小伙伴可以在文末扫描二维码，发送【设计模式】即可</p></blockquote><h2 id="设计模式的系列文章推荐"><a href="#设计模式的系列文章推荐" class="headerlink" title="设计模式的系列文章推荐"></a>设计模式的系列文章推荐</h2><table><thead><tr><th>所属类型</th><th>设计模式</th><th>标题 &amp; 链接</th></tr></thead><tbody><tr><td><font color="red">行为型模式</font></td><td>策略模式</td><td><a href="https://juejin.im/post/5eb67fc46fb9a043830f597a" target="_blank" rel="noopener">【一起学系列】之策略模式：好多鸭子啊</a></td></tr><tr><td><font color="red">行为型模式</font></td><td>观察者模式</td><td><a href="https://juejin.im/post/5ec2a1dde51d454ddf23697d" target="_blank" rel="noopener">【一起学系列】之观察者模式：我没有在监控你啊</a></td></tr><tr><td><font color="red">行为型模式</font></td><td>命令模式</td><td><a href="https://juejin.im/post/5ed5265851882543477c7abf" target="_blank" rel="noopener">【一起学系列】之命令模式：封装一个简单Jedis？</a></td></tr><tr><td><font color="red">行为型模式</font></td><td>模板方法模式</td><td><a href="https://juejin.im/post/5ede6ce151882543485772ea" target="_blank" rel="noopener">【一起学系列】之模板方法：写SSO我只要5分钟</a></td></tr><tr><td><font color="red">行为型模式</font></td><td>迭代器模式</td><td><a href="https://juejin.im/post/5ee64aade51d45789671b974" target="_blank" rel="noopener">【一起学系列】之迭代器&amp;组合：虽然有点用不上啦</a></td></tr><tr><td><font color="red">行为型模式</font></td><td>状态模式</td><td><a href="https://juejin.im/post/5ee8f64be51d452f9c27e66a" target="_blank" rel="noopener">【一起学系列】之状态模式：你听过“流程”模式吗？</a></td></tr><tr><td><font color="red">行为型模式</font></td><td>职责链模式</td><td><a href="https://juejin.im/post/5efe0653e51d4534a81a9121" target="_blank" rel="noopener">【一起学系列】之剩下的设计模式们</a></td></tr><tr><td><font color="red">行为型模式</font></td><td>备忘录模式</td><td><a href="https://juejin.im/post/5efe0653e51d4534a81a9121" target="_blank" rel="noopener">【一起学系列】之剩下的设计模式们</a></td></tr><tr><td><font color="blue">结构型模式</font></td><td>装饰器模式</td><td><a href="https://juejin.im/post/5ec2a87c5188256e9b728e70" target="_blank" rel="noopener">【一起学系列】之装饰器模式：不改代码增强功能？</a></td></tr><tr><td><font color="blue">结构型模式</font></td><td>适配器模式 &amp; 外观模式</td><td><a href="https://juejin.im/post/5ed688c051882543413c1168" target="_blank" rel="noopener">【一起学系列】之适配器模式：还有外观模式呢</a></td></tr><tr><td><font color="blue">结构型模式</font></td><td>组合模式</td><td><a href="https://juejin.im/post/5ee64aade51d45789671b974" target="_blank" rel="noopener">【一起学系列】之迭代器&amp;组合：虽然有点用不上啦</a></td></tr><tr><td><font color="blue">结构型模式</font></td><td>代理模式</td><td><a href="https://juejin.im/post/5ef2b053f265da02e3401e5c" target="_blank" rel="noopener">【一起学系列】之代理模式：是为了控制访问啊！</a></td></tr><tr><td><font color="green">创建型模式</font></td><td>工厂模式<br>（工厂方法及抽象工厂）</td><td><a href="https://juejin.im/post/5ecbcf19e51d4578a475ea5e" target="_blank" rel="noopener">【一起学系列】之工厂模式：产品？产品族?</a></td></tr><tr><td><font color="green">创建型模式</font></td><td>单例模式</td><td><a href="https://juejin.im/post/5ecbcabc6fb9a047d070c779" target="_blank" rel="noopener">【一起学系列】之单例模式：只推荐三种~</a></td></tr><tr><td><font color="green">创建型模式</font></td><td>建造者模式</td><td><a href="https://juejin.im/post/5efe0653e51d4534a81a9121" target="_blank" rel="noopener">【一起学系列】之剩下的设计模式们</a></td></tr></tbody></table><h2 id="源码链接"><a href="#源码链接" class="headerlink" title="源码链接"></a>源码链接</h2><p><a href="https://github.com/kkzhilu/Kerwin-DesignPattern" target="_blank" rel="noopener">GitHub地址</a></p><ul><li>兼顾了《HeadFirst》以及《GOF》两本经典书籍中的案例</li><li>提供了友好的阅读指导</li></ul><p><img src="/2023/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%AF%87%EF%BC%9A%E5%89%96%E6%9E%90%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/172284a1c8caf324" srcset="/img/loading.gif" alt></p>]]></content>
    
    
    <categories>
      
      <category>编码及设计模式篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式总篇：剖析七大原则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>迭代器和组合模式</title>
    <link href="/2023/09/12/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/09/12/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="迭代器及组合模式篇"><a href="#迭代器及组合模式篇" class="headerlink" title="迭代器及组合模式篇"></a>迭代器及组合模式篇</h1><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴漏该对象的内部表示</p><h3 id="迭代器模式的诞生"><a href="#迭代器模式的诞生" class="headerlink" title="迭代器模式的诞生"></a>迭代器模式的诞生</h3><p>【<font color="orange">产品</font>】：嘿，有一个好消息，咱们旗下的餐厅把月巴克的咖啡店吞并了！太棒了！年终奖稳了！</p><p>【<font color="blue">开发</font>】：Yeah！Yeah！Yeah！</p><p>【<font color="orange">产品</font>】：但是他们好像反应一个问题，月巴克的点餐系统好像不兼容我们的体系，怎么回事？不就是一个菜单吗？</p><p>【<font color="blue">开发</font>】：Oh！No！一定它们的 <font color="red">数据结构</font> 不一样导致的，遍历出现了问题！</p><p>【<font color="orange">产品</font>】：那怎么办？BOSS，你们一起想想办法吧！</p><p>【<font color="blue">开发</font>】：老大，我们能不能把遍历方法抽取出来啊？我们遍历操作就可以不用考虑各种细节了，只需要管遍历类就好了。</p><p>【<font color="red">BOSS</font>】：什么遍历类的，这叫 <font color="red">迭代器</font>  好吗！其实JDK对于迭代器已经维护的很好了，但是咱们这业务也有一点特殊性，就按你说的办吧，办不好的话，刚才说的年终奖就没了。</p><p>【<font color="blue">开发</font>】：哦，好的（脸上笑嘻嘻，心里MMP）</p><p><img src="/2023/09/12/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/image-20200614112304352.png" srcset="/img/loading.gif" alt="image-20200614112304352"></p><h3 id="HeadFirst-核心代码"><a href="#HeadFirst-核心代码" class="headerlink" title="HeadFirst 核心代码"></a>HeadFirst 核心代码</h3><h4 id="自己整一个迭代器"><a href="#自己整一个迭代器" class="headerlink" title="自己整一个迭代器"></a>自己整一个迭代器</h4><p><strong><em>定义迭代器持有者  非必须代码</em></strong></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * ******************************</span><span class="hljs-comment"> * description:  迭代器持有者</span><span class="hljs-comment"> * ******************************</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyContainer</span> </span>&#123;    <span class="hljs-function">MyIterator <span class="hljs-title">getIterator</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p><strong><em>迭代器接口</em></strong></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * ******************************</span><span class="hljs-comment"> * description:  迭代器接口</span><span class="hljs-comment"> * ******************************</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyIterator</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">Object <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p><strong><em>迭代器工作类  食物菜单</em></strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FoodRepository</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MyContainer</span> </span>&#123;    String[] names = &#123;<span class="hljs-string">"宫保鸡丁"</span>, <span class="hljs-string">"麻辣香锅"</span>, <span class="hljs-string">"油闷大虾"</span>&#125;;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> MyIterator <span class="hljs-title">getIterator</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NameIterator();    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NameIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MyIterator</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> index;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> index &lt; names.length;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;           <span class="hljs-keyword">return</span> hasNext() ? names[index++] : <span class="hljs-keyword">null</span>;        &#125;        NameIterator() &#123;            index = <span class="hljs-number">0</span>;        &#125;    &#125;&#125;</code></pre><p><strong><em>迭代器工作类  咖啡菜单</em></strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoffeeRepository</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MyContainer</span> </span>&#123;    List&lt;String&gt; names = Arrays.asList(<span class="hljs-string">"雀巢咖啡"</span>, <span class="hljs-string">"黑糖玛奇朵"</span>, <span class="hljs-string">"半点寂寞"</span>);    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> MyIterator <span class="hljs-title">getIterator</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NameIterator();    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NameIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MyIterator</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> index;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> index &lt; names.size();        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;           <span class="hljs-keyword">return</span> hasNext() ? names.get(index++) : <span class="hljs-keyword">null</span>;        &#125;        NameIterator() &#123;            index = <span class="hljs-number">0</span>;        &#125;    &#125;&#125;</code></pre><p><strong><em>测试类 观察调用的表现形式</em></strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        <span class="hljs-comment">// 餐厅菜单</span>        FoodRepository food = <span class="hljs-keyword">new</span> FoodRepository();        MyIterator foodIterator = food.getIterator();        <span class="hljs-keyword">while</span> (foodIterator.hasNext()) &#123;            System.out.println(<span class="hljs-string">"Food: -&gt; "</span> + foodIterator.next());        &#125;        CodeUtils.spilt();        <span class="hljs-comment">// 咖啡菜单</span>        CoffeeRepository coffee = <span class="hljs-keyword">new</span> CoffeeRepository();        MyIterator coffeeIterator = coffee.getIterator();        <span class="hljs-keyword">while</span> (coffeeIterator.hasNext()) &#123;            System.out.println(<span class="hljs-string">"Coffee: -&gt; "</span> + coffeeIterator.next());        &#125;    &#125;&#125;</code></pre><h4 id="JDK中的迭代"><a href="#JDK中的迭代" class="headerlink" title="JDK中的迭代"></a>JDK中的迭代</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        <span class="hljs-comment">// JDK</span>        List&lt;String&gt; names = Arrays.asList(<span class="hljs-string">"Han"</span>, <span class="hljs-string">"John"</span>, <span class="hljs-string">"Tomams"</span>);        Iterator&lt;String&gt; iterable = names.iterator();        <span class="hljs-keyword">while</span> (iterable.hasNext()) &#123;            System.out.println(<span class="hljs-string">"JDK Iterator: -&gt; "</span> + iterable.next());        &#125;        CodeUtils.spilt();        <span class="hljs-comment">// JDK</span>        names.forEach(s -&gt; System.out.println(<span class="hljs-string">"JDK forEach: -&gt; "</span> + s));    &#125;&#125;</code></pre><p>因此对于业务上没有什么要求且常见的数据结构，我们不再需要自行定义迭代器</p><p><font color="red">迭代器模式的设计思路：</font></p><ul><li>Iterator                     迭代器</li><li>Concretelterator      具体迭代器</li><li>Aggregate                 集合</li><li>ConcreteAggregate  具体集合</li></ul><p>简单来说，</p><ol><li>我们需要明确集合的类型（数组，链表，Map，树结构或者普通List）</li><li>我们需要定义迭代器的行为，是否有下一个（遍历完成），取值，移除等等</li><li>遍历的行为或者算法在具体的迭代器中实现，根据不同的数据结构和业务要求完成编码，实现访问一致，但细节不同的效果</li></ol><blockquote><p>如果看着有点模棱两可，就看完本文后，访问专题设计模式开源项目，里面有具体的代码示例，链接在最下面</p></blockquote><h3 id="遵循的设计原则"><a href="#遵循的设计原则" class="headerlink" title="遵循的设计原则"></a>遵循的设计原则</h3><ul><li>单一职责原则</li></ul><p>说明：迭代器类在设计中仅仅包含集合迭代的作用，它是把原本数据结构中的遍历抽取出来，达到  <font color="red">高内聚</font>  的效果。</p><p>所谓高内聚：当一个模块或一个类被设计成只支持一组相关功能时，我们说它具有 <font color="red">高内聚</font>  的特征。</p><h3 id="什么场景适合使用"><a href="#什么场景适合使用" class="headerlink" title="什么场景适合使用"></a>什么场景适合使用</h3><ul><li>访问一个聚合对象的内容而无需暴漏它的内部表示</li><li>支持对聚合对象的多种遍历</li><li>为遍历不同的聚合结构提供一个统一的接口</li></ul><h3 id="Code-生活中的实际应用"><a href="#Code-生活中的实际应用" class="headerlink" title="Code/生活中的实际应用"></a>Code/生活中的实际应用</h3><p>举一个不是很恰当的例子，我们都用自动贩卖机买过水，付钱之后它会自动滚出来，大家有没有想过它是怎么实现这个效果的呢？它支持瓶装的，罐装的，甚至还支持袋装的，方便面，口红等等五花八门的产品，它的内部结构可能都各不相同，但是最终的表现效果就是我们直接从出口处拿即可，这是不是迭代器模式的一种体现呢？</p><h3 id="迭代器模式UML图"><a href="#迭代器模式UML图" class="headerlink" title="迭代器模式UML图"></a>迭代器模式UML图</h3><p><img src="/2023/09/12/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/image-20200614115015075.png" srcset="/img/loading.gif" alt="image-20200614115015075"></p><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><h3 id="意图-1"><a href="#意图-1" class="headerlink" title="意图"></a>意图</h3><p>将对象组合成树形结构以表示 “部分-整体” 的层次结构，Composite使得用户对单个对象和组合对象的使用具有一致性</p><p><font color="red">说人话：</font>想想Java里的File类</p><h3 id="组合模式的误区"><a href="#组合模式的误区" class="headerlink" title="组合模式的误区"></a>组合模式的误区</h3><p>组合模式 <font color="red">不是</font> 一堆模式的组合！</p><h3 id="组合模式的诞生"><a href="#组合模式的诞生" class="headerlink" title="组合模式的诞生"></a>组合模式的诞生</h3><p>【<font color="blue">开发</font>】：老大，我在写菜单类的时候感觉好痛苦啊！</p><p>【<font color="red">BOSS</font>】：怎么了？</p><p>【<font color="blue">开发</font>】：菜单有真正的菜品，还有父级菜单啊，它们俩得维护两套逻辑，混在一起好难受！</p><p>【<font color="red">BOSS</font>】：你在操作文件的时候怎么不觉得难受？你咋不动动脑子想着抽象一下啊！</p><p>【<font color="blue">开发</font>】：对啊！我去改代码！</p><h3 id="HeadFirst-核心代码-1"><a href="#HeadFirst-核心代码-1" class="headerlink" title="HeadFirst 核心代码"></a>HeadFirst 核心代码</h3><p><strong><em>定义抽象行为</em></strong></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * ******************************</span><span class="hljs-comment"> * description:  定义抽象行为</span><span class="hljs-comment"> * ******************************</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MenuComponent</span> </span>&#123;    <span class="hljs-keyword">public</span> String name;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 添加</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(MenuComponent component)</span> <span class="hljs-keyword">throws</span> Exception</span>;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 移除</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(MenuComponent component)</span> <span class="hljs-keyword">throws</span> Exception</span>;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 获取菜单名</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 获取子菜单</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> MenuComponent <span class="hljs-title">getChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> <span class="hljs-keyword">throws</span> Exception</span>;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 打印菜单</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p><strong><em>实现 “整体”</em></strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Menu</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MenuComponent</span></span>&#123;    List&lt;MenuComponent&gt; menuComponents = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Menu</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(MenuComponent component)</span> </span>&#123;        <span class="hljs-keyword">this</span>.menuComponents.add(component);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(MenuComponent component)</span> </span>&#123;        <span class="hljs-keyword">this</span>.menuComponents.remove(component);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> MenuComponent <span class="hljs-title">getChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;        <span class="hljs-keyword">return</span> menuComponents.get(i);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"当前菜单项: "</span> + getName());        <span class="hljs-keyword">for</span> (MenuComponent component : menuComponents) &#123;            component.print();        &#125;    &#125;&#125;</code></pre><p><strong><em>实现 “部分”</em></strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MentItem</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MenuComponent</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MentItem</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(MenuComponent component)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"无法添加"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(MenuComponent component)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"无法移除"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> MenuComponent <span class="hljs-title">getChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"无子节点"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"    食物名: "</span> + getName());    &#125;&#125;</code></pre><p><strong><em>测试类</em></strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 推荐代码阅读顺序：</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> MenuComponent</span><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> Menu</span><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> MentItem</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Menu meat = <span class="hljs-keyword">new</span> Menu(<span class="hljs-string">"炒菜类"</span>);        MentItem item1 = <span class="hljs-keyword">new</span> MentItem(<span class="hljs-string">"宫保鸡丁"</span>);        MentItem item2 = <span class="hljs-keyword">new</span> MentItem(<span class="hljs-string">"剁椒鸡蛋"</span>);        MentItem item3 = <span class="hljs-keyword">new</span> MentItem(<span class="hljs-string">"鱼香肉丝"</span>);        Menu vegetable = <span class="hljs-keyword">new</span> Menu(<span class="hljs-string">"素食"</span>);        MentItem v1 = <span class="hljs-keyword">new</span> MentItem(<span class="hljs-string">"酸辣土豆丝"</span>);        MentItem v2 = <span class="hljs-keyword">new</span> MentItem(<span class="hljs-string">"爆炒包菜"</span>);        meat.add(item1);        meat.add(item2);        meat.add(item3);        vegetable.add(v1);        vegetable.add(v2);        meat.add(vegetable);        meat.print();    &#125;&#125;<span class="hljs-comment">/***</span><span class="hljs-comment"> * 输出内容：</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 当前菜单项: 炒菜类</span><span class="hljs-comment"> *     食物名: 宫保鸡丁</span><span class="hljs-comment"> *     食物名: 剁椒鸡蛋</span><span class="hljs-comment"> *     食物名: 鱼香肉丝</span><span class="hljs-comment"> * 当前菜单项: 素食</span><span class="hljs-comment"> *     食物名: 酸辣土豆丝</span><span class="hljs-comment"> *     食物名: 爆炒包菜</span><span class="hljs-comment"> */</span></code></pre><p><font color="red">组合模式的设计思路：</font></p><ul><li>Component      为组合的对象声明接口或抽象类</li><li>Leaf                   叶子节点（最小单元）</li><li>Composite       组合节点（即还有子节点的节点）</li><li>Client                客户端，调用方</li></ul><p>简单来说，</p><ol><li>当我们需要树形结构时，抽象叶子节点和组合节点（有子节点的节点）的共同行为</li><li>让两者实现同一个接口</li></ol><blockquote><p>如果看着有点模棱两可，就看完本文后，访问专题设计模式开源项目，里面有具体的代码示例，链接在最下面</p></blockquote><h3 id="什么场景适合使用-1"><a href="#什么场景适合使用-1" class="headerlink" title="什么场景适合使用"></a>什么场景适合使用</h3><ul><li>需要表示对象的部分-整体层次结构</li><li>希望用户忽略组合对象与单个对象的不同，用户统一地使用组合结构中所有对象</li></ul><h3 id="Code-生活中的实际应用-1"><a href="#Code-生活中的实际应用-1" class="headerlink" title="Code/生活中的实际应用"></a>Code/生活中的实际应用</h3><p>依然是一个不太恰当的例子，我们在操作文件和文件夹的时候，都有其移动，复制，重命名，查看文件大小等等功能，对于Java来说，它的底层实现是有一个 <code>是否是文件夹</code> 的方法来区分，但实际上这也是组合模式的根本思想，即对于表示 <font color="red">部分</font> 的对象，和 <font color="red">整体</font> 的对象，<font color="red">拥有统一的操作行为</font></p><h3 id="组合模式的UML图"><a href="#组合模式的UML图" class="headerlink" title="组合模式的UML图"></a>组合模式的UML图</h3><p><img src="/2023/09/12/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/image-20200614235513451.png" srcset="/img/loading.gif" alt="image-20200614235513451"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>迭代器模式：该模式在JDK中已经封装的非常好，我们其实不太需要再自行处理，不过在处理特殊数据结构时这种统一操作的思想仍然值得借鉴</li><li>组合模式：组合模式仅在需要树形结构的场景下可发挥巨大的作用，同样的，它规范不同类型对象的行为，统一操作的思想，值得我们借鉴</li></ul><h2 id="相关代码链接"><a href="#相关代码链接" class="headerlink" title="相关代码链接"></a>相关代码链接</h2><p><a href="https://github.com/kkzhilu/Kerwin-DesignPattern" target="_blank" rel="noopener">GitHub地址</a></p><ul><li>兼顾了《HeadFirst》以及《GOF》两本经典书籍中的案例</li><li>提供了友好的阅读指导</li></ul><p><img src="/2023/09/12/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/%E5%BE%AE%E4%BF%A1%E4%BA%8C%E7%BB%B4%E7%A0%81.png" srcset="/img/loading.gif" alt></p>]]></content>
    
    
    <categories>
      
      <category>编码及设计模式篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>迭代器和组合模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kerwin&#39;s Library</title>
    <link href="/2023/09/12/Kerwin&#39;s%20Library/"/>
    <url>/2023/09/12/Kerwin&#39;s%20Library/</url>
    
    <content type="html"><![CDATA[<h1 id="Kerwin’s-Library"><a href="#Kerwin’s-Library" class="headerlink" title="Kerwin’s Library"></a>Kerwin’s Library</h1><blockquote><p>这里是Kerwin的编程图书馆，通过ABC—Z#构建快速检索话语工具，专业名词等等</p></blockquote><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><h3 id="1-AbstractRoutingDataSource"><a href="#1-AbstractRoutingDataSource" class="headerlink" title="1.  AbstractRoutingDataSource"></a>1.  AbstractRoutingDataSource</h3><p>Spring + Mybtias实现数据源切换的核心类，需要重写<code>determineCurrentLookupKey</code>方法，动态的更换当前线程中数据源指向</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DynamicRoutingDataSource</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractRoutingDataSource</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">determineCurrentLookupKey</span><span class="hljs-params">()</span> </span>&#123;        logger.info(<span class="hljs-string">"切换数据源: "</span> + DataSourceContextHolder.getDbType());        <span class="hljs-keyword">return</span> DataSourceContextHolder.getDbType();    &#125;&#125;</code></pre><h3 id="2-Adapter-Pattern"><a href="#2-Adapter-Pattern" class="headerlink" title="2. Adapter Pattern"></a>2. Adapter Pattern</h3><p>文章详情链接：<a href="https://juejin.im/post/5ed688c051882543413c1168" target="_blank" rel="noopener">https://juejin.im/post/5ed688c051882543413c1168</a></p><p>适配器模式</p><p>1）将一个类的接口转换成客户希望的另外一个接口，adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作</p><p>2）核心代码如下：</p><p>简单来说，当我们需要对两个本不相关的接口混合一起用时，需要用一个适配器实现A接口，持有B对象，再用B对象的方法去填充A接口的方法，同时还可以增加一些其他的逻辑</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 火鸡适配器</span><span class="hljs-comment"> * 实现鸭子接口同时持有火鸡对象，在实现的接口处用火鸡对象的方法填充一下（同时还可以做额外的事情）</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TurkeyAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Duck</span></span>&#123;    Turkey turkey;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quack</span><span class="hljs-params">()</span> </span>&#123;        turkey.gobble();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123;        turkey.fly();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TurkeyAdapter</span><span class="hljs-params">(Turkey turkey)</span> </span>&#123;        <span class="hljs-keyword">this</span>.turkey = turkey;    &#125;&#125;</code></pre><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><h3 id="1-Command-Pattern"><a href="#1-Command-Pattern" class="headerlink" title="1. Command Pattern"></a>1. Command Pattern</h3><p>文章详情链接：<a href="https://juejin.im/post/5ed5265851882543477c7abf" target="_blank" rel="noopener">https://juejin.im/post/5ed5265851882543477c7abf</a></p><p>命令模式</p><p>1）将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；</p><p>2）对请求排队或记录请求日志，以及支持可撤销的操作</p><p>3）核心代码如下：</p><p>代码的核心即：把请求抽象为一个命令，把执行命令的接收者和命令本身分离，交由第三方类（Invoker）去管理，达到解耦的目的</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LightOnCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Command</span> </span>&#123;    Light light;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LightOnCommand</span><span class="hljs-params">(Light light)</span> </span>&#123;        <span class="hljs-keyword">this</span>.light = light;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;        light.on();    &#125;&#125;</code></pre><h3 id="2-Composite-Pattern"><a href="#2-Composite-Pattern" class="headerlink" title="2. Composite Pattern"></a>2. Composite Pattern</h3><p>文章详情链接：<a href="https://juejin.im/post/5ee64aade51d45789671b974" target="_blank" rel="noopener">https://juejin.im/post/5ee64aade51d45789671b974</a></p><p>组合模式</p><p>意图：将对象组合成树形结构以表示 “部分-整体” 的层次结构，Composite使得用户对单个对象和组合对象的使用具有一致性</p><p>核心代码：让表示部分的实体和表示整体的实体实现同一个接口（或抽象类）</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Menu</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MenuComponent</span></span>&#123;    List&lt;MenuComponent&gt; menuComponents = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Menu</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(MenuComponent component)</span> </span>&#123;        <span class="hljs-keyword">this</span>.menuComponents.add(component);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(MenuComponent component)</span> </span>&#123;        <span class="hljs-keyword">this</span>.menuComponents.remove(component);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> MenuComponent <span class="hljs-title">getChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;        <span class="hljs-keyword">return</span> menuComponents.get(i);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"当前菜单项: "</span> + getName());        <span class="hljs-keyword">for</span> (MenuComponent component : menuComponents) &#123;            component.print();        &#125;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MentItem</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MenuComponent</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MentItem</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(MenuComponent component)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"无法添加"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(MenuComponent component)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"无法移除"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> MenuComponent <span class="hljs-title">getChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"无子节点"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"    食物名: "</span> + getName());    &#125;&#125;</code></pre><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><h3 id="1-determineCurrentLookupKey"><a href="#1-determineCurrentLookupKey" class="headerlink" title="1. determineCurrentLookupKey"></a>1. determineCurrentLookupKey</h3><p>determineCurrentLookupKey方法是Mybatis数据源切换时需要重写的方法，如下图所示：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DynamicRoutingDataSource</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractRoutingDataSource</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">determineCurrentLookupKey</span><span class="hljs-params">()</span> </span>&#123;        logger.info(<span class="hljs-string">"切换数据源: "</span> + DataSourceContextHolder.getDbType());        <span class="hljs-keyword">return</span> DataSourceContextHolder.getDbType();    &#125;&#125;</code></pre><h3 id="2-Decorator-Pattern"><a href="#2-Decorator-Pattern" class="headerlink" title="2. Decorator Pattern"></a>2. Decorator Pattern</h3><p>文章详情链接：<a href="https://juejin.im/user/5c729b0b5188255cf64b2da6/posts" target="_blank" rel="noopener">https://juejin.im/user/5c729b0b5188255cf64b2da6/posts</a></p><p>装饰器模式</p><p>1）动态地给一个对象添加一些额外的职责，就增加功能来说，Decorator模式相比生成子类更为灵活</p><p>2）设计原则：</p><ul><li><strong>「对扩展开放，对修改关闭」</strong>：完美实现了不修改其代码达到增强方法的目的</li><li><strong>「针对接口编程」</strong>：装饰器与其本身都有同样的父级</li></ul><p>3）核心代码如下：（装饰类和原类实现同一个接口，装饰类持有原类对象，在实现自身方法时囊括原类对象的方法，达到增强的目的）</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 装饰器类 注意它利用了组合的方式，同时注意函数实现的部分</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MilkDecorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Component</span> </span>&#123;    Component coffe;    MilkDecorator(Component coffe) &#123;        <span class="hljs-keyword">this</span>.coffe = coffe;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-keyword">return</span> coffe.getName() + <span class="hljs-string">", 牛奶"</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getSpend</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> coffe.getSpend() + <span class="hljs-number">2</span>D;    &#125;&#125;</code></pre><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><h3 id="1-Explain"><a href="#1-Explain" class="headerlink" title="1. Explain"></a>1. Explain</h3><p>Mysql中的用以解释数据库查询的关键字，如：EXPLAIN SELECT * FROM user_coll;</p><pre><code class="hljs asciidoc">mysql&gt; EXPLAIN SELECT * FROM <span class="hljs-code">`user_coll`</span> where pid = 1;<span class="hljs-code">+----+</span>-<span class="hljs-code">+-----+</span>-<span class="hljs-code">+---+</span><span class="hljs-code">+---+</span><span class="hljs-code">++---+</span>| id | select<span class="hljs-emphasis">_type | table     | type  | possible_</span>keys | key  | key<span class="hljs-emphasis">_len | ref  | rows | Extra                 |</span><span class="hljs-emphasis">+----+-+-----+-+---++---+++---+</span><span class="hljs-emphasis">|  1 | SIMPLE      | user_</span>coll | index | pid           | demo | 45      | NULL |    3 | Using where |<span class="hljs-code">+----+</span>-<span class="hljs-code">+-----+</span>-<span class="hljs-code">+---+</span><span class="hljs-code">+---+</span><span class="hljs-code">++---+</span>1 row in set (0.05 sec)</code></pre><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><h3 id="1-final"><a href="#1-final" class="headerlink" title="1. final"></a>1. final</h3><p>1）修饰类则不可被继承，修饰方法则不可被重写，修饰变量则不可被复制</p><blockquote><p>在进行框架设计或者组件化代码，开源代码时，通过给方法或者变量附加final关键字可以增强语意</p></blockquote><h3 id="2-Factory-Pattern"><a href="#2-Factory-Pattern" class="headerlink" title="2. Factory Pattern"></a>2. Factory Pattern</h3><p>文章详情链接：<a href="https://juejin.im/post/5ecbcf19e51d4578a475ea5e" target="_blank" rel="noopener">https://juejin.im/post/5ecbcf19e51d4578a475ea5e</a></p><p>工厂模式：简单工厂，工厂方法以及抽象工厂模式</p><p>意图：工厂模式属于对象创建型模式，无论是上述三种的哪一种都是为了同一个设计原则即<font color="red">依赖抽象，不要依赖具体</font></p><p>简单来说就是把<font color="blue">复杂对象创建（初始化）的细节</font>或者<font color="blue">依赖关系经常可能发生变化的细节</font>交给一个第三方类（工厂类），避免在业务逻辑中书写不必要的内容</p><p><strong><em>简单工厂核心代码：</em></strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Factory</span> </span>&#123;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 产品订购方案</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractCPU <span class="hljs-title">orderCpu</span> <span class="hljs-params">()</span> </span>&#123;        AbstractCPU cpu = generateCpu();        cpu.show();        cpu.prepare();        cpu.box();        <span class="hljs-comment">// 假设有相同的业务处理逻辑...</span>        <span class="hljs-keyword">return</span> cpu;    &#125;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> AbstractCPU <span class="hljs-title">generateCpu</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p><strong><em>抽象工厂核心代码：</em></strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractFactory</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 创建CPU对象</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> CPU对象</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> AbstractCPU <span class="hljs-title">createCpu</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 创建主板对象</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 主板对象</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> AbstractMotherboard <span class="hljs-title">createMainboard</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p><strong>相同点：</strong></p><ul><li>所有的工厂都是用来封装对象的创建</li><li>简单工厂，虽然不是真正的设计模式，但仍不失为一个简单的方法，可以进行解耦</li><li>所有工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合</li><li>依赖倒置原则，指导我们避免依赖具体类型，而要尽量依赖抽象</li><li>工厂是很有威力的技巧，帮助我们针对抽象编程，而不是具体类编程</li></ul><p><strong>工厂方法：</strong></p><ul><li>工厂方法利用继承：把对象的创建委托给子类，子类实现工厂方法来创建对象</li><li>工厂方法允许类将实例化延迟到子类实现</li></ul><p><strong>抽象工厂：</strong></p><ul><li>抽象工厂使用对象组合：对象的创建被实现在工厂接口所暴露出来的方法中</li><li>抽象工厂创建相关的<font color="red">对象家族</font>，而不需要依赖它们的具体类</li></ul><h3 id="3-Facade-Pattern"><a href="#3-Facade-Pattern" class="headerlink" title="3. Facade Pattern"></a>3. Facade Pattern</h3><p>文章详情链接：<a href="https://juejin.im/post/5ed688c051882543413c1168" target="_blank" rel="noopener">https://juejin.im/post/5ed688c051882543413c1168</a></p><p>外观模式</p><p>意图：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用</p><p>核心代码如下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FacadeComputer</span> </span>&#123;    <span class="hljs-keyword">private</span> Cpu cpu;    <span class="hljs-keyword">private</span> Ram ram;    <span class="hljs-keyword">private</span> Ssd ssd;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FacadeComputer</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.cpu = <span class="hljs-keyword">new</span> Cpu();        <span class="hljs-keyword">this</span>.ram = <span class="hljs-keyword">new</span> Ram();        <span class="hljs-keyword">this</span>.ssd = <span class="hljs-keyword">new</span> Ssd();    &#125;    <span class="hljs-comment">/** Cpu On **/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCpu</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.cpu.open();    &#125;    <span class="hljs-comment">/** Ram On **/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onRam</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.ram.open();    &#125;    <span class="hljs-comment">/** Ssd On **/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSsd</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.ssd.open();    &#125;    <span class="hljs-comment">/** All On **/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">allOn</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.cpu.open();        <span class="hljs-keyword">this</span>.ram.open();        <span class="hljs-keyword">this</span>.ssd.open();    &#125;&#125;</code></pre><h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><h2 id="H"><a href="#H" class="headerlink" title="H"></a>H</h2><h2 id="I"><a href="#I" class="headerlink" title="I"></a>I</h2><h3 id="1-InitializingBean"><a href="#1-InitializingBean" class="headerlink" title="1. InitializingBean"></a>1. InitializingBean</h3><p>1） InitializingBean接口为bean提供了初始化方法的方式，它只包括afterPropertiesSet方法，凡是继承该接口的类，在初始化bean的时候会执行该方法 </p><p>2） 两种初始化bean的方式之一，另一种是通过在配置文件中指定init-method</p><p>3）可以利用其初始化Bean的特征，进行通用Bean的注入和处理，如下代码所示</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomStrategyFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InitializingBean</span> </span>&#123;    <span class="hljs-comment">// 可获取到所有实现CustomStrategyInterface的实现类</span>    <span class="hljs-meta">@Autowired</span>    List&lt;CustomStrategyInterface&gt; interfaces;    <span class="hljs-comment">// MAP存储对象</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, CustomStrategyInterface&gt; INTERFACES = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">1024</span>);    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, CustomStrategyInterface&gt; <span class="hljs-title">getInterfaces</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> INTERFACES;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">for</span> (CustomStrategyInterface demo : interfaces) &#123;            demo.handle();            INTERFACES.put(demo.getClass().getSimpleName(), demo);        &#125;    &#125;&#125;</code></pre><h3 id="2-Iterator-Pattern"><a href="#2-Iterator-Pattern" class="headerlink" title="2. Iterator Pattern"></a>2. Iterator Pattern</h3><p>文章详情链接：<a href="https://juejin.im/post/5ee64aade51d45789671b974" target="_blank" rel="noopener">https://juejin.im/post/5ee64aade51d45789671b974</a></p><p>迭代器模式</p><p>意图：提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴漏该对象的内部表示</p><p>核心代码如下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyContainer</span> </span>&#123;    <span class="hljs-function">MyIterator <span class="hljs-title">getIterator</span><span class="hljs-params">()</span></span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyIterator</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">Object <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FoodRepository</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MyContainer</span> </span>&#123;    String[] names = &#123;<span class="hljs-string">"宫保鸡丁"</span>, <span class="hljs-string">"麻辣香锅"</span>, <span class="hljs-string">"油闷大虾"</span>&#125;;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> MyIterator <span class="hljs-title">getIterator</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NameIterator();    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NameIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MyIterator</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> index;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> index &lt; names.length;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;           <span class="hljs-keyword">return</span> hasNext() ? names[index++] : <span class="hljs-keyword">null</span>;        &#125;        NameIterator() &#123;            index = <span class="hljs-number">0</span>;        &#125;    &#125;&#125;</code></pre><h2 id="J"><a href="#J" class="headerlink" title="J"></a>J</h2><h3 id="1-Jstack"><a href="#1-Jstack" class="headerlink" title="1. Jstack"></a>1. Jstack</h3><p> jstack能得到运行java程序的java stack和native stack的信息 </p><h2 id="K"><a href="#K" class="headerlink" title="K"></a>K</h2><h2 id="L"><a href="#L" class="headerlink" title="L"></a>L</h2><h2 id="M"><a href="#M" class="headerlink" title="M"></a>M</h2><h2 id="N"><a href="#N" class="headerlink" title="N"></a>N</h2><h2 id="O"><a href="#O" class="headerlink" title="O"></a>O</h2><h3 id="1-Observer-Pattern"><a href="#1-Observer-Pattern" class="headerlink" title="1. Observer Pattern"></a>1. <strong>Observer Pattern</strong></h3><p>文章详情链接：<a href="https://juejin.im/post/5ec2a1dde51d454ddf23697d" target="_blank" rel="noopener">https://juejin.im/post/5ec2a1dde51d454ddf23697d</a></p><p>观察者模式</p><p>1）具备极强的解耦能力，可以很好的优化代码设计</p><p>2）JDK已默认实现，具备推拉模式</p><p>3）设计原则：</p><p><strong>「封装变化」</strong></p><ul><li>在观察者模式中会经常改变的是主题的状态，以及观察者的数目和类型</li><li>我们可以改变依赖于主题状态的对象，但是不必改变主题本身，这便是提前规划</li></ul><p><strong>「针对接口编程」</strong></p><ul><li>主题和观察者都使用了接口</li><li>观察者利用主题的接口向主题注册</li><li>主题利用观察者接口通知观察者，可以使两者之间正常交互，同时又具有松耦合的特性</li></ul><p><strong>「多使用组合」</strong></p><ul><li>观察者模式利用组合将许多观察者组合进主题中</li><li>它们之间的关系并不是通过继承得到，而是在运行时动态改变</li></ul><p>4）核心代码如下：（某一个目标持有观察者容器，可以增加和移除观察者，观察者实现同一个接口，当触发时调用容器内所有对象的更新方法即可）</p><pre><code class="hljs java"><span class="hljs-comment">// 核心代码</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Weather</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observable</span> </span>&#123;    <span class="hljs-keyword">private</span> List&lt;Observer&gt; observers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addObserver</span><span class="hljs-params">(Observer observer)</span> </span>&#123;        observers.add(observer);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeObserver</span><span class="hljs-params">(Observer observer)</span> </span>&#123;        observers.remove(observer);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObservers</span><span class="hljs-params">(WeatherData data)</span> </span>&#123;        <span class="hljs-keyword">for</span> (Observer observer : observers)            observer.update(data);    &#125;&#125;</code></pre><h2 id="P"><a href="#P" class="headerlink" title="P"></a>P</h2><h3 id="1-Proxy-Pattern"><a href="#1-Proxy-Pattern" class="headerlink" title="1. Proxy Pattern"></a>1. <strong>Proxy Pattern</strong></h3><p>文章详情链接：<a href="https://juejin.im/post/5ef2b053f265da02e3401e5c" target="_blank" rel="noopener">https://juejin.im/post/5ef2b053f265da02e3401e5c</a></p><p>代理模式</p><p><strong>「意图」</strong>：为其他对象提供一种代理以控制对这个对象的访问</p><p><strong>「设计原则」</strong></p><ul><li>封装变化：在父级接口中提供 default 方法，子类实现其对应的状态方法即可</li><li>多用组合，少用继承：代理模式经常和策略模式做对比，它们都是利用组合而非继承增强其变化和能力</li></ul><p><strong>「核心代码」</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PhoneInterface</span> </span>&#123;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 更新电话号码</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> phoneNum    电话号码</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception  可能抛出Exception 异常</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updatePhone</span><span class="hljs-params">(Long phoneNum)</span></span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">// 核心代理类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhoneServiceProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PhoneInterface</span> </span>&#123;    <span class="hljs-comment">/** 代理模式一般自行New对象, 反观装饰器模式则是传入对象 **/</span>    <span class="hljs-keyword">private</span> PhoneInterface phoneInterface;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PhoneServiceProxy</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.phoneInterface = <span class="hljs-keyword">new</span> PhoneServiceImpl();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updatePhone</span><span class="hljs-params">(Long phoneNum)</span> </span>&#123;        before(phoneNum);        phoneInterface.updatePhone(phoneNum);        after();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">(Long phoneNum)</span> </span>&#123;        System.out.println(MessageFormat.format(<span class="hljs-string">"log start time:&#123;0&#125; , phoneNum is: &#123;1&#125;"</span>, <span class="hljs-keyword">new</span> Date(), phoneNum));        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == phoneNum || String.valueOf(phoneNum).length() != <span class="hljs-number">11</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Update phoneNum fail, phoneNum is wrong."</span>);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(MessageFormat.format(<span class="hljs-string">"log end time:&#123;0&#125;"</span>, <span class="hljs-keyword">new</span> Date()));    &#125;&#125;</code></pre><h2 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h2><h2 id="R"><a href="#R" class="headerlink" title="R"></a>R</h2><h3 id="1-redirect"><a href="#1-redirect" class="headerlink" title="1. redirect"></a>1. redirect</h3><p>重定向关键字，使用方式如：</p><pre><code class="hljs java"><span class="hljs-keyword">return</span> <span class="hljs-string">"redirect:"</span> + redirectUri;</code></pre><h3 id="2-Rancher"><a href="#2-Rancher" class="headerlink" title="2. Rancher"></a>2. Rancher</h3><p>Rancher是一个开源的企业级容器管理平台。通过Rancher，企业再也不必自己使用一系列的开源软件去从头搭建容器服务平台。Rancher提供了在生产环境中使用的管理Docker和Kubernetes的全栈化容器部署与管理平台（Testin云测使用中）</p><h2 id="S"><a href="#S" class="headerlink" title="S"></a>S</h2><h3 id="1-synchronize"><a href="#1-synchronize" class="headerlink" title="1. synchronize"></a>1. <strong>synchronize</strong></h3><p>1）基于字节码底层实现的Java对象锁</p><p>2）具有锁升级的特性，偏向锁，轻量级锁，重量级锁，但是无法降级</p><h3 id="2-Singleton-Pattern"><a href="#2-Singleton-Pattern" class="headerlink" title="2. Singleton Pattern"></a>2. Singleton Pattern</h3><p>文章详情链接：<a href="https://juejin.im/post/5ecbcabc6fb9a047d070c779" target="_blank" rel="noopener">https://juejin.im/post/5ecbcabc6fb9a047d070c779</a></p><p>意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p>推荐的实现方式：</p><p><strong><em>懒汉型之双重锁校验：</em></strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyTypeSingleton</span> </span>&#123;    <span class="hljs-comment">// volatile关键字修饰，防止指令重排</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> App app = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * Double Check Lock（DCL） 双重锁校验</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">static</span> App <span class="hljs-title">getInstanceByDCL</span> <span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == app) &#123;            <span class="hljs-keyword">synchronized</span> (LazyTypeSingleton<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == app) &#123;                    System.out.println(<span class="hljs-string">"APP - 饿汉模式DCL 双重锁校验"</span>);                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> App();                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> app;    &#125;&#125;</code></pre><p><strong><em>静态内部类方式</em></strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnterTypeSingleton</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">InnterTypeSingleton</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException();    &#125;    <span class="hljs-comment">// 静态内部类方式，类似饿汉保证天然的线程安全</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span></span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> App app = <span class="hljs-keyword">new</span> App();    &#125;    <span class="hljs-function"><span class="hljs-keyword">static</span> App <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"APP - 静态内部类方式(Holder)"</span>);        <span class="hljs-keyword">return</span> SingletonHolder.app;    &#125;&#125;</code></pre><p><strong><em>枚举方式</em></strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span>  EnumSingleton &#123;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * APP对象</span><span class="hljs-comment">     */</span>    APP;    <span class="hljs-keyword">private</span> App app;    EnumSingleton() &#123;        app = <span class="hljs-keyword">new</span> App();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> App <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"**************************"</span>);        System.out.println(<span class="hljs-string">"APP - 枚举方式"</span>);        <span class="hljs-keyword">return</span> app;    &#125;&#125;</code></pre><h3 id="3-Strategy-Pattern"><a href="#3-Strategy-Pattern" class="headerlink" title="3. Strategy Pattern"></a>3. Strategy Pattern</h3><p>文章详情链接：<a href="https://juejin.im/post/5eb67fc46fb9a043830f597a" target="_blank" rel="noopener">https://juejin.im/post/5eb67fc46fb9a043830f597a</a></p><p>意图：定义个一个算法族， 各个算法的实现可以相互替换， 算法的实现和具体的算法使用场景隔离</p><p>核心代码：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Duck</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 飞行行为是动态的，可能会变的，因此抽成多个接口的组合，而不是让Duck类继承</span><span class="hljs-comment">     */</span>    FlyBehavior flyBehavior;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 每个鸭子的叫声不同，抽象成接口</span><span class="hljs-comment">     */</span>    QuackBehavior quackBehavior;&#125;</code></pre><p>遵循的设计原则：</p><ul><li>封装变化</li><li>多用组合，少用继承</li><li>针对接口编程，而不是针对实现编程</li></ul><h3 id="4-State-Pattern"><a href="#4-State-Pattern" class="headerlink" title="4. State Pattern"></a>4. State Pattern</h3><p>文章详情链接：<a href="https://juejin.im/post/5ee8f64be51d452f9c27e66a" target="_blank" rel="noopener">https://juejin.im/post/5ee8f64be51d452f9c27e66a</a></p><p>意图：允许一个对象在其内部状态改变时改变它的行为</p><p>核心代码：</p><p><strong><em>状态接口</em></strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">State</span> </span>&#123;    <span class="hljs-comment">/** 投币 **/</span>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">giveMoney</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"无法投币"</span>);    &#125;    <span class="hljs-comment">/** 移动滑杆 **/</span>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">move</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"无法移动滑杆"</span>);    &#125;    <span class="hljs-comment">/** 抓取 **/</span>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">grab</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"无法抓取"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">changeState</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p><strong><em>实际状态类</em></strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MoneyState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">State</span></span>&#123;    Context context;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MoneyState</span><span class="hljs-params">(Context context)</span> </span>&#123;        <span class="hljs-keyword">this</span>.context = context;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">giveMoney</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"已投币!"</span>);        changeState();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeState</span><span class="hljs-params">()</span> </span>&#123;        context.setExecute(<span class="hljs-keyword">new</span> MoveState(context));    &#125;&#125;</code></pre><p><strong><em>遵循的设计原则</em></strong></p><ul><li>封装变化：在父级接口中提供 default 方法，子类实现其对应的状态方法即可</li><li>多用组合，少用继承：状态模式经常和策略模式做对比，它们都是利用组合而非继承增强其变化和能力</li></ul><blockquote><p><font color="red">状态模式拓展：</font> 当N种状态方法名不一样时，我们在接口中实现 default 关键字，保证其默认方法，子类重写自身对应的核心方法即可，当所有状态的方法名一致时，通过 while(true) 循环执行，也可以达到一种奇妙的效果</p><p>非常适合后台多流程的情况</p></blockquote><h2 id="T"><a href="#T" class="headerlink" title="T"></a>T</h2><h3 id="1-Template-Method-Pattern"><a href="#1-Template-Method-Pattern" class="headerlink" title="1. Template Method Pattern"></a>1. <strong>Template Method Pattern</strong></h3><p>文章详情链接：<a href="https://juejin.im/post/5ede6ce151882543485772ea" target="_blank" rel="noopener">https://juejin.im/post/5ede6ce151882543485772ea</a></p><p>模板方法模式意图：</p><p>定义一个操作中的算法的骨架，将一些步骤延迟到子类中。 Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤</p><p>核心代码：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TemplateClass</span> </span>&#123; <span class="hljs-comment">/***</span><span class="hljs-comment">  * 模板方法，用来控制炒菜的流程 （炒菜的流程是一样的-复用）</span><span class="hljs-comment">  * 可根据需求申明为final，防止子类覆盖这个方法，导致流程的执行顺序</span><span class="hljs-comment">  */</span> <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cookProcess</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 第一步：倒油</span>  <span class="hljs-keyword">this</span>.pourOil();  <span class="hljs-comment">// 第二步：热油</span>  <span class="hljs-keyword">this</span>.heatOil();  <span class="hljs-comment">// 第三步：倒蔬菜</span>  <span class="hljs-keyword">this</span>.pourVegetable();  <span class="hljs-comment">// 配合钩子函数, 确定是否需要倒调味料</span>  <span class="hljs-keyword">if</span> (needSauce()) &#123;   <span class="hljs-keyword">this</span>.pourSauce();  &#125;  <span class="hljs-comment">// 第五步：翻炒</span>  <span class="hljs-keyword">this</span>.fry(); &#125; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pourOil</span><span class="hljs-params">()</span> </span>&#123;  System.out.println(<span class="hljs-string">"倒油"</span>); &#125; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heatOil</span><span class="hljs-params">()</span> </span>&#123;  System.out.println(<span class="hljs-string">"热油"</span>); &#125; <span class="hljs-comment">/***</span><span class="hljs-comment">  * 需要变化的部分就定义为抽象</span><span class="hljs-comment">  */</span> <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pourVegetable</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pourSauce</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">/***</span><span class="hljs-comment">  * 钩子函数, 影响方法调用逻辑</span><span class="hljs-comment">  */</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">needSauce</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>; &#125; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fry</span><span class="hljs-params">()</span> </span>&#123;  System.out.println(<span class="hljs-string">"炒啊炒啊炒到熟啊"</span>); &#125;&#125;</code></pre><p><strong><em>遵循的设计原则</em></strong></p><p><strong>「封装变化」</strong></p><ul><li>在抽象基类中，我们可以有已经实现的方法供子类调用</li><li>在抽象基类中，对于必然不同的方法逻辑，定义为抽象的，供子类自行实现</li></ul><p><strong>「好莱坞原则」</strong></p><ul><li>别找我，我会找你   指的是底层代码（具体的实现类）不依赖于高层代码，我们在本次的SSO实战中也体现了，直接依赖接口，实现类只是作为真正的执行者而已</li></ul><h2 id="U"><a href="#U" class="headerlink" title="U"></a>U</h2><h2 id="V"><a href="#V" class="headerlink" title="V"></a>V</h2><h3 id="1-volatile"><a href="#1-volatile" class="headerlink" title="1. volatile"></a>1. volatile</h3><p>1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的 </p><p>2）禁止进行指令重排序 </p><blockquote><p>经典应用：一写多读多读场景可以保证线程安全，另外如单理模式中禁止指令重排等</p></blockquote><h2 id="W"><a href="#W" class="headerlink" title="W"></a>W</h2><h2 id="X"><a href="#X" class="headerlink" title="X"></a>X</h2><h2 id="Y"><a href="#Y" class="headerlink" title="Y"></a>Y</h2><h2 id="Z"><a href="#Z" class="headerlink" title="Z"></a>Z</h2><h2 id><a href="#" class="headerlink" title="#"></a>#</h2>]]></content>
    
    
    <categories>
      
      <category>程序人生篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kerwin&#39;s Library</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac工具 BitBar</title>
    <link href="/2023/09/12/Mac%E5%B7%A5%E5%85%B7%20BitBar/"/>
    <url>/2023/09/12/Mac%E5%B7%A5%E5%85%B7%20BitBar/</url>
    
    <content type="html"><![CDATA[<blockquote><p>借助 BitBar，我们可以自己在 Mac 上做出实用的菜单栏插件小工具。</p></blockquote><p>提到生存在 macOS 菜单栏里面的小工具，我们就不得不提到 <a href="https://sspai.com/post/41089" target="_blank" rel="noopener">iStat Menu</a> 这一应用。强调「系统监控」的 iStat Menu，其华丽的外表之下真正的工作原理是：<strong>每隔一段时间，执行一个程序，获取监控对象的各项数据，并将结果展示给我们看。</strong>查看本机 CPU、内存等使用率，检测上传、下载速度等就是这一原理，查看天气、日程、月相、待办事项等同样也是这一原理。</p><p>![](Mac工具 BitBar/15806642732044.jpg)拥有丰富监控项目与样式的 macOS 菜单栏小工具界标杆：iStat Menu</p><p>既然都是「执行程序、获取数据」，那我们能不能直接不借助于付费的 iStat Menu，用开源的解决方案来实现自己的 macOS 菜单栏小工具呢？当然可以，BitBar 正是为此而生。开源免费的 BitBar，是专门为 macOS 菜单栏准备，能够将任何脚本、程序、代码的运行结果输出到菜单栏上面的应用。几乎不需要任何动手能力，我们就能够用 BitBar 大致复刻 iStat Menu 的功能。虽然可能做不到同样精致的界面，但单就功能上的实现，BitBar 还是值得尝试的。</p><h2 id="安装运行"><a href="#安装运行" class="headerlink" title="安装运行"></a>安装运行</h2><p>BitBar 开源在 <a href="https://github.com/matryer/bitbar" target="_blank" rel="noopener">GitHub - matryer/bitbar</a>，我们可以直接到其 <a href="https://github.com/matryer/bitbar/releases" target="_blank" rel="noopener">Release 页面</a> 下载安装 macOS 版本的 BitBar。使用 Homebrew 的同学当然可以用下面的命令安装 BitBar：</p><pre><code class="hljs mipsasm"><span class="hljs-keyword">brew </span>cask <span class="hljs-keyword">install </span><span class="hljs-keyword">bitbar</span></code></pre><p>安装成功之后，我们首次运行 BitBar 时，BitBar 会要求我们指定一个「插件目录」，这里我们需要记住这一目录的位置，之后会频繁用到。在正式开始安装插件、编写脚本之前，我们先来聊聊 BitBar 在华丽的外观背后，是如何具体运作的。</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>纵观 BitBar 的工作原理，我们可以发现：实际上 BitBar 就是一个为监控系统执行的程序提供一个方便的输出环境。前面提到的 BitBar 的「插件」安装目录（文件夹），其实际上就是所有 BitBar 需要执行的程序的本体所在。在实际工作中，BitBar 正是从这一目录下寻找可执行的程序，定时执行相应的程序，并根据程序输出将结果显示在我们 macOS 的菜单栏之中。</p><p>![](Mac工具 BitBar/15806642732112.png)BitBar 底层工作原理</p><p>我们用一个简单的例子来解释这一相对抽象的过程 —— <strong>显示当前系统日期</strong>。</p><p>日期在 macOS 上可以用简单的命令 <code>date</code> 来获取，打开终端（<code>Terminal.app</code>），输入 <code>date</code> 并回车，即可得到当前的系统时间、星期、日期、时区等等信息。这里，命令 <code>date</code> 就是我们「系统监控」的程序本体，其类似 <code>Mon Feb 3 00:54:14 CST 2020</code> 的输出即为我们 BitBar 接收的脚本输出，最终 BitBar 即会将这一结果显示于 macOS 菜单栏上面，作为查看日期的「小工具」。</p><p>![](Mac工具 BitBar/15806642732124.jpg)使用命令 date 获取当前系统日期</p><p>当然，一个命令远远不够，我们需要将命令放在一个文件中，定义其运行方法，从而告诉 BitBar：每隔一段时间，用「这个方法」执行「这个文件」，就可以得到当前系统日期啦。我们在刚刚给 BitBar 指定的「插件」安装目录下创建一个名称为 date.1s.sh 的文件。这里，识别文件名就是 BitBar 设置程序运行方式的第一步。文件名中：</p><ul><li><code>date</code> 即为文件的宽泛名称，程序的标识符</li><li><code>1s</code> 表示每隔 1s 执行一次本程序</li><li><code>sh</code> 为文件后缀，这里表示此程序为一个 Shell 脚本程序，可以用 Bash 来运行</li></ul><p>各个项目之间用 <code>.</code> 拼接起来，成为一个以 <code>{文件名}.{执行频率}.{扩展名}</code> 为格式的完整文件名。我们打开这一文件，向其中填写如下的内容：</p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>date</code></pre><p>之后，如果我们保存文件，并重新加载 BitBar，那么不出意外我们就可以看到 BitBar 的一个菜单栏项目开始生效：日期、星期、时间正确显示并每隔 1s 刷新一次。</p><p>![](Mac工具 BitBar/15806642732132.gif)BitBar 每秒执行一次命令获取当前时间</p><p>我们看一下刚刚输入文件的内容：文件分为两行，第一行 <code>#!/bin/bash</code> 在程序界被称为 <a href="https://zh.wikipedia.org/wiki/Shebang" target="_blank" rel="noopener">Shebang</a> —— 表示程序执行方式，这里即为用 <code>/bin/bash &lt;文件名称&gt;</code> 的命令执行程序；第二行 <code>date</code> 即为执行程序输出结果的「命令」—— 获取当前日期，就在这里我们会获取到当前系统时间的输出，并将结果传递给 BitBar 显示于菜单栏上。我们的第一个最为简单的 BitBar 小插件就算完成啦。✌️</p><p>当然，BitBar 可实现的功能比上面这一例子要多得多，我们不仅可以简单绘制用户界面、提供自定义执行脚本、实现网络请求，还可以直接下载安装其他用户编写完好的 BitBar 插件。BitBar 的插件库非常丰富，我们直接访问其 <a href="https://getbitbar.com/" target="_blank" rel="noopener">官方网站</a>，在侧边栏即可选择不同的插件分类，我们找到选好的插件，点击 <code>+ Add to BitBar</code> 即可直接安装到我们本机的 BitBar，之后经过一些调整（比如安装插件的依赖、填写必要的 API 参数等），我们刷新 BitBar 即可直接使用相应的插件。</p><p>![](Mac工具 BitBar/15807157397459.png)在 BitBar 官网下载安装插件</p><h2 id="用插件全面监控系统，还有更多功能"><a href="#用插件全面监控系统，还有更多功能" class="headerlink" title="用插件全面监控系统，还有更多功能"></a>用插件全面监控系统，还有更多功能</h2><p>除了实现类似 iStat Menu 的系统监控功能，BitBar 还有像汇率换算、查看任务等许多实用插件。接下来就介绍几款好用的插件给你。</p><h3 id="武汉疫情监控"><a href="#武汉疫情监控" class="headerlink" title="武汉疫情监控"></a>武汉疫情监控</h3><p>在今年武汉新型肺炎爆发后，有国内开发者通过新浪接口提供的国家卫健委统计的全国数据，开发了 BitBar 的疫情监控插件。插件默认会显示国内患病人数最多五个省份的数据，数据每十秒刷新一次，你也可以根据需求自行修改刷新时间等参数。</p><p>你可以在插件的 <a href="https://github.com/Anthonyeef/wuhan-virus-bitbar-plugin/blob/master/README.md" target="_blank" rel="noopener">GitHub 页面</a> 查看更多细节，并下载插件。</p><p>![](Mac工具 BitBar/907acead2c5c286bf291d7def059f958.jpg)</p><h3 id="检测上传、下载速度"><a href="#检测上传、下载速度" class="headerlink" title="检测上传、下载速度"></a>检测上传、下载速度</h3><p>最基本也最简单的系统监控就是对网络速度、带宽的监测。BitBar 插件库中与网络相关的插件有很多，我们可以前往 <a href="https://getbitbar.com/plugins/Network" target="_blank" rel="noopener">BitBar Plugins | Network</a> 查看。这里我选择使用 <a href="https://getbitbar.com/plugins/Network/bandwidth.1s.sh" target="_blank" rel="noopener">Bandwidth by Ant Cosentino</a>，一个 Shell 脚本实现的网速监控。我们不需要进行特殊的改动，直接安装即可。</p><p>![](Mac工具 BitBar/15807157397472.jpg)监控上传、下载速度</p><p>重新加载脚本之后，我们就可以看到 macOS 菜单栏上显示了我们的上传、下载网速状况，同时，点击菜单项，我们也可以看到本机各个网络端口的具体带宽。</p><h3 id="监控-CPU-使用率"><a href="#监控-CPU-使用率" class="headerlink" title="监控 CPU 使用率"></a>监控 CPU 使用率</h3><p>监控系统信息怎么可能少了 CPU 使用率的监控，我们可以使用 <a href="https://getbitbar.com/plugins/System/mtop.5s.sh" target="_blank" rel="noopener">CPU Usage Graph</a> 来在菜单栏实现一个监视 CPU 使用率，并显示为小图表的工具。这一插件也不需要过多配置，直接安装即可。</p><p>![](Mac工具 BitBar/15807157397480.jpg)使用 CPU Usage Graph 检测当前系统 CPU 使用率</p><p>另外，这一脚本还可以实现监控当前使用 CPU 最多的五个进程，方便我们掌控当前消耗 CPU 最多的软件，好能快速打开 Activity Monitor，及时杀掉资源消耗过高的程序。</p><h3 id="监控电池电量、使用循环"><a href="#监控电池电量、使用循环" class="headerlink" title="监控电池电量、使用循环"></a>监控电池电量、使用循环</h3><p>我们 macOS 原有的「电池」显示控件只有电量百分比、能耗等的显示，用 BitBar 我们还可以直接将电池的「循环次数」进行显示，并用不同的颜色表示电池的使用状况。</p><p>![](Mac工具 BitBar/15807157397488.png)Colorful Battery Indicator：用不同的颜色显示电池信息</p><p>这里我们选择 <a href="https://getbitbar.com/plugins/System/ColorfulBatteryLevel.5s.sh" target="_blank" rel="noopener">Colorful Battery Indicator</a> 这一插件，直接安装即可。运行插件之后，我们可以看到 BitBar 控件成功加载，可以直接显示电池的电量与循环次数等信息，比 macOS 原生电量控件的功能多出不少。</p><p>![](Mac工具 BitBar/15807157397498.jpg)不仅能显示电池电量，还可以估算剩余时间、显示循环次数</p><h3 id="监测天气信息"><a href="#监测天气信息" class="headerlink" title="监测天气信息"></a>监测天气信息</h3><p>最后，我们来实现相对复杂的天气监控。BitBar 插件库的<a href="https://getbitbar.com/plugins/Weather" target="_blank" rel="noopener">天气分类</a>非常丰富，不仅拥有普通天气、温度的插件，还能直接检测 AQI 等空气指标。我选择使用 <a href="https://getbitbar.com/plugins/Weather/DarkSky/weather.15m.py" target="_blank" rel="noopener">Weather by Daniel Seripap</a>，点击安装即可。这一脚本用 Python 编写，请求的是国外知名天气信息 Dark Sky 的 API。另外，脚本也使用了 OpenCage 的全球经纬度 API，辅助我们将地理位置与经度纬度进行转换。为了让脚本更方便运行，我们需要：</p><ul><li>去 Dark Sky 申请一个私有 API Key：前往 <a href="https://darksky.net/dev" target="_blank" rel="noopener">Dark Sky API</a>，点击 Try for free 注册账号，并按照说明申请 API Key，之后我们复制 Dark Sky 为我们生成的 Secret Key 留作备用。为了方便称呼，我们用 <code>{DARK_SKY_API_KEY}</code> 代指这一 API Key</li></ul><p>![](Mac工具 BitBar/15807157397525.png)在 Dark Sky 申请 API Key</p><ul><li>去 OpenCage 申请一个私有 API Key：前往 <a href="https://opencagedata.com/" target="_blank" rel="noopener">OpenCage API</a>，按照步骤注册账户并进入 Dashboard，没有问题的话下方 API Key 处即为我们需要的密钥。我们同样复制这一 API Key 留作备用。为了方便称呼，我们用 <code>{GEO_API_KEY}</code> 代指这一 API Key</li></ul><p>![](Mac工具 BitBar/15807203601222.png)在 OpenCage 申请一个私有 API Key</p><p>接下来，我们进入 BitBar 插件目录，打开 <code>weather.15m.py</code>，按照下面的步骤依次将相应的内容进行修改，让脚本使用我们自己的 API Key 进行数据请求：</p><p>![](Mac工具 BitBar/15807203601234.png)修改脚本的 API Key，替换使用我们自己的秘钥进行请求</p><ul><li>将 <code>api_key</code> 一行后面单引号里面的内容替换为我们 Dark Sky 的 API Key：<code>{DARK_SKY_API_KEY}</code></li><li>将 <code>geo_api_key</code> 一行后面单引号里的内容替换为我们 OpenCage 的 API Key：<code>{GEO_API_KEY}</code></li><li>将下方 <code>units</code> 后面单引号里添加 <code>si</code>：表示我们使用「公制单位」（也就是摄氏度）</li></ul><p>这样设置下来我们就应该可以直接运行脚本了。另外，如果使用之后发现脚本定位速度慢，或者因为是根据 IP 进行地理位置确定导致位置不准确，我们也可以直接手动定义目标城市与其经纬度。脚本文件中定义地理位置的内容位于：</p><ul><li><code>manual_city</code>：城市名称</li><li><code>manual_latlng</code>：城市所在经纬度</li></ul><p>我们可以访问 <a href="https://opencagedata.com/demo" target="_blank" rel="noopener">OpenCage Demo</a> 网站，在下方点击定位获取当前所在位置的经纬度与城市名称，按照上方注释给出的格式依次填写即可。之后，我们重新加载 BitBar，不出意外的话我们就可以正确查看当地天气情况了。</p><p>![](Mac工具 BitBar/15807203601243.jpg)</p><h3 id="Currency-Rates：货币汇率"><a href="#Currency-Rates：货币汇率" class="headerlink" title="Currency Rates：货币汇率"></a>Currency Rates：货币汇率</h3><p><a href="https://getbitbar.com/plugins/Finance/currency-rates.1h.py" target="_blank" rel="noopener">Currency Rates</a> 采用 Python 编写，它可以实时查询货币汇率，然后通过 BitBar 显示在菜单栏中。</p><p>![](Mac工具 BitBar/8594952abd65a815326d7285a9acc6d4.png)</p><p>不过需要注意的是，Currency Rates 的汇率规则是 1 美元兑各币种的汇率，而且默认在菜单栏显示的汇率是 1 美元 USD 兑印度卢比 INR。当然修改成人民币也很简单。我们只要使用「文本编辑」打开插件代码，把 <code>if nValue1 == &quot;INR&quot;</code> 修改为 <code>if nValue1 == &quot;CNY&quot;</code> 即可。</p><p>如果你觉得 Currency Rates 显示了太多无关紧要的其他币种，可以试试 <a href="https://getbitbar.com/plugins/Finance/currency-tracker.1h.py" target="_blank" rel="noopener">Currency Tracker</a>，它只显示一种货币的兑换汇率。</p><h3 id="Death-Timer：距死亡还剩多少天"><a href="#Death-Timer：距死亡还剩多少天" class="headerlink" title="Death Timer：距死亡还剩多少天"></a>Death Timer：距死亡还剩多少天</h3><p>很多应用都可以帮你预计死亡还剩多少天，<a href="https://getbitbar.com/plugins/Lifestyle/deathTimer.5m.py" target="_blank" rel="noopener">Death Timer</a> 把它带到了 Mac 菜单栏上，不过要使用它，还是得先修改下它的代码。</p><p>用「文本编辑」打开插件代码，修改 <code>death = datetime(2081, 5,31, 12, 0, 0)</code>和 <code>birth = datetime(1994, 5,31, 12, 0, 0)</code> 中修改你的预测死亡时间和出生时间，之后刷新即可 。如果你不知道预计的死亡时间，开发者建议你去 <a href="https://www.blueprintincome.com/tools/life-expectancy-calculator-how-long-will-i-live/results?id=eyJnZW5kZXIiOiJNQUxFIiwicmFjZSI6Ik9USEVSIiwiaGVpZ2h0IjoxLjc3LCJjdXJyZW50X2FnZSI6MjgsIndlaWdodCI6NjIsImVkdWNhdGlvbiI6IkNPTExFR0VfR1JBRCIsIm1hcml0YWxfc3RhdHVzIjoiTkVWRVJfTUFSUklFRCIsImluY29tZSI6IjQwTUlOVVMiLCJpbmNvbWVTdGF0dXMiOiJXT1JLSU5HIiwiZXhlcmNpc2UiOiJfM19UT180X1BFUl9XRUVLIiwiaGVhbHRoIjoiR09PRCIsImRpYWJldGVzIjpmYWxzZSwiYWxjb2hvbCI6Il9MVF8yX1BFUl9XRUVLIiwic21va2luZyI6Ik5PTl9TTU9LRVIiLCJ1c191bml0cyI6ZmFsc2UsIm9wdEluIjpmYWxzZSwic21va2luZ1N0YXR1cyI6Ik5FVkVSX1NNT0tFRCIsInNtb2tpbmdRdWl0IjpudWxsLCJzbW9raW5nQW1vdW50IjpudWxsLCJoZWlnaHRfdHlwZSI6Ik1FVFJJQyIsIndlaWdodF90eXBlIjoiTUVUUklDIn0&lc_r=n" target="_blank" rel="noopener">这个网站</a> 看看。</p><p>![](Mac工具 BitBar/d98c461973511bd9aa0cf4bdf4045191.png)</p><p>另一个插件 <a href="https://getbitbar.com/plugins/Lifestyle/life-percentage.12h.rb" target="_blank" rel="noopener">Life Percentage</a> 和 Death Timer，它显示的是人生百分比。<a href="https://getbitbar.com/plugins/Lifestyle/time_on_earth.10m.rb" target="_blank" rel="noopener">Your time on earth</a> 显示的是你出生多少天了，也比较类似。</p><h3 id="Moon-Phase：显示月相"><a href="#Moon-Phase：显示月相" class="headerlink" title="Moon Phase：显示月相"></a>Moon Phase：显示月相</h3><p><a href="https://getbitbar.com/plugins/Lifestyle/moon-phase.1h.js" target="_blank" rel="noopener">显示月相</a> 对于一般人来说可能没有什么用，但是它的月相是用 Emoji 显示的，可以给死板的菜单栏增添一些乐趣。</p><p>![](Mac工具 BitBar/83aefe129ad1f1a413ebbdf61e7889fc.png)</p><p>另一个 <a href="https://getbitbar.com/plugins/Tutorial/emoji.sh" target="_blank" rel="noopener">Show emoji</a> 插件更粗暴，它会直接在菜单栏随机显示三个 Emoji。</p><h3 id="Smile：适用于-Slack-的-Emoji-代码"><a href="#Smile：适用于-Slack-的-Emoji-代码" class="headerlink" title="Smile：适用于 Slack 的 Emoji 代码"></a>Smile：适用于 Slack 的 Emoji 代码</h3><p><a href="https://getbitbar.com/plugins/Lifestyle/smile.12h.sh" target="_blank" rel="noopener">Smile</a> 不是在菜单栏显示微笑表情，它的作用有点特殊。我们知道在 Slack 或者 Github 上输入 Emoji 只能点选。Smile 的作用是把 Emoji 图标自动转换为代码，并且拷贝到剪贴板，在 Slack 或 GitHub 里粘贴就行了。</p><p>![](Mac工具 BitBar/73d52180ef1ad77b4f14b9693270c468.png)</p><h3 id="Things-3-Today：在菜单栏显示-Things-任务"><a href="#Things-3-Today：在菜单栏显示-Things-任务" class="headerlink" title="Things 3 Today：在菜单栏显示 Things 任务"></a>Things 3 Today：在菜单栏显示 Things 任务</h3><p>如果你在用 Things，<a href="https://getbitbar.com/plugins/Lifestyle/Things/thingstoday.6s.sh" target="_blank" rel="noopener">Things 3 Today</a> 可以在菜单栏显示你今天的任务。它还能直接创建任务、清空废纸篓等等。不过这个插件对中文系统不太支持，你可以把下面代码中的<code>Today</code> 改为 <code>今天</code>：</p><pre><code class="hljs applescript"><span class="hljs-keyword">with</span> n <span class="hljs-keyword">from</span> <span class="hljs-number">1</span> <span class="hljs-keyword">to</span> <span class="hljs-built_in">count</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">to</span> dos <span class="hljs-keyword">of</span> <span class="hljs-built_in">list</span> <span class="hljs-string">"Today"</span><span class="hljs-keyword">set</span> toDo <span class="hljs-keyword">to</span> <span class="hljs-built_in">item</span> n <span class="hljs-keyword">of</span> <span class="hljs-keyword">to</span> dos <span class="hljs-keyword">of</span> <span class="hljs-built_in">list</span> <span class="hljs-string">"Today"</span></code></pre><p>![](Mac工具 BitBar/6527b30cf753483e2e413f3ffec89045.png)</p><p>和 Things 有关的插件还有 <a href="https://getbitbar.com/plugins/Lifestyle/Things/thingsdoingnow.10s.sh" target="_blank" rel="noopener">Things Doing Now</a> 和 <a href="https://getbitbar.com/plugins/Lifestyle/Things/thingsinbox.6s.sh" target="_blank" rel="noopener">Things - View Inbox</a>。</p><h3 id="iTunes-Now-Playing：正在播放"><a href="#iTunes-Now-Playing：正在播放" class="headerlink" title="iTunes Now Playing：正在播放"></a>iTunes Now Playing：正在播放</h3><p><a href="https://getbitbar.com/plugins/Music/itunes.10s.sh" target="_blank" rel="noopener">iTunes Now Playing</a> 可以抓取 iTunes 目前正在播放的音乐，在菜单栏显示歌曲名和艺人，点击还能进行切歌和暂停操作，还能显示专辑封面，视觉上比较不错。不过这个插件对中文系统不友好，中文系统用户需要把代码中的 <code>iTunes</code> 改为 <code>音乐</code> 才行。</p><p>![](Mac工具 BitBar/aafc6d6f665427cade842ff23e1117fd.png)</p><p>BitBar 中还有 <a href="https://getbitbar.com/plugins/Music/spotify.10s.sh" target="_blank" rel="noopener">Spotify Now Playing</a> 用来显示 Spotify 的正在播放歌曲。还有其他的操控 iTunes 和 Spotify 播放控制的插件，不再列举。</p><h3 id="Battery-Dot：显示-Mac、键盘和触控板的电量"><a href="#Battery-Dot：显示-Mac、键盘和触控板的电量" class="headerlink" title="Battery Dot：显示 Mac、键盘和触控板的电量"></a>Battery Dot：显示 Mac、键盘和触控板的电量</h3><p><a href="https://getbitbar.com/plugins/System/Battery/battery-dot.1h.swift" target="_blank" rel="noopener">Battery Dot</a> 可以在菜单栏显示 MacBook、Apple 的键盘和触控板的电量。显示 Mac 的电量不足为奇，但是能显示键盘和触控板就很方便了。工作的时候键盘和触控板没电那种抓狂的感觉令人印象深刻，有 Battery Dot 应该会好很多。</p><p>![](Mac工具 BitBar/c86df48a662bbaea8771a4b6a813c535.png)</p><h3 id="Date-Picker：提供多种格式的日期样式"><a href="#Date-Picker：提供多种格式的日期样式" class="headerlink" title="Date Picker：提供多种格式的日期样式"></a>Date Picker：提供多种格式的日期样式</h3><p>办公写文件时，经常需要在落款处留日期，每次手动输入会比较麻烦。<a href="https://getbitbar.com/plugins/Time/date-picker.1m.sh" target="_blank" rel="noopener">Date Picker</a> 在菜单栏显示了多种样式的日期格式，点击就能拷贝到剪贴板，在写作时就能复制了，非常方便。不过它的默认格式是 2020-02-03，没有包含中文「年月日」的样式。 </p><p>![](Mac工具 BitBar/56be0bf00a487c1c117da5ecbaf4207e.png)</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>BitBar 的设计理念实际上非常易懂，这一简单的工作原理为我们提供了一种开源免费的解决方案，让我们能够更有效地利用 macOS 菜单栏来做一些有用、有趣的事情。BitBar 支持运行的程序非常丰富，Bash、Python、Lua、Ruby、JavaScript 等等都有支持。理论上，只要你在 Mac 上面能够运行的脚本，BitBar 就能将其输出显示于 macOS 菜单栏上面。</p><p>BitBar 脚本库的生态同样丰富，不仅提供了上面介绍的各项参数的监控功能，还有比如<a href="https://getbitbar.com/plugins/Music" target="_blank" rel="noopener">控制音乐播放</a>、<a href="https://getbitbar.com/plugins/Finance" target="_blank" rel="noopener">查看货币价格涨幅</a>、<a href="https://getbitbar.com/plugins/Science" target="_blank" rel="noopener">订阅 Nasa 每日一图</a> 等等各种有趣的小工具。当然，BitBar 使用时还是出现一些问题，比如我发现各个插件之间的相对位置事实上不太好维持，每次重新加载都会凌乱，只能手动给脚本名称前面添加编号来解决。不过，BitBar 的功能还是相当丰富，可以实现以 iStat Menu 为代表的「系统监控」软件所提供的大部分功能，希望丰富自己 macOS 菜单栏功能的同学一定不要错过。</p><p>你可以在 <a href="https://getbitbar.com/" target="_blank" rel="noopener">这里</a> 下载 BitBar。</p>]]></content>
    
    
    <categories>
      
      <category>设备篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mac工具 BitBar</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis篇</title>
    <link href="/2023/09/12/MyBatis%E7%AF%87/"/>
    <url>/2023/09/12/MyBatis%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="Mybatis篇"><a href="#Mybatis篇" class="headerlink" title="Mybatis篇"></a>Mybatis篇</h1><blockquote><p>首先推荐一个简单的Mybatis原理视频教程，可以作为入门教程进行学习：<a href="https://b23.tv/av57161139/p1" target="_blank" rel="noopener">点我</a>  (该教程讲解的是如何手写简易版Mybatis)</p></blockquote><h2 id="执行流程的理解"><a href="#执行流程的理解" class="headerlink" title="执行流程的理解"></a>执行流程的理解</h2><blockquote><p>理解Mybatis的简单流程后自己手写一个，可以解决百分之70的面试问题和开发中遇到的困惑，此乃重中之重</p></blockquote><p>假如我们要自己设计一个半自动的仿Mybatis框架，有哪些环节是必不可少的呢？思考再三，必然有以下环节：</p><ul><li>相关配置文件加载（XML类型，接口类型则可以省略）</li><li>接口代理（JDK 动态代理）</li><li>针对XML或者接口进行解析 ==》即把<code>不可直接执行的SQL</code>处理为携带参数，返回值明确的数据结构</li><li>JDBC模块执行，并返回对应的返回值类型</li></ul><p>如果仅考虑这三点的话，其实实现一个简单的ORM框架就很容易了，再附加一些反射和正则表达式等等就可以搞定了.</p><p>那如果去参考Mybatis，我们来看看它的几个环节是如何设计的：</p><p><img src="http://ww1.sinaimg.cn/large/006j28Gply1gbkiuiow0rj30o60a7ad9.jpg" srcset="/img/loading.gif" alt="图片"></p><p>其实大致思路一样，需要一个数据结构去存储全部的变量，通过接口代理的方式调用Sqlsession里面内置的方法，<code>不同的是真正的执行者又加了一层，是 Executor</code>，再通过原始JDBC返回数据给调用者，当然，<strong>真正的Mybatis包含了众多的设计模式以及数据源，缓存，动态SQL，数据库事务，延迟加载处理</strong>等等</p><p>为了验证mybatis的执行流程，采用了两种方式去调用接口，如下所示：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    <span class="hljs-comment">// 指定全局配置文件</span>    String resource = <span class="hljs-string">"mybatis-config.xml"</span>;    <span class="hljs-comment">// 读取配置文件</span>    InputStream inputStream = Resources.getResourceAsStream(resource);    <span class="hljs-comment">// 构建sqlSessionFactory</span>    SqlSessionFactory sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);    SqlSession sqlSession = sqlSessionFactory.openSession();    <span class="hljs-comment">// Mapper 编程方式</span>    ScriptDirDao mapper = sqlSession.getMapper(ScriptDirDao<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    System.out.println(mapper.selectOne(<span class="hljs-number">1</span>));    <span class="hljs-comment">// ibatis 编程方式 ---&gt; 注意由于没有显式设置提交, 因此两个sql执行使用的是同一次sqlsession, 即默认触发了一级缓存</span>    Object object = sqlSession.selectOne(<span class="hljs-string">"com.mycode.mybatis.ScriptDirDao.selectOne"</span>, <span class="hljs-number">1</span>);    System.out.println(object);&#125;</code></pre><blockquote><p>ibatis编程方式实际就是通过 namespace+方法名定位具体的接口方法，然后传递参数并执行</p><p>正常使用方式就是基于上述的基本流程做了一层自动的返回值映射，接口方法的匹配</p></blockquote><p>这里有个小点需要强调下，真正的执行者是<code>Executor</code>，我们每次在使用以下代码：</p><pre><code class="hljs java"><span class="hljs-comment">// 构建sqlSessionFactory</span>SqlSessionFactory sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);SqlSession sqlSession = sqlSessionFactory.openSession();<span class="hljs-comment">// Mapper 编程方式</span>ScriptDirDao mapper = sqlSession.getMapper(ScriptDirDao<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;System.out.println(mapper.selectOne(<span class="hljs-number">1</span>));</code></pre><p>通过查看源码也可以看到，SqlSession接口的默认实现类是<code>DefaultSqlSession</code></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultSqlSession</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SqlSession</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Configuration configuration;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Executor executor;  <span class="hljs-comment">// 执行者</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> autoCommit;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> dirty;  <span class="hljs-keyword">private</span> List&lt;Cursor&lt;?&gt;&gt; cursorList;  .......&#125;</code></pre><p>而方法真正的执行，如selectList方法：</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> &lt;E&gt; <span class="hljs-function">List&lt;E&gt; <span class="hljs-title">selectList</span><span class="hljs-params">(String statement, Object parameter, RowBounds rowBounds)</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        MappedStatement ms = configuration.getMappedStatement(statement);        <span class="hljs-keyword">return</span> executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        <span class="hljs-keyword">throw</span> ExceptionFactory.wrapException(<span class="hljs-string">"Error querying database.  Cause: "</span> + e, e);    &#125; <span class="hljs-keyword">finally</span> &#123;        ErrorContext.instance().reset();    &#125;&#125;</code></pre><h2 id="深度分析文章参考"><a href="#深度分析文章参考" class="headerlink" title="深度分析文章参考"></a>深度分析文章参考</h2><p><a href="https://juejin.im/post/5dcaa0fd51882557486c2de6" target="_blank" rel="noopener">源码分析Mybatis MapperProxy初始化之Mapper对象的扫描与构建</a> (作者：掘金- <a href="https://juejin.im/user/5d9742c4f265da5b7a753c36" target="_blank" rel="noopener">中间件兴趣圈</a>)</p><p><a href="https://juejin.im/post/5dcd4d8ef265da0bea052777" target="_blank" rel="noopener">源码分析Mybatis MappedStatement的创建流程</a>(作者：掘金- <a href="https://juejin.im/user/5d9742c4f265da5b7a753c36" target="_blank" rel="noopener">中间件兴趣圈</a>)</p><p><a href="https://juejin.im/post/5dd148175188254c635876d1#heading-5" target="_blank" rel="noopener">Mybatis执行SQL的4大基础组件详解</a>(作者：掘金- <a href="https://juejin.im/user/5d9742c4f265da5b7a753c36" target="_blank" rel="noopener">中间件兴趣圈</a>)</p><p><a href="https://tech.meituan.com/2018/01/19/mybatis-cache.html" target="_blank" rel="noopener">源码解析MyBatis Sharding-Jdbc SQL语句执行流程详解</a>(作者：掘金- <a href="https://juejin.im/user/5d9742c4f265da5b7a753c36" target="_blank" rel="noopener">中间件兴趣圈</a>)</p><p><a href="https://tech.meituan.com/2018/01/19/mybatis-cache.html" target="_blank" rel="noopener">mybatis 一级二级缓存原理及使用建议</a>(美团技术团队-官方博客)</p><h2 id="面试题集锦"><a href="#面试题集锦" class="headerlink" title="面试题集锦"></a>面试题集锦</h2><blockquote><p>Myabtis的细节使用和执行原理其实都很好理解，对于源码感兴趣的可以深挖，但大多时候建议点到为止即可</p><p>还是着眼当下 面向面试要点进行针对性学习（<strong>不包括一些简单的使用问题</strong>）</p></blockquote><h3 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{}和${}的区别是什么？"></a>#{}和${}的区别是什么？</h3><p> #{} 是预编译处理，${}是字符串替换。Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 的<br>set 方法来赋值；<br>Mybatis 在处理时，就是把时，就是把{}替换成变量的值。<br>使用#{}可以有效的防止 SQL 注入，提高系统安全性 </p><p>PS：mybatis执行的本质还是SQL，因此回归本质可以简单理解为一个对于PreparedStatement ，一个对应 Statement </p><h3 id="通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应，请问，这个-Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？（id是否可以相同）"><a href="#通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应，请问，这个-Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？（id是否可以相同）" class="headerlink" title="通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？（id是否可以相同）"></a>通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？（id是否可以相同）</h3><p>Dao 接口即 Mapper 接口，接口的全限名，就是映射文件中的 namespace 的值；接口的方法名，就是映射文件中 Mapper 的 Statement 的 id 值；接口方法内的参数，就是传递给 sql 的参数</p><pre><code class="hljs 实现原理：```Mapper接口的工作原理是JDK动态代理，mybatis会对每一个mapper代理生成一个mapperProxy对象，代理对象会拦截接口方法，转而自动对应到sqlsession上，最终由```Executor```执行">&#96;&#96;&#96;参数不同，方法不可重载&#96;&#96;&#96;，为什么？上文说到mybatis有一个环节是解析XML文件或者解析接口，它会去构建一个叫做 MapperStatement 对象去存储mapper的相关信息，每一个dao接口方法在执行的时候到底是如何定位找到对应的MapperStatement 的呢？源码逻辑图：![1](http:&#x2F;&#x2F;ww1.sinaimg.cn&#x2F;large&#x2F;006j28Gply1gbkub983z8j30q107e3zc.jpg)![2](http:&#x2F;&#x2F;ww1.sinaimg.cn&#x2F;large&#x2F;006j28Gply1gbkuchgemwj30re06f74o.jpg)&#96;&#96;&#96;java&#x2F;&#x2F; 这个 mappedStatements 即protected final Map&lt;String, MappedStatement&gt; mappedStatements &#x3D; new StrictMap&lt;MappedStatement&gt;(&quot;Mapped Statements collection&quot;);&#x2F;&#x2F; Key即 XML文件中配置的&lt;mapper namespace&#x3D;&quot;com.mycode.mybatis.ScriptDirDao&quot;&gt;&lt;select id&#x3D;&quot;selectOne&quot; resultMap&#x3D;&quot;BaseResultMap&quot;&gt;    namespace + id &#x3D;&#x3D;&#x3D;》 全限名（NameSpace）+方法名</code></pre><h3 id="Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</h3><p>第一种是使用 标签，逐一定义数据库列名和对象属性名之间的映射关系<br>第二种是使用 sql 列的别名功能，将列的别名书写为对象属性名，有了列名与属性名的映射关系后，Mybatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的 </p><h3 id="Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？"></a>Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？</h3><p> Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载，association 指的就是一对一，collection 指的就是一对多查询，在 Mybatis配置文件中，可以配置是否启用延迟加载 lazyLoadingEnabled=true|false</p><p>它的原理是，使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 a.getB().getName()，拦截器 invoke()方法发现 a.getB()是null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName()法的调用，这就是延迟加载的基本原理</p><h3 id="Mybatis-的一级、二级缓存"><a href="#Mybatis-的一级、二级缓存" class="headerlink" title="Mybatis 的一级、二级缓存"></a>Mybatis 的一级、二级缓存</h3><p>一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存，无法关闭</p><p>二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态),可在它的映射文件中配置</p><p>对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了 C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear</p><h3 id="简述-Mybatis-的插件运行原理，以及如何编写一个插件"><a href="#简述-Mybatis-的插件运行原理，以及如何编写一个插件" class="headerlink" title="简述 Mybatis 的插件运行原理，以及如何编写一个插件"></a>简述 Mybatis 的插件运行原理，以及如何编写一个插件</h3><p>Mybatis 仅可以编写针对 ParameterHandler、ResultSetHandler、StatementHandler、Executor 这 4 种接口的插件，Mybatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 InvocationHandler 的 invoke()方法，当然，只会拦截那些你指定需要拦截的方法</p><p>编写插件：实现 Mybatis 的 Interceptor 接口并复写 intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，需要在配置文件中配置你编写的插件 </p><blockquote><p>Mybatis 的插件实际在执行的流程留下了一些固定的环节，允许你自行做一些处理，我们自己利用接口扫描，在代码执行的某个阶段去调用目标方法，也可以实现这种类似插件的做法</p><p>Demo：<a href="https://juejin.im/post/5e37fc40e51d4527214b9fce" target="_blank" rel="noopener">SpringBoot代码生成器</a> 包含自定义接口拦截，实现了类似的插件效果</p></blockquote><p>以下问题来源于掘金文章<a href="https://juejin.im/post/5de9ab066fb9a016554eb6a6?utm_source=gold_browser_extension#heading-2" target="_blank" rel="noopener">【面试官之你说我听】-MyBatis常见面试题</a>(作者:<strong>Ccww</strong>)</p><h3 id="数据库链接中断如何处理"><a href="#数据库链接中断如何处理" class="headerlink" title="数据库链接中断如何处理"></a>数据库链接中断如何处理</h3><p>数据库的访问底层是通过tcp实现的，当链接中断是程序是无法得知，导致程序一直会停顿一段时间在这，最终会导致用户体验不好，因此面对数据库连接中断的异常，该怎么设置mybatis呢？</p><p>connection操作底层是一个循环处理操作，因此可以进行时间有关的参数：</p><ul><li>max_idle_time ： 表明最大的空闲时间，超过这个时间socket就会关闭</li><li>connect_timeout ： 表明链接的超时时间</li></ul><h3 id="在开发过程中，经常遇到插入重复的现象，这种情况该如何解决呢？"><a href="#在开发过程中，经常遇到插入重复的现象，这种情况该如何解决呢？" class="headerlink" title="在开发过程中，经常遇到插入重复的现象，这种情况该如何解决呢？"></a>在开发过程中，经常遇到插入重复的现象，这种情况该如何解决呢？</h3><blockquote><p> 插入的过程一般都是分两步的：先判断是否存在记录，没有存在则插入否则不插入。如果存在并发操作，那么同时进行了第一步，然后大家都发现没有记录，然后都插入了数据从而造成数据的重复 </p></blockquote><p>分布式环境中通过Redis分布式锁解决即可，多线程环节下用普通的Lock锁解决即可</p><h3 id="事务执行过程中宕机的应对处理方式"><a href="#事务执行过程中宕机的应对处理方式" class="headerlink" title="事务执行过程中宕机的应对处理方式"></a>事务执行过程中宕机的应对处理方式</h3><blockquote><p>数据库插入百万级数据的时候，还没操作完，但是把服务器重启了，数据库会继续执行吗？ 还是直接回滚了？</p></blockquote><p>不会自动继续执行，不会自动直接回滚 ,但可以依据事务日志进行回滚或者进行执行。</p><p>事务开启时，事务中的操作，都会先写入存储引擎的日志缓冲中，在事务提交之前，这些缓冲的日志都需要提前刷新到磁盘上持久化 ，两种类型：</p><blockquote><p>在事务执行的过程中，除了记录redo log，还会记录一定量的undo log。</p></blockquote><ul><li>redo log  ：按语句的执行顺序，依次交替的记录在一起</li><li>undo log： 主要为事务的回滚服务。undo log记录了数据在每个操作前的状态，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作</li></ul><h3 id="Mybatis都有哪些Executor执行器？它们之间的区别是什么？"><a href="#Mybatis都有哪些Executor执行器？它们之间的区别是什么？" class="headerlink" title="Mybatis都有哪些Executor执行器？它们之间的区别是什么？"></a>Mybatis都有哪些Executor执行器？它们之间的区别是什么？</h3><p>Mybatis有三种基本的Executor执行器，<strong>SimpleExecutor、ReuseExecutor、BatchExecutor。</strong></p><ul><li><strong>SimpleExecutor：</strong>每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</li><li><strong>ReuseExecutor：</strong>执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用Statement对象。</li><li><strong>BatchExecutor：</strong>执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</li></ul><p>作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内</p><p>在Mybatis配置文件中，可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数</p><h2 id="记一次Mybatis使用错误：集合遍历"><a href="#记一次Mybatis使用错误：集合遍历" class="headerlink" title="记一次Mybatis使用错误：集合遍历"></a>记一次Mybatis使用错误：集合遍历</h2><pre><code class="hljs sql">Parameter ‘customerIdList’ not found. Available parameters are [collection, list]</code></pre><pre><code class="hljs 情景还原```">&#96;&#96;&#96;xmlDAO 层：Long selectCustomerCountList(List customerIdList);XML文件：&lt;select id&#x3D;&quot;selectCustomerCountList&quot; parameterType&#x3D;&quot;java.util.List&quot; resultType&#x3D;&quot;java.lang.Long&quot;&gt;select count(1) from np_customer_info where id in&lt;foreach item&#x3D;&quot;item&quot; collection&#x3D;&quot;customerIdList&quot; separator&#x3D;&quot;,&quot; open&#x3D;&quot;(&quot; close&#x3D;&quot;)&quot; index&#x3D;&quot;&quot;&gt;  #&#123;item, jdbcType&#x3D;INTEGER&#125;    &lt;&#x2F;foreach&gt; &lt;&#x2F;select&gt;结果：报错-&gt;Parameter ‘customerIdList’ not found. Available parameters are [collection, list]</code></pre><pre><code class="hljs 分析```">当我们传递一个 List 实例或者数组作为参数对象传给 MyBatis。当你这么做的时 候,**MyBatis 会自动将它包装在一个 Map 中,用名称****作为键，List 实例将会以“list” 作为键,而数组实例将会以“array”作为键** 因此需要进行修改和调整，方式如下：方案一： 将我们的XML中collection属性值设置为list &#96;&#96;&#96;xmlDAO 层：Long selectCustomerCountList( List customerIdList);XML文件：&lt;select id&#x3D;&quot;selectCustomerCountList&quot; parameterType&#x3D;&quot;java.util.List&quot; resultType&#x3D;&quot;java.lang.Long&quot;&gt;select count(1) from np_customer_info where id in&lt;foreach item&#x3D;&quot;item&quot; collection&#x3D;&quot;list&quot; ......&lt;&#x2F;foreach&gt; &lt;&#x2F;select&gt;</code></pre><p>方案二： 利用注解@Param指定我们的入参名称 </p><pre><code class="hljs xml">DAO层：Long selectCustomerCountList(@Param("customerIdList") List customerIdList);XML文件：<span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectCustomerCountList"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"java.util.List"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"java.lang.Long"</span>&gt;</span>select count(1) from np_customer_info where id in<span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">item</span>=<span class="hljs-string">"item"</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">"customerIdList"</span> <span class="hljs-attr">....</span>   </span>&lt;/foreach&gt; <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre><p>方案三： 将我们的List包装成Map参数进行传递 </p><pre><code class="hljs xml">Service层：public Long selectCustomerCountMap(List customerIdList) &#123;   Map maps = new HashMap();maps.put("customerIds", customerIdList);return customerMapper.selectCustomerCountMap(maps);&#125;DAO层：Long selectCustomerCountMap(Map maps);XML文件：<span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectCustomerCountMap"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"java.util.Map"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"java.lang.Long"</span>&gt;</span>    select count(1) from np_customer_info where id in    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">item</span>=<span class="hljs-string">"item"</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">"customerIds"</span> <span class="hljs-attr">.....</span>   </span>    &lt;/foreach&gt; <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>Myabtis也有其缺点，重复代码实在太多，在这里推荐我的另一篇文章，SpringBoot &amp; Mybatis代码生成器，解决百分之90的重复代码，数据库建好即可CRUD，所有XML都是手写，欢迎尝试一下</p><p>点击 ===》 <a href="https://juejin.im/post/5e37fc40e51d4527214b9fce" target="_blank" rel="noopener">SpringBoot代码生成器</a></p><p>集中感谢几位作者：</p><p>掘金-<a href="https://juejin.im/user/5cd27385e51d453f146bb8e7" target="_blank" rel="noopener">Ccww</a></p><p>掘金- <a href="https://juejin.im/user/5d9742c4f265da5b7a753c36" target="_blank" rel="noopener">中间件兴趣圈</a></p><p>美团技术团队-<a href="https://tech.meituan.com/2018/01/19/mybatis-cache.html" target="_blank" rel="noopener">官方博客</a></p>]]></content>
    
    
    <categories>
      
      <category>框架篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MyBatis篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring篇</title>
    <link href="/2023/09/12/Spring%E7%AF%87/"/>
    <url>/2023/09/12/Spring%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring篇核心问题"><a href="#Spring篇核心问题" class="headerlink" title="Spring篇核心问题"></a>Spring篇核心问题</h1><pre><code class="hljs java"><span class="hljs-comment">/***</span><span class="hljs-comment">    * 入门：Spring的组成</span><span class="hljs-comment">    * 1.Spring的核心 IOC 和 AOP的理解,优点是什么</span><span class="hljs-comment">    * 2.简单实现Spring IOC容器，理解IOC源码</span><span class="hljs-comment">    * 3.Spring中bean的注入方式</span><span class="hljs-comment">    * 4.bean的行为模式,是否线程安全,为什么? 怎样处理线程不安全</span><span class="hljs-comment">    * 5.什么是bean的自动装配，实现途径及局限性</span><span class="hljs-comment">    * 6.理解bean工厂和ApplicationContext的区别</span><span class="hljs-comment">    * 7.Spring中常见注解及实现原理</span><span class="hljs-comment">    * 8.请解释自动装配模式的区别(配合注解)</span><span class="hljs-comment">    * 9.Spring中bean的作用域及生命周期</span><span class="hljs-comment">    * 10.深刻理解AOP的各个属性概念及掌握,具体的应用场景</span><span class="hljs-comment">    * 11.动态,静态代理深入,对比JDK 动态代理和Cglib动态代理区别</span><span class="hljs-comment">    * 12.Spring的事务处理类型,有几种方式，详细描述一种</span><span class="hljs-comment">    * 13.描述Spring事务的传播</span><span class="hljs-comment">    * 14.FileSystemResource和ClassPathResource有何区别？</span><span class="hljs-comment">    * 15.Spring中设计模式体现在哪里,用到了哪些设计模式</span><span class="hljs-comment">    * 16.Spring框架中有哪些不同类型的事件</span><span class="hljs-comment">    *</span><span class="hljs-comment">    * 常见题目一览：</span><span class="hljs-comment">    * 1.https://www.jianshu.com/p/994489074601</span><span class="hljs-comment">    * 2.https://blog.csdn.net/dengken53/article/details/54630062</span><span class="hljs-comment">    * 3.http://www.importnew.com/19538.html</span><span class="hljs-comment">    *</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> args</span><span class="hljs-comment">    */</span></code></pre><h2 id="Spring源码导入IDEA"><a href="#Spring源码导入IDEA" class="headerlink" title="Spring源码导入IDEA"></a>Spring源码导入IDEA</h2><pre><code class="hljs java">参考教程：https:<span class="hljs-comment">//www.liangzl.com/get-article-detail-126631.html</span>Jar包缺失解决方案：https:<span class="hljs-comment">//blog.csdn.net/wkztselina/article/details/81277627</span>注释aspect项目 ---》 :include <span class="hljs-string">"spring-aop"</span><span class="hljs-comment">// include "spring-aspects"</span>include <span class="hljs-string">"spring-beans“......</span><span class="hljs-string"></span><span class="hljs-string">报错解决方案：</span><span class="hljs-string">Error:(30, 0) No such property: values for class: org.gradle.api.internal.tasks.DefaultTaskDependency</span><span class="hljs-string">Possible solutions: values</span><span class="hljs-string">Open File(spring-beans\spring-beans.gradle ）</span><span class="hljs-string">点击：Open File 然后注释掉</span><span class="hljs-string">//compileGroovy.dependsOn = compileGroovy.taskDependencies.values - ‘compileJava’</span><span class="hljs-string"></span><span class="hljs-string">解决方案大全：https://blog.csdn.net/lianjiaokeji/article/details/82177236</span><span class="hljs-string"></span><span class="hljs-string"></span><span class="hljs-string">总结步骤:</span><span class="hljs-string">借鉴：https://blog.csdn.net/jiaotuwoaini/article/details/65937185</span><span class="hljs-string">1.配置好gradle，配置阿里云镜像，配置仓库指向目标仓库</span><span class="hljs-string">2.预编译oxm模块：cd 到目录 - gradlew cleanIdea :spring-oxm:compileTestJava (失败重试即可)</span><span class="hljs-string">3.注释setting.gradles模块中aspect模块的内容  // include "</span>spring-aspects<span class="hljs-string">"</span><span class="hljs-string">4.导入项目即可自动build，应该会遇到错误，如下，配置如下 -&gt; 入项目，即开启自动构建,配置加载可参考下图：截图       </span><span class="hljs-string">5.提示错误：No such property: values for class: org.gradle.api.internal.tasks.DefaultTaskDependency</span><span class="hljs-string">Possible solutions: values </span><span class="hljs-string">文件名为: spring-beans.gradle</span><span class="hljs-string">open file 注释 ---》 // compileGroovy.dependsOn = compileGroovy.taskDependencies.values - 'compileJava'</span><span class="hljs-string">6.重新build，如没反应，则关闭重新打开，即会自动build</span><span class="hljs-string"></span><span class="hljs-string">7.提示缺少依赖环境：参考下图执行相应命令：右侧gradle中 spring-Tasks-other-cglibRepack.jar（双击执行），执行</span><span class="hljs-string">spring-Tasks-other-objenesisRepack.jar</span></code></pre><p><img src="/2023/09/12/Spring%E7%AF%87/1561974269622.png" srcset="/img/loading.gif" alt="1561974269622"></p><h2 id="源码-Spring-IOC容器源码分析"><a href="#源码-Spring-IOC容器源码分析" class="headerlink" title="源码: Spring IOC容器源码分析"></a>源码: Spring IOC容器源码分析</h2><ul><li><input disabled type="checkbox"> <a href="https://javadoop.com/post/spring-ioc" target="_blank" rel="noopener">https://javadoop.com/post/spring-ioc</a> 容器源码分析</li></ul><h3 id="Spring的组成"><a href="#Spring的组成" class="headerlink" title="Spring的组成"></a>Spring的组成</h3><p>Spring共分为七层结构：</p><p>A.  Spring Core  Spring最核心的部分，提供依赖注入实现了对Bean的管理，最基本的概念是BeanFactory，它是任何Spring应用的核 心。BeanFactory是工厂模式的一个实现，它使用IoC将应用配置和依赖说明从实际的应用代码中分离出来</p><p>B.  SpringContext：ApplicationContext，扩展核心容器，提供事件处理、国际化等功能。它提供了一些企业级服务的功能，提供了JNDI，EJB，RMI的支持</p><p>C.  Spring DAO DAO(Data Access Object)提供了JDBC的抽象层，它可消除冗长的JDBC编码和解析数据库厂商特有的错误代码。并且，JDBC封装包还提供了一种比编程性更好的声明性事务管理方法，不仅仅</p><p>D.  Spring AOP：提供切面支持</p><p>E.  Spring ORM：对流行的O/R Mapping封装或支持</p><p>F.  Spring Web：提供Web应用上下文，对Web开发提供功能上的支持，如请求，表单，异常等。</p><p>G.  Spring Web MVC：全功能MVC框架，作用等同于Struts。</p><h3 id="Spring-IOC及DI理解和优点"><a href="#Spring-IOC及DI理解和优点" class="headerlink" title="Spring IOC及DI理解和优点"></a>Spring IOC及DI理解和优点</h3><pre><code class="hljs java">IOC及DI是同一层面的含义，前者是思想 - 控制反转，后者是实现，依赖注入，基本思想即解除AB对象相互引用的强耦合，将其转化到配置文件中，实现弱耦合的一种思想，控制反转，反转的是什么？即是获取对象的方式发生了变化，以前是直接<span class="hljs-keyword">new</span>一个对象，而现在则是从IOC容器中取，取的过程当中，需要set一些引用或者参数之类，这个即是依赖注入 ---&gt; 依赖注入是实现控制反转的方式谁依赖于谁：当然是应用程序依赖于IoC容器；为什么需要依赖：应用程序需要IoC容器来提供对象需要的外部资源；谁注入谁：很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象；注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）    IOC | DI ----&gt; AOP的基础</code></pre><h3 id="Spring-AOP的理解"><a href="#Spring-AOP的理解" class="headerlink" title="Spring AOP的理解"></a>Spring AOP的理解</h3><pre><code class="hljs angelscript">AOP 即面向切面编程，以无侵入的方式，去为当前的业务逻辑系统增加一些额外的功能，比如日志输出等等概念理解:<span class="hljs-number">1.</span>通知（Advice）就是你想要的功能，也就是上面说的 安全，事物，日志等。你给先定义好把，然后在想用的地方用一下。<span class="hljs-number">2.</span>连接点（JoinPoint）这个更好解释了，就是spring允许你使用通知的地方，那可真就多了，基本每个方法的前，后（两者都有也行），或抛出异常时都可以是连接点，spring只支持方法连接点.其他如aspectJ还可以让你在构造器或属性注入时都行，不过那不是咱关注的，只要记住，和方法有关的前前后后（抛出异常），都是连接点。<span class="hljs-number">3.</span>切入点（Pointcut）上面说的连接点的基础上，来定义切入点，你的一个类里，有<span class="hljs-number">15</span>个方法，那就有几十个连接点了，但是你并不想在所有方法附近都使用通知（使用叫织入，以后再说），你只想让其中的几个，在调用这几个方法之前，之后或者抛出异常时干点什么，那么就用切点来定义这几个方法，让切点来筛选连接点，选中那几个你想要的方法。<span class="hljs-number">4.</span>切面（Aspect）切面是通知和切入点的结合。现在发现了吧，没连接点什么事情，连接点就是为了让你好理解切点，搞出来的，明白这个概念就行了。通知说明了干什么和什么时候干（什么时候通过方法名中的before,after，around等就能知道），而切入点说明了在哪干（指定到底是哪个方法），这就是一个完整的切面定义。<span class="hljs-number">5.</span>引入（<span class="hljs-built_in">int</span>roduction）允许我们向现有的类添加新方法属性。这不就是把切面（也就是新方法属性：通知定义的）用到目标类中吗<span class="hljs-number">6.</span>目标（target）引入中所提到的目标类，也就是要被通知的对象，也就是真正的业务逻辑，他可以在毫不知情的情况下，被咱们织入切面。而自己专注于业务本身的逻辑。<span class="hljs-number">7.</span>代理(proxy)怎么实现整套aop机制的，都是通过代理的方式<span class="hljs-number">8.</span>织入(weaving)把切面应用到目标对象来创建新的代理对象的过程,spring采用的是运行时关键就是：切点定义了哪些连接点会得到通知spring用代理类包裹切面，把他们织入到Spring管理的bean中。也就是说代理类伪装成目标类，它会截取对目标类中方法的调用，让调用者对目标类的调用都先变成调用伪装类，伪装类中就先执行了切面，再把调用转发给真正的目标bean代理类的两种方式 ---&gt; 兄弟模式  一种是实现了某一接口，则可以通过共同的实现，伪装其本类，然后执行方法，把属性转发给真正的Bean父子模式  另一种是无接口实现，spring使用CGLIB库生成目标类的一个子类，在创建这个子类的时候，spring织入通知，并且把对这个子类的调用委托到目标类思考：即使是Spring，它也无法绕过java本身的规则， 父子模式下，创建目标类的子类，那<span class="hljs-keyword">final</span>方法该怎么办？<span class="hljs-keyword">final</span>类会怎么样？答案是：如果是<span class="hljs-keyword">final</span>方法，则在AOP实现中，会调用其目标类本身的方法Demo：一个对象  <span class="hljs-keyword">final</span> getTest() , setTest()通过AOP，它会创建代理类，<span class="hljs-keyword">set</span>到代理对象，即注入到代理对象中了，但是调用<span class="hljs-keyword">get</span>方法时，由于被<span class="hljs-keyword">final</span>修饰，因此调用的是其目标类的<span class="hljs-keyword">get</span>方法，因此结果仍然为<span class="hljs-literal">null</span>Demo概括：Spring AOP默认使用cglib会生成目标对象的子类，然后调用<span class="hljs-keyword">set</span>时会直接设置被代理对象的data，所以造成了target的data没有设置，当你调用<span class="hljs-keyword">get</span>方法时因为是<span class="hljs-keyword">final</span> 所以没有被代理 直接调用的是目标对象的，所以是<span class="hljs-literal">null</span></code></pre><h1 id="Spring视频学习笔记"><a href="#Spring视频学习笔记" class="headerlink" title="Spring视频学习笔记"></a>Spring视频学习笔记</h1><h2 id="注解驱动-IOC"><a href="#注解驱动-IOC" class="headerlink" title="@注解驱动  - IOC"></a>@注解驱动  - IOC</h2><pre><code class="hljs java"><span class="hljs-number">1</span>.<span class="hljs-meta">@Configuration</span>(自身也是组件Bean) - <span class="hljs-meta">@Bean</span>       ---&gt; 替代&lt;bean&gt;配置<span class="hljs-number">2</span>.<span class="hljs-meta">@ConmpoentScan</span> value 包名     ---&gt; 替代context-scan 包扫描 (自动扫描service,controller,Component,Repository)excludeFilters = Filter[] ===&gt;  排除某些不扫描demo:<span class="hljs-meta">@ConmpoentScan</span>(value=<span class="hljs-string">""</span>,excludeFilters = &#123;<span class="hljs-meta">@Filter</span>(type=FilterType,ANNOTATION,CLASSES = &#123;Controller<span class="hljs-class">.<span class="hljs-keyword">class</span>...&#125;)</span><span class="hljs-class">&#125;)</span>&#123;&#125;includeFilters 只扫描....    Filter规则很多...注解,类型,自定义...<span class="hljs-number">3</span>.组件作用域 <span class="hljs-meta">@Scope</span>(<span class="hljs-string">"prototype"</span>)singleton, prototype，request，session单实例 ---》 IOC容器启动，创建对象,永远唯一多实例 ---》 每次调用，才创建新的对象<span class="hljs-number">4</span>.懒加载【针对】单实例Bean - 容器启动时创建对象(懒加载:容器启动不加载，第一次使用的时候，即获取的时候才加载Bean)<span class="hljs-meta">@Lazy</span> 注解<span class="hljs-number">5</span>. <span class="hljs-meta">@Conditional</span> (用作具体的Bean或者类级别)Spring4<span class="hljs-number">.0</span>新增功能 按一定的条件进行判断，注册Bean补充：Spring可以获取到当前操作系统的详细信息 Environment注解的参数是conditonal数组，因此需要自定义条件接口实现，实现其match方法,通过context进行相关匹配等等，返回<span class="hljs-keyword">true</span>，<span class="hljs-keyword">false</span>如：<span class="hljs-meta">@Conditional</span>(&#123;Windows<span class="hljs-class">.<span class="hljs-keyword">class</span>&#125;)</span><span class="hljs-class"></span><span class="hljs-class">6.<span class="hljs-title">Bean</span>注册总结</span><span class="hljs-class">一. 传统注解  <span class="hljs-title">Componment</span>，<span class="hljs-title">service</span>，<span class="hljs-title">controller</span>等</span><span class="hljs-class">二. <span class="hljs-title">Bean</span>注解，通过包扫描去拿到<span class="hljs-title">Bean</span>(第三方包)</span><span class="hljs-class">三. @<span class="hljs-title">Import</span>注解 快速给容器中导入一个组件</span><span class="hljs-class"></span><span class="hljs-class">方式三具体说明</span>;  value参数如下:A. 如：一个类 注解  <span class="hljs-meta">@Configuration</span>  加上注解 <span class="hljs-meta">@Import</span>(Color.clss) 即可直接导入该类的bean，ID默认是全类名导入多个： <span class="hljs-meta">@Import</span>(&#123;Color,<span class="hljs-class"><span class="hljs-keyword">class</span>,<span class="hljs-title">Red</span>,<span class="hljs-title">class</span>&#125;)</span><span class="hljs-class"><span class="hljs-title">B</span>. <span class="hljs-title">ImportSelector</span> 导入选择器，接口 ，返回需要被导入的全类名数组即可 ---&gt; 包名+类名</span><span class="hljs-class"><span class="hljs-title">C</span>. <span class="hljs-title">ImportBeanDefinitionRegistrar</span>接口，通过手动注册，可注册新的<span class="hljs-title">bean</span> 调用<span class="hljs-title">register</span>...注册方法即可</span><span class="hljs-class"></span><span class="hljs-class">四. <span class="hljs-title">Bean</span>注册之  <span class="hljs-title">FactoryBean</span> 工厂方式注册</span><span class="hljs-class"><span class="hljs-title">ColorFactory</span> <span class="hljs-title">implents</span> <span class="hljs-title">FactoryBean</span>&lt;<span class="hljs-title">Color</span>&gt; </span>&#123;&#125;工厂Bean实现其接口即可,工厂类本身需要成为beanapplicationContext.getBean(<span class="hljs-string">"colorFactory"</span>)  ====&gt; 获取的是其生产的对象applicationContext.getBean(<span class="hljs-string">"&amp;colorFactory"</span>) ====&gt; 获取工厂Bean本身<span class="hljs-number">7</span>.Bean的生命周期创建---初始化---销毁的过程  整个过程由容器去管理我们可以自定义初始化和销毁方法,容器在进行到当前的生命周期时，会调用我们定义的初始化和销毁方法单实例：  构造(对象创建) --- 容器启动时创建  初始化 --- 对象创建完成,并赋值好，调用初始化方法  销毁   --- 容器关闭时，销毁多实例:  构造(对象创建) --- 获取对象时  初始化 --- 对象创建完成,并赋值好，调用初始化方法  销毁   --- 容器关闭时不销毁...自行销毁,容器不会调用销方法A. 指定初始化和销毁方法(对应 xml：init-method,destroy-method)   <span class="hljs-meta">@Bean</span>(initMethod = <span class="hljs-string">"init"</span>, destroyMethod = <span class="hljs-string">"destroy"</span>)B, 实现接口 InitializingBean接口,afterPropertiesSet方法,定义初始化逻辑   实现接口 DisposableBean接口 ,destroy方法,定义销毁逻辑 C. 注解  <span class="hljs-meta">@PostConstruct</span> 标注方法 --- 在bean创建完成并赋值完成后执行        <span class="hljs-meta">@PreDestroy</span> 被移除之前调用巧用<span class="hljs-meta">@PostConstruct</span>注解给<span class="hljs-keyword">static</span>变量赋值，利用的即是生命周期初始化的过程方式一 - 注入<span class="hljs-keyword">static</span>变量:<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DistinctUtil</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RedisHelper redisHelper;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> DistinctUtil distinctUtil;    <span class="hljs-meta">@PostConstruct</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;        distinctUtil = redisHelper;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doDistinct</span><span class="hljs-params">()</span> </span>&#123;        distinctUtil.redisHelper.sdiff();    &#125;&#125;方式二 - 注入<span class="hljs-keyword">static</span>变量:：<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DistinctUtil</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> RedisHelper redisHelper;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRedisHelper</span><span class="hljs-params">(RedisHelper redisHelper)</span> </span>&#123;        DistinctUtil.redisHelper = redisHelper;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doDistinct</span><span class="hljs-params">()</span> </span>&#123;        redisHelper.sdiff();    &#125;&#125;D. 组件：BeanPostProcessor Bean的后置处理器(在bean初始化前后，进行处理工作)        方法：             【---源碼分析：属性赋值】             【bean的初始化】             postProcessBeforeInitialization  初始化之前处理工作             【自定义初始化方法】             postProcessAfterInitialization   初始化之后处理工作<span class="hljs-number">8</span>.BeanPostProcessor的应用  ApplicationContextAware接口，可以获取IOC容器应用于私有云SpringBoot获取IOC容器任务<span class="hljs-meta">@PostConstruct</span>注解...bean的赋值<span class="hljs-meta">@Autowire</span>注解...都是基于BeanPostProcessor的应用来实现的<span class="hljs-number">9</span>. <span class="hljs-meta">@Value</span>注解   方式：  A.直接写基本的数值          B.可以写SpEL =&gt; <span class="hljs-meta">@Value</span>(<span class="hljs-string">"#&#123;20 - 2&#125;"</span>)          C.<span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;配置文件&#125;"</span>)   ---&gt;           如果没有配置文件可以用 <span class="hljs-meta">@PropertySource</span>(value&#123;<span class="hljs-string">"classpath:/person.properties"</span>,<span class="hljs-string">""</span>&#125;)注解指定配置文件,参数可以是字符串数组的形式，即一次加载多个                    注解写在<span class="hljs-meta">@Configuration</span>配置注解下注：ioc容器也可以直接获取到配置文件里面的参数等等.environment.getProperties()...    <span class="hljs-number">10</span>. 自动装配 <span class="hljs-meta">@Autowired</span> Spring依赖DI，完成对IOC容器中各个组件的依赖关系赋值A. 自动注入工作原理： 默认优先按照类型去容器中找组件（类型的意思即 xxx<span class="hljs-class">.<span class="hljs-keyword">class</span>）</span><span class="hljs-class"><span class="hljs-title">B</span>. 如果有多个是如何处理的：相同类型找到多个，就将属性的名称作为组件的<span class="hljs-title">ID</span>，在容器中查找</span>配合 @Qualifier("bookDao") ---&gt; 明确装配的IDC. 如果容器中找不到该类型组件：报错，创建Bean失败,因此是默认一定要赋值成功，否则就抛出错误配合 <span class="hljs-meta">@Autowired</span>(required = <span class="hljs-keyword">false</span>) 即表示非必须找到，找不到就赋个<span class="hljs-keyword">null</span><span class="hljs-meta">@Primary</span> 默认首选的bean，在可能多个的时候，此注解可以默认首选<span class="hljs-number">11</span>. <span class="hljs-meta">@Resource</span> 注解可以和Autowired一样，都是自动装配,它默认按照组件名称进行装配<span class="hljs-meta">@Inject</span> 需要导入javax.inject 和 autowired功能一致,但是内部无属性,所以用的也不多总结：Autowired是Spring的注解，Resource，inject是Java的规范AutowiredAnnotationBeanPostProcessor： 解析完成自动装配的功能<span class="hljs-number">12</span>. <span class="hljs-meta">@Autowired</span>  构造器，方法，属性使用该注解 ---&gt; 从容器中获取参数组件的值<span class="hljs-meta">@Autowired</span> 标注在方法上,spring容器创建该对象时，就会执行该方法，一般用以配置参数，<span class="hljs-keyword">static</span>变量赋值等等默认情况下容器启动，会调用bean的无参构造器构造对象,再进行初始化赋值等操作，但是放在构造器上，即可使之使用有参构造器如果组件只有一个有参构造器，这个有参构造器的<span class="hljs-meta">@Autowired</span>可以省略,参数位置的组件还是可以从容器中获取放到参数上 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">void</span> <span class="hljs-params">(@Autowired Car car)</span> </span>&#123;&#125;<span class="hljs-number">13</span>. 自定义组件想要使用Spring容器底层的组件,比如applicationContext...BeanFactory等等组件实现对应的 xxxAware接口即可如：ApplicationAware   EmbeddedValueResolver  字符串解析器.可以解析  $&#123;os.name&#125;  #$...原理：有其相关的ApplicationAwareProcessor后置处理器处理的...一一对应<span class="hljs-number">14</span>. Pofile - 可以结合Profile注解完成 - Spring为我们提供的可以根据当前环境，动态的激活和切换一系列组件的功能<span class="hljs-meta">@Profile</span> 指定组件在哪个环境的情况下才能被注册到容器中,默认是<span class="hljs-keyword">default</span>环境<span class="hljs-meta">@Profile</span>(<span class="hljs-string">"test"</span>)<span class="hljs-meta">@Bean</span>......运行方式: A. jar运行时 指定激活类型m, 在虚拟机参数位置加载: -Dspring.profiles.active=testB. 代码的方式,利用无参构造器启动Spring容器:①创建applicationcontext对象②设置激活环境（environment.setActiveProfiles）③注册主配置类(register(MainConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span><span class="hljs-class"></span><span class="hljs-class">个人认为最好的实现方式还是类似云测项目中写在<span class="hljs-title">POM</span>文件中，切换更加方便</span><span class="hljs-class">    </span><span class="hljs-class"></span><span class="hljs-class">15.<span class="hljs-title">IOC</span>小结 - 注意@<span class="hljs-title">Conditional</span> ,@<span class="hljs-title">Import</span> 注解 在<span class="hljs-title">boot</span>中使用频繁</span></code></pre><h2 id="注解驱动-AOP"><a href="#注解驱动-AOP" class="headerlink" title="@注解驱动  - AOP"></a>@注解驱动  - AOP</h2><pre><code class="hljs java">AOP：在程序运行期间将某段代码切入到指定方法指定位置进行运行的编程方式<span class="hljs-number">1</span>.通知类型<span class="hljs-comment">// 匹配该类下所有方法,参数任意</span>前置通知：<span class="hljs-meta">@Before</span>(<span class="hljs-string">"public int com.xxx.MathCalculator.*(..)"</span>)后置通知：<span class="hljs-meta">@After</span>返回通知：<span class="hljs-meta">@AfterReturning</span>异常通知：<span class="hljs-meta">@AfterThrowing</span>环绕通知：<span class="hljs-meta">@Around</span><span class="hljs-number">2</span>.基于注解配置<span class="hljs-comment">// 抽取公共的切入点表达式</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"public int com.xxx.MathCalculator.*(..)"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pointCut</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-meta">@Before</span>(<span class="hljs-string">"pointCut()"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">()</span></span>&#123;&#125; <span class="hljs-number">3</span>.配置重点<span class="hljs-comment">// 重点 - 切面类和被切类都应该被加入到容器中，且切面类 需要加注解 @Aspect 表示切面类</span><span class="hljs-comment">// 配置类开启AOP --- @EnableAspectJAutoProxy(配置类)</span><span class="hljs-number">4</span>.拿到切点方法和参数的方式拿到切入点的具体参数<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">aop</span> <span class="hljs-params">(JoinPoint joinPoint)</span> </span>&#123;joinPoint.getSignature().getName() ---&gt; 方法名joinPoint.getArgs();  ---&gt; 参数列表&#125;<span class="hljs-number">5</span>,返回通知和异常通知拿到结果或者异常的方式获取返回值 --- AfterReturning(value = <span class="hljs-string">"pointCut()"</span>, returning = <span class="hljs-string">"result"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">returning</span> <span class="hljs-params">(Object result)</span> </span>&#123;&#125;获取异常 --- AfterReturning(value = <span class="hljs-string">"pointCut()"</span>, throwing = <span class="hljs-string">"exception"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exception</span> <span class="hljs-params">(Exception exception)</span> </span>&#123;&#125;<span class="hljs-meta">@Around</span>(<span class="hljs-string">"com.javadoop.aop.SystemArchitecture.businessService()"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">doBasicProfiling</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;    <span class="hljs-comment">// start stopwatch</span>    Object retVal = pjp.proceed();    <span class="hljs-comment">// stop stopwatch</span>    <span class="hljs-keyword">return</span> retVal;&#125;总结: A. 将业务逻辑和切面类加入到容器中，注意<span class="hljs-meta">@Aspect</span>B. 在切面类的每一个通知方法上标注通知注解，告诉Spring何时何地进行C. 基于注解的AOP配置  <span class="hljs-meta">@EnableAspectJAutoProxy</span>(配置类)</code></pre><h2 id="原理-AOP"><a href="#原理-AOP" class="headerlink" title="原理 - AOP"></a>原理 - AOP</h2><pre><code class="hljs kotlin">源头：<span class="hljs-meta">@EnableAspectJAutoProxy</span>调用了AspectJAutoProxyRegister<span class="hljs-class">.<span class="hljs-keyword">class</span> ---&gt; 目的是为了向容器类注册<span class="hljs-title">bean</span> ---》 自动代理创建器</span>自动代理创建器即组件: AnnotatainAwareAspectJAutoProxyCreatorSpring 通过组装advice注解，自动生成新的Bean，getBean的时候返回的实质即是 代理类代理一般分为两种方式：JDK自带的动态代理以及CGLIB代理JDK：接口CGLIB：继承，注意<span class="hljs-keyword">final</span>和<span class="hljs-keyword">private</span> 方法无法被增强Demo：一个对象  <span class="hljs-keyword">final</span> getTest() , setTest()通过AOP，它会创建代理类，<span class="hljs-keyword">set</span>到代理对象，即注入到代理对象中了，但是调用<span class="hljs-keyword">get</span>方法时，由于被<span class="hljs-keyword">final</span>修饰，因此调用的是其目标类的<span class="hljs-keyword">get</span>方法，因此结果仍然为<span class="hljs-literal">null</span>Demo概括：Spring AOP默认使用cglib会生成目标对象的子类，然后调用<span class="hljs-keyword">set</span>时会直接设置被代理对象的<span class="hljs-keyword">data</span>，所以造成了target的<span class="hljs-keyword">data</span>没有设置，当你调用<span class="hljs-keyword">get</span>方法时因为是<span class="hljs-keyword">final</span> 所以没有被代理 直接调用的是目标对象的，所以是<span class="hljs-literal">null</span></code></pre><h3 id="Q1-为什么SpringIOC容器加载的时候-使用HashMap-线程不安全-检测有没有看Spring源码"><a href="#Q1-为什么SpringIOC容器加载的时候-使用HashMap-线程不安全-检测有没有看Spring源码" class="headerlink" title="Q1:为什么SpringIOC容器加载的时候 使用HashMap (线程不安全-检测有没有看Spring源码)?"></a>Q1:为什么SpringIOC容器加载的时候 使用HashMap (线程不安全-检测有没有看Spring源码)?</h3><pre><code class="hljs java"><span class="hljs-comment">// AutowiredAnnotationBeanPostProcessor</span><span class="hljs-comment">// synchronized 锁住了代码块</span><span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>.candidateConstructorsCache) &#123;    &#125;</code></pre><h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题:"></a>遗留问题:</h2><ol><li>为什么Jdk1.8 可以支持重复注解扫描</li></ol><p>\1. IoC 属于哪种设计模式？</p><p>\2. 谈谈你对 Spring IoC 和 DI 的理解，它们有什么区别？</p><p>\3. 简单谈谈 IoC 容器的原理。</p><p>\4. bean 的 scope 有几种类型？请详细列举。</p><p>\5. 说说 IoC 中的继承和 Java 继承的区别。</p><p>\6. IoC 中 car 对象的配置如下，现在要添加 user 对象，并且将 car 注入到 user 中，正确的配置是？</p><p>\7. 请分别写出 IoC 静态工厂方法和实例工厂方法的配置。</p><p>\8. IoC 自动装载有几种方式？</p><p>\9. 介绍一下 Spring 框架中 bean 的生命周期。</p><p>\10. IoC 容器自动完成装载，默认的方式是？</p>]]></content>
    
    
    <categories>
      
      <category>框架篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第6章  查询性能优化</title>
    <link href="/2023/09/12/%E7%AC%AC6%E7%AB%A0%20%20%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2023/09/12/%E7%AC%AC6%E7%AB%A0%20%20%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="第6章-查询性能优化"><a href="#第6章-查询性能优化" class="headerlink" title="第6章  查询性能优化"></a>第6章  查询性能优化</h1><blockquote><p>本文为《高性能Mysql 第三版》第六章读书笔记，Mysql版本为5.5</p></blockquote><h2 id="为什么查询速度会慢"><a href="#为什么查询速度会慢" class="headerlink" title="为什么查询速度会慢"></a>为什么查询速度会慢</h2><blockquote><p>查询优化，索引优化，库表结构优化需要齐头并进，一个不落</p><p>如果把查询看作是一个任务，那么它由一系列子任务构成，每个子任务h都会消耗一定的时间，如果要优化查询，实际上要优化其子任务，要么消除其中一些子任务，要么减少子任务的执行次数，要么让子任务运行得更快</p></blockquote><p>通常来说，查询的生命周期大致可以按照顺序来看：从客户端，到服务器，然后在服务器上进行解析，生成执行计划，执行，并返回结果给客户端。其中“执行”可以认为是整个生命周期中最重要的阶段，这其中包含了大量为了检索数据到存储引擎的调用以及调用后的数据处理，包括排序，分组等</p><p>在完成这些任务时，查询需要在不同地方花费时间，包括网络，CPU计算，生成统计信息和执行计划，锁等待等操作。</p><p>在消耗大量时间的查询中，我们都能看到一些不必要的额外操作、某些操作额外地重复多次执行，某些操作执行太慢等。优化查询的目的就会减少和消除这些操作所花费的时间。</p><h2 id="慢查询基础：优化数据访问"><a href="#慢查询基础：优化数据访问" class="headerlink" title="慢查询基础：优化数据访问"></a>慢查询基础：优化数据访问</h2><p>查询性能低下最基本的原因是访问的数据太多，某些查询可能不可避免地需要筛选大量数据，大部分性能低下的查询都可以通过减少访问数据量的方式进行优化，主要包含：</p><ul><li>判断是否程序检索了要多不必要的行或者不必要的列</li><li>确认Mysql服务器层是否在分析大量超过需要的数据行</li></ul><h3 id="是否向数据库请求了不需要的数据"><a href="#是否向数据库请求了不需要的数据" class="headerlink" title="是否向数据库请求了不需要的数据"></a>是否向数据库请求了不需要的数据</h3><ul><li>查询不需要的记录（Mysql是返回全部结果集再进行计算）===》 <code>解决方案：LIMIT</code></li><li>多表关联返回全部列 ===》 <code>解决方案：通过SELECT [特定表的字段]</code></li><li>总是取出全部列 SELECT * </li><li>重复查询相同的数据  例如用户在执行重复性操作时候容易调用相同的查询逻辑（评论时查询用户信息）</li></ul><h3 id="Mysql是否在扫描额外的记录"><a href="#Mysql是否在扫描额外的记录" class="headerlink" title="Mysql是否在扫描额外的记录"></a>Mysql是否在扫描额外的记录</h3><p>衡量指标：</p><ul><li>响应时间</li><li>扫描的行数</li><li>返回的行数</li></ul><pre><code class="hljs 响应时间：```响应时间包括**服务时间**（数据库处理这个查询真正花了多长时间）和排队时间（服务器等待资源的时间，如I/O操作，等待行锁等）">MySQL无法详细划分在这两个部分上的时间，也没有一致的规律或公式来衡量计算响应时间。需要凭借自己的经验判断响应时间否合理，或者使用&quot;快速上限估计&quot;&#96;&#96;&#96;扫描的行数和返回的行数：&#96;&#96;&#96;事实情况下很难做到扫描行数与返回的行数完全一致。例如关联查询时，需要扫描多行才能生成一行结果，扫描行数和返回行数的比例越高说明扫描行的效率越高&#96;&#96;&#96;扫描的行数和访问类型：</code></pre><p>在EXPLAIN语句中的type列反应了访问类型，访问类型有很多种，从全表扫描到索引扫描，范围扫描，唯一索引扫描，常熟引用速度依次从慢到快，扫描的行数也是从大到小，需要理解的是扫描表，扫描索引，范围访问，和单值访问的概念</p><p>如果EXPLAIN语句时候发现，查询没有办法找到合适的访问类型，最好的解决办法通常就是增加一个合适的索引</p><p>有时候我们在查询中EXPLAIN语句，会看到 “Using Where”，这表示Mysql将通过WHERE条件来筛选存储引擎返回的记录，一般来说Mysql能够使用如下三种方式应用WHERE条件，从好到坏依次是：</p><ul><li><p><strong>在索引中使用WHERE条件过滤不匹配的记录，这是在存储引擎层完成的</strong></p></li><li><p><strong>使用索引覆盖扫描（在 Extra 中出现了Using index）来返回记录，直接从索引中过滤不需要的记录并返回命中的结果，这是在</strong></p><p><strong>Mysql服务层完成的事，但无需再回表查询记录</strong></p></li><li><p><strong>从数据表返回数据，然后过滤不满足条件的记录（在Extra中出现了Using Where），这是在Mysql服务器层完成，Mysql需要先</strong></p><p><strong>从数据表读出记录然后过滤</strong></p></li></ul><p>如果发现查询需要扫描大量的数据但只返回少量的行，那么通常可以尝试下面的技巧去优化它：</p><ul><li>使用索引覆盖扫描，把所有需要用的列都放到索引中，这样存储引擎无须回表获取对应行就可以返回结果了</li><li>改变库表结构，例如使用单独的汇总表</li><li>重写这个复杂的查询，让Mysql优化器能够以更优化的方式去执行这个查询</li></ul><h2 id="重构查询方式"><a href="#重构查询方式" class="headerlink" title="重构查询方式"></a>重构查询方式</h2><h3 id="一个复杂查询还是多个简单查询"><a href="#一个复杂查询还是多个简单查询" class="headerlink" title="一个复杂查询还是多个简单查询"></a>一个复杂查询还是多个简单查询</h3><p>传统实现中，总是强调需要数据库层完成尽可能多的工作。这样的逻辑是认为网络通行，查询解析和优化是一件代价很高的事情</p><p>但是对MySQL并不适用。MySQL从设计让连接和断开连接都很轻量级，在返回一个小的结果方面效率很高。同时现代网络也比以前快很多。因此一些场景下可以将一个复杂查询分解为多个简单查询</p><h3 id="切分查询"><a href="#切分查询" class="headerlink" title="切分查询"></a>切分查询</h3><p>有时候可以对一个大查询分解为多个小查询，每个查询的功能完全相同。</p><p>举个例子：删除旧的数据。如果用一个大的语句一次删除，可能需要一次锁住很多数据，占满整个事务日志，耗尽系统资源，阻塞很多小的但是重要的查询。此时就可以将一个大的delete语句切分成多个较小的查询，尽可能减小对MySQL的性能影响</p><h3 id="分解关联查询"><a href="#分解关联查询" class="headerlink" title="分解关联查询"></a>分解关联查询</h3><p>可以将关联查询改变为<strong>对每一个表进行一次查询，然后将结果在应用程序中进行关联</strong>。这样做的好处有：</p><ol><li>让缓存的效率更高。有一些数据可能已经被缓存了，利用缓存可以获得单表查询的结果</li><li>将查询分解后，执行单个查询可以减少锁的竞争</li><li>在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展</li><li>查询本身的效率也会有所提升</li><li>可以减少冗余记录的查询。在应用层做关联，意味着某条记录应用只需要查询一次，但是在数据库中做关联，则可能需要重复地访问一部分数据</li><li>分解关联查询相当于在应用中实现了<strong>哈希关联</strong>，而不是使用MySQL中的<strong>嵌套循环关联</strong>。效率更高</li></ol><h2 id="查询执行的基础"><a href="#查询执行的基础" class="headerlink" title="查询执行的基础"></a>查询执行的基础</h2><p>当向Mysql发送一个请求的时候，Mysql到底做了什么？</p><p>![image-20200308164147687](第6章  查询性能优化/image-20200308164147687.png)</p><ol><li>客户端发送一条查询给服务器</li><li>服务器先检查缓存，如果命中缓存，则立即返回存储在缓存中的结果</li><li>服务器进行SQL解析，预处理，再由优化器生成对应的执行计划</li><li>MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询</li><li>将结果返回给客户端</li></ol><h3 id="Mysql客户端-服务器通信协议"><a href="#Mysql客户端-服务器通信协议" class="headerlink" title="Mysql客户端/服务器通信协议"></a>Mysql客户端/服务器通信协议</h3><p>Mysql客户端和服务器之间的通信协议是 “半双工”的，这意味着在任何一个时刻，要么由服务器向客户端发送数据，要么由客户端向服务器发送数据，这两个动作不可能同时发生</p><p> 客户端用<strong>一个单独的数据包</strong>将查询传给服务器。如果查询太大，服务器会拒接接受更多的数据并抛出错误，可以通过<code>max_allowed_packet</code>设置查询最大长度</p><p>服务器端响应给客户端的数据通常很多，由多个数据包组成，客户端必须完整地接受整个返回结果，不能取前几条数据然后让服务器端停止发送，因此如果只需要获取其中部分数据，比较好的方式是加LIMIT </p><pre><code class="hljs 查询状态：```对于一个Mysql连接，或者一个线程，任何时刻都有一个状态，该状态表示了Mysql当前正在做什么，有很多种方式能查看当前的状态，最简单的是使用SHOW">- Sleep      线程等待客户端发送新的请求- Query     线程正在执行查询或者正在将结果发送给客户端- Locked   在Mysql服务器层，该线程正在等候表锁，在存储引擎级别实现的锁- Analyzing and statistics   线程正在收集存储引擎的统计信息，并生成查询的执行计划- Copying to tmp table [on disk]   线程正在执行查询，并且将结果集都复制到一个临时表中，这种状态一般要么是在做Group By  操作，要么是文件排序操作，或者UNION操作，如果这个状态还有 [on disk] 标记，那表示Mysql正在将一个内存临时表放到磁  盘上- Sorting result   线程正在对结果集进行排序- Sending data   这表示多种情况，线程可能在多个状态之间传送数据，或者在生成结果集，或者在向客户端返回数据SHOW FULL PROCESSLIST 常用相关命令整理： **按客户端 IP 分组，看哪个客户端的链接数最多** &#96;&#96;&#96;sqlselect client_ip,count(client_ip) as client_num from (select substring_index(host,&#39;:&#39; ,1) as client_ip from information_schema.processlist ) as connect_info group by client_ip order by client_num desc;</code></pre><p> <strong>查看正在执行的线程，并按 Time 倒排序，看看有没有执行时间特别长的线程</strong> </p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> information_schema.processlist <span class="hljs-keyword">where</span> Command != <span class="hljs-string">'Sleep'</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-built_in">Time</span> <span class="hljs-keyword">desc</span>;</code></pre><p><strong>找出所有执行时间超过 5 分钟的线程，拼凑出 kill 语句，方便后面查杀 （此处 5分钟）</strong> </p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">concat</span>(<span class="hljs-string">'kill '</span>, <span class="hljs-keyword">id</span>, <span class="hljs-string">';'</span>) <span class="hljs-keyword">from</span> information_schema.processlist <span class="hljs-keyword">where</span> Command != <span class="hljs-string">'Sleep'</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">Time</span> &gt; <span class="hljs-number">300</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-built_in">Time</span> <span class="hljs-keyword">desc</span>;</code></pre><p> <strong>查询线程及相关信息</strong> </p><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">full</span> <span class="hljs-keyword">processlist</span>;</code></pre><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>在解析一个查询语句之前，如果查询缓存是打开的，那么Mysql会优先检查这个查询是否命中查询缓存中的数据，这个检查是通过一个对大小写敏感的哈希查找实现的</p><p>如果当前的查询命中了查询缓存，那么在返回查询结果之前Mysql会检查一次用户权限，这仍然是无须解析查询SQL语句的，因为在查询缓存中已经存放了当前查询需要访问的表信息，如果权限没有问题，Mysql会跳过所有其他阶段，直接从缓存中拿到结果并返回给客户端，在这种情况下，查询不会被解析，不用生成执行计划，不会被执行。</p><h3 id="查询处理优化"><a href="#查询处理优化" class="headerlink" title="查询处理优化"></a>查询处理优化</h3><h4 id="语法解析器和预处理"><a href="#语法解析器和预处理" class="headerlink" title="语法解析器和预处理"></a>语法解析器和预处理</h4><p>首先，Mysql通过关键字将SQL语句进行解析，并生成一颗对应的<code>解析树</code>，Mysql解析器将使用Mysql语法规则验证和解析查询，例如，它将验证是否使用错误的关键字，或者使用关键字的顺序是否正确等，再或者它会验证引号是否能前后正确匹配</p><p>预处理器则根据一些Mysql规则进一步检查解析树是否合法，下一步预处理器会验证权限等</p><h4 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h4><p>一条查询可以有很多种执行方式，最后都返回相同的结果，优化器的作用就是找到这其中最好的执行计划。</p><p>Mysql基于成本的优化器，它将尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最小的一个，最初，成本最小单位是随机读取一个4K数据页的成本，后来计算公式变得更加复杂，并且引入了一些 “因子”，来估算某些操作的代价，</p><p>如，当执行一次WHERE条件比较的成本，可以通过查询当前会话的Last_query_cost的值来得知Mysql计算当前查询成本</p><pre><code class="hljs sql">mysql &gt; SHOW STATUS LIKE 'Last_query_cost';<span class="hljs-comment"># Result</span>Last_query_cost12.499000</code></pre><p>优化器在评估成本的时候并不考虑任何层面的缓存，它假设读取任何数据都需要一次磁盘I/O</p><p>有很多种原因会导致Mysql优化器选择错误的执行计划，例如：</p><ul><li>统计信息不准确，例如 InnoDB因为其MVCC的架构，并不能维护一个数据表的行数的精确统计信息</li><li>执行计划中的成本估算并不是实际执行的成本，所以选择依然可能有误</li><li>Mysql的最优可能和你想的最优不一样，Mysql的最优标准是成本最低，而不是速度最快</li><li>Mysql从不考虑其他并发执行的查询，这可能会影响当前查询的速度</li><li>Mysql并不是任何时候都是基于成本优化，有时候也会基于一些固定的规则，Eg：match()子句 </li><li>Mysql不会考虑不受控制的操作的成本，比如用户自定义函数 </li></ul><p>以下是Mysql优化器可以处理的优化类型：</p><ul><li>重新定义关联表的顺序</li><li>将外连接转化为内连接</li><li>使用等价变换规则</li><li>优化COUNT(), MIN(), MAX()</li><li>预估并转化为常数表达式</li><li>覆盖索引扫描</li><li>子查询优化</li><li>提前终止查询</li><li>等值传递</li><li>列表IN()的比较-Mysql中将IN()的列表中的数据先进行排序，然后通过二分查找的方法来确定列表中的值是否满足条件，这是一个O(log n)复杂度的操作，等价的转换成OR查询的复杂度是O(n)，对于IN()列表中有大量取值的时候，MySQL的处理速度将会更快</li></ul><h4 id="数据和索引的统计信息"><a href="#数据和索引的统计信息" class="headerlink" title="数据和索引的统计信息"></a>数据和索引的统计信息</h4><p>MySQL架构由多个层次组成，在服务器查询优化器，却没有保存数据和索引的统计信息，统计信息由存储引擎实现，不用的存储引擎可能会存储不同的统计信息</p><p>因为服务器层没有任何统计信息，所以MySQL查询优化器在生成查询的执行计划时，需要向存储引擎获取相应的统计信息，存储引擎则提供给优化器对应的统计信息，包括每个表或者索引有多少个Page，每个表每个索引的基数是多少，数据行和索引长度，索引的分布信息。优化器根据这些信息来选择一个最优的执行计划</p><h4 id="MySQL如何执行关联查询"><a href="#MySQL如何执行关联查询" class="headerlink" title="MySQL如何执行关联查询"></a>MySQL如何执行关联查询</h4><p>在MySQL中，任何一次查询都是一次关联，所以理解Mysql如何执行关联查询至关重要</p><p>对于UNION查询，Mysql先将一系列的单个查询结果放到一个临时表中，然后再重新读出临时表数据来完成UNION查询，在Mysql的概念中，每一次查询都是一次关联，所以读取结果临时表也是一次关联</p><p>Mysql对任何关联都执行嵌套循环关联操作，即Mysql先在一个表中循环取出单条数据，然后再嵌套到下一个表中寻找匹配的行，依次下去，直到找到所有表中匹配的行为止，然后根据各个表匹配的行，返回查询中需要的各个列，Mysql会尝试在最后一个关联表中找到所有匹配的行，如果最后一个关联表无法找到更多的行以后，MySQL返回到上一层次关联表，看是否能够找到更多的匹配记录，依次类推迭代执行。</p><h4 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h4><p>Mysql最终的执行计划包括了重构查询的全部信息，如果对某个查询执行EXPLAIN EXTENDED，再执行SHOW WARNINGS，就可以看到重构出的查询</p><h4 id="关联查询优化器"><a href="#关联查询优化器" class="headerlink" title="关联查询优化器"></a>关联查询优化器</h4><p>Mysql优化器最重要的一部分就是关联查询优化，它决定了多个表关联时的顺序，通过多表关联的时候，可以有多种不同的关联顺序来获得相同的执行结果，选取最佳方案的依据依然是成本计算</p><h4 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h4><p>Mysql在排序中，如果数据量小则在内存中进行，如果数据量大则需要使用磁盘，不过Mysql将这个过程统一称为文件排序(filesort)，即使完全是内存排序不需要使用磁盘也是如此</p><p>数据量的核算标准则是“排序缓冲区”，如果排序缓冲区不够，那么Mysql则会先将数据分块，对每个独立的块使用“快速排序”进行排序，并将各个块的排序结果放到磁盘上，然后将各个排好序的块进行合并，最后返回排序结果</p><h3 id="查询执行引擎"><a href="#查询执行引擎" class="headerlink" title="查询执行引擎"></a>查询执行引擎</h3><p>在解析和优化阶段，MYSQL将生成查询对应的执行计划，MYSQL的査询执行引则根据这个执行计划来完成整个查询。这里执行计划是一个数据结构，而不是和很多其他的关系型数据库那样会生成对应的字节码</p><p>相对于查询优化阶段,査询执行阶段不是那么复杂：MYSQL只是简单地根据执行计划给出的指令逐步执行。在根据执行计划逐步执行的过程中,有大量的操作需要通过调用存储引擎实现的接口来完成,这些接口也就是我们称为“ handler AP”的接口。査询中的每一个表由一个 handler的实例表示， MYSQL在优化阶段就为每个表创建了一个 handler实例,优化器根据这些实例的接口可以获取表的相关信息,包括表的所有列名、素引统计信息,等等</p><h3 id="返回结果给客户端"><a href="#返回结果给客户端" class="headerlink" title="返回结果给客户端"></a>返回结果给客户端</h3><p>查询执行的最后一个阶段将会是将结果返回给客户端，即使查询不需要返回结果集给客户端，Mysql仍然会返回这个查询的一些信息，如该查询影响到的行数</p><p>如果査询可以被缓存，那么 MYSQL在这个阶段也会将结果存放到査询缓存中。MYSQL将结果集返回客户端是一个增量、逐步返回的过程，例如，我们回头看看前面的关联操作，一旦服务器处理完最后一个关联表，开始生成第一条结果时，MYSQL就可以开始向客户端逐步返回结果集了</p><h2 id="Mysql查询优化器的局限性"><a href="#Mysql查询优化器的局限性" class="headerlink" title="Mysql查询优化器的局限性"></a>Mysql查询优化器的局限性</h2><h3 id="关联子查询"><a href="#关联子查询" class="headerlink" title="关联子查询"></a>关联子查询</h3><p>常见的一种查询， 希望找到 Sakila 数据库中， 演员 PG(actor_id = 1) 所参演的影片信息, 一般来讲我们都会以下面的方式完成子查询：</p><pre><code class="hljs sql">mysql&gt; SELECT * FROM sakila.film-&gt; WHERE film_id IN(-&gt; SELECT film_id FROM sakila.film_actor WHERE actor_id = 1);</code></pre><p>大多数情况下我们都会以为上面的语句执行时会按照下面的顺序执行：</p><pre><code class="hljs angelscript">-- SELECT GROUP_CONCAT(film_id) FROM sakila.film_actor WHERE actor_id = <span class="hljs-number">1</span>;-- Result: <span class="hljs-number">1</span>,<span class="hljs-number">23</span>,<span class="hljs-number">25</span>,<span class="hljs-number">106</span>,<span class="hljs-number">140</span>,<span class="hljs-number">166</span>,<span class="hljs-number">277</span>,<span class="hljs-number">361</span>,<span class="hljs-number">438</span>,<span class="hljs-number">499</span>,<span class="hljs-number">506</span>,<span class="hljs-number">509</span>,<span class="hljs-number">605</span>,<span class="hljs-number">635</span>,<span class="hljs-number">749</span>,<span class="hljs-number">832</span>,<span class="hljs-number">939</span>,<span class="hljs-number">970</span>,<span class="hljs-number">980</span>SELECT * FROM sakila.filmWHERE film_id IN(<span class="hljs-number">1</span>,<span class="hljs-number">23</span>,<span class="hljs-number">25</span>,<span class="hljs-number">106</span>,<span class="hljs-number">140</span>,<span class="hljs-number">166</span>,<span class="hljs-number">277</span>,<span class="hljs-number">361</span>,<span class="hljs-number">438</span>,<span class="hljs-number">499</span>,<span class="hljs-number">506</span>,<span class="hljs-number">509</span>,<span class="hljs-number">605</span>,<span class="hljs-number">635</span>,<span class="hljs-number">749</span>,<span class="hljs-number">832</span>,<span class="hljs-number">939</span>,<span class="hljs-number">970</span>,<span class="hljs-number">980</span>);</code></pre><p>但是时间情况却是MySQL 会先全表扫描 film 表， 然后进行子查询，依次比对 film 表中的 film_id 与 file_actor 表中 actor_id = 1的 film_id， sql 在执行时将会改写成以下语句：</p><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> sakila.film <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">EXISTS</span> ( <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> sakila.film_actor <span class="hljs-keyword">WHERE</span> actor_id = <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> film_actor.film_id = film.film_id);</code></pre><p>如果外层的表 film 数据量并不是很大的时候， 对性能的影响不会引起注意， 如果外层的表很大， 这个查询的性能就会很糟糕， 常见的一个优化的方式为：</p><pre><code class="hljs SQL">mysql&gt; SELECT film.* FROM sakila.film-&gt; INNER JOIN sakila.film_actor USING(film_id) -&gt; WHERE actor_id = 1;</code></pre><p>至于使用子查询还是内/外连接， 需要看具体的执行计划， 并不一定说内/外连接的性能一定比子查询好</p><h3 id="UNION限制"><a href="#UNION限制" class="headerlink" title="UNION限制"></a>UNION限制</h3><p>两个表进行UNION， 数据量很大时， 临时表可能会很大， 可以在 UNION 的子查询中加上 LIMIT 来减少临时表的数据 </p><h3 id="索引合并优化"><a href="#索引合并优化" class="headerlink" title="索引合并优化"></a>索引合并优化</h3><p>当查询语句中有 OR 时, 会求并集。查询SELECT * FROM TB1 WHERE c1=”xxx” OR c2=””xxx”时，如果c1和c2列上分别有索引，可以按照c1和c2条件进行查询，再将查询结果合并（union）操作</p><p>当查询语句中有 AND 时, 会求交集。如查询SELECT * FROM TB1 WHERE c1=”xxx” AND c2=””xxx”时，如果c1和c2列上分别有索引，可以按照c1和c2条件进行查询，再将查询结果取交集（intersect）操作</p><p>索引索引合并的性能并不及复合索引</p><h3 id="等值传递"><a href="#等值传递" class="headerlink" title="等值传递"></a>等值传递</h3><p> 非常大的 IN()列表 MySQL 优化器会将这个列表的值与另一个表做关联，类似于子查询是对 IN 语句的改写 </p><h3 id="并行执行"><a href="#并行执行" class="headerlink" title="并行执行"></a>并行执行</h3><p>在5.X版本均不支持并行执行</p><h3 id="哈希关联"><a href="#哈希关联" class="headerlink" title="哈希关联"></a>哈希关联</h3><p>在5.X版本， MySQL 的查询都是嵌套循环查询， 不支持哈希关联 </p><h3 id="松散哈希扫描"><a href="#松散哈希扫描" class="headerlink" title="松散哈希扫描"></a>松散哈希扫描</h3><p> MySQL 的索引扫描需要指定起点和终点。假设有索引 key(a,b), 如何查询的语句中只要字段 b， MySQL 是无法使用这个索引的， 只能通过全表扫描查找数据</p><p>而松散索引是先扫描 a 列对应的 b 列的范围，再跳到 a 列第二个不同值扫描对应 b 列的范围。更好的做法是为 b 增加一个索引，但是也会遇到第一列为范围查询， 第二列为等值查询的情况 </p><h3 id="在同一个表的查询与更新"><a href="#在同一个表的查询与更新" class="headerlink" title="在同一个表的查询与更新"></a>在同一个表的查询与更新</h3><p>Mysql不允对同一张表同时进行查询和更新</p><h2 id="查询优化器的提示（hint）"><a href="#查询优化器的提示（hint）" class="headerlink" title="查询优化器的提示（hint）"></a>查询优化器的提示（hint）</h2><p> 如果对于优化器选择的执行计划不满意，可以使用优化器提供的几个提示来控制最终的执行计划：</p><ul><li>HIGH_PRIORITY and LOW_PRIORITY<ul><li>告诉数据库如果多个语句同事访问某一个表的时候，哪些语句优先级高</li></ul></li><li>DELAYED<ul><li>这个提示对于INSET 和REPLACE</li><li>MySQL会将使用该提示语句立即返回给客户端。并将插入的行数据放入缓冲区中。然后在表空闲时批量将数据写入。日志系统很有效。</li></ul></li><li>STRAIGH_JOIN<ul><li>这个提示可以放置在SELECT语句的SELECT 关键字之后。也可以放置在任何两个关联表的名字之间。</li><li>1、让查询中的所有的表按照在语句中出现的顺序进行关联</li><li>2、固定器前后两个表的关联顺序。</li></ul></li><li>SQL_SMALL_RESULT SQL_BIG_RESULT<ul><li>只对于SELECT有效</li><li>其可以告诉优化器对GROUP BY或者DISTINCT查询如何使用临时表及排序。</li><li>small说明查询结果集很小可以存放在内存总的索引临时表</li><li>big建议使用磁盘临时表做排序操作</li></ul></li><li>SQL_BUFFER_RESULT<ul><li>告诉优化器将查询记过放入到一个临时表中，然后尽可能快的释放表锁。</li></ul></li><li>SQL_CACHE_SQL_NO_CACHE<ul><li>是否应该缓存在查询缓存中。</li></ul></li><li>SQL_CALC_FOUND_ROWS<ul><li>加上后MySQL会计算除去LIMIT子句后这个传要返回的结果集的总数。</li><li>实际上只要返回LIMIT要求的结果集，可以通过函数FOUND_ROW()获取这个值</li></ul></li><li>FOR UPDATE LOCK IN SHARE MODE<ul><li>控制SELECT语句的锁机制，但只对实现了行级锁的存储引擎有效。</li></ul></li><li>USE INDEX IGNORE FORCE INDEX<ul><li>使用或者不使用哪些索引来查询记录</li></ul></li></ul><h2 id="优化特定类型查询"><a href="#优化特定类型查询" class="headerlink" title="优化特定类型查询"></a>优化特定类型查询</h2><h3 id="优化COUNT-查询"><a href="#优化COUNT-查询" class="headerlink" title="优化COUNT() 查询"></a>优化COUNT() 查询</h3><p>COUNT()函数有两个作用：</p><ul><li>统计某个列值的数量， 统计列值时要求列值是非空的（NOT NULL）或者表达式的值不为NULL，计算时去会出为NULL的行</li><li>统计结果集的行数，COUNT(*）时， * 并不会扩展成所有列，而是直接统计行数，效率最高</li></ul><h3 id="优化关联查询"><a href="#优化关联查询" class="headerlink" title="优化关联查询"></a>优化关联查询</h3><ul><li>当表 A 与表 B 关联时， 只需要在关联顺序的第二张表相应列创建索引即可</li><li>GROUP BY 和 ORDER BY 只涉及到一个表的列才能使 MySQL 索引生效</li></ul><h3 id="优化GROUP-BY"><a href="#优化GROUP-BY" class="headerlink" title="优化GROUP BY"></a>优化GROUP BY</h3><p> 无法使用索引时， GROUP BY 使用临时表或者文件排序来实现分组 </p><h3 id="优化-LIMIT分页"><a href="#优化-LIMIT分页" class="headerlink" title="优化 LIMIT分页"></a>优化 LIMIT分页</h3><p>利用延迟关联或者子查询优化超多分页场景</p><p>MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写</p><pre><code class="hljs sql"><span class="hljs-comment"># 先快速定位需要获取的 id 段，然后再关联</span><span class="hljs-keyword">SELECT</span> a.* <span class="hljs-keyword">FROM</span> 表 <span class="hljs-number">1</span> a, (<span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">from</span> 表 <span class="hljs-number">1</span> <span class="hljs-keyword">where</span> 条件 <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">100000</span>,<span class="hljs-number">20</span> ) b <span class="hljs-keyword">where</span> a.id=b.id</code></pre><h3 id="优化-UNION"><a href="#优化-UNION" class="headerlink" title="优化 UNION"></a>优化 UNION</h3><p> UNION在使用时要注意是否是UNION ALL， 否则在查询时还需要对临时表去重 </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果把创建高性能应用程序比作是一个环环相扣的“难题”，查询优化应该是解开“难题”的最后一步了。要想写一个好的查询,你必须要理解 schema设计、索引设计等，反之亦然。优化通常都需要三管齐下：不做、少做、快速地做。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第6章  查询性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法实战篇</title>
    <link href="/2023/09/12/%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98%E7%AF%87/"/>
    <url>/2023/09/12/%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="算法实战篇-大数据量问题解决方案"><a href="#算法实战篇-大数据量问题解决方案" class="headerlink" title="算法实战篇 - 大数据量问题解决方案"></a>算法实战篇 - 大数据量问题解决方案</h1><h2 id="1-如何从大量的-URL-中找出相同的-URL？"><a href="#1-如何从大量的-URL-中找出相同的-URL？" class="headerlink" title="1. 如何从大量的 URL 中找出相同的 URL？"></a>1. 如何从大量的 URL 中找出相同的 URL？</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定 a、b 两个文件，各存放 50 亿个 URL，每个 URL 各占 64B，内存限制是 4G。请找出 a、b 两个文件共同的 URL。</p><h3 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h3><p>每个 URL 占 64B，那么 50 亿个 URL占用的空间大小约为 320GB。</p><blockquote><p>5,000,000,000 * 64B ≈ 5GB * 64 = 320GB</p></blockquote><p>由于内存大小只有 4G，因此，我们不可能一次性把所有 URL 加载到内存中处理。对于这种类型的题目，一般采用<strong>分治策略</strong>，即：把一个文件中的 URL 按照某个特征划分为多个小文件，使得每个小文件大小不超过 4G，这样就可以把这个小文件读到内存中进行处理了。</p><p><strong>思路如下</strong>：</p><p>首先遍历文件 a，对遍历到的 URL 求 <code>hash(URL) % 1000</code>，根据计算结果把遍历到的 URL 存储到 a0, a1, a2, …, a999，这样每个大小约为 300MB。使用同样的方法遍历文件 b，把文件 b 中的 URL 分别存储到文件 b0, b1, b2, …, b999 中。这样处理过后，所有可能相同的 URL 都在对应的小文件中，即 a0 对应 b0, …, a999 对应 b999，不对应的小文件不可能有相同的 URL。那么接下来，我们只需要求出这 1000 对小文件中相同的 URL 就好了。</p><p>接着遍历 ai( <code>i∈[0,999]</code>)，把 URL 存储到一个 HashSet  集合中。然后遍历 bi 中每个 URL，看在 HashSet 集合中是否存在，若存在，说明这就是共同的 URL，可以把这个 URL 保存到一个单独的文件中。</p><h3 id="方法总结"><a href="#方法总结" class="headerlink" title="方法总结"></a>方法总结</h3><ol><li>分而治之，进行哈希取余；</li><li>对每个子文件进行 HashSet 统计。</li></ol><h2 id="2-如何从大量数据中找出高频词？"><a href="#2-如何从大量数据中找出高频词？" class="headerlink" title="2. 如何从大量数据中找出高频词？"></a>2. 如何从大量数据中找出高频词？</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>有一个 1GB 大小的文件，文件里每一行是一个词，每个词的大小不超过 16B，内存大小限制是 1MB，要求返回频数最高的 100 个词(Top 100)。</p><h3 id="解答思路-1"><a href="#解答思路-1" class="headerlink" title="解答思路"></a>解答思路</h3><p>由于内存限制，我们依然无法直接将大文件的所有词一次读到内存中。因此，同样可以采用<strong>分治策略</strong>，把一个大文件分解成多个小文件，保证每个文件的大小小于 1MB，进而直接将单个小文件读取到内存中进行处理。</p><p><strong>思路如下</strong>：</p><p>首先遍历大文件，对遍历到的每个词x，执行 <code>hash(x) % 5000</code>，将结果为 i 的词存放到文件 ai 中。遍历结束后，我们可以得到 5000 个小文件。每个小文件的大小为 200KB 左右。如果有的小文件大小仍然超过 1MB，则采用同样的方式继续进行分解。</p><p>接着统计每个小文件中出现频数最高的 100 个词。最简单的方式是使用 HashMap 来实现。其中 key 为词，value 为该词出现的频率。具体方法是：对于遍历到的词 x，如果在 map 中不存在，则执行 <code>map.put(x, 1)</code>；若存在，则执行 <code>map.put(x, map.get(x)+1)</code>，将该词频数加 1。</p><p>上面我们统计了每个小文件单词出现的频数。接下来，我们可以通过维护一个<strong>小顶堆</strong>来找出所有词中出现频数最高的 100 个。具体方法是：依次遍历每个小文件，构建一个<strong>小顶堆</strong>，堆大小为 100。如果遍历到的词的出现次数大于堆顶词的出现次数，则用新词替换堆顶的词，然后重新调整为<strong>小顶堆</strong>，遍历结束后，小顶堆上的词就是出现频数最高的 100 个词。</p><h3 id="方法总结-1"><a href="#方法总结-1" class="headerlink" title="方法总结"></a>方法总结</h3><ol><li>分而治之，进行哈希取余；</li><li>使用 HashMap 统计频数；</li><li>求解<strong>最大</strong>的 TopN 个，用<strong>小顶堆</strong>；求解<strong>最小</strong>的 TopN 个，用<strong>大顶堆</strong>。</li></ol><h2 id="3-如何找出某一天访问百度网站最多的-IP？"><a href="#3-如何找出某一天访问百度网站最多的-IP？" class="headerlink" title="3. 如何找出某一天访问百度网站最多的 IP？"></a>3. 如何找出某一天访问百度网站最多的 IP？</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>现有海量日志数据保存在一个超大文件中，该文件无法直接读入内存，要求从中提取某天访问百度次数最多的那个 IP。</p><h3 id="解答思路-2"><a href="#解答思路-2" class="headerlink" title="解答思路"></a>解答思路</h3><p>这道题只关心某一天访问百度最多的 IP，因此，可以首先对文件进行一次遍历，把这一天访问百度 IP 的相关信息记录到一个单独的大文件中。接下来采用的方法与上一题一样，大致就是先对 IP 进行哈希映射，接着使用 HashMap 统计重复 IP 的次数，最后计算出重复次数最多的 IP。</p><blockquote><p>注：这里只需要找出出现次数最多的 IP，可以不必使用堆，直接用一个变量 max 即可。</p></blockquote><h3 id="方法总结-2"><a href="#方法总结-2" class="headerlink" title="方法总结"></a>方法总结</h3><ol><li>分而治之，进行哈希取余；</li><li>使用 HashMap 统计频数；</li><li>求解<strong>最大</strong>的 TopN 个，用<strong>小顶堆</strong>；求解<strong>最小</strong>的 TopN 个，用<strong>大顶堆</strong>。</li></ol><h2 id="4-如何在大量的数据中找出不重复的整数？"><a href="#4-如何在大量的数据中找出不重复的整数？" class="headerlink" title="4. 如何在大量的数据中找出不重复的整数？"></a>4. 如何在大量的数据中找出不重复的整数？</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>在 2.5 亿个整数中找出不重复的整数。注意：内存不足以容纳这 2.5 亿个整数。</p><h3 id="解答思路-3"><a href="#解答思路-3" class="headerlink" title="解答思路"></a>解答思路</h3><h4 id="方法一：分治法"><a href="#方法一：分治法" class="headerlink" title="方法一：分治法"></a>方法一：分治法</h4><p>与前面的题目方法类似，先将 2.5 亿个数划分到多个小文件，用 HashSet/HashMap 找出每个小文件中不重复的整数，再合并每个子结果，即为最终结果。</p><h4 id="方法二：位图法"><a href="#方法二：位图法" class="headerlink" title="方法二：位图法"></a>方法二：位图法</h4><p><strong>位图</strong>，就是用一个或多个 bit 来标记某个元素对应的值，而键就是该元素。采用位作为单位来存储数据，可以大大节省存储空间。</p><p>位图通过使用位数组来表示某些元素是否存在。它可以用于快速查找，判重，排序等。不是很清楚？我先举个小例子。</p><p>假设我们要对 <code>[0,7]</code> 中的 5 个元素 (6, 4, 2, 1, 5) 进行排序，可以采用位图法。0~7 范围总共有 8 个数，只需要 8bit，即 1 个字节。首先将每个位都置 0：</p><pre><code class="hljs angelscript"><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>复制代码</code></pre><p>然后遍历 5 个元素，首先遇到 6，那么将下标为 6 的位的 0 置为 1；接着遇到 4，把下标为 4 的位 的 0 置为 1：</p><pre><code class="hljs angelscript"><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span>复制代码</code></pre><p>依次遍历，结束后，位数组是这样的：</p><pre><code class="hljs angelscript"><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span>复制代码</code></pre><p>每个为 1 的位，它的下标都表示了一个数：</p><pre><code class="hljs matlab"><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> in range(<span class="hljs-number">8</span>):    <span class="hljs-keyword">if</span> bits[<span class="hljs-built_in">i</span>] == <span class="hljs-number">1</span>:        print(<span class="hljs-built_in">i</span>)复制代码</code></pre><p>这样我们其实就已经实现了排序。</p><p>对于整数相关的算法的求解，<strong>位图法</strong>是一种非常实用的算法。假设 int 整数占用 4B，即 32bit，那么我们可以表示的整数的个数为 232。</p><p><strong>那么对于这道题</strong>，我们用 2 个 bit 来表示各个数字的状态：</p><ul><li>00 表示这个数字没出现过；</li><li>01 表示这个数字出现过一次（即为题目所找的不重复整数）；</li><li>10 表示这个数字出现了多次。</li></ul><p>那么这 232 个整数，总共所需内存为 232*2b=1GB。因此，当可用内存超过 1GB 时，可以采用位图法。假设内存满足位图法需求，进行下面的操作：</p><p>遍历 2.5 亿个整数，查看位图中对应的位，如果是 00，则变为 01，如果是 01 则变为 10，如果是 10 则保持不变。遍历结束后，查看位图，把对应位是 01 的整数输出即可。</p><h3 id="方法总结-3"><a href="#方法总结-3" class="headerlink" title="方法总结"></a>方法总结</h3><p><strong>判断数字是否重复的问题</strong>，位图法是一种非常高效的方法。</p><h2 id="5-如何在大量的数据中判断一个数是否存在？"><a href="#5-如何在大量的数据中判断一个数是否存在？" class="headerlink" title="5. 如何在大量的数据中判断一个数是否存在？"></a>5. 如何在大量的数据中判断一个数是否存在？</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定 40 亿个不重复的没排过序的 unsigned int 型整数，然后再给定一个数，如何快速判断这个数是否在这 40 亿个整数当中？</p><h3 id="解答思路-4"><a href="#解答思路-4" class="headerlink" title="解答思路"></a>解答思路</h3><h4 id="方法一：分治法-1"><a href="#方法一：分治法-1" class="headerlink" title="方法一：分治法"></a>方法一：分治法</h4><p>依然可以用分治法解决，方法与前面类似，就不再次赘述了。</p><h4 id="方法二：位图法-1"><a href="#方法二：位图法-1" class="headerlink" title="方法二：位图法"></a>方法二：位图法</h4><p>40 亿个不重复整数，我们用 40 亿个 bit 来表示，初始位均为 0，那么总共需要内存：4,000,000,000b≈512M。</p><p>我们读取这 40 亿个整数，将对应的 bit 设置为 1。接着读取要查询的数，查看相应位是否为 1，如果为 1 表示存在，如果为 0 表示不存在。</p><h3 id="方法总结-4"><a href="#方法总结-4" class="headerlink" title="方法总结"></a>方法总结</h3><p><strong>判断数字是否存在、判断数字是否重复的问题</strong>，位图法是一种非常高效的方法。</p><h2 id="6-如何查询最热门的查询串？"><a href="#6-如何查询最热门的查询串？" class="headerlink" title="6. 如何查询最热门的查询串？"></a>6. 如何查询最热门的查询串？</h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>搜索引擎会通过日志文件把用户每次检索使用的所有查询串都记录下来，每个查询床的长度不超过 255 字节。</p><p>假设目前有 1000w 个记录（这些查询串的重复度比较高，虽然总数是 1000w，但如果除去重复后，则不超过 300w 个）。请统计最热门的 10 个查询串，要求使用的内存不能超过 1G。（一个查询串的重复度越高，说明查询它的用户越多，也就越热门。）</p><h3 id="解答思路-5"><a href="#解答思路-5" class="headerlink" title="解答思路"></a>解答思路</h3><p>每个查询串最长为 255B，1000w 个串需要占用 约 2.55G 内存，因此，我们无法将所有字符串全部读入到内存中处理。</p><h4 id="方法一：分治法-2"><a href="#方法一：分治法-2" class="headerlink" title="方法一：分治法"></a>方法一：分治法</h4><p>分治法依然是一个非常实用的方法。</p><p>划分为多个小文件，保证单个小文件中的字符串能被直接加载到内存中处理，然后求出每个文件中出现次数最多的 10 个字符串；最后通过一个小顶堆统计出所有文件中出现最多的 10 个字符串。</p><p>方法可行，但不是最好，下面介绍其他方法。</p><h4 id="方法二：HashMap-法"><a href="#方法二：HashMap-法" class="headerlink" title="方法二：HashMap 法"></a>方法二：HashMap 法</h4><p>虽然字符串总数比较多，但去重后不超过 300w，因此，可以考虑把所有字符串及出现次数保存在一个 HashMap 中，所占用的空间为 300w*(255+4)≈777M（其中，4表示整数占用的4个字节）。由此可见，1G 的内存空间完全够用。</p><p><strong>思路如下</strong>：</p><p>首先，遍历字符串，若不在 map 中，直接存入 map，value 记为 1；若在 map 中，则把对应的 value 加 1，这一步时间复杂度 <code>O(N)</code>。</p><p>接着遍历 map，构建一个 10 个元素的小顶堆，若遍历到的字符串的出现次数大于堆顶字符串的出现次数，则进行替换，并将堆调整为小顶堆。</p><p>遍历结束后，堆中 10 个字符串就是出现次数最多的字符串。这一步时间复杂度 <code>O(Nlog10)</code>。</p><h4 id="方法三：前缀树法"><a href="#方法三：前缀树法" class="headerlink" title="方法三：前缀树法"></a>方法三：前缀树法</h4><p>方法二使用了 HashMap 来统计次数，当这些字符串有大量相同前缀时，可以考虑使用前缀树来统计字符串出现的次数，树的结点保存字符串出现次数，0 表示没有出现。</p><p><strong>思路如下</strong>：</p><p>在遍历字符串时，在前缀树中查找，如果找到，则把结点中保存的字符串次数加 1，否则为这个字符串构建新结点，构建完成后把叶子结点中字符串的出现次数置为 1。</p><p>最后依然使用小顶堆来对字符串的出现次数进行排序。</p><h3 id="方法总结-5"><a href="#方法总结-5" class="headerlink" title="方法总结"></a>方法总结</h3><p>前缀树经常被用来统计字符串的出现次数。它的另外一个大的用途是字符串查找，判断是否有重复的字符串等。</p><h2 id="7-如何统计不同电话号码的个数？"><a href="#7-如何统计不同电话号码的个数？" class="headerlink" title="7. 如何统计不同电话号码的个数？"></a>7. 如何统计不同电话号码的个数？</h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>已知某个文件内包含一些电话号码，每个号码为 8 位数字，统计不同号码的个数。</p><h3 id="解答思路-6"><a href="#解答思路-6" class="headerlink" title="解答思路"></a>解答思路</h3><p>这道题本质还是求解<strong>数据重复</strong>的问题，对于这类问题，一般首先考虑位图法。</p><p>对于本题，8 位电话号码可以表示的号码个数为 108 个，即 1 亿个。我们每个号码用一个 bit 来表示，则总共需要 1 亿个 bit，内存占用约 100M。</p><p><strong>思路如下</strong>：</p><p>申请一个位图数组，长度为 1 亿，初始化为 0。然后遍历所有电话号码，把号码对应的位图中的位置置为 1。遍历完成后，如果 bit 为 1，则表示这个电话号码在文件中存在，否则不存在。bit 值为 1 的数量即为 不同电话号码的个数。</p><h3 id="方法总结-6"><a href="#方法总结-6" class="headerlink" title="方法总结"></a>方法总结</h3><p>求解数据重复问题，记得考虑位图法。</p><h2 id="8-如何从-5-亿个数中找出中位数？"><a href="#8-如何从-5-亿个数中找出中位数？" class="headerlink" title="8. 如何从 5 亿个数中找出中位数？"></a>8. 如何从 5 亿个数中找出中位数？</h2><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><p>从 5 亿个数中找出中位数。数据排序后，位置在最中间的数就是中位数。当样本数为奇数时，中位数为 第 <code>(N+1)/2</code> 个数；当样本数为偶数时，中位数为 第 <code>N/2</code> 个数与第 <code>1+N/2</code> 个数的均值。</p><h3 id="解答思路-7"><a href="#解答思路-7" class="headerlink" title="解答思路"></a>解答思路</h3><p>如果这道题没有内存大小限制，则可以把所有数读到内存中排序后找出中位数。但是最好的排序算法的时间复杂度都为 <code>O(NlogN)</code>。这里使用其他方法。</p><h4 id="方法一：双堆法"><a href="#方法一：双堆法" class="headerlink" title="方法一：双堆法"></a>方法一：双堆法</h4><p>维护两个堆，一个大顶堆，一个小顶堆。大顶堆中最大的数<strong>小于等于</strong>小顶堆中最小的数；保证这两个堆中的元素个数的差不超过 1。</p><p>若数据总数为<strong>偶数</strong>，当这两个堆建好之后，<strong>中位数就是这两个堆顶元素的平均值</strong>。当数据总数为<strong>奇数</strong>时，根据两个堆的大小，<strong>中位数一定在数据多的堆的堆顶</strong>。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MedianFinder</span> </span>&#123;        <span class="hljs-keyword">private</span> PriorityQueue&lt;Integer&gt; maxHeap;    <span class="hljs-keyword">private</span> PriorityQueue&lt;Integer&gt; minHeap;    <span class="hljs-comment">/** initialize your data structure here. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MedianFinder</span><span class="hljs-params">()</span> </span>&#123;        maxHeap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(Comparator.reverseOrder());        minHeap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(Integer::compareTo);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;        <span class="hljs-keyword">if</span> (maxHeap.isEmpty() || maxHeap.peek() &gt; num) &#123;            maxHeap.offer(num);        &#125; <span class="hljs-keyword">else</span> &#123;            minHeap.offer(num);        &#125;                <span class="hljs-keyword">int</span> size1 = maxHeap.size();        <span class="hljs-keyword">int</span> size2 = minHeap.size();        <span class="hljs-keyword">if</span> (size1 - size2 &gt; <span class="hljs-number">1</span>) &#123;            minHeap.offer(maxHeap.poll());        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (size2 - size1 &gt; <span class="hljs-number">1</span>) &#123;            maxHeap.offer(minHeap.poll());        &#125;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedian</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">int</span> size1 = maxHeap.size();        <span class="hljs-keyword">int</span> size2 = minHeap.size();                <span class="hljs-keyword">return</span> size1 == size2             ? (maxHeap.peek() + minHeap.peek()) * <span class="hljs-number">1.0</span> / <span class="hljs-number">2</span>            : (size1 &gt; size2 ? maxHeap.peek() : minHeap.peek());    &#125;&#125;</code></pre><blockquote><p>见 LeetCode No.295：<a href="https://leetcode.com/problems/find-median-from-data-stream/" target="_blank" rel="noopener">leetcode.com/problems/fi…</a></p></blockquote><p>以上这种方法，需要把所有数据都加载到内存中。当数据量很大时，就不能这样了，因此，这种方法<strong>适用于数据量较小的情况</strong>。5 亿个数，每个数字占用 4B，总共需要 2G 内存。如果可用内存不足 2G，就不能使用这种方法了，下面介绍另一种方法。</p><h4 id="方法二：分治法"><a href="#方法二：分治法" class="headerlink" title="方法二：分治法"></a>方法二：分治法</h4><p>分治法的思想是把一个大的问题逐渐转换为规模较小的问题来求解。</p><p>对于这道题，顺序读取这 5 亿个数字，对于读取到的数字 num，如果它对应的二进制中最高位为，则把这个数字写到 f1 中，否则写入 f0 中。通过这一步，可以把这 5 亿个数划分为两部分，而且 f0 中的数都大于 f1 中的数（最高位是符号位）。</p><p>划分之后，可以非常容易地知道中位数是在 f0 还是 f1 中。假设 f1 中有 1 亿个数，那么中位数一定在 f0 中，且是在 f0 中，从小到大排列的第 1.5 亿个数与它后面的一个数的平均值。</p><blockquote><p><strong>提示</strong>，5 亿数的中位数是第 2.5 亿与右边相邻一个数求平均值。若 f1 有一亿个数，那么中位数就是 f0 中从第 1.5 亿个数开始的两个数求得的平均值。</p></blockquote><p>对于 f0 可以用次高位的二进制继续将文件一分为二，如此划分下去，直到划分后的文件可以被加载到内存中，把数据加载到内存中以后直接排序，找出中位数。</p><blockquote><p><strong>注意</strong>，当数据总数为偶数，如果划分后两个文件中的数据有相同个数，那么中位数就是数据较小的文件中的最大值与数据较大的文件中的最小值的平均值。</p></blockquote><h3 id="方法总结-7"><a href="#方法总结-7" class="headerlink" title="方法总结"></a>方法总结</h3><p>分治法，真香！</p><h2 id="9-如何按照-query-的频度排序？"><a href="#9-如何按照-query-的频度排序？" class="headerlink" title="9. 如何按照 query 的频度排序？"></a>9. 如何按照 query 的频度排序？</h2><h3 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h3><p>有 10 个文件，每个文件大小为 1G，每个文件的每一行存放的都是用户的 query，每个文件的 query 都可能重复。要求按照 query 的频度排序。</p><h3 id="解答思路-8"><a href="#解答思路-8" class="headerlink" title="解答思路"></a>解答思路</h3><p>如果 query 的重复度比较大，可以考虑一次性把所有 query 读入内存中处理；如果 query 的重复率不高，那么可用内存不足以容纳所有的 query，这时候就需要采用分治法或其他的方法来解决。</p><h4 id="方法一：HashMap-法"><a href="#方法一：HashMap-法" class="headerlink" title="方法一：HashMap 法"></a>方法一：HashMap 法</h4><p>如果 query 重复率高，说明不同 query 总数比较小，可以考虑把所有的 query 都加载到内存中的 HashMap 中。接着就可以按照 query 出现的次数进行排序。</p><h4 id="方法二：分治法-1"><a href="#方法二：分治法-1" class="headerlink" title="方法二：分治法"></a>方法二：分治法</h4><p>分治法需要根据数据量大小以及可用内存的大小来确定问题划分的规模。对于这道题，可以顺序遍历 10 个文件中的 query，通过 Hash 函数 <code>hash(query) % 10</code> 把这些 query 划分到 10 个小文件中。之后对每个小文件使用 HashMap 统计 query 出现次数，根据次数排序并写入到零外一个单独文件中。</p><p>接着对所有文件按照 query 的次数进行排序，这里可以使用归并排序（由于无法把所有 query 都读入内存，因此需要使用外排序）。</p><h3 id="方法总结-8"><a href="#方法总结-8" class="headerlink" title="方法总结"></a>方法总结</h3><ul><li>内存若够，直接读入进行排序；</li><li>内存不够，先划分为小文件，小文件排好序后，整理使用外排序进行归并。</li></ul><h2 id="10-如何找出排名前-500-的数？"><a href="#10-如何找出排名前-500-的数？" class="headerlink" title="10. 如何找出排名前 500 的数？"></a>10. 如何找出排名前 500 的数？</h2><h3 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h3><p>有 20 个数组，每个数组有 500 个元素，并且有序排列。如何在这 20*500 个数中找出前 500 的数？</p><h3 id="解答思路-9"><a href="#解答思路-9" class="headerlink" title="解答思路"></a>解答思路</h3><p>对于 TopK 问题，最常用的方法是使用堆排序。对本题而言，假设数组降序排列，可以采用以下方法：</p><p>首先建立大顶堆，堆的大小为数组的个数，即为 20，把每个数组最大的值存到堆中。</p><p>接着删除堆顶元素，保存到另一个大小为 500 的数组中，然后向大顶堆插入删除的元素所在数组的下一个元素。</p><p>重复上面的步骤，直到删除完第 500 个元素，也即找出了最大的前 500 个数。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构及算法篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法实战篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法篇</title>
    <link href="/2023/09/12/%E7%AE%97%E6%B3%95%E7%AF%87/"/>
    <url>/2023/09/12/%E7%AE%97%E6%B3%95%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="算法篇"><a href="#算法篇" class="headerlink" title="算法篇"></a>算法篇</h1><h2 id="时间复杂度计算方式-（渐进时间复杂度）"><a href="#时间复杂度计算方式-（渐进时间复杂度）" class="headerlink" title="时间复杂度计算方式 （渐进时间复杂度）"></a>时间复杂度计算方式 （渐进时间复杂度）</h2><h3 id="什么是复杂度分析？"><a href="#什么是复杂度分析？" class="headerlink" title="什么是复杂度分析？"></a>什么是复杂度分析？</h3><blockquote><p>复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低</p><p>常见的复杂度：<br>O(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n^2)（平方阶）、O(n^3)（立方阶）</p><p>非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，<br>O(2^n)（指数阶）、O(n!)（阶乘阶）</p><p>读作 BIG O n  |  BIG  O  1</p></blockquote><h3 id="简单计算方式"><a href="#简单计算方式" class="headerlink" title="简单计算方式"></a>简单计算方式</h3><blockquote><ol><li>只关注循环执行次数最多的一段代码</li><li>加法法则：总复杂度等于量级最大的那段代码的复杂度</li><li>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</li></ol><p>简单来说，n 项式则是简单计算最高阶即可（去除所有系数，常熟项）</p><p>​                    m，n 多项式则是计算两个值的加，或者相乘</p></blockquote><h3 id="浅析最好、最坏、平均、均摊时间复杂度"><a href="#浅析最好、最坏、平均、均摊时间复杂度" class="headerlink" title="浅析最好、最坏、平均、均摊时间复杂度"></a>浅析最好、最坏、平均、均摊时间复杂度</h3><pre><code class="hljs java"><span class="hljs-comment">// n 表示数组 array 的长度 | 找x的所在位置</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> x)</span> </span>&#123; <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-keyword">int</span> pos = -<span class="hljs-number">1</span>; <span class="hljs-keyword">for</span> (; i &lt; n; ++i) &#123;      <span class="hljs-keyword">if</span> (array[i] == x) &#123;          pos = i;          <span class="hljs-keyword">break</span>;      &#125; &#125;<span class="hljs-keyword">return</span> pos;&#125;</code></pre><p>最好情况：一次，最坏情况：n次，平均：考虑到各种情况出现的概率以及出现的概率进行加权平均数计算</p><p><img src="/2023/09/12/%E7%AE%97%E6%B3%95%E7%AF%87/image-20191227095846923.png" srcset="/img/loading.gif" alt="image-20191227095846923"></p><p>结果仍为 0(n)</p><pre><code class="hljs 均摊时间复杂度```：摊还分析（平摊分析）">每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是O(1)## 排序算法### 冒泡排序&#96;&#96;&#96;java&#x2F;*** * 最好： O(n) * 最坏： O(n2) * 空间复杂度: O(1) * 稳定的排序算法 * * 5 7 4 8 1 * &#x3D;&#x3D;&#x3D;》 5 4 7 1 8 * &#x3D;&#x3D;&#x3D;》 4 5 1 7 8 * &#x3D;&#x3D;&#x3D;》 4 1 5 7 8 * &#x3D;&#x3D;&#x3D;》 1 4 5 7 8 * * 以从小到大为例，相邻的两个数字两两比较，小的前移 * 从每个数字开始，每个数字都对应一次循环比较，因此最坏时间复杂度为：O(n2) *&#x2F;private static void sort (int[] num) &#123;    int length &#x3D; num.length;    for (int i &#x3D; 0; i &lt; length; i++) &#123;        &#x2F;&#x2F; 提前退出冒泡循环的标志位        boolean flag &#x3D; false;        for (int k &#x3D; 0; k &lt; length - i - 1; k++) &#123;            if (num[k] &gt; num[k + 1]) &#123;                int temp &#x3D; num[k];                num[k] &#x3D; num[k + 1];                num[k + 1] &#x3D; temp;                flag &#x3D; true;            &#125;        &#125;        if (!flag) break;    &#125;&#125;</code></pre><p><img src="/2023/09/12/%E7%AE%97%E6%B3%95%E7%AF%87/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.png" srcset="/img/loading.gif" alt></p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><pre><code class="hljs java"><span class="hljs-comment">/***</span><span class="hljs-comment">    * 最好： O(n2)</span><span class="hljs-comment">    * 最坏： O(n2)</span><span class="hljs-comment">    * 空间复杂度: O(1)</span><span class="hljs-comment">    * 不稳定的排序算法 - 选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性</span><span class="hljs-comment">    *</span><span class="hljs-comment">    * 5 7 4 8 1</span><span class="hljs-comment">    * ===》 5 7 4 8 1</span><span class="hljs-comment">    * ===》 1 7 4 8 5  寻找最小的数与之交换 | 更好理解的插入排序</span><span class="hljs-comment">    * ===》 1 4 7 8 5</span><span class="hljs-comment">    * ===》 1 4 5 7 8</span><span class="hljs-comment">    *</span><span class="hljs-comment">    * 基于插入排序，从左边开始构建已经排好序的数组，从右侧找到最小的数进行交换</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>[] num)</span> </span>&#123;       <span class="hljs-keyword">int</span> len = num.length;       <span class="hljs-keyword">int</span> minIndex, temp;       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;           minIndex = i;           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; len; j++) &#123;               <span class="hljs-keyword">if</span> (num[j] &lt; num[minIndex]) &#123;                   minIndex = j;               &#125;           &#125;           temp = num[i];           num[i] = num[minIndex];           num[minIndex] = temp;       &#125;   &#125;</code></pre><p><img src="/2023/09/12/%E7%AE%97%E6%B3%95%E7%AF%87/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.jpg" srcset="/img/loading.gif" alt></p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><pre><code class="hljs java"><span class="hljs-comment">/***</span><span class="hljs-comment"> * 最好：O(nlogn)</span><span class="hljs-comment"> * 最坏：O(nlogn)</span><span class="hljs-comment"> * 空间复杂度：O(n)</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 稳定排序算法 分解 -&gt; 合并阶段</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 分治的思想 -&gt; 递归算法</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] sort (<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right) &#123;    <span class="hljs-keyword">if</span> (left &gt;= right)        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; nums[left] &#125;;    <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;    <span class="hljs-keyword">int</span>[] leftArr  = sort(nums, left, mid);                   <span class="hljs-comment">// 左有序数组</span>    <span class="hljs-keyword">int</span>[] rightArr = sort(nums, mid + <span class="hljs-number">1</span>, right);              <span class="hljs-comment">// 右有序数组</span>    <span class="hljs-keyword">int</span>[] newNum = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[leftArr.length + rightArr.length]; <span class="hljs-comment">// 新有序数组</span>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (i &lt; leftArr.length &amp;&amp; j &lt; rightArr.length) &#123;        <span class="hljs-keyword">if</span> (leftArr[i] &lt; rightArr[j]) &#123;            newNum[index++] = leftArr[i++];        &#125; <span class="hljs-keyword">else</span> &#123;            newNum[index++] = rightArr[j++];        &#125;    &#125;    <span class="hljs-keyword">while</span> (i &lt; leftArr.length)        newNum[index++] = leftArr[i++];    <span class="hljs-keyword">while</span> (j &lt; rightArr.length)        newNum[index++] = rightArr[j++];    <span class="hljs-keyword">return</span> newNum;&#125;</code></pre><p><img src="/2023/09/12/%E7%AE%97%E6%B3%95%E7%AF%87/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.jpg" srcset="/img/loading.gif" alt></p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><pre><code class="hljs java"><span class="hljs-comment">/***</span><span class="hljs-comment"> * 最好： O(n)</span><span class="hljs-comment"> * 最坏： O(n2)</span><span class="hljs-comment"> * 空间复杂度: O(1)</span><span class="hljs-comment"> * 稳定的排序算法</span><span class="hljs-comment"> *</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 5 7 4 8 1</span><span class="hljs-comment"> * ===》 4 5 7 8 1</span><span class="hljs-comment"> * ===》 4 5 7 8 1</span><span class="hljs-comment"> * ===》 1 4 5 7 8</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 以从小到大为例, 从第三个数字开始和前面两个数字对比，找到合适的插入位置，一直到最后一位插入完毕</span><span class="hljs-comment"> * 算法结束，所以实际循环次数理论为 n - 2，每次对比数字也是2 起步，一直加到n - 1</span><span class="hljs-comment"> * 去除其他位阶, 因此最坏时间复杂度为：O(n2)</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>[] num)</span> </span>&#123;    <span class="hljs-keyword">int</span> length = num.length;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; length; ++i) &#123;        <span class="hljs-keyword">int</span> value = num[i];        <span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>;        <span class="hljs-comment">// 查找插入的位置</span>        <span class="hljs-keyword">for</span> (; j &gt;= <span class="hljs-number">0</span>; --j) &#123;            <span class="hljs-keyword">if</span> (num[j] &gt; value) &#123;                num[j + <span class="hljs-number">1</span>] = num[j];            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-comment">// 插入数据</span>        num[j + <span class="hljs-number">1</span>] = value;    &#125;&#125;</code></pre><p><img src="/2023/09/12/%E7%AE%97%E6%B3%95%E7%AF%87/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.jpg" srcset="/img/loading.gif" alt></p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><pre><code class="hljs java"><span class="hljs-comment">/****</span><span class="hljs-comment"> * 最好：O(nlogn)</span><span class="hljs-comment"> * 最坏：O(n2)</span><span class="hljs-comment"> * 平均：O(nlogn)</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 空间复杂度：</span><span class="hljs-comment"> *     最好：O(logn)</span><span class="hljs-comment"> *     最坏：O( n )</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 原地，不稳定排序算法</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 快排基于分治的思想，选择某一焦点，将数据分为三部分，以此类推一直当每小部分数据的节点都为1时完成排序</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>[] array, <span class="hljs-keyword">int</span> left ,<span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-keyword">if</span>(left &gt; right) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">// base中存放基准数</span>    <span class="hljs-keyword">int</span> base = array[left];    <span class="hljs-keyword">int</span> i = left, j = right;    <span class="hljs-keyword">while</span>(i != j) &#123;        <span class="hljs-comment">// 顺序很重要，先从右边开始往左找，直到找到比base值小的数</span>        <span class="hljs-keyword">while</span>(array[j] &gt;= base &amp;&amp; i &lt; j) &#123;            j--;        &#125;        <span class="hljs-comment">// 再从左往右边找，直到找到比base值大的数</span>        <span class="hljs-keyword">while</span>(array[i] &lt;= base &amp;&amp; i &lt; j) &#123;            i++;        &#125;        <span class="hljs-comment">// 上面的循环结束表示找到了位置或者(i&gt;=j)了，交换两个数在数组中的位置</span>        <span class="hljs-keyword">if</span>(i &lt; j) &#123;            <span class="hljs-keyword">int</span> tmp = array[i];            array[i] = array[j];            array[j] = tmp;        &#125;    &#125;    <span class="hljs-comment">// 将基准数放到中间的位置（基准数归位）</span>    array[left] = array[i];    array[i] = base;    <span class="hljs-comment">// 递归，继续向基准的左右两边执行和上面同样的操作</span>    <span class="hljs-comment">// i的索引处为上面已确定好的基准值的位置，无需再处理</span>    sort(array, left, i - <span class="hljs-number">1</span>);    sort(array, i + <span class="hljs-number">1</span>, right);&#125;</code></pre><p><img src="/2023/09/12/%E7%AE%97%E6%B3%95%E7%AF%87/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.jpg" srcset="/img/loading.gif" alt></p><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><pre><code class="hljs java"><span class="hljs-comment">/***</span><span class="hljs-comment">    * 桶排序，顾名思义，会用到“桶”，核心思想是将要排序的数据分到几个有序的桶里</span><span class="hljs-comment">    * 每个桶里的数据再单独进行排序, 桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了</span><span class="hljs-comment">    *</span><span class="hljs-comment">    * 缺点：桶排序的缺陷就在于如何合理的把数据分配到桶种</span><span class="hljs-comment">    *       当桶的个数数据反而大于数据总量的时候，更不适合</span><span class="hljs-comment">    *</span><span class="hljs-comment">    * 桶排序的适用：</span><span class="hljs-comment">    *     桶排序比较适合用在外部排序中。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中</span><span class="hljs-comment">    *     比如处理大文件里的数据，文件数据等等 (核心思想：分治)</span><span class="hljs-comment">    *</span><span class="hljs-comment">    * 计数排序 -&gt; 属于桶排序的一种特殊情况，例如  50万考生，根据分数进行排序</span><span class="hljs-comment">    *                                          100万用户，根据年龄进行排序</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123; &#125;</code></pre><p><img src="/2023/09/12/%E7%AE%97%E6%B3%95%E7%AF%87/%E6%A1%B6%E6%8E%92%E5%BA%8F.jpg" srcset="/img/loading.gif" alt></p><h3 id="基于各种排序算法的场景思考题"><a href="#基于各种排序算法的场景思考题" class="headerlink" title="基于各种排序算法的场景思考题"></a>基于各种排序算法的场景思考题</h3><blockquote><ol><li>如何对50万考生根据成绩快速的进行排序</li><li>内存1G的电脑如何把10个文件各为1G的有序日志文件，按实际排序整合到一个新文件中</li><li>数据补全，比如考试成绩确定到小数点后一位，字母补全等等，如 a,ab,abc  可将其转化为<strong>ASCII</strong>，然后补0占位即可</li></ol><p>主要即结合排序算法中，递归，分治，分区，桶的思想进行思考</p><p>如题1，即可使用桶排序，成绩范围为0-900，901个桶即可</p><p>如题2，使用十个IO流，每次各自的一条数据，取出最小的，写入新文件中，一行一行的读，一行一行的写，内存占用很低</p></blockquote><h2 id="字符串匹配算法实践"><a href="#字符串匹配算法实践" class="headerlink" title="字符串匹配算法实践"></a>字符串匹配算法实践</h2><blockquote><p>具体的字符串匹配实践，如BF算法，RK算法，BM算法等等</p></blockquote><h3 id="BF-算法-（-暴力匹配算法-）"><a href="#BF-算法-（-暴力匹配算法-）" class="headerlink" title="BF 算法 （ 暴力匹配算法 ）"></a>BF 算法 （ 暴力匹配算法 ）</h3><blockquote><p> BF 算法的思想可以用一句话来概括，那就是，我们在主串中，检查起始位置分别是 0、1、2…n-m 且长度为 m 的 n-m+1 个子串，看有没有跟模式串匹配的 </p></blockquote><p><img src="/2023/09/12/%E7%AE%97%E6%B3%95%E7%AF%87/image-20191227095938513.png" srcset="/img/loading.gif" alt="image-20191227095938513"></p><pre><code class="hljs java"><span class="hljs-comment">/***</span><span class="hljs-comment"> * BF 算法思路</span><span class="hljs-comment"> * 暴力匹配算法 -&gt;</span><span class="hljs-comment"> * abcde</span><span class="hljs-comment"> *  bd</span><span class="hljs-comment"> *   bd</span><span class="hljs-comment"> *    bd...</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bfHandle</span> <span class="hljs-params">(String content, String target)</span> </span>&#123;    <span class="hljs-keyword">if</span> (StringUtils.isBlank(content) || StringUtils.isBlank(target) || content.length() &lt; target.length()) &#123;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">// 模拟BF算法思路 省略全字符串匹配 -&gt; 用substring替代</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; content.length(); i++) &#123;        String current = content.substring(i, target.length() + i);        <span class="hljs-keyword">if</span> (current.length() &lt; target.length()) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">if</span> (target.equals(current)) &#123;            <span class="hljs-keyword">return</span> i;        &#125;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;<span class="hljs-comment">/***</span><span class="hljs-comment"> * BF 算法思路优化</span><span class="hljs-comment"> * 1. 根据String 本质是char[]的特点，通过预先下标比对，进行优化</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 2. 待做：优化一是拿到第一个char去对比,判断是否有对比的必要</span><span class="hljs-comment"> * 还可以继续优化 ---&gt; 像是判断鸡蛋在第几层会碎一样，除了从头到尾，还可以从尾到头，根据方案一的优化之后</span><span class="hljs-comment"> * 然后从最后一位开始对比，可以更快的确定是否是指定的字符</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bfHandleImprove</span> <span class="hljs-params">(String content, String target)</span> </span>&#123;    <span class="hljs-keyword">if</span> (StringUtils.isBlank(content) || StringUtils.isBlank(target) || content.length() &lt; target.length()) &#123;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">// 预先存储第一个char</span>    <span class="hljs-keyword">char</span> targetChar = target.charAt(<span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; content.length(); i++) &#123;        <span class="hljs-comment">// 优化BF算法，预先比对第一个字符即可</span>        <span class="hljs-keyword">if</span> (content.charAt(i) != targetChar) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        String current = content.substring(i, target.length() + i);        <span class="hljs-keyword">if</span> (current.length() &lt; target.length()) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">if</span> (target.equals(current)) &#123;            <span class="hljs-keyword">return</span> i;        &#125;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre><h3 id="RK-算法"><a href="#RK-算法" class="headerlink" title="RK 算法"></a>RK 算法</h3><blockquote><p> RK算法通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个 子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配 （Hash冲突额外考虑）</p><p> 重点：如何更高的效率，通过一次遍历获取所有子串的哈希值</p><p> 策略：比如要处理的字符串只包含 a～z 这 26 个小写字母，那我们就用二十六进制来表示一个字符串。我们把 a～z 这 26 个字符映射到 0～25 这 26 个数字，a 就表示 0，b 就表示 1，以此类推，z 表示 25</p><p> <img src="/2023/09/12/%E7%AE%97%E6%B3%95%E7%AF%87/c47b092408ebfddfa96268037d53aa9c.jpg" srcset="/img/loading.gif" alt="img"> </p><p> 这样即可根据 index[i -1]的hash值推导处index[i]的hash值，这样即可高效的进行对比</p><p> 当产生hash冲突时，再对比字符串本身即可，而且如果需要匹配的字符串长度过长，还可以压缩长度，虽然这样会加大hash冲突，但是效率仍然可以大大提高</p></blockquote><h3 id="BM-算法-最高效算法"><a href="#BM-算法-最高效算法" class="headerlink" title="BM 算法 最高效算法"></a>BM 算法 最高效算法</h3><blockquote> <pre><code class="hljs 字符串匹配的算法耗时主要核心：如何减少单位字符串内匹配的次数```"> **BM算法本质上其实就是在寻找如何跳过更多的字符串，达到仅进行更少的匹配次数的算法** 因为真正的匹配计算中，不一定真的是一次跳过一个字节，而可能是很多个，因此BM算法实际在寻找如何跳过最多字节的规律，借助这种规律，在模式串与主串匹配的过程中，当模式串和主串某个字符不匹配的时候，能够跳过一些肯定不会匹配的情况，将模式串往后多滑动几位   BM 算法包含两部分，分别是坏字符规则（bad character rule）和好后缀规则（good suffix shift )####  坏字符规则 BM 算法的匹配顺序比较特别，它是按照模式串下标从大到小的顺序，倒着匹配的 ![image-20191115144217875](算法篇&#x2F;image-20191115144217875.png)我们从模式串的末尾往前倒着匹配，当我们发现某个字符没法匹配的时候**我们把这个没有匹配的字符叫作坏字符（主串中的字符）** ![image-20191115144249440](算法篇&#x2F;image-20191115144249440.png)我们拿坏字符 c 在模式串中查找，发现模式串中并不存在这个字符，也就是说，字符 c 与模式串中的任何字符都不可能匹配。这个时候，我们可以将模式串直接往后滑动三位，将模式串滑动到 c 后面的位置，再从模式串的末尾字符开始比较 ![image-20191115144359955](算法篇&#x2F;image-20191115144359955.png)这个时候，我们发现，模式串中最后一个字符 d，还是无法跟主串中的 a 匹配，这个时候，还能将模式串往后滑动三位吗？答案是不行的。因为这个时候，坏字符 a 在模式串中是存在的，模式串中下标是 0 的位置也是字符 a。这种情况下，我们可以将模式串往后滑动两位，让两个 a 上下对齐，然后再从模式串的末尾字符开始，重新匹配 ![image-20191115144554974](算法篇&#x2F;image-20191115144554974.png)当发生不匹配的时候，我们把坏字符对应的模式串中的字符下标记作 si。如果坏字符在模式串中存在，我们把这个坏字符在模式串中的下标记作 xi。如果不存在，我们把 xi 记作 -1。那模式串往后移动的位数就等于 si-xi。（注意，我这里说的下标，都是字符在模式串的下标） ![image-20191115145041597](算法篇&#x2F;image-20191115145041597.png)不过，单纯使用坏字符规则还是不够的。因为根据 si-xi 计算出来的移动位数，有可能是负数，比如主串是 aaaaaaaaaaaaaaaa，模式串是 baaa。不但不会向后滑动模式串，还有可能倒退。所以，BM 算法还需要用到“好后缀规则” ####  好后缀规则 好后缀规则实际上跟坏字符规则的思路很类似。下面这幅图。当模式串滑动到图中的位置的时候，模式串和主串有 2 个字符是匹配的，倒数第 3 个字符发生了不匹配的情况 ![image-20191115151453142](算法篇&#x2F;image-20191115151453142.png)滑动规则如下：![image-20191115151629066](算法篇&#x2F;image-20191115151629066.png)当好后缀匹配不到第二个的时候，如何处理呢？![image-20191115151708875](算法篇&#x2F;image-20191115151708875.png)即：以bc为标准点，向后移动，同时匹配字符串bc，及字符串c，这样可以保证不会过度滑动&#96;&#96;&#96;java&#x2F;&#x2F; 代码实现略 注意重复数据配置缓存 -&gt; 通过散列表实现，坏字符在模式串中下标位置的快速查询 </code></pre></blockquote><h3 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h3><blockquote><p>朴素算法（BF算法）：有点类似双指针，一个指针指字符串本身，一个指针指需要匹配的串<br>主指针：BBC ABCDAB ABCDABCDABDE<br>从指针：ABCDABD<br>每次都是主指针，从指针，一个字符串一个字符串的比对，如果不适配，则主指针从下一个开始元素开始，从指针归于开始位置，再进行匹配<br>（注意：主指针的每一次移动都进行了字符串的匹配）</p><p>KMP算法：在理解朴素算法的基础上，我们依然需要从头到尾移动主指针，但是为了提高性能，我们可以根据已有的对比的数据进行一定的处理，达到更少的匹配次数，即：</p><pre><code class="hljs 主指针依然从头指到目标位置，从指针依然从头指到尾部，但是一次比对失败后，利用已有的数据，让主指针尽可能多的移动，移动但不进行对比，到达比对位置起点后，同样的利用已知数据，从指针也并非从头开始进行对比，这样一来可以大大的提高字串查询效率```">而KMP算法的核心即如何寻找到这种规律：求解著名的Next数组### AC自动机  多模式串匹配算法场景：过滤敏感词汇 -》主串一个，模式串可能有上千个，此时我们需要的多模式串匹配的算法思路，否则单模式串的方式会损耗大量的性能多模式串匹配算法：&#96;&#96;&#96;AC自动机 </code></pre><ul><li>将多个模式串构建成 Trie 树 </li><li>在 Trie 树上构建失败指针（相当于 KMP 中的失效函数 next 数组） </li></ul><p><img src="/2023/09/12/%E7%AE%97%E6%B3%95%E7%AF%87/image-20191127093626600.png" srcset="/img/loading.gif" alt="image-20191127093626600"></p><p>即 -》 abcf 匹配 敏感词汇：</p><ol><li>从a字符入口，匹配到b，c 节点匹配失败</li><li>指向bcd，c.next匹配再次失败，指向c</li><li>c匹配成功，因此c字符匹配成功，进行业务处理</li></ol></blockquote><h2 id="数据结构与算法实战算法实战篇"><a href="#数据结构与算法实战算法实战篇" class="headerlink" title="数据结构与算法实战算法实战篇"></a>数据结构与算法实战算法实战篇</h2><pre><code class="hljs 以下内容为开拓思路```">### 朴素贝叶斯算法-过滤垃圾短信- 基于黑名单过滤  ---  瑕疵：数据存储在手机导致数据量过于庞大，存储到服务器导致网络依赖- 基于规则过滤 &gt; 是否包含特殊单词，词语，号码是否符合正常规则，短信格式判断，内容判断等等&gt;&gt; 瑕疵：&gt;&gt; 1. 规则不好提取&gt;&gt; 2. 当规则被识别后，垃圾短信完全可以绕过扫描机制- 基于概率的过滤器&gt; 基础理论算法：朴素贝叶斯算法&gt;&gt; 简单来说就是计算，多个事件A,B 各自单独发生概率，以及互相影响情况下的发生概率&gt;&gt; &gt;&gt; 这样一来即可进行综合的过滤，多管齐下：&gt;&gt; 1. 在网络情况下通过网络比对&gt; 2. 网络状态不好时，通过复杂的规则比对 ---》 即对基于概率计算的方式进行更细颗粒的比对&gt;&gt; 比如判断号码是异常号码的前提下，且出现了反动词语，且出现了等等其他情况，综合计算朴素贝叶斯算法的结果，以此判断是否需要进行过滤，而不是简单的单一规则符合即可### 位图-布隆过滤器&gt; 为什么需要布隆过滤器？&gt;&gt; 布隆过滤器的作用可以通过哈希表进行替代，那为什么还需要布隆过滤器呢？因为它极端省内存&gt;&gt; 比如：&gt;&gt; 假设我们要爬取 10 亿个网页，为了判重，我们把这 10 亿网页链接存储在散列表中。大约需要多少内存？假设一个 URL 的平均长度是 64 字节，那单纯存储这 10 亿个 URL，需要大约 60GB 的内存空间&gt;&gt; &gt;&gt; 布隆过滤器的基本原理：&gt;&gt; ![1577116880503](算法篇&#x2F;1577116880503.png)&gt;&gt; 我们再存储一个数，假设为100，计算出f1,f2,f3 为：0，1，4 与之对应的值都是1，那么布隆过滤器可以告诉我们100这个数可能已经存在，如果计算得2，3，5 则100这个数一定不存在，这即是其简单的原理，通过存储简单的0，1来大大的减少内存的消耗&gt;&gt; &gt;&gt; 应用：比如Redis缓存使用时，我们为了避免缓存穿透，对一定不存在的值构造一个布隆过滤器，用以排除无效的查询### 向量空间-实现一个简单的音乐推荐系统&gt; 我们先不管这些高大上的名词，如果真的让你去实现一个音乐推荐系统，你会怎么做？&gt;&gt; - 通过找到口味相似的用户，把其他人的喜爱歌曲推荐给用户&gt; - 通过用户喜欢的歌曲找到相似的歌曲进行推荐#### 基于相似用户做推荐只需要计算用户口味是否相似即可，那么如何计算用户的口味相似是否相似？统计两个人共同喜欢的歌曲数量，再深度计算喜欢程度，我们可以思考一个量化统计的方案，比如：![1577117602803](算法篇&#x2F;1577117602803.png)我们可能得到这样一个结果：![1577117647459](算法篇&#x2F;1577117647459.png)&gt; 欧几里得距离（Euclidean distance）：欧几里得距离是用来计算两个向量之间的距离的![1577117703785](算法篇&#x2F;1577117703785.png)为什么要引入欧几里得距离？因为我们现在可以得到非常细化的分数，我们需要利用这些分数，就应该有一个明确的理论依据的计算方式，因此可以计算出各自的值为：![1577117757400](算法篇&#x2F;1577117757400.png)毫无疑问，我们和小明最相似，因此把小明喜欢的歌推荐给我们，可能是最适合的。#### 基于相似歌曲做推荐一样的思路，人工对歌曲进行标注其实非常带有主观色彩，因此用户的真实数据才是最好的记录，我们可以利用已有的数据进行合理的计算![1577117916655](算法篇&#x2F;1577117916655.png)计算欧几里得距离，差值越小，即可表明两首歌的风格越相似，当然，数据量小的话可能会出大问题，但是推荐系统就是这样，当数据量越来越大的时候，它就会越来越趋于准确## 一、回溯法&gt; 回溯法大多使用递归的技巧进行处理，详情如下：&gt;&gt; &#x2F;***&gt;&gt;  * 递归需要满足的三个条件&gt;  * 1. 一个问题的解可以分解为几个子问题的解&gt;  * 2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样&gt;  * 3. 存在递归终止条件&gt;   * 总结：写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件， 最后将递推公式和终止条件翻译成代码&gt; *&#x2F;&#96;&#96;&#96; 算法实战：走台阶问题</code></pre><pre><code class="hljs java"><span class="hljs-comment">/***</span><span class="hljs-comment"> * 走台阶: 1 2 3 5 8 13</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">goStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;    <span class="hljs-keyword">if</span> (num == <span class="hljs-number">1</span> || num == <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> num;    &#125;    <span class="hljs-keyword">return</span> goStairs(num - <span class="hljs-number">1</span>) + goStairs(num - <span class="hljs-number">2</span>);&#125;<span class="hljs-comment">/***</span><span class="hljs-comment"> * 优化走台阶: 1 2 3 5 8 13</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">goStairsMore</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;    <span class="hljs-keyword">if</span> (num == <span class="hljs-number">1</span> || num == <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> num;    &#125;    <span class="hljs-keyword">if</span> (!map.containsKey(num)) &#123;        <span class="hljs-keyword">int</span> value = goStairsMore(num - <span class="hljs-number">1</span>) + goStairsMore(num - <span class="hljs-number">2</span>);        map.put(num, value);        <span class="hljs-keyword">return</span> value;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> map.get(num);    &#125;&#125;</code></pre><pre><code class="hljs 算法实战：倒序输出一个正整数```">&#96;&#96;&#96;java&#x2F;*** * 倒序输出一个正整数 *&#x2F;private static void printOrderNum(int num) &#123;    if (num &gt;&#x3D; 10) &#123;        System.out.print(num % 10);        printOrderNum(num &#x2F;&#x3D; 10);    &#125; else &#123;        System.out.print(num);    &#125;&#125;</code></pre><pre><code class="hljs 算法实战：角谷定理```">&#96;&#96;&#96;java&#x2F;*** * 角谷定理。输入一个自然数，若为偶数，则把它除以2，若为奇数，则把它乘以3加1。经过如此有限次运算后，总可以得到自然数值1。 * 求经过多少次可得到自然数1 *&#x2F;private static int jiaoGu(int number, int num) &#123;    num++;    if (number &#x3D;&#x3D; 1) &#123;        return num;    &#125;    int value &#x3D; number % 2 &#x3D;&#x3D; 0 ? number &#x2F; 2 : number * 3 + 1;    return jiaoGu(value, num);&#125;</code></pre><pre><code class="hljs 算法实战：验证指定的字符串是否为反转字符```">&#96;&#96;&#96;java&#x2F;*** * 编写一个方法用于验证指定的字符串是否为反转字符，返回true和false * 请用递归算法实现 *&#x2F;private static boolean isReturnString(String string) &#123;    char head &#x3D; string.charAt(0);    char foot &#x3D; string.charAt(string.length() - 1);    if (head !&#x3D; foot) &#123;        return false;    &#125;    if (string.length() &#x3D;&#x3D; 1 || string.length() &#x3D;&#x3D; 2) &#123;        return true;    &#125;    return isReturnString(string.substring(1, string.length() - 1));&#125;</code></pre><pre><code class="hljs 算法实战：一个射击运动员打靶,靶一共有10环,连开10枪打中90环的可能性有多少种```">&#96;&#96;&#96;java&#x2F;*** * 一个射击运动员打靶,靶一共有10环,连开10枪打中90环的可能性有多少种 *&#x2F;private static int   sum &#x3D; 0;private static void  getNum(int score, int num) &#123;    if (score &lt; 0 || score &gt; num * 10) &#123;        return;    &#125;    if (num &#x3D;&#x3D; 0) &#123;        sum++;    &#125;    for (int i &#x3D; 0; i &lt; 11; i++) &#123;        getNum(score - i, num - 1);    &#125;&#125;</code></pre><h2 id="二、二分查找"><a href="#二、二分查找" class="headerlink" title="二、二分查找"></a>二、二分查找</h2><blockquote><p>注意事项：</p><ol><li>二分查找必须依然顺序表结构</li><li>针对有序数据</li><li>数据量太小不适合使用二分查找</li><li>数据量太大不适合使用二分查找 -&gt; 因为数据需要连续的存储空间，因此数据量非常大的情况，空间占用也非常高</li></ol></blockquote><pre><code class="hljs 简单二分查找```">&#96;&#96;&#96;java&#x2F;** * 二分法查找 | 要求为有序数组 * @param array  数组 * @param num    元素 *&#x2F;private static boolean search (int[] array, int num) &#123;    if (array.length &#x3D;&#x3D; 0) &#123;        return false;    &#125;    int left  &#x3D; 0;    int right &#x3D; array.length - 1;    while (left &lt;&#x3D; right) &#123;        int mid &#x3D; (left + right) &#x2F; 2;        if (array[mid] &#x3D;&#x3D; num) &#123;            return true;        &#125; else if (array[mid] &gt; num) &#123;            right &#x3D; mid;        &#125; else &#123;            &#x2F;&#x2F; 因为mid 肯定不是，因此可以多 + 1            left &#x3D; mid + 1;        &#125;    &#125;    return false;&#125;</code></pre><pre><code class="hljs 二分查找">&gt; 1. 查找第一个值等于给定值的元素&gt; 2. 找到最后一个等于给定值的元素&gt; 3. 查找第一个大于等于给定值的元素&gt; 4. 查找最后一个小于等于给定值的元素&gt;&gt; 即给定的有序集合中包含重复的元素，如何抉择？&#96;&#96;&#96;查找第一个值等于给定值的元素</code></pre><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 有序重复元素的数据, 寻找第一个符合要求的元素下标</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 关键在于 符合要求时候的判断，是否前面的一个元素不符合要求</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> array  数组</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> value  元素</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">searchFirstValue</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>[] array, <span class="hljs-keyword">int</span> value)</span> </span>&#123;    <span class="hljs-keyword">int</span> left  = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> right = array.length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;        <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span> (array[mid] &gt; value) &#123;            right = mid - <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (array[mid] &lt; value) &#123;            left = mid + <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">if</span> ((mid == <span class="hljs-number">0</span>) || (array[mid - <span class="hljs-number">1</span>] != value)) <span class="hljs-keyword">return</span> mid;            <span class="hljs-keyword">else</span> left = mid - <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre><pre><code class="hljs 查找最后一个值等于给定值的元素```">&#96;&#96;&#96;javapublic int bsearch(int[] a, int n, int value) &#123;    int low &#x3D; 0;    int high &#x3D; n - 1;    while (low &lt;&#x3D; high) &#123;        int mid &#x3D;  low + ((high - low) &gt;&gt; 1);        if (a[mid] &gt; value) &#123;            high &#x3D; mid - 1;        &#125; else if (a[mid] &lt; value) &#123;            low &#x3D; mid + 1;        &#125; else &#123;            if ((mid &#x3D;&#x3D; n - 1) || (a[mid + 1] !&#x3D; value)) return mid;            else low &#x3D; mid + 1;        &#125;    &#125;    return -1;&#125;</code></pre><pre><code class="hljs 查找第一个大于等于给定值的元素```">&#96;&#96;&#96;javapublic int bsearch(int[] a, int n, int value) &#123;    int low &#x3D; 0;    int high &#x3D; n - 1;    while (low &lt;&#x3D; high) &#123;        int mid &#x3D;  low + ((high - low) &gt;&gt; 1);        if (a[mid] &gt;&#x3D; value) &#123;            if ((mid &#x3D;&#x3D; 0) || (a[mid - 1] &lt; value)) return mid;            else high &#x3D; mid - 1;        &#125; else &#123;            low &#x3D; mid + 1;        &#125;    &#125;    return -1;&#125;</code></pre><pre><code class="hljs 查找最后一个小于等于给定值的元素```">&#96;&#96;&#96;javapublic int bsearch7(int[] a, int n, int value) &#123;    int low &#x3D; 0;    int high &#x3D; n - 1;    while (low &lt;&#x3D; high) &#123;        int mid &#x3D;  low + ((high - low) &gt;&gt; 1);        if (a[mid] &gt; value) &#123;            high &#x3D; mid - 1;        &#125; else &#123;            if ((mid &#x3D;&#x3D; n - 1) || (a[mid + 1] &gt; value)) return mid;            else low &#x3D; mid + 1;        &#125;    &#125;    return -1;&#125;</code></pre><h2 id="三、递推法"><a href="#三、递推法" class="headerlink" title="三、递推法"></a>三、递推法</h2><blockquote><p>概念：递推算法是一种简单的算法，即通过已知条件，利用特定关系得出中间推论，直至得到结果的算法。递推算法分为顺推和逆推两种。</p><p>递推算法适合有着明显规律的场合</p></blockquote><pre><code class="hljs 兔子生崽的问题```">&#96;&#96;&#96;java如果有两个月大的兔子以后每个月都可以产一对小兔子，而一对小兔子出生两个月后可以在生小兔子，也就是1月份出生，3月份才可以产崽子。那么假定一年内没有发生死亡事件，那么现在有一对小兔子一年后共有多少对兔子。案例分析：1月 1对兔子2月 1对兔子3月 2对兔子 一对成熟兔子4月 3对兔子 5月 5对兔子 两对成熟兔子6月 8对兔子 三对成熟兔子。。。。。。规律：前两个月都是一对兔子，以后每个月的兔子的对数是前两个月的总和除1,2月份的计算公式：n月  Fn &#x3D; (Fn-1)+(Fn-2)public class Recurrence &#123;    public int recurrence(int months)&#123;        int a &#x3D; 1;&#x2F;&#x2F;第1个月        int b &#x3D; 1;&#x2F;&#x2F;第2个月        int c &#x3D; 1;&#x2F;&#x2F;第n个月        while (months &gt; 2)&#123;            c &#x3D; a + b;            a &#x3D; b;            b &#x3D; c;            months--;        &#125;        return c;&#125;&#125;</code></pre><pre><code class="hljs 爬楼梯```">&#96;&#96;&#96;java假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？注意：给定 n 是一个正整数。案例分析一层 1两层 2三层 3四层 5五层 8......规律分析：与兔子题不同的一点在于第一个数和第二个数除1,2层的计算公式：n层  Fn &#x3D; (Fn-1)+(Fn-2)public class upStairs&#123;public int climbStairs(int n) &#123;        if (n &#x3D;&#x3D; 0) return 0;        int last &#x3D; 0;        int newLast &#x3D; 1;        int res &#x3D; last + newLast;        if (n &#x3D;&#x3D; 1) return res;        for (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;            last &#x3D; newLast;            newLast &#x3D; res;            res &#x3D; last + newLast;        &#125;        return res;    &#125;&#125;</code></pre><h2 id="四、贪心算法"><a href="#四、贪心算法" class="headerlink" title="四、贪心算法"></a>四、贪心算法</h2><blockquote><p>贪心算法在求解某个问题时，总是做出眼前的最大利益，也就是说只顾眼前不顾大局，所以他是局部最优解</p><p>贪心算法不是对所有问题都能得到整体最好的解决办法，关键是<strong>贪心策略</strong>的选择，选择的贪心策略必须具备无后效性，即某个状态以前的状态不会影响以后的状态，只与当前状态有关</p><p> 贪心算法两个重要的特点是：<br>（1）贪心策略<br>（2）通过局部最优解能够得到全局最优解 </p></blockquote><pre><code class="hljs 加油站```"></code></pre><p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p><p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p><p>说明:<br>    如果题目有解，该答案即为唯一答案。<br>    输入数组均为非空数组，且长度相同。<br>    输入数组中的元素均为非负数。</p><p>输入:<br>gas  = [1,2,3,4,5]<br>cost = [3,4,5,1,2]</p><p>输出: 3</p><p>解释:<br>从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油<br>开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油<br>开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油<br>开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油<br>开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油<br>开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。<br>因此，3 可为起始索引。</p><pre><code class="hljs angelscript">```java<span class="hljs-comment">// 如果A站不能到B站，那么A，B之间到任何一个站都不能到B站，（B站是A站第一个不能到的站）</span><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> canCompleteCircuit(<span class="hljs-built_in">int</span>[] gas, <span class="hljs-built_in">int</span>[] cost) &#123;    <span class="hljs-built_in">int</span> n = gas.length;    <span class="hljs-built_in">int</span> total_tank = <span class="hljs-number">0</span>;    <span class="hljs-built_in">int</span> curr_tank = <span class="hljs-number">0</span>;    <span class="hljs-built_in">int</span> starting_station = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;        total_tank += gas[i] - cost[i];        curr_tank += gas[i] - cost[i];        <span class="hljs-keyword">if</span> (curr_tank &lt; <span class="hljs-number">0</span>) &#123;            starting_station = i + <span class="hljs-number">1</span>;            curr_tank = <span class="hljs-number">0</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> total_tank &gt;= <span class="hljs-number">0</span> ? starting_station : <span class="hljs-number">-1</span>;&#125;</code></pre><h2 id="五、分治法"><a href="#五、分治法" class="headerlink" title="五、分治法"></a>五、分治法</h2><blockquote><pre><code class="hljs 分治法的精髓：```">分--将问题分解为规模更小的子问题；治--将这些规模更小的子问题逐个击破；合--将已解决的子问题合并，最终得出“母”问题的解；&#96;&#96;&#96;最大子序和 </code></pre></blockquote><pre><code class="hljs java"><span class="hljs-comment">// 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</span><span class="hljs-comment">// 输入: [-2,1,-3,4,-1,2,1,-5,4],</span><span class="hljs-comment">// 输出: 6</span><span class="hljs-comment">// 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = nums.length;        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">return</span> maxSubArraySum(nums, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxCrossingSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> right)</span> </span>&#123;        <span class="hljs-comment">// 一定会包含 nums[mid] 这个元素</span>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> leftSum = Integer.MIN_VALUE;        <span class="hljs-comment">// 左半边包含 nums[mid] 元素，最多可以到什么地方</span>        <span class="hljs-comment">// 走到最边界，看看最值是什么</span>        <span class="hljs-comment">// 计算以 mid 结尾的最大的子数组的和</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = mid; i &gt;= left; i--) &#123;            sum += nums[i];            <span class="hljs-keyword">if</span> (sum &gt; leftSum) &#123;                leftSum = sum;            &#125;        &#125;        sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> rightSum = Integer.MIN_VALUE;        <span class="hljs-comment">// 右半边不包含 nums[mid] 元素，最多可以到什么地方</span>        <span class="hljs-comment">// 计算以 mid+1 开始的最大的子数组的和</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = mid + <span class="hljs-number">1</span>; i &lt;= right; i++) &#123;            sum += nums[i];            <span class="hljs-keyword">if</span> (sum &gt; rightSum) &#123;                rightSum = sum;            &#125;        &#125;        <span class="hljs-keyword">return</span> leftSum + rightSum;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArraySum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;        <span class="hljs-keyword">if</span> (left == right) &#123;            <span class="hljs-keyword">return</span> nums[left];        &#125;        <span class="hljs-keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">return</span> max3(maxSubArraySum(nums, left, mid),                maxSubArraySum(nums, mid + <span class="hljs-number">1</span>, right),                maxCrossingSum(nums, left, mid, right));    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">max3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1, <span class="hljs-keyword">int</span> num2, <span class="hljs-keyword">int</span> num3)</span> </span>&#123;        <span class="hljs-keyword">return</span> Math.max(num1, Math.max(num2, num3));    &#125;&#125;</code></pre><pre><code class="hljs 搜索二位矩阵```">&#96;&#96;&#96;java编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：每行的元素从左到右升序排列每列的元素从上到下升序排列给定矩阵[  [1,   4,  7, 11, 15],  [2,   5,  8, 12, 19],  [3,   6,  9, 16, 22],  [10, 13, 14, 17, 24],  [18, 21, 23, 26, 30]]给定 target &#x3D; 5，返回 true给定 target &#x3D; 20，返回 falsepublic class Solution &#123;    public boolean searchMatrix(int[][] matrix, int target) &#123;        int row &#x3D; matrix.length-1;        int col &#x3D; 0;        while (row &gt;&#x3D; 0 &amp;&amp; col &lt; matrix[0].length) &#123;            if (matrix[row][col] &gt; target) &#123;                row--;            &#125; else if (matrix[row][col] &lt; target) &#123;                col++;            &#125; else &#123;                 &#x2F;&#x2F;找到了target                return true;            &#125;        &#125;        return false;    &#125;&#125;</code></pre><h2 id="六、动态规划法"><a href="#六、动态规划法" class="headerlink" title="六、动态规划法"></a>六、动态规划法</h2><blockquote><p>A * “1+1+1+1+1+1+1+1 =？” *</p><p>A : “上面等式的值是多少”<br>B : <em>计算</em> “8!”</p><p>A <em>在上面等式的左边写上 “1+” *<br>A : “此时等式的值为多少”<br>B : *quickly</em> “9!”<br>A : “你怎么这么快就知道答案了”<br>A : “只要在8的基础上加1就行了”<br>A : “所以你不用重新计算因为你记住了第一个等式的值为8!动态规划算法也可以说是 ‘记住求过的解来节省时间’”</p></blockquote><pre><code class="hljs 动态规划实战-切钢条```">![image-20191227092802025](算法篇&#x2F;image-20191227092802025.png)&gt; 给一段长度小于等于10的钢条，如何切割效益最大？&gt;&gt; &#96;&#96;&#96;java&gt; &#x2F;&#x2F; 已知条件&gt; private static int[] arr &#x3D; new int[11];&gt; static &#123;&gt;     arr[0] &#x3D; 0;&gt;     arr[1] &#x3D; 1;&gt;     arr[2] &#x3D; 5;&gt;     arr[3] &#x3D; 8;&gt;     arr[4] &#x3D; 9;&gt;     arr[5] &#x3D; 10;&gt;     arr[6] &#x3D; 17;&gt;     arr[7] &#x3D; 17;&gt;     arr[8] &#x3D; 20;&gt;     arr[9] &#x3D; 24;&gt;     arr[10] &#x3D; 30;&gt; &#125;&gt;</code></pre><p>我们通过普通递归，推导备忘录算法，再推导动态规划，来看看其演进的过程：</p><pre><code class="hljs java"><span class="hljs-comment">/***</span><span class="hljs-comment"> * 递归方法</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cut</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> length)</span> </span>&#123;    <span class="hljs-keyword">if</span> (length == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> result = Integer.MIN_VALUE;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= length; i++) &#123;        result = Math.max(result, arr[i] + cut(arr, length - i));    &#125;    <span class="hljs-keyword">return</span> result;&#125;递归算法的反思：    例如我们在计算<span class="hljs-number">8</span>的时候，分解为<span class="hljs-number">3</span>，<span class="hljs-number">5</span> -》 <span class="hljs-number">1</span>，<span class="hljs-number">7</span>    分解为<span class="hljs-number">3</span>，<span class="hljs-number">5</span>的时候又把<span class="hljs-number">5</span>进行分解    分解为<span class="hljs-number">1</span>，<span class="hljs-number">7</span>的时候又可以把<span class="hljs-number">7</span>分解为<span class="hljs-number">2</span>，<span class="hljs-number">5</span>，又对<span class="hljs-number">5</span>进行了分解        简单来说，如果打印此纪录：System.out.println(length - <span class="hljs-number">1</span>);    则可以发现有非常多的重复计算</code></pre><p>计算思路演示图，<code>图和题目不符</code>，但是思想是一致的，即递归算法是<code>自上而下的</code>穷举遍历，很多计算重复了</p><p><img src="/2023/09/12/%E7%AE%97%E6%B3%95%E7%AF%87/image-20191227093808655.png" srcset="/img/loading.gif" alt="image-20191227093808655"></p><pre><code class="hljs 递归法的演进">&#96;&#96;&#96;java&#x2F;*** * 备忘录算法 *&#x2F;private static Map&lt;Integer, Integer&gt; map &#x3D; new HashMap&lt;&gt;();private static int cutMap (int[] arr, int length) &#123;    if (length &#x3D;&#x3D; 0) &#123;        return 0;    &#125;    int result &#x3D; Integer.MIN_VALUE;    for (int i &#x3D; 1; i &lt;&#x3D; length; i++) &#123;        if (map.containsKey(length - i)) &#123;            result &#x3D; Math.max(result, arr[i] + map.get(length - i));        &#125; else &#123;            int curr &#x3D; cutMap(arr, length - i);            map.put(length - i, curr);            result &#x3D; Math.max(result, arr[i] + curr);        &#125;    &#125;    return result;&#125;备忘录算法其实就做了一件事，杜绝重复计算，以此极大的提高效率，而且备忘录算法非常简单，能够写出递归    即可非常自然的实现备忘录</code></pre><pre><code class="hljs 备忘录算法的演进">&gt; 上文说到，动态规划的实质是&#96;&#96;&#96;记住求过的解来节省时间&#96;&#96;&#96;，这个目的其实备忘录算法已经实现了，只不过备忘录算法仍然有递归的成分在，难免性能较低，能否更加直观的计算呢？还是上文的思路图，如果我们&#96;&#96;&#96;自下而上&#96;&#96;&#96;去进行计算，是不是可以更加直观的利用求过的解来解决问题？![image-20191227094354358](算法篇&#x2F;image-20191227094354358.png)&#96;&#96;&#96;java&#x2F;** * 动态规划 *&#x2F;private static int dynamicHandle (int[] arr, int length) &#123;    &#x2F;&#x2F; result数组保存已经求过的解    int[] result &#x3D; new int[length + 1];    for (int i &#x3D; 1; i &lt;&#x3D; length; i++) &#123;        int num &#x3D; Integer.MIN_VALUE;        for (int j &#x3D; 1; j &lt;&#x3D; i; j++) &#123;            num &#x3D; Math.max(num, arr[j] + result[i - j]);        &#125;        &#x2F;&#x2F; 保存求过的解        result[i] &#x3D; num;    &#125;    return result[length];&#125;</code></pre><pre><code class="hljs 动态规划实战```">&#96;&#96;&#96;java&#x2F;&#x2F; 走楼梯问题,一次只能走一步或者走两步，问走n楼,一共多少种走法&#x2F;*** * 递归算法 *&#x2F;private static int goFlow (int num) &#123;    if (num &lt; 3) &#123;        return num;    &#125;    return goFlow(num - 1) + goFlow(num - 2);&#125;&#x2F;*** * 备忘录算法-存取值 *&#x2F;private static int goFlowByMap (int num, HashMap&lt;Integer,Integer&gt; map) &#123;    if (num &lt; 3) &#123;        return num;    &#125;    if (map &#x3D;&#x3D; null) &#123;        map &#x3D; new HashMap&lt;&gt;();    &#125;    if (map.containsKey(num)) &#123;        return map.get(num);    &#125; else &#123;        int value &#x3D; goFlowByMap(num - 1, map) + goFlowByMap(num -2, map);        map.put(num, value);        return value;    &#125;&#125;&#x2F;*** * 动态规划算法 - 关键点有两个，一个是找出一个数据变化的i，n关系，另一个是用代码实现这种i，n关系 * 如本题中的关键逻辑在于: d(i) &#x3D; d(i-1) + d(i-2),所以动态的存取这两个值即可 * 自下向上 *&#x2F;private static int goFlowByDP (int num) &#123;    if (num &lt; 3) &#123;        return num;    &#125;    int a &#x3D; 1;    int b &#x3D; 2;    int temp &#x3D; 0;    for (int i &#x3D; 3; i &lt;&#x3D; num; i++) &#123;        temp &#x3D; a + b;        a &#x3D; b;        b &#x3D; temp;    &#125;    return temp;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构及算法篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构篇</title>
    <link href="/2023/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/"/>
    <url>/2023/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="一、线性表"><a href="#一、线性表" class="headerlink" title="一、线性表"></a>一、线性表</h2><blockquote><p>概念：线性表是最常用且最简单的一种数据结构，它是n个数据元素的有限序列</p><p>实现线性表的方式一般有两种，一种是使用数组存储线性表的元素，即用一组连续的存储单元依次存储线性表的数据元素</p><p>另一种是使用链表存储线性表的元素，即用一组任意的存储单元存储线性表的数据元素（存储单元可以是连续的，也可以是不连续的）</p></blockquote><h3 id="1-1-数组"><a href="#1-1-数组" class="headerlink" title="1.1 数组"></a>1.1 数组</h3><blockquote><p>概念：数组是一种大小固定的数据结构，对线性表的所有操作都可以通过数组来实现</p><p>虽然数组一旦创建之后，它的大小就无法改变了，但是当数组不能再存储线性表中的新元素时，我们可以创建一个新的大的数组来替换当前数组,这样就可以使用数组实现动态的数据结构</p><p>寻址公式，计算出该元素存储的内存地址：</p><pre><code class="hljs a[i]_address">数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)上述的寻址公式也揭示了为什么数组下标一般从0开始，因为index索引位置，其实表示偏移量，如果一般情况从1开始，表示无偏移量则会写成 (i - 1) * xxxxx  这样CPU的操作就会又多了一次，效率肯定会降低一些，另外C语言是众多高级语言的初期领导者，也是为了一定程度的照顾开发者的使用习惯吧数组由于其结构特点，当删除元素的时，为了保证内存连续性，后置的元素需要前移，这样效率就会低，但是我们也可以通过记录被删除元素的位置，实现&#96;&#96;&#96;假删除&#96;&#96;&#96;，当存储空间不够，或者达到某一要求后，一次性删除所有应该删除的元素，然后元素移动只需要移动一次（移动的位置多了，但是不影响效率）即可上述的思路其实也是Java GC的标记清除算法的核心思想，即： 大多数主流虚拟机采用可达性分析算法来判断对象是否存活，在标记阶段，会遍历所有 GC ROOTS，将所有 GC ROOTS 可达的对象标记为存活。只有当标记工作完成后，清理工作才会开始。不足：1.效率问题。标记和清理效率都不高，但是当知道只有少量垃圾产生时会很高效2.空间问题。会产生不连续的内存空间碎片**相关代码**&#96;&#96;&#96;创建一个更大的数组来替换当前的数组 </code></pre></blockquote><pre><code class="hljs java"><span class="hljs-comment">/***</span><span class="hljs-comment"> * 数组扩容</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> oldArray  oldArray</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> newArray  newArray</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] expansione (<span class="hljs-keyword">int</span>[] oldArray, <span class="hljs-keyword">int</span>[] newArray) <span class="hljs-keyword">throws</span> Exception &#123;    <span class="hljs-keyword">if</span> (oldArray.length &gt; newArray.length) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"oldArray is more than newArray"</span>);    &#125;    <span class="hljs-comment">// method one</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; oldArray.length; i++) &#123;        newArray[i] = oldArray[i];    &#125;    <span class="hljs-comment">// JDK Method</span>    <span class="hljs-comment">// System.arraycopy(oldArray, 0, newArray, 0, oldArray.length);</span>    <span class="hljs-keyword">return</span> newArray;&#125;</code></pre> <pre><code class="hljs 在数组位置index上添加元素e">&#96;&#96;&#96;java&#x2F;*** * 指定位置添加某一元素 * @param array  数组 * @param index  索引位置 * @param num    num元素 *&#x2F;private static void addElement (int[] array, int index, int num) throws Exception &#123;    if (index &gt;&#x3D; array.length) &#123;        throw new Exception(&quot;index value is more than array length&quot;);    &#125;    &#x2F;&#x2F; 针对最后一位直接处理    if (index &#x3D;&#x3D; array.length - 1) &#123;        array[index] &#x3D; num;        return;    &#125;    for (int i &#x3D; index; i &lt; array.length; i++) &#123;        array[index + 1] &#x3D; array[index];    &#125;    array[index] &#x3D; num;&#125;</code></pre><pre><code class="hljs 常见算法：二分法```">&#96;&#96;&#96;java&#x2F;** * 二分法查找 | 要求为有序数组 * @param array  数组 * @param num    元素 *&#x2F;private static boolean search (int[] array, int num) &#123;    if (array.length &#x3D;&#x3D; 0) &#123;        return false;    &#125;    int left  &#x3D; 0;    int right &#x3D; array.length - 1;    while (left &lt;&#x3D; right) &#123;        int mid &#x3D; (left + right) &#x2F; 2;        if (array[mid] &#x3D;&#x3D; num) &#123;            return true;        &#125; else if (array[mid] &gt; num) &#123;            right &#x3D; mid;        &#125; else &#123;            &#x2F;&#x2F; 因为mid 肯定不是，因此可以多 + 1            left &#x3D; mid + 1;        &#125;    &#125;    return false;&#125;</code></pre><pre><code class="hljs 常见问题：找数问题">&gt; 1001数求和 减去 1000数求和即得到答案&#96;&#96;&#96;常见问题：数组逆置</code></pre><pre><code class="hljs java"><span class="hljs-comment">/***</span><span class="hljs-comment"> * 数组逆置</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> array array</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>[] array)</span> </span>&#123;    <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> end   = array.length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> temp  = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (start &lt; end) &#123;        temp         = array[start];        array[start] = array[end];        array[end]   = temp;        start++;        end--;    &#125;&#125;</code></pre><pre><code class="hljs 常见问题：两数求和```">&#96;&#96;&#96;java&#x2F;*** * 两数求和 LeeCode Q1 * 给定一个整数数组和一个目标值，找出数组中和为目标值的两个数 * 你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用 *&#x2F;private static int[] twoNumSum(int[] array, int target) &#123;    Map&lt;Integer, Integer&gt; map &#x3D; new HashMap&lt;&gt;(array.length);    for (int i &#x3D; 0; i &lt; array.length; i++) &#123;        int num &#x3D; target - array[i];        if (map.containsKey(num)) &#123;            return new int[] &#123;map.get(num), i&#125;;        &#125;        map.put(array[i], i);    &#125;    return null;&#125;</code></pre><pre><code class="hljs JDK">&#96;&#96;&#96;java&#x2F;&#x2F; Arrays.binarySearch  二分查找&#x2F;&#x2F; Arrays.equals        判断两个数组是否相同 (值)&#x2F;&#x2F; Arrays.toString()    按特定格式打印数组&#x2F;&#x2F; Arrays.fill()        数据填充 (循环赋值)&#x2F;&#x2F; Arrays.sort()        排序&#x2F;&#x2F; System.arraycopy(oldArray, 0, newArray, 0, oldArray.length);   从旧数组某处复制到新数组某处开始&#x2F;&#x2F; Arrays.copyOf()      数组拷贝 -&gt; 拷贝指定length的长度数组&#x2F;&#x2F; Arrays.asList()      数组转化为集合&#x2F;&#x2F; Arrays.hashCode()    获取数据的hashcode</code></pre><h3 id="1-2-链表"><a href="#1-2-链表" class="headerlink" title="1.2 链表"></a>1.2 链表</h3><blockquote><p>概念：链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的链表由一系列节点组成，这些节点不必在内存中相连</p><p>PS：数组需要内存连续，如果一个数组构建需要100M，剩下的空间大于100M但是不连续，仍然会申请失败，而链表则不同，内存不需要连续</p><p>每个节点由数据部分Data和链部分Next，Next指向下一个节点，这样当添加或者删除时，只需要改变相关节点的Next的指向，效率很高 O(1)，遍历则是O(n)</p></blockquote><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p><img src="/2023/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/1571130997512.png" srcset="/img/loading.gif" alt="1571130997512"></p><h4 id="循环链表-（特殊的单链表）"><a href="#循环链表-（特殊的单链表）" class="headerlink" title="循环链表 （特殊的单链表）"></a>循环链表 （特殊的单链表）</h4><p><img src="/2023/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/1571131035351.png" srcset="/img/loading.gif" alt="1571131035351"></p><h4 id="双向链表-（如-LinkedHashMap）"><a href="#双向链表-（如-LinkedHashMap）" class="headerlink" title="双向链表 （如 LinkedHashMap）"></a>双向链表 （如 LinkedHashMap）</h4><p><img src="/2023/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/1571131079625.png" srcset="/img/loading.gif" alt="1571131079625"></p><blockquote><p>真实使用场景：双向链表更多</p><p>为什么？ 因此双向链表支持向前，向后遍历，在很多场景比单链表更灵活</p><p>平均下来所耗时间比单链表少一半 （用空间换时间的思想）</p></blockquote><pre><code class="hljs 常用链表代码：LRU缓存淘汰算法```">&#96;&#96;&#96;java&#x2F;** * ****************************** * author：      柯贤铭 * createTime:   2019&#x2F;10&#x2F;15 17:36 * description:  Linked LRU 单链表实现LRU算法 *               缓存淘汰算法 *               思路  如果此时缓存未满，则将此结点直接插入到链表的头部 *                     如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部 * version:      V1.0 * ****************************** *&#x2F;public class LinkedLRUApp &#123;    &#x2F;&#x2F; 头节点    private LinkedApp.LinkedNode head;    &#x2F;&#x2F; size    private int size;    &#x2F;&#x2F; 最大容量    private int maxSize;    &#x2F;**     * Demo 版本 以数组作为原始数据     *           缓存容量为数组的 2 倍     *&#x2F;    public LinkedLRUApp (int[] array) &#123;        LinkedApp.LinkedNode[] nodes &#x3D; new LinkedApp.LinkedNode[array.length];        for (int i &#x3D; 0; i &lt; nodes.length; i++) &#123;            LinkedApp.LinkedNode current &#x3D; new LinkedApp.LinkedNode();            current.setVal(array[i]);            nodes[i] &#x3D; current;        &#125;        &#x2F;&#x2F; 设置链表next        for (int i &#x3D; 0; i &lt; nodes.length; i++) &#123;            if (i &#x3D;&#x3D; nodes.length - 1)                break;            nodes[i].setNext(nodes[i + 1]);        &#125;        head &#x3D; nodes[0];        &#x2F;&#x2F; 设置size        size    &#x3D; array.length;        &#x2F;&#x2F; 最大容量为 2倍数组长度        maxSize &#x3D; size * 2;    &#125;    &#x2F;&#x2F; 获取容量    public int getSize () &#123;return size;&#125;    &#x2F;&#x2F; 打印缓存链表    public void printLinkedLRU () &#123;        System.out.println(head);    &#125;    &#x2F;***     * 添加缓存数据     * 如果此时缓存未满，则将此结点直接插入到链表的头部     * 如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部     *&#x2F;    public void addNum (int target) &#123;        LinkedApp.LinkedNode currentHead &#x3D; head;        head &#x3D; new LinkedApp.LinkedNode();        head.setVal(target);        head.setNext(currentHead);        &#x2F;&#x2F; 未满        if (size &lt; maxSize) &#123;            size++;            System.out.println(&quot;LRU :: 未满, 插入数据 &#x3D;&gt; &quot; + target);        &#125; else &#123;            LinkedApp.LinkedNode current &#x3D; head;            while (current.getNext() !&#x3D; null &amp;&amp; current.getNext().getNext() !&#x3D; null) &#123;                current &#x3D; current.getNext();            &#125;            current.setNext(null);            System.out.println(&quot;LRU :: 已满, 添加的数为: &quot; + target);        &#125;    &#125;        public static void main(String[] args)&#123;        int[] array &#x3D; &#123;4, 8, 6&#125;;        LinkedLRUApp linkedLRUApp &#x3D; new LinkedLRUApp(array);        linkedLRUApp.printLinkedLRU();        for (int i &#x3D; 0; i &lt; 10; i++) &#123;            int target &#x3D; (int) (Math.random() * 20);            linkedLRUApp.addNum(target);            linkedLRUApp.printLinkedLRU();        &#125;    &#125;    &#x2F;*protected static class LinkedNode &#123;        private int val;        private LinkedNode next;        public int getVal() &#123;            return val;        &#125;        public void setVal(int val) &#123;            this.val &#x3D; val;        &#125;        public LinkedNode getNext() &#123;            return next;        &#125;        public void setNext(LinkedNode next) &#123;            this.next &#x3D; next;        &#125;        @Override        public String toString() &#123;            return &quot;[&quot; + &quot;val: &quot; + val + &quot;] &#x3D;&#x3D;&#x3D;&gt; &quot; + next;        &#125;    &#125;*&#x2F;&#125;</code></pre><pre><code class="hljs 常用链表代码：去除头节点```">&#96;&#96;&#96;java&#x2F;*** * 链表去除头节点 *&#x2F;private static LinkedNode removeHeadNode (LinkedNode node) &#123;    if (node &#x3D;&#x3D; null || node.getNext() &#x3D;&#x3D; null) &#123;        return node;    &#125;    return node &#x3D; node.getNext();&#125;</code></pre><pre><code class="hljs 常用链表代码：链表反转```">&#96;&#96;&#96;java&#x2F;*** * LeeCode 206: * [val: 12] &#x3D;&#x3D;&#x3D;&gt; [val: 7] &#x3D;&#x3D;&#x3D;&gt; [val: 6] &#x3D;&#x3D;&#x3D;&gt; [val: 3] &#x3D;&#x3D;&#x3D;&gt; null * 即每次取出一个节点作为新的头, 利用变量存储，每次再取一个新的，然后设置之前存储的 &#x3D;&#x3D;&#x3D;&gt; * 12         7-&gt;6-&gt;3 * 7-&gt;12      6-&gt;3 * 6-&gt;7-&gt;12   3 * 结果：3-&gt;6-&gt;7-&gt;12 *&#x2F;private static void reverser (LinkedNode head) &#123;    LinkedNode prev &#x3D; null;    LinkedNode curr &#x3D; head;    while (curr !&#x3D; null) &#123;        LinkedNode next &#x3D; curr.getNext();        curr.setNext(prev);        prev &#x3D; curr;        curr &#x3D; next;    &#125;&#125;</code></pre><pre><code class="hljs 常用链表代码：判断是否包含环状链表```">&#96;&#96;&#96;java&#x2F;*** * LeeCode 141: 判断是否是环状链表 * 判断循环一周的方式是: p-&gt;next&#x3D;&#x3D;head-&gt;next *&#x2F;private static boolean hasCycle (LinkedNode head) &#123;    Map&lt;LinkedNode, LinkedNode&gt; map &#x3D; new HashMap&lt;&gt;();    while (head !&#x3D; null &amp;&amp; head.getNext() !&#x3D; null) &#123;        if (map.containsKey(head)) &#123;            return true;        &#125; else &#123;            map.put(head, head);        &#125;        head &#x3D; head.getNext();    &#125;    return false;&#125;</code></pre><pre><code class="hljs 常用链表代码：合并两个有序链表```">&#96;&#96;&#96;java&#x2F;*** * 哨兵节点 -&gt; 创建一个空值逻辑头节点, 简化实现难度 * LeeCode 21: 合并两个有序链表 * 把两个有序链表合并成一个 *&#x2F;private static LinkedNode mergeTwoLists(LinkedNode l1, LinkedNode l2) &#123;    System.out.println(&quot;*******************************************&quot;);    System.out.println(&quot;L1: -&gt; &quot; + l1);    System.out.println(&quot;L2: -&gt; &quot; + l2);    LinkedNode result  &#x3D; new LinkedNode();    LinkedNode current &#x3D; result;    while (l1 !&#x3D; null &amp;&amp; l2 !&#x3D; null) &#123;        if (l1.val &lt; l2.val) &#123;            current.next &#x3D; l1;            current &#x3D; current.next;            l1 &#x3D; l1.next;        &#125; else &#123;            current.next &#x3D; l2;            current &#x3D; current.next;            l2 &#x3D; l2.next;        &#125;    &#125;    &#x2F;&#x2F; 拼接剩下的链表    current.next &#x3D; (l1 !&#x3D; null ? l1 : l2);    return result.next;&#125;</code></pre><pre><code class="hljs 常用链表代码：删除链表的倒数第N个节点```">&#96;&#96;&#96;java&#x2F;*** * LeeCode 19: 删除链表的倒数第N个节点 * 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点 * * 示例： * 给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n &#x3D; 2. * 当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. *&#x2F;private static LinkedNode removeNthFromEnd(LinkedNode head, int n) &#123;    System.out.println(&quot;*****************************************&quot;);    System.out.println(&quot;原结点Node: &quot; + head);    &#x2F;&#x2F; 一次遍历获取长度    LinkedNode current &#x3D; head;    int length &#x3D; 0;    while (current !&#x3D; null) &#123;        current &#x3D; current.next;        length++;    &#125;    &#x2F;&#x2F; 利用哨兵解决边界情况    LinkedNode dummy &#x3D; new LinkedNode();    dummy.next &#x3D; head;    &#x2F;&#x2F; 二次遍历确定 需要删除的前一个节点的位置    LinkedNode linkedNode &#x3D; dummy;    length &#x3D; length - n;    while (length &gt; 0) &#123;        linkedNode &#x3D; linkedNode.next;        length--;    &#125;    &#x2F;&#x2F; 删除节点    linkedNode.next &#x3D; linkedNode.next.next;    return dummy.next;&#125;</code></pre><pre><code class="hljs 常用链表代码：链表的中间结点```">&#96;&#96;&#96;java&#x2F;*** * LeeCode 876: 链表的中间结点 | 利用哨兵解决边界情况 * 给定一个带有头结点 head 的非空单链表，返回链表的中间结点 * 如果有两个中间结点，则返回第二个中间结点 *&#x2F;private static LinkedNode middleNode(LinkedNode head) &#123;    System.out.println(&quot;*****************************************&quot;);    System.out.println(&quot;原结点Node: &quot; + head);    &#x2F;&#x2F; 一次遍历获取长度    LinkedNode current &#x3D; head;    int length &#x3D; 0;    while (current !&#x3D; null) &#123;        current &#x3D; current.next;        length++;    &#125;    &#x2F;&#x2F; 利用哨兵解决边界情况    LinkedNode dummy &#x3D; new LinkedNode();    dummy.next &#x3D; head;    &#x2F;&#x2F; 中间节点规则 | 根据题意无论奇偶都是该规则    LinkedNode linkedNode &#x3D; dummy;    int middleIndex &#x3D; length &#x2F; 2 + 1;    int index &#x3D; 0;    &#x2F;&#x2F; 把结点处理到中间结点位置    while (index &lt; middleIndex) &#123;        linkedNode &#x3D; linkedNode.next;        index++;    &#125;    return linkedNode;&#125;</code></pre><pre><code class="hljs 常用链表代码：两两交换链表中的元素（递归法）```"></code></pre><p>题目：给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<br>     你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。<br>示例：输入1-&gt;2-&gt;3-&gt;4<br>     输出2-&gt;1-&gt;4-&gt;3</p><p>public class ListNode {<br>    int val;<br>    ListNode list;<br>    ListNode(int x) { val = x; }<br>}<br>public ListNode swapPairs(ListNode head) {<br>        //1.递归结束的条件：当链表为空时或链表只剩一个元素<br>        if(head == null || head.next == null){<br>            return head;<br>        }<br>       //3.本次递归的任务是交换三个节点中前两个节点的位置<br>       //交换三个节点的位置：head - next - swapPairs(n.next) -&gt; next - head-swapPairs(n.next)<br>        ListNode n = head.next;<br>        head.next = swapPairs(n.next);<br>        n.next = head;<br>        //2.需要返回给上一级的内容<br>        return n;<br>    }</p><p>递归三要素：<br>1.结束递归的条件？<br>2.需要返回给上一级的内容？<br>3.本次递归的任务是什么？</p><pre><code class="hljs">### 1.3 应用场景对比</code></pre><p>数组：优点.查找数据的时候效率比较高；<br>     缺点.在改变数据个数时，增加、插入、删除数据效率比较低<br>         所需要的内容空间是连续的，容易造成out of memory<br>应用场景<br>    1.数据比较少；<br>    2.经常做的运算是按序号访问数据元素；<br>    3.数组更容易实现，任何高级语言都支持；<br>    4.构建的信息表较稳定；</p><p>链表：优点.动态申请内存空间，数据增加和删除以及插入比数组灵活；<br>         天然支持扩容；<br>     缺点.查找数据的时候效率比较低<br>应用场景<br>    1.对线性表的长度或者规模难以估计；<br>    2.插入删除操作效率较高； （但会导致频繁的内存申请和释放，容易造成内存碎片，Java语言的话容易频发GC）<br>    3.构建动态性比较强的线性表；</p><p>PS: CPU在从内存读取数据的时候，会先把读取到的数据加载到CPU的缓存中。而CPU每次从内存读取数据并不是只读取那个特定要访问的地址，而是读取一个数据块并保存到CPU缓存中，然后下次访问内存数据的时候就会先从CPU缓存开始查找，如果找到就不需要再从内存中取。这样就实现了比内存访问速度更快的机制，也就是CPU缓存存在的意义:为了弥补内存访问速度过慢与CPU执行速度快之间的差异而引入</p><p>对于数组来说，存储空间是连续的，所以在加载某个下标的时候可以把以后的几个下标元素也加载到CPU缓存这样执行速度会快于存储空间不连续的链表存储</p><pre><code class="hljs">## 二、堆、栈与队列### 2.1 栈（stack）&gt; 概念：它是一种运算受限的线性表,后进先出(LIFO)或者说先进后出(FILO)&gt;&gt;   1.LIFO(last in first out)意思是后进入的元素, 第一个弹出栈空间&gt;   2.其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底&gt;   3.向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素&gt;   4.从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素&gt;&gt; 举例&gt; 生活中：邮件、自助餐的托盘&gt; 程序中：函数调用栈```实现一个栈:  定义栈结构，实现入栈出栈操作</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">stack</span> </span>&#123;ArrayList&lt;Object&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-comment">// 入栈</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(Object o)</span></span>&#123;        list.add(o);    &#125;        <span class="hljs-comment">// 出栈</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;        Object o = list.get(list.size() - <span class="hljs-number">1</span>);        list.remove(o);        <span class="hljs-keyword">return</span> o;    &#125;        <span class="hljs-comment">//栈是否为空</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> list.isEmpty();    &#125;        <span class="hljs-comment">//栈大小</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> list.size();    &#125;        <span class="hljs-comment">//打印栈元素</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> String.valueOf(list);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">//创建一个栈</span>    Stack stack = <span class="hljs-keyword">new</span> Stack();    <span class="hljs-comment">//入栈</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">10</span>;i++)&#123;stack.push(i);    &#125;    <span class="hljs-comment">//出栈</span>    <span class="hljs-keyword">while</span>(!stack.isEmpty())&#123;System.out.println(<span class="hljs-string">"栈："</span> + stack.toString() + <span class="hljs-string">"\t栈大小为："</span> + stack.size() + <span class="hljs-string">"\t出栈元素为："</span> + stack.pop());&#125;&#125;</code></pre><pre><code class="hljs 实现一个栈:">&#96;&#96;&#96;java&#x2F;*** * LeeCode 20  判断有效的括号 * 巧用Map反向构建匹配关系, 利用栈去匹配是否一致 * s: []()&#123;&#125;]]] *&#x2F;private static boolean isValid(String str) &#123;    Map&lt;Character, Character&gt; map &#x3D; new HashMap&lt;&gt;();    map.put(&#39;&#125;&#39;, &#39;&#123;&#39;);    map.put(&#39;)&#39;, &#39;(&#39;);    map.put(&#39;]&#39;, &#39;[&#39;);    Stack&lt;Character&gt; stack &#x3D; new Stack&lt;&gt;();    for (int i &#x3D; 0; i &lt; str.length(); i++) &#123;        Character character &#x3D; str.charAt(i);        if (map.containsKey(character) &amp;&amp; !stack.empty()) &#123;            Character tep &#x3D; stack.pop();            if (map.get(character) !&#x3D; tep) &#123;                return false;            &#125;        &#125; else &#123;            stack.push(character);        &#125;    &#125;    return stack.empty();&#125;</code></pre><pre><code class="hljs 问：Java">内存中的堆栈和数据结构堆栈不是一个概念，JVM中的堆栈是实际存在的存储区域，数据结构中的堆栈是抽象的数据存储结构但是JVM栈确实运用了栈的数据结构 &#x3D;&#x3D;&#x3D;》**为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？**其实，我们不一定非要用栈来保存临时变量，只不过如果这个函数调用符合后进先出的特性，用栈这种数据结构来实现，是最顺理成章的选择。从调用函数进入被调用函数，对于数据来说，变化的是什么呢？是作用域。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。  #### 栈的应用场景</code></pre><p>1.子程序的调用：在跳往子程序前，会将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中<br>2.处理递归调用：和子程序的调用类似，只是出了存储下一个指令的地址外，也将参数、区域变量等数据存入堆栈中<br>3.逆序输出<br>4.表达式的转换[中缀表达式转后缀表达式]与求值<br>5.二叉树的遍历<br>6.图的深度优先(depth-first)搜索法<br>7.数制转换：通过求余法，每次将余数进栈，最后将所有余数出栈即可<br>8.括号匹配校验<br>9.迷宫求解<br>10.实现递归-汉诺塔</p><pre><code class="hljs">### 2.2 堆（heap）&gt; 概念：堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质&gt;  1.堆中某个节点的值总是不大于或不小于其父节点的值；&gt;  2.堆总是一棵完全二叉树&gt;&gt; &gt;&gt; 大顶堆：堆顶元素（即第一个元素）为最大项，&gt; 小顶堆：堆顶元素为最小项![1573396417450](数据结构篇/1573396417450.png)```堆的存储</code></pre><p>堆 -&gt; 完全二叉树 -&gt; 完全二叉树非常适用于数组存储</p><p><img src="/2023/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/4d349f57947df6590a2dd1364c3b0b1e.jpg" srcset="/img/loading.gif" alt="img"></p><h4 id="堆的插入"><a href="#堆的插入" class="headerlink" title="堆的插入"></a>堆的插入</h4><blockquote><p>往堆中插入一个元素后，我们需要继续满足堆的两个特性 需要调整堆，这个过程叫堆化</p><p>堆化实际上有两种，从下往上和从上往下</p><p><img src="/2023/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/e578654f930002a140ebcf72b11eb722-1573396645980.jpg" srcset="/img/loading.gif" alt="img"></p><pre><code class="hljs 堆化非常简单，就是顺着节点所在的路径，向上或者向下，对比，然后交换```">#### 删除堆顶元素为了避免数组空洞（不符合完全二叉树的定义）有一个巧妙的方式，即把数组最后一位移到堆顶，利用自上而下的方式进行交换（堆化）即可#### 堆的构建及堆排序&#96;&#96;&#96;java&#x2F;***    * 什么是堆:    * 堆的实质就是完全二叉树，因此适合用数组存储    *    * 特性：    * 每个节点的值都大于等于或者小于等于子树每个节点的值    * 因此称之为大顶堆和小顶堆    *    * 插入 -&gt; 堆化调整结构    * 方式一：从下往上，即对比数据，交换节点即可    * 方式二: 从上往下，从上至下的对比数据，交换节点即可    *    *    * 删除堆顶元素：    * 为了避免数组空洞（不符合完全二叉树的定义）    * 有一个巧妙的方式，即把数组最后一位移到堆顶，利用自上而下的方式进行交换（堆化）即可    *    * 建堆：    * 思路一: 我们可以假设堆中只包含一个数据，根据堆本身的特点，调用插入操作即可（从前往后处理数据）    *    * 思路二: 从后往前处理数据，每个数据都是从上往下堆化    *    * 堆排序:    * 建堆结束之后，数组中的数据已经是按照大顶堆的特性来组织的    * 数组中的第一个元素就是堆顶，也就是最大的元素    * 我们把它跟最后一个元素交换，那最大元素就放到了下标为 n 的位置    * 然后循环操作直到数据剩一即可实现排序    *&#x2F; </code></pre></blockquote><h4 id="堆的应用场景"><a href="#堆的应用场景" class="headerlink" title="堆的应用场景"></a>堆的应用场景</h4><blockquote><pre><code class="hljs 优先级队列```"> 在优先级队列中，数据的出队顺序不是先进先出，而是按照优先级来，优先级最高的，最先出队Q1：如何实现一个高性能定时器利用堆，可以很方便的实现（用数组的话需要遍历所有任务是否到达指定时间）关键点：利用小顶堆可以知道最小执行时间在哪里，然后程序可以多等待几秒再来执行，每次执行不用扫描全部数据&#96;&#96;&#96;利用堆求 Top K </code></pre><p>维护一个大小为K的小顶堆，顺序遍历数组，从数组中取出数据与堆顶元素比较。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理，继续遍历数组。这样等数组中的数据都遍历完之后，堆中的数据就是前 K 大数据了</p><pre><code class="hljs 利用堆求中位数```">对于静态不变的数据，进行排序即可，简单处理但是对于动态数据，利用堆方可更好的解决：我们需要维护两个堆，一个大顶堆，一个小顶堆，大顶堆存储前半部分数据，小顶堆存储后半部分数据，且小顶堆中的数据都大于大顶堆中的数据当插入数据的时候，根据大小插入到前半部分或者后半部分，同时主动通过移动堆顶元素，保持两个部分的平衡即可&#96;&#96;&#96;利用堆求百分之99响应时间 </code></pre><p>思路和中位数一致：</p><p>维护两个堆，一个大顶堆，一个小顶堆。假设当前总数据的个数是 n，大顶堆中保存 n * 99% 个数据，小顶堆中保存 n * 1% 个数据</p><p>大顶堆堆顶的数据就是我们要找的数据</p><pre><code class="hljs 真实问题：如何处理10亿关键字，求出TOP10```">求top多少一定需要使用堆这种数据结构，但是使用堆的前提是我们需要获得每个关键字的数量，因此可以对文件进行遍历，通过哈希表得到每个关键字的数量，然后通过堆进行求TOP10的操作但是如果限定内存只有1G呢，我们可以用分治的思路，通过对文件关键字进行哈希，然后对10取模，把文件分散到10个文件中，这样每个文件就是包含了若干个关键字的文件总集，然后利用哈希表扫描，存储关键字的重复次数得到最终的关键字-次数数据后，构建堆，即可轻松获取TOP的排名了启发：1. 真实问题的处理场景一定不能太过狭隘，使用单一数据结构，不现实2. 哈希表的成功性，通用性3. 不可一叶障目，比如得到TOP10的堆之后，如何获取排名呢？堆怎么获取排名呢？堆利用数组存储，10个长度而已直接利用排序即可，又或者取10次堆顶元素即可#### Java 关于堆的API&#96;&#96;&#96;javapublic static void main(String[] args)&#123;   &#x2F;&#x2F; 默认构建小顶堆   PriorityQueue&lt;Integer&gt; minHeap &#x3D; new PriorityQueue&lt;&gt;();   minHeap.offer(8);   minHeap.offer(5);   minHeap.offer(3);   minHeap.offer(4);   minHeap.offer(2);   while(!minHeap.isEmpty()) &#123;       &#x2F;&#x2F; poll取堆顶元素       System.out.println(minHeap.poll());   &#125;&#125; </code></pre></blockquote><h3 id="2-3-队列（queue）"><a href="#2-3-队列（queue）" class="headerlink" title="2.3 队列（queue）"></a>2.3 队列（queue）</h3><blockquote><p>概念：队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头</p></blockquote><pre><code class="hljs 实现简单队列类（链表队列）```">&#96;&#96;&#96;javapublic class MyQueue&lt;E&gt; &#123;    private LinkedList&lt;E&gt; list &#x3D; new LinkedList&lt;&gt;();    &#x2F;&#x2F; 入队    public void enqueue(E e) &#123;        list.addLast(e);    &#125;    &#x2F;&#x2F; 出队    public E dequeue() &#123;        return list.removeFirst();    &#125;&#125;</code></pre><pre><code class="hljs JDK普通队列">&#96;&#96;&#96;java&#x2F;&#x2F; ArrayDeque&#x2F;&#x2F; push -&gt; 添加元素在队首&#x2F;&#x2F; add  -&gt; 添加元素在队尾&#x2F;&#x2F; poll -&gt; 弹出第一个元素</code></pre><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><blockquote><p>队列的应用非常广泛，特别是一些具有某些额外特性的队列，比如循环队列、阻塞队列、并发队列。它们在很多偏底层的系统、框架、中间件的开发中，起着关键性的作用。比如高性能队列 Disruptor、Linux 环形缓存，都用到了循环并发队列；Java concurrent 并发包利用 ArrayBlockingQueue 来实现公平锁等。</p><p>关于如何实现无锁并发队列<br>可以使用 cas + 数组的方式实现</p><p>队列的其他应用<br>分布式消息队列，如 kafka 也是一种队列。 </p></blockquote><h4 id="简易队列实现"><a href="#简易队列实现" class="headerlink" title="简易队列实现"></a>简易队列实现</h4><blockquote><p>首先我们来看一下基于内存的队列<br>在java并发包中已经提供了BlockingQueue的实现;<br>比较常用的有ArrayBlockingQueue和LinkedBlockingQueue,前者是以数组的形式存储，后者是以Node节点的链表形式存储</p></blockquote><h5 id="JDK-阻塞队列"><a href="#JDK-阻塞队列" class="headerlink" title="JDK 阻塞队列"></a>JDK 阻塞队列</h5><table><thead><tr><th align="left">方法</th><th>说明</th></tr></thead><tbody><tr><td align="left">put()</td><td>往队列里插入元素,如果队列已满,则等待直到队列为空插入新元素,或线程被中断抛出异常</td></tr><tr><td align="left">offer()</td><td>往队列添加元素;队列已满返回false,队列未满则插入并返回true</td></tr><tr><td align="left">add()</td><td>对offer()方法的简单封装.如果队列已满,抛出异常</td></tr><tr><td align="left">remove()</td><td>直接删除队头元素</td></tr><tr><td align="left">peek()</td><td>直接取出队头元素,且不删除</td></tr><tr><td align="left">element()</td><td>对peek方法的简单封装,队头元素存在则取出且不删除,不存在抛出异常</td></tr><tr><td align="left">poll()</td><td>取出并删除队头元素,当队列为空,返回null</td></tr><tr><td align="left">take()</td><td>取出并删除队头元素,当队列为空,则等待直到队列有新元素可以取出,或线程被中断抛出异常</td></tr></tbody></table><p>offer()方法一般跟poll()方法相对应, put()方法一般跟take()方法相对应.日常开发过程中offer()与poll()方法用的相对比较频繁</p><pre><code class="hljs JDK">&#96;&#96;&#96;javapublic class UserTask &#123;        &#x2F;&#x2F;队列大小    private final int QUEUE_LENGTH &#x3D; 10000*10;        &#x2F;&#x2F;基于内存的阻塞队列    private BlockingQueue&lt;String&gt; queue &#x3D; new LinkedBlockingQueue&lt;String&gt;(QUEUE_LENGTH);        &#x2F;&#x2F;创建计划任务执行器    private ScheduledExecutorService es &#x3D; Executors.newScheduledThreadPool(1);       &#x2F;**     * 构造函数，执行execute方法     *&#x2F;    public UserTask() &#123;        execute();    &#125;           &#x2F;**     * 添加信息至队列中     * @param content     *&#x2F;     public void addQueue(String content) &#123;        queue.add(content);    &#125;           &#x2F;**     * 初始化执行     *&#x2F;     public void execute() &#123;        &#x2F;&#x2F; 每一分钟执行一次        es.scheduleWithFixedDelay(new Runnable()&#123;            public void run() &#123;                try &#123;                    String content &#x3D; queue.take();                    &#x2F;&#x2F; 处理队列中的信息...                    System.out.println(content);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;, 0, 1, TimeUnit.MINUTES);    &#125;&#125;</code></pre><h5 id="Redis-消息队列"><a href="#Redis-消息队列" class="headerlink" title="Redis 消息队列"></a>Redis 消息队列</h5><p>利用redis发布订阅模式即可</p><h5 id="基于数据库的队列"><a href="#基于数据库的队列" class="headerlink" title="基于数据库的队列"></a>基于数据库的队列</h5><p>数据库队列不建议使用，但最大的好处是整个流程都由自己设计和把握，且消息不存在丢失，重复的问题，适合小场景使用</p><h2 id="三、哈希，跳表，各种树"><a href="#三、哈希，跳表，各种树" class="headerlink" title="三、哈希，跳表，各种树"></a>三、哈希，跳表，各种树</h2><h3 id="3-1-跳表"><a href="#3-1-跳表" class="headerlink" title="3.1 跳表"></a>3.1 跳表</h3><blockquote><p>对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 O(n)</p><p>对链表建立一级“索引”，查找起来是不是就会更快一些呢？每两个结点提取一个结点到上一级，我们把抽出来的那一级叫作索引或索引层</p><p><img src="/2023/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/14753c824a5ee4a976ea799727adc78e-1571998941621.jpg" srcset="/img/loading.gif" alt="img"></p><p>多级索引效果：</p><p><img src="/2023/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/1572231378358.png" srcset="/img/loading.gif" alt="1572231378358"></p></blockquote><pre><code class="hljs 第">相比于红黑树，更趋于跳表实现，因为相对而言实现较为简单&#96;&#96;&#96;java&#x2F;** * ****************************** * author：      柯贤铭 * createTime:   2019&#x2F;10&#x2F;28 10:40 * description:  跳表 *               跳表中存储的是正整数，并且存储的是不重复的 * version:      V1.0 * ****************************** *&#x2F;public class SkipListApp &#123;    private static final float SKIPLIST_P &#x3D; 0.5f;    private static final int MAX_LEVEL &#x3D; 16;    private int levelCount &#x3D; 1;    private Node head &#x3D; new Node();  &#x2F;&#x2F; 带头链表    public Node find(int value) &#123;        Node p &#x3D; head;        for (int i &#x3D; levelCount - 1; i &gt;&#x3D; 0; --i) &#123;            while (p.forwards[i] !&#x3D; null &amp;&amp; p.forwards[i].data &lt; value) &#123;                p &#x3D; p.forwards[i];            &#125;        &#125;        if (p.forwards[0] !&#x3D; null &amp;&amp; p.forwards[0].data &#x3D;&#x3D; value) &#123;            return p.forwards[0];        &#125; else &#123;            return null;        &#125;    &#125;    public void insert(int value) &#123;        int level &#x3D; randomLevel();        Node newNode &#x3D; new Node();        newNode.data &#x3D; value;        newNode.maxLevel &#x3D; level;        Node update[] &#x3D; new Node[level];        for (int i &#x3D; 0; i &lt; level; ++i) &#123;            update[i] &#x3D; head;        &#125;        &#x2F;&#x2F; record every level largest value which smaller than insert value in update[]        Node p &#x3D; head;        for (int i &#x3D; level - 1; i &gt;&#x3D; 0; --i) &#123;            while (p.forwards[i] !&#x3D; null &amp;&amp; p.forwards[i].data &lt; value) &#123;                p &#x3D; p.forwards[i];            &#125;            update[i] &#x3D; p;&#x2F;&#x2F; use update save node in search path        &#125;        &#x2F;&#x2F; in search path node next node become new node forwords(next)        for (int i &#x3D; 0; i &lt; level; ++i) &#123;            newNode.forwards[i] &#x3D; update[i].forwards[i];            update[i].forwards[i] &#x3D; newNode;        &#125;        &#x2F;&#x2F; update node hight        if (levelCount &lt; level) levelCount &#x3D; level;    &#125;    public void delete(int value) &#123;        Node[] update &#x3D; new Node[levelCount];        Node p &#x3D; head;        for (int i &#x3D; levelCount - 1; i &gt;&#x3D; 0; --i) &#123;            while (p.forwards[i] !&#x3D; null &amp;&amp; p.forwards[i].data &lt; value) &#123;                p &#x3D; p.forwards[i];            &#125;            update[i] &#x3D; p;        &#125;        if (p.forwards[0] !&#x3D; null &amp;&amp; p.forwards[0].data &#x3D;&#x3D; value) &#123;            for (int i &#x3D; levelCount - 1; i &gt;&#x3D; 0; --i) &#123;                if (update[i].forwards[i] !&#x3D; null &amp;&amp; update[i].forwards[i].data &#x3D;&#x3D; value) &#123;                    update[i].forwards[i] &#x3D; update[i].forwards[i].forwards[i];                &#125;            &#125;        &#125;        while (levelCount&gt;1&amp;&amp;head.forwards[levelCount]&#x3D;&#x3D;null)&#123;            levelCount--;        &#125;    &#125;    &#x2F;&#x2F; 理论来讲，一级索引中元素个数应该占原始数据的 50%，二级索引中元素个数占 25%，三级索引12.5% ，一直到最顶层。    &#x2F;&#x2F; 因为这里每一层的晋升概率是 50%。对于每一个新插入的节点，都需要调用 randomLevel 生成一个合理的层数。    &#x2F;&#x2F; 该 randomLevel 方法会随机生成 1~MAX_LEVEL 之间的数，且 ：    &#x2F;&#x2F;        50%的概率返回 1    &#x2F;&#x2F;        25%的概率返回 2    &#x2F;&#x2F;      12.5%的概率返回 3 ...    private int randomLevel() &#123;        int level &#x3D; 1;        while (Math.random() &lt; SKIPLIST_P &amp;&amp; level &lt; MAX_LEVEL)            level +&#x3D; 1;        return level;    &#125;    public void printAll() &#123;        Node p &#x3D; head;        while (p.forwards[0] !&#x3D; null) &#123;            System.out.print(p.forwards[0] + &quot; &quot;);            p &#x3D; p.forwards[0];        &#125;        System.out.println();    &#125;    public class Node &#123;        private int data &#x3D; -1;        private Node forwards[] &#x3D; new Node[MAX_LEVEL];        private int maxLevel &#x3D; 0;        @Override        public String toString() &#123;            StringBuilder builder &#x3D; new StringBuilder();            builder.append(&quot;&#123; data: &quot;);            builder.append(data);            builder.append(&quot;; levels: &quot;);            builder.append(maxLevel);            builder.append(&quot; &#125;&quot;);            return builder.toString();        &#125;    &#125;&#125;</code></pre><h3 id="3-2-哈希表-（散列表）"><a href="#3-2-哈希表-（散列表）" class="headerlink" title="3.2  哈希表 （散列表）"></a>3.2  哈希表 （散列表）</h3><blockquote><p>散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表</p></blockquote><p>核心点：</p><ul><li>Key （键，关键字)</li><li>散列函数（Hash函数）</li><li>散列值（Hash值）</li><li>装载因子（散列表的装载因子=填入表中的元素个数/散列表的长度   —》 </li><li>装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降）</li></ul><h4 id="如何解决：散列冲突问题"><a href="#如何解决：散列冲突问题" class="headerlink" title="如何解决：散列冲突问题"></a>如何解决：散列冲突问题</h4><pre><code class="hljs 开放寻址法```">&gt; 开放寻址法的核心思想是，如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入探测方法：线性探测![1572231952736](数据结构篇&#x2F;1572231952736.png)&gt; 插入 -&gt; 从所计算位置开始，如果位置已被占用则向下挪一位&gt;&gt; 查找 -&gt; 从所计算位置开始，判断key是否相同，不同则向下挪一位，为null则表示不存在&gt;&gt; 删除 -&gt; 由于查找的特殊性，因此不可直接标记为null，增加deleted标识，表示被删除&gt;&gt; 当散列表中插入的数据越来越多时，散列冲突发生的可能性就会越来越大，空闲位置会越来越少，线性探测的时间就会越来越久。极端情况下，我们可能需要探测整个散列表，所以最坏情况下的时间复杂度为 O(n)。同理，在删除和查找时，也有可能会线性探测整张散列表，才能找到要查找或者删除的数据其他方法：二次探测：步长就变成了原来的“二次方”， 即 hash(key) + ---&gt; 0 1 4 .... 扩大向下挪动的位置双重散列：即利用多个hash函数进行探测，如果A函数占用了，则用B...**优点：**1.散列表中的数据都存储在数组中，可以有效地利用 CPU 缓存加快查询速度2.序列化起来比较简单**缺点：**1.删除数据的时候比较麻烦2.在开放寻址法中，所有的数据都存储在一个数组中，比起链表法来说，冲突的代价更高3.为了保证减少冲突，因此装载因子较大，所以更加浪费空间**总结：**当数据量比较小、装载因子小的时候，适合采用开放寻址法这也是 Java 中的ThreadLocalMap使用开放寻址法解决散列冲突的原因&#96;&#96;&#96;链表法</code></pre><p>在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中</p><p><img src="/2023/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/1572233670824.png" srcset="/img/loading.gif" alt="1572233670824"></p><p><strong>总结：</strong></p><p>基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表</p><h4 id="到底什么是哈希算法"><a href="#到底什么是哈希算法" class="headerlink" title="到底什么是哈希算法"></a>到底什么是哈希算法</h4><blockquote><p>将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法</p><p> 而通过原始数据映射之后得到的二进制值串就是哈希值 </p><p>哈希算法要求：</p><ul><li>从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法；</li><li>对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同；</li><li>散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小；</li><li>哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值 </li></ul></blockquote><pre><code class="hljs 用途：```">-  应用一：安全加密  MD5 消息摘要算法，SHA 安全散列算法 -  应用二：唯一标识 文件服务器，文件唯一标识 （例如取文件开头和末尾指定大小的字节量，进行哈希，获取唯一标识）-   应用三：数据校验 例如基于P2P协议，BT文件下载（P2P协议是去中心化的协议，利用种子文件，从无数个服务器中找到所需要的超大文件的分片信息，然后从多个服务器进并行下载，以此实现分布式及去除单点压力），问题来临：从多个服务器下载，如何保证安全性，因为黑客也可以模拟自己的身份，替换所需文件，然后植入木马  ---&gt;  即可利用哈希摘要进行验证-   应用四：散列函数 散列函数中用到的散列算法，更加关注散列后的值是否能平均分布，也就是，一组数据是否能均匀地散列在各个槽中除此之外，散列函数执行的快慢，也会影响散列表的性能，所以，散列函数用的散列算法一般都比较简单，比较追求效率-  应用五：负载均衡 常用的负载均衡的策略如： 轮询、随机、加权轮询 ，但是结合哈希，在nginx中可以轻松实现 iphash通过哈希算法，对客户端 IP 地址或者会话 ID 计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器编号 -  应用六：数据分片 MapReduce思想，利用散列进行数据分治-  应用七：分布式存储 基于散列表，对数据进行映射分散到多个存储容器中（Redis），当设备需要扩容操作时候，可以借用一致性哈希算法，更优雅的解决散列表映射扩容的问题#### 题外:如何防范密码字典攻击&gt; 1. 最好的办法是禁止用户输入简单密码&gt; 2. 可以采用  salt  的方式，对称加密的思想，设定公司独有或者基于用户不可变的特征等等进行与密码的糅合，这样即使输入的是简单密码，密码的复杂度也大大增加&gt; 3. 采用更复杂的密码加密模式 （MD5加密已被中国女博士从操作层面破解，绕过验证）### 3.3 树 ![img](数据结构篇&#x2F;220043e683ea33b9912425ef759556ae.jpg) &gt;  &#96;&#96;&#96;父节点：&#96;&#96;&#96;A 节点就是 B 节点的父节点&gt;&gt; &#96;&#96;&#96;  子节点：&#96;&#96;&#96;B 节点是 A 节点的子节点&gt;&gt; &#96;&#96;&#96;兄弟节点：&#96;&#96;&#96;B，C，D节点&gt;&gt; &#96;&#96;&#96;根节点：&#96;&#96;&#96;E节点&gt;&gt; &#96;&#96;&#96;叶子节点 | 叶节点：&#96;&#96;&#96;G，H，I，J节点&gt;&gt; &#96;&#96;&#96;满二叉树：&#96;&#96;&#96; 叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点 &gt;&gt; &#96;&#96;&#96;完全二叉树：&#96;&#96;&#96;叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大 &gt;&gt; &gt;&gt; &#96;&#96;&#96;高度，深度，层</code></pre><blockquote><p> <img src="/2023/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/image-20191106163644849.png" srcset="/img/loading.gif" alt="image-20191106163644849"> </p></blockquote><h4 id="如何存储一棵二叉树"><a href="#如何存储一棵二叉树" class="headerlink" title="如何存储一棵二叉树"></a>如何存储一棵二叉树</h4><pre><code class="hljs 基于引用的二叉链式存储法```">![image-20191106165539011](数据结构篇&#x2F;image-20191106165539011.png)&#96;&#96;&#96; 基于数组的顺序存储法</code></pre><p><img src="/2023/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/image-20191106165658136.png" srcset="/img/loading.gif" alt="image-20191106165658136"></p><p>为什么二叉树需要把完全二叉树单独来讨论，因为如果一棵树是完全二叉树，则用数组存储是非常省内存的一种方式（因为不需要链表那样指针）</p><p>为什么完全二叉树一个定义是最后一行靠左（因为这样数组的长度可以去掉不存在的部分）</p><h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><ul><li>前序遍历：根左右</li><li>中序遍历：左根右</li><li>后序遍历：左右根 </li><li>层级遍历</li></ul><blockquote><p>题外问题： 给定一组数据，比如 1，3，5，6，9，10。你来算算，可以构建出多少种不同的二叉树 </p><p>由于树的其中一种存储方式即是数组，那么则该问题相当于数组内的元素有多少种组合方式 </p></blockquote><pre><code class="hljs 代码实践：打印一颗树及遍历```">&#96;&#96;&#96;java&#x2F;&#x2F; TreeNode 创建树的基类及打印一颗树public class TreeNode&#123;    public int val;    public TreeNode left;    public TreeNode right;    public TreeNode(int e)&#123; val &#x3D; e; &#125;    &#x2F;&#x2F; 用于获得树的层数    private static int getTreeDepth(TreeNode root) &#123;        return root &#x3D;&#x3D; null ? 0 : (1 + Math.max(getTreeDepth(root.left), getTreeDepth(root.right)));    &#125;    private static void writeArray(TreeNode currNode, int rowIndex, int columnIndex, String[][] res, int treeDepth) &#123;        &#x2F;&#x2F; 保证输入的树不为空        if (currNode &#x3D;&#x3D; null) return;        &#x2F;&#x2F; 先将当前节点保存到二维数组中        res[rowIndex][columnIndex] &#x3D; String.valueOf(currNode.val);        &#x2F;&#x2F; 计算当前位于树的第几层        int currLevel &#x3D; ((rowIndex + 1) &#x2F; 2);        &#x2F;&#x2F; 若到了最后一层，则返回        if (currLevel &#x3D;&#x3D; treeDepth) return;        &#x2F;&#x2F; 计算当前行到下一行，每个元素之间的间隔（下一行的列索引与当前元素的列索引之间的间隔）        int gap &#x3D; treeDepth - currLevel - 1;        &#x2F;&#x2F; 对左儿子进行判断，若有左儿子，则记录相应的&quot;&#x2F;&quot;与左儿子的值        if (currNode.left !&#x3D; null) &#123;            res[rowIndex + 1][columnIndex - gap] &#x3D; &quot;&#x2F;&quot;;            writeArray(currNode.left, rowIndex + 2, columnIndex - gap * 2, res, treeDepth);        &#125;        &#x2F;&#x2F; 对右儿子进行判断，若有右儿子，则记录相应的&quot;\&quot;与右儿子的值        if (currNode.right !&#x3D; null) &#123;            res[rowIndex + 1][columnIndex + gap] &#x3D; &quot;\\&quot;;            writeArray(currNode.right, rowIndex + 2, columnIndex + gap * 2, res, treeDepth);        &#125;    &#125;    public static void printTree (TreeNode root) &#123;        if (root &#x3D;&#x3D; null) System.out.println(&quot;EMPTY!&quot;);        &#x2F;&#x2F; 得到树的深度        int treeDepth &#x3D; getTreeDepth(root);        &#x2F;&#x2F; 最后一行的宽度为2的（n - 1）次方乘3，再加1        &#x2F;&#x2F; 作为整个二维数组的宽度        int arrayHeight &#x3D; treeDepth * 2 - 1;        int arrayWidth &#x3D; (2 &lt;&lt; (treeDepth - 2)) * 3 + 1;        &#x2F;&#x2F; 用一个字符串数组来存储每个位置应显示的元素        String[][] res &#x3D; new String[arrayHeight][arrayWidth];        &#x2F;&#x2F; 对数组进行初始化，默认为一个空格        for (int i &#x3D; 0; i &lt; arrayHeight; i ++) &#123;            for (int j &#x3D; 0; j &lt; arrayWidth; j ++) &#123;                res[i][j] &#x3D; &quot; &quot;;            &#125;        &#125;        &#x2F;&#x2F; 从根节点开始，递归处理整个树        writeArray(root, 0, arrayWidth&#x2F; 2, res, treeDepth);        &#x2F;&#x2F; 此时，已经将所有需要显示的元素储存到了二维数组中，将其拼接并打印即可        for (String[] line: res) &#123;            StringBuilder sb &#x3D; new StringBuilder();            for (int i &#x3D; 0; i &lt; line.length; i ++) &#123;                sb.append(line[i]);                if (line[i].length() &gt; 1 &amp;&amp; i &lt;&#x3D; line.length - 1) &#123;                    i +&#x3D; line[i].length() &gt; 4 ? 2: line[i].length() - 1;                &#125;            &#125;            System.out.println(sb.toString());        &#125;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">// 树的遍历</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TraversingTreeApp</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">8</span>);        TreeNode left = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">4</span>);        TreeNode leftChild = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">11</span>);        left.left = leftChild;        TreeNode right = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">6</span>);        root.left  = left;        root.right = right;        <span class="hljs-comment">// 打印树结构</span>        TreeNode.printTree(root);        System.out.println();        preorder(root);        System.out.println();        inorder(root);        System.out.println();        postorder(root);        System.out.println();        floorOrder(root);    &#125;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 前序遍历</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preorder</span><span class="hljs-params">(TreeNode root)</span></span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">return</span>;        System.out.print(root.val + <span class="hljs-string">" "</span>);        preorder(root.left);        preorder(root.right);    &#125;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 中序遍历</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode root)</span></span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">return</span>;        inorder(root.left);        System.out.print(root.val + <span class="hljs-string">" "</span>);        inorder(root.right);    &#125;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 后序遍历</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postorder</span><span class="hljs-params">(TreeNode root)</span></span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">return</span>;        inorder(root.left);        inorder(root.right);        System.out.print(root.val + <span class="hljs-string">" "</span>);    &#125;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 层次遍历</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">floorOrder</span> <span class="hljs-params">(TreeNode root)</span> </span>&#123;        ArrayDeque&lt;TreeNode&gt; deque = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();        deque.add(root);        <span class="hljs-keyword">while</span> (deque.size() &gt; <span class="hljs-number">0</span>) &#123;            TreeNode poll = deque.poll();            System.out.print(poll.val + <span class="hljs-string">" "</span>);            <span class="hljs-keyword">if</span> (poll.left != <span class="hljs-keyword">null</span>) &#123;                deque.add(poll.left);            &#125;            <span class="hljs-keyword">if</span> (poll.right != <span class="hljs-keyword">null</span>) &#123;                deque.add(poll.right);            &#125;        &#125;    &#125;&#125;</code></pre><h4 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h4><blockquote><p> 二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值 </p></blockquote><pre><code class="hljs 二叉查找树模型```">![img](数据结构篇&#x2F;96b3d86ed9b7c4f399e8357ceed0db2a.jpg)&#96;&#96;&#96;二叉查找树的简单实现</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySearchTree</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">8</span>);        TreeNode left = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">4</span>);        left.left = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">3</span>);        TreeNode right = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">12</span>);        root.left  = left;        root.right = right;        <span class="hljs-comment">// 打印树结构</span>        TreeNode.printTree(root);        <span class="hljs-comment">// 查找</span>        TreeNode.printTree( find(root, <span class="hljs-number">4</span>) );        <span class="hljs-comment">// 插入</span>        insert(root,<span class="hljs-number">10</span>);        TreeNode.printTree(root);    &#125;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 二叉查找树 根据value找值</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> TreeNode <span class="hljs-title">find</span> <span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> val)</span> </span>&#123;        TreeNode p = root;        <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (val &lt; p.val) p = p.left;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val &gt; p.val) p = p.right;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> p;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 插入数据</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> data)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;            root = <span class="hljs-keyword">new</span> TreeNode(data);            <span class="hljs-keyword">return</span>;        &#125;        TreeNode p = root;        <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (data &gt; p.val) &#123;                <span class="hljs-keyword">if</span> (p.right == <span class="hljs-keyword">null</span>) &#123;                    p.right = <span class="hljs-keyword">new</span> TreeNode(data);                    <span class="hljs-keyword">return</span>;                &#125;                p = p.right;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">if</span> (p.left == <span class="hljs-keyword">null</span>) &#123;                    p.left = <span class="hljs-keyword">new</span> TreeNode(data);                    <span class="hljs-keyword">return</span>;                &#125;                p = p.left;            &#125;        &#125;    &#125;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 删除数据</span><span class="hljs-comment">     * 第一种情况是，如果要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为 null</span><span class="hljs-comment">     * 第二种情况是，如果要删除的节点只有一个子节点（只有左子节点或者右子节点），我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以</span><span class="hljs-comment">     * 第三种情况是，如果要删除的节点有两个子节点，我们需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再删除掉这个最小节点</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> data)</span> </span>&#123;        TreeNode p = root;     <span class="hljs-comment">// p指向要删除的节点，初始化指向根节点</span>        TreeNode pp = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">// pp记录的是p的父节点</span>        <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span> &amp;&amp; p.val != data) &#123;            pp = p;            <span class="hljs-keyword">if</span> (data &gt; p.val) p = p.right;            <span class="hljs-keyword">else</span> p = p.left;        &#125;        <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 没有找到</span>        <span class="hljs-comment">// 要删除的节点有两个子节点</span>        <span class="hljs-keyword">if</span> (p.left != <span class="hljs-keyword">null</span> &amp;&amp; p.right != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 查找右子树中最小节点</span>            TreeNode minP = p.right;            TreeNode minPP = p; <span class="hljs-comment">// minPP表示minP的父节点</span>            <span class="hljs-keyword">while</span> (minP.left != <span class="hljs-keyword">null</span>) &#123;                minPP = minP;                minP = minP.left;            &#125;            p.val = minP.val; <span class="hljs-comment">// 将minP的数据替换到p中</span>            p = minP;         <span class="hljs-comment">// 下面就变成了删除minP了</span>            pp = minPP;        &#125;        <span class="hljs-comment">// 删除节点是叶子节点或者仅有一个子节点</span>        TreeNode child; <span class="hljs-comment">// p的子节点</span>        <span class="hljs-keyword">if</span> (p.left != <span class="hljs-keyword">null</span>) child = p.left;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p.right != <span class="hljs-keyword">null</span>) child = p.right;        <span class="hljs-keyword">else</span> child = <span class="hljs-keyword">null</span>;        <span class="hljs-comment">// 删除的是根节点</span>        <span class="hljs-keyword">if</span> (pp == <span class="hljs-keyword">null</span>) root = child;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pp.left == p) pp.left = child;        <span class="hljs-keyword">else</span> pp.right = child;    &#125;&#125;</code></pre><h4 id="红黑树（平衡二叉查找树）"><a href="#红黑树（平衡二叉查找树）" class="headerlink" title="红黑树（平衡二叉查找树）"></a>红黑树（平衡二叉查找树）</h4><blockquote><p>平衡二叉树的严格定义是这样的：二叉树中任意一个节点的左右子树的高度相差不能大于 1。从这个定义来看，完全二叉树、满二叉树其实都是平衡二叉树，但是非完全二叉树也有可能是平衡二叉树</p><p>发明平衡二叉查找树这类数据结构的初衷是，解决普通二叉查找树在频繁的插入、删除等动态更新的情况下，出现时间复杂度退化的问题</p><p>平衡二叉查找树中“平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些</p><p>红黑树是一种平衡二叉查找树。它是为了解决普通二叉查找树在数据更新的过程中，复杂度退化的问题而产生的。红黑树的高度近似 log2n，所以它是近似平衡，插入、删除、查找操作的时间复杂度都是 O(logn)</p><pre><code class="hljs 红黑树即不严格平衡二叉树```，主要核心要求如下：">- 根节点是黑色的；- 每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；- 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；- 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；&#96;&#96;&#96;java&#x2F;**** 红黑树的基础是二叉查找树:* @see BinarySearchTree** 红黑树的由来 -&gt; 树这种结构性能之高效就是因为其保证了树结构的特点，* 但是由于数据的修改和删除操作，会使得树结构的形状遭到破坏，比如* 二叉查找树一直插入比较小的值该怎么办呢? 整个树结构都退化成了链表，* 这就丧失了树结构的高效，因此需要有新的数据结构** 即平衡二叉树 -&gt;  即左右高度相差不为1，实质就是保证树的左右对称性，避免性能退化** 除了红黑树之外，还有很多如AVL树等等，但是红黑树实在兼容删除，更新等诸多操作时，* 节点调整最小，平均效率最高的一种非严格的平衡二叉树，因此红黑树的适用范围很广** 红黑树的要求：* - 根节点是黑色的；* - 每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；* - 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；* - 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；** 代码实现：略*&#x2F; </code></pre></blockquote><h4 id="Trie树（字典树）"><a href="#Trie树（字典树）" class="headerlink" title="Trie树（字典树）"></a>Trie树（字典树）</h4><blockquote><p> Trie 树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起 </p><p>应用：通过公共前缀，查出符合前缀要求的字符串</p><p><img src="/2023/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/image-20191126165545691.png" srcset="/img/loading.gif" alt="image-20191126165545691"></p></blockquote><p> Trie 树的构建过程：</p><p><img src="/2023/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/image-20191126165338413.png" srcset="/img/loading.gif" alt="image-20191126165338413"></p><p><img src="/2023/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/image-20191126165352555.png" srcset="/img/loading.gif" alt="image-20191126165352555"></p><h5 id="Java-Trie-类库"><a href="#Java-Trie-类库" class="headerlink" title="Java Trie 类库"></a>Java Trie 类库</h5><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 通用工具包 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-lang3<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrieApp</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        <span class="hljs-comment">// Double 权重</span>        PatriciaTrie&lt;Double&gt; t = <span class="hljs-keyword">new</span> PatriciaTrie&lt;&gt;();        t.put(<span class="hljs-string">"ronak"</span>  , <span class="hljs-number">100.0</span>);        t.put(<span class="hljs-string">"ronald"</span> , <span class="hljs-number">90.0</span>);        t.put(<span class="hljs-string">"rat"</span>    , <span class="hljs-number">50.0</span>);        t.put(<span class="hljs-string">"robert"</span> , <span class="hljs-number">200.0</span>);        t.put(<span class="hljs-string">"bat"</span>    , <span class="hljs-number">44.0</span>);        t.put(<span class="hljs-string">"batman"</span> , <span class="hljs-number">440.0</span>);        t.put(<span class="hljs-string">"张三"</span> , <span class="hljs-number">440.0</span>);        t.put(<span class="hljs-string">"张武"</span> , <span class="hljs-number">50.0</span>);        t.put(<span class="hljs-string">"李四"</span> , <span class="hljs-number">440.0</span>);        System.out.println(t.containsKey(<span class="hljs-string">"ronak"</span>));        <span class="hljs-comment">// 符合ro标准，权重最高者</span>        System.out.println(t.selectKey(<span class="hljs-string">"ro"</span>));        System.out.println(t.prefixMap(<span class="hljs-string">"r"</span>));        System.out.println(t.prefixMap(<span class="hljs-string">"ro"</span>));        System.out.println(t.prefixMap(<span class="hljs-string">"ron"</span>));        System.out.println(t.prefixMap(<span class="hljs-string">"张"</span>));        System.out.println(t.prefixMap(<span class="hljs-string">"李"</span>));    &#125;&#125;<span class="hljs-comment">// 控制台</span><span class="hljs-comment">// robert</span><span class="hljs-comment">// &#123;rat=50.0, robert=200.0, ronak=100.0, ronald=90.0&#125;</span><span class="hljs-comment">// &#123;robert=200.0, ronak=100.0, ronald=90.0&#125;</span><span class="hljs-comment">// &#123;ronak=100.0, ronald=90.0&#125;</span><span class="hljs-comment">// &#123;张三=440.0, 张武=50.0&#125;</span><span class="hljs-comment">// &#123;李四=440.0&#125;</span></code></pre><h3 id="3-6-B-Tree-B-Tree"><a href="#3-6-B-Tree-B-Tree" class="headerlink" title="3.6 B-Tree B+Tree"></a>3.6 B-Tree B+Tree</h3><pre><code class="hljs B-Tree">&gt;  B树事实上是一种平衡的多叉查找树，也就是说最多可以开m个叉（m&gt;&#x3D;2），我们称之为m阶b树 ![image-20191226172051621](数据结构篇&#x2F;image-20191226172051621.png)-  所有键值分布在整个树中-  任何关键字出现且只出现在一个节点中 -  搜索有可能在非叶子节点结束 -  在关键字全集内做一次查找，性能逼近二分查找算法 &gt;  B+树是B树的变体，也是一种多路平衡查找树，B+树的示意图为： ![image-20191226172504810](数据结构篇&#x2F;image-20191226172504810.png)-  所有关键字存储在叶子节点，非叶子节点不存储真正的data -  为所有叶子节点增加了一个链指针 ### 3.7 MySql索引为什么选择B+Tree#### 索引需要满足什么条件- 查找快，增删改尽量也快- 支持区域查找经过思考，仅支持区域查找这一条就让红黑树，哈希表等无法作为索引的数据结构，因此可供选择只有如跳表，但是跳表这种数据结构的诞生时间很晚，真正的抉择依然是改造现有的二叉查找树，即对子节点增加双向链表，让其支持区域查找#### 如何处理索引占用存储过大&gt;  比如，我们给一亿个数据构建二叉查找树索引，那索引中会包含大约 1 亿个节点，每个节点假设占用 16 个字节，那就需要大约 1GB 的内存空间 &gt;如果是十亿级别则是10G内存，这显然无法支持，因此需要利用时间换空间的思想，把数据存储到硬盘之中，以减少数据库对于内存的占用情况#### IO存储索引如何提高效率我们知道一次IO读取的耗时其实已经做出了很多的优化，因此无法在此处做特别的文章，因此只有一个办法，即尽可能的减少IO读取的次数以二叉查找树为例，我们以二叉查找树构建索引，IO的读取次数如何计算？![image-20191226175724120](数据结构篇&#x2F;image-20191226175724120.png)其实很容易想到，树的&#96;&#96;&#96;高度&#96;&#96;&#96;代表着IO交互的次数，也就是树的高度越低，那么IO次数越少，性能就越高#### 如何保证索引的高度和分叉的合理性 对于相同个数的数据构建 m 叉树索引，m 叉树中的 m 越大，那树的高度就越小，那 m 叉树中的 m 是不是越大越好呢？到底多大才最合适呢？&gt; 不管是内存中的数据，还是磁盘中的数据，操作系统都是按页（一页大小通常是 4KB，这个值可以通过 getconfig PAGE_SIZE 命令查看）来读取的，一次会读一页的数据。如果要读取的数据量超过一页的大小，就会触发多次 IO 操作。所以，我们在选择 m 大小的时候，要尽量让每个节点的大小等于一个页的大小。读取一个节点，只需要一次磁盘 IO 操作。 &#96;&#96;按页读取的意义：涉及到系统的数据的区域局部性原理&#96;&#96;&gt; - 1）刚刚被访问过的元素，极有可能在不久之后再次被访问到；&gt; - 2）将被访问的下一个元素，极有可能就处于之前被访问过的某个元素的附近；&gt;&gt; 因此即使可能只需要一页中的一点点数据，机器仍然会默认每次IO读取一页数据，以提高效率#### 如何保证索引节点存储为一页 对于一个 B+ 树来说，m 值是根据页的大小事先计算好的，也就是说，每个节点最多只能有 m 个子节点。在往数据库中写入数据的过程中，这样就有可能使索引中某些节点的子节点个数超过 m，这个节点的大小超过了一个页的大小，读取这样一个节点，就会导致多次磁盘 IO 操作。我们该如何解决这个问题呢？  只需要将这个节点分裂成两个节点。但是，节点分裂之后，其上层父节点的子节点个数就有可能超过 m 个。不过这也没关系，我们可以用同样的方法，将父节点也分裂成两个节点。这种级联反应会从下往上，一直影响到根节点![image-20191226180732441](数据结构篇&#x2F;image-20191226180732441.png)#### 索引到底是怎么存储工作的刚才讲到由于数据的增大，我们需要把节点进行分裂，那整个B树的源头在哪里呢？已知索引存储到硬盘之中，但也不可能完全放弃内存的使用，因此我们可以把头节点和第一层存储到内存之中，每次服务启动时加载至内存，关闭时保存至硬盘，然后剩余三层结构都保存在硬盘之中#### 终极问题：为什么选择B+TreeB 树实际上是低级版的 B+ 树，或者说 B+ 树是 B 树的改进版B 树跟 B+ 树的不同点主要集中在这几个地方：- B+ 树中的节点不存储数据，只是索引，而 B 树中的节点存储数据；- B 树中的叶子节点并不需要链表来串联因此选B树还是选B+树，其实讨论的意义不大## 四、图### 如何理解图&gt; 图中的元素我们就叫作顶点（vertex）&gt;&gt; 从图中可以看出来，图中的一个顶点可以与任意其他顶点建立连接关系。我们把这种建立的关系叫作边（edge）&gt;&gt; ![img](数据结构篇&#x2F;df85dc345a9726cab0338e68982fd1af.jpg)&gt;&gt; 度：跟顶点相连接的边的条数&gt;&gt; &gt;&gt; 如微博，QQ等在两个用户的之上还有复杂的如，互为好友，亲密度等信息，无非是在为点和点之间增加向量，同时增加权重，表示“亲密的”### 图的存储方式#### 邻接矩阵存储方法&gt; 邻接矩阵的底层依赖一个二维数组。对于无向图来说，如果顶点 i 与顶点 j 之间有边，我们就将 A[i][j] 和 A[j][i] 标记为 1；对于有向图来说，如果顶点 i 到顶点 j 之间，有一条箭头从顶点 i 指向顶点 j 的边，那我们就将 A[i][j] 标记为 1。同理，如果有一条箭头从顶点 j 指向顶点 i 的边，我们就将 A[j][i] 标记为 1。对于带权图，数组中就存储相应的权重![1573480157573](数据结构篇&#x2F;1573480157573.png)#### 邻接表存储方法![1573480277946](数据结构篇&#x2F;1573480277946.png)&gt; 针对链表的部分，还可以类似HashMap处理，当长度大于多少的时候转化为红黑树或者跳表#### ~~广度优先搜索算法~~![1573481231338](数据结构篇&#x2F;1573481231338.png)广度优先搜索算法即把数据点作为圆心，一层一层向外递进，即先查找离起始顶点最近的，然后是次近的，依次往外搜索#### ~~深度优先搜索算法~~&gt; 深度优先搜索用的是一种比较著名的算法思想，回溯思想。这种思想解决问题的过程，非常适合用递归来实现![1573482141433](数据结构篇&#x2F;1573482141433.png)### 图的拓扑排序&gt;  给定一幅有向图，将所有的顶点排序，使得所有的有向边均从排在前面的元素指向排在后面的元素 &gt;&gt; 应用：比如编译器编译类的时候，类加载顺序的问题#### 有向无环图 - 邻接表存储详解&#96;&#96;&#96;javapublic class GraphDirected &#123;    private int v;                      &#x2F;&#x2F; 顶点的个数    private LinkedList&lt;Integer&gt; adj[];  &#x2F;&#x2F; 邻接表    public GraphDirected(int v) &#123;        this.v &#x3D; v;        adj &#x3D; new LinkedList[v];        for (int i&#x3D;0; i&lt;v; ++i) &#123;            adj[i] &#x3D; new LinkedList&lt;&gt;();        &#125;    &#125;    &#x2F;&#x2F; s先于t，边s-&gt;t    public void addEdge(int s, int t) &#123;        adj[s].add(t);    &#125;    public static void main(String[] args)&#123;        GraphDirected directed &#x3D; new GraphDirected(6);        &#x2F;&#x2F; x-y 坐标，x表示顶点，y表示指向的顶点        directed.addEdge(1,3);        directed.addEdge(1,5);        directed.addEdge(2,5);        directed.addEdge(3,4);    &#125;&#125;</code></pre><pre><code class="hljs 针对上述代码绘制图```">![image-20191221104226773](数据结构篇&#x2F;image-20191221104226773.png)####  Kahn 算法 &gt;  定义数据结构的时候，如果 s 需要先于 t 执行，那就添加一条 s 指向 t 的边。所以，如果某个顶点入度为 0， 也就表示，没有任何顶点必须先于这个顶点执行，那么这个顶点就可以执行了。&gt;&gt; &gt;&gt; 我们先从图中，找出一个入度为 0 的顶点，将其输出到拓扑排序的结果序列中（对应代码中就是把它打印出来），并且把这个顶点从图中删除（也就是把这个顶点可达的顶点的入度都减 1）。我们循环执行上面的过程，直到所有的顶点都被输出。最后输出的序列，就是满足局部依赖关系的拓扑排序 &gt;&gt; &#96;&#96;&#96;用以输出有向无环图路径</code></pre><blockquote><pre><code class="hljs 用以检测是否存在循环依赖的情况```">**Kahn 算法，如果最后输出出来的顶点个数，少于图中顶点个数，图中还有入度不是 0 的顶点，那就说明，图中存在环** &#96;&#96;&#96;javapublic void topoSortByKahn() &#123;   int[] inDegree &#x3D; new int[v]; &#x2F;&#x2F; 统计每个顶点的入度   for (int i &#x3D; 0; i &lt; v; ++i) &#123;       for (int j &#x3D; 0; j &lt; adj[i].size(); ++j) &#123;           int w &#x3D; adj[i].get(j); &#x2F;&#x2F; i-&gt;w           inDegree[w]++;       &#125;   &#125;   LinkedList&lt;Integer&gt; queue &#x3D; new LinkedList&lt;&gt;();   for (int i &#x3D; 0; i &lt; v; ++i) &#123;       if (inDegree[i] &#x3D;&#x3D; 0) queue.add(i);   &#125;   while (!queue.isEmpty()) &#123;       int i &#x3D; queue.remove();       System.out.print(&quot;-&gt;&quot; + i);       for (int j &#x3D; 0; j &lt; adj[i].size(); ++j) &#123;           int k &#x3D; adj[i].get(j);           inDegree[k]--;           if (inDegree[k] &#x3D;&#x3D; 0) queue.add(k);       &#125;   &#125;&#125; </code></pre></blockquote><h4 id="DFS-算法"><a href="#DFS-算法" class="headerlink" title="DFS 算法"></a>DFS 算法</h4><blockquote><p> 深度优先遍历，遍历图中的所有顶点，而非只是搜索一个顶点到另一个顶点的路径 </p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">topoSortByDFS</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 先构建逆邻接表，边s-&gt;t表示，s依赖于t，t先于s</span>  LinkedList&lt;Integer&gt; inverseAdj[] = <span class="hljs-keyword">new</span> LinkedList[v];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v; ++i) &#123; <span class="hljs-comment">// 申请空间</span>    inverseAdj[i] = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v; ++i) &#123; <span class="hljs-comment">// 通过邻接表生成逆邻接表</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; adj[i].size(); ++j) &#123;      <span class="hljs-keyword">int</span> w = adj[i].get(j); <span class="hljs-comment">// i-&gt;w</span>      inverseAdj[w].add(i); <span class="hljs-comment">// w-&gt;i</span>    &#125;  &#125;  <span class="hljs-keyword">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[v];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v; ++i) &#123; <span class="hljs-comment">// 深度优先遍历图</span>    <span class="hljs-keyword">if</span> (visited[i] == <span class="hljs-keyword">false</span>) &#123;      visited[i] = <span class="hljs-keyword">true</span>;      dfs(i, inverseAdj, visited);    &#125;  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">int</span> vertex, LinkedList&lt;Integer&gt; inverseAdj[], <span class="hljs-keyword">boolean</span>[] visited)</span> </span>&#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; inverseAdj[vertex].size(); ++i) &#123;    <span class="hljs-keyword">int</span> w = inverseAdj[vertex].get(i);    <span class="hljs-keyword">if</span> (visited[w] == <span class="hljs-keyword">true</span>) <span class="hljs-keyword">continue</span>;    visited[w] = <span class="hljs-keyword">true</span>;    dfs(w, inverseAdj, visited);  &#125; <span class="hljs-comment">// 先把vertex这个顶点可达的所有顶点都打印出来之后，再打印它自己</span>  System.out.print(<span class="hljs-string">"-&gt;"</span> + vertex);&#125;</code></pre><h3 id="地图查找-最短路径算法"><a href="#地图查找-最短路径算法" class="headerlink" title="地图查找-最短路径算法"></a>地图查找-最短路径算法</h3><blockquote><p>图的相关内容更多是了解，能够建立模型，具体的算法内容不作了解</p><p>在处理地图最短路径寻路问题中，我们就应该想到如何把现实世界的模型进行抽象，转化为指定的数据结构</p><p><code>我们在分析的时候可以明确考虑到地图可以转化为图，但是顶点如何规划，是否有向，是否有权值</code><br>          —&gt;   最终经过思考可以构建成有向加权图，把每一个路口作为顶点并增加权值（权值表示路的长度，红绿灯，当前车况，收费站个数等等）</p><p>最后我们便得到了地图如何寻找最短路径的答案</p><p>​          —&gt;   可以用广度遍历搜索出最短路径(无权值要求情况)<br>​          —&gt;   更专业适合算法是：Dijkstra算法，A*算法（去除明显相反方向的路径探索）</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据结构及算法篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot代码生成器</title>
    <link href="/2023/09/12/SpringBoot%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <url>/2023/09/12/SpringBoot%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Code-Generate-代码生成器"><a href="#Code-Generate-代码生成器" class="headerlink" title="Code-Generate 代码生成器"></a><a href="https://github.com/kkzhilu/Code-Generate" target="_blank" rel="noopener">Code-Generate</a> 代码生成器</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p> 🚀  Code-Generate是一个基于原生Mysql &amp; SpringBoot &amp; Mybatis 的代码生成器，建表之后即可完全解放双手，1秒钟构建CRUD接口以及漂亮的LayUi前端界面，同时支持<code>在不改动任何老代码的情况下拓展新的模板</code>，适合：</p><ul><li>规律性定制化开发</li><li>解放劳动力，一键完成固有代码</li><li>原生mybatis.xml以及SpringBoot，简单Demo的学习利器</li><li>允许开发者继承接口实现自定义文件内容，阅读简单开源项目的首选</li><li>测试同学的测试Demo案例，1秒钟造一个，就说快不快</li><li>学生党快速交作业（咳咳咳，如果你是该类，一定要关注加点赞啊！）</li></ul><h2 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a>效果演示</h2><p><img src="/2023/09/12/SpringBoot%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/code-generate.gif" srcset="/img/loading.gif" alt></p><p>步骤说明：</p><ol><li>自行建立数据库及需要映射的数据表</li><li>打开Code-Generate，进行基础的配置，如项目名，作者名，输出地址，应用哪些模板等等</li><li>运行App.java核心类，即得到了最终的项目</li><li>运行生成的项目即可</li></ol><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><p>该项目为普通Java项目，依赖的环境有：</p><ul><li>JDK</li><li>MySQL</li><li>Maven</li><li>Lombok插件</li></ul><table><thead><tr><th align="center">可配置项</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">ip</td><td align="center">IP地址</td></tr><tr><td align="center">port</td><td align="center">端口号</td></tr><tr><td align="center">driver</td><td align="center">驱动</td></tr><tr><td align="center">dataBase</td><td align="center">数据库</td></tr><tr><td align="center">encoding</td><td align="center">编码</td></tr><tr><td align="center">loginName</td><td align="center">数据库用户名</td></tr><tr><td align="center">passWord</td><td align="center">数据库密码</td></tr><tr><td align="center">include</td><td align="center">包括哪些表，默认*; 全部</td></tr><tr><td align="center">projectName</td><td align="center">项目名称</td></tr><tr><td align="center">packageName</td><td align="center">自定义包名</td></tr><tr><td align="center">authorName</td><td align="center">作者名称（用作注释）</td></tr><tr><td align="center">rootPath</td><td align="center">输出路径</td></tr><tr><td align="center">customHandleInclude</td><td align="center">自定义模板，默认*;全部</td></tr></tbody></table><pre><code class="hljs Main方法">&#96;&#96;&#96;javapublic class App &#123;    &#x2F;***     * 执行 - 构建项目     *&#x2F;    public static void main(String[] args)&#123;        AbstractEngine engine &#x3D; AbstractEngine.init();        engine.execute();    &#125;&#125;</code></pre><blockquote><p>生成的结果是一个Maven项目，直接用IDE打开即可</p></blockquote><h2 id="现有模块"><a href="#现有模块" class="headerlink" title="现有模块"></a>现有模块</h2><ul><li>基础的接口访问</li><li>基于MD的数据库字段文档</li><li>基于LayUi的前端展示模块</li></ul><p>如下图所示：</p><p><strong>接口访问</strong></p><p><img src="/2023/09/12/SpringBoot%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/image-20200505000913778.png" srcset="/img/loading.gif" alt="image-20200505000913778"></p><p><strong>MD的数据库字段文档</strong></p><p><img src="/2023/09/12/SpringBoot%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/image-20200505001007953.png" srcset="/img/loading.gif" alt="image-20200505001007953"></p><p><strong>LayUi的前端展示模块</strong></p><p><img src="/2023/09/12/SpringBoot%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/image-20200505001023936.png" srcset="/img/loading.gif" alt="image-20200505001023936"></p><h2 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h2><p><code>本项目主要的核心即两个通过mysql内置的表字段查询配合FreeMaker模板，构建具有一定规律性，通用的代码内容</code></p><ul><li>FreeMaker  DefaultEngine.java process方法</li><li>mybatis 原生XML，包含增，批量增，删，批量删，多条件分页查询，列表查询，单一查询，单一数据修改等</li><li>logback日志</li><li>SpringBoot</li><li>拔插式拦截器（基于org.reflections实现），支持扫描指定接口</li></ul><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><h3 id="GNU-General-Public-License-v3-0"><a href="#GNU-General-Public-License-v3-0" class="headerlink" title="GNU General Public License v3.0"></a>GNU General Public License v3.0</h3><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>该项目是从无到有一点点构建出来的，适合初学者和刚入门的人进行学习，更加适合大佬们直接快速构建简单Demo，把时间花在更有价值的事情上，欢迎各位Star &amp; Fork.</p><p>点我：<a href="https://github.com/kkzhilu/Code-Generate/tree/master" target="_blank" rel="noopener">GitHub地址</a></p><p><img src="/2023/09/12/SpringBoot%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/%E5%BE%AE%E4%BF%A1%E4%BA%8C%E7%BB%B4%E7%A0%81.png" srcset="/img/loading.gif" alt="微信二维码"></p>]]></content>
    
    
    <categories>
      
      <category>开源篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot代码生成器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JRebel篇</title>
    <link href="/2023/09/12/JRebel%E7%AF%87/"/>
    <url>/2023/09/12/JRebel%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="JRebel篇"><a href="#JRebel篇" class="headerlink" title="JRebel篇"></a>JRebel篇</h1><p>JRebel是一个非常厉害的热部署工具，可以大大的减少项目的重启次数，极大的节约开发者们的时间</p><p>IDEA插件：搜索<code>JRebel for IntelliJ</code></p><h2 id="破解方法"><a href="#破解方法" class="headerlink" title="破解方法"></a>破解方法</h2><ul><li>步骤1:生成一个GUID：<br><a href="https://www.guidgen.com/" target="_blank" rel="noopener">在线生成GUID地址</a></li><li>步骤2: 根据反向代理服务器地址拼接激活地址</li></ul><p>服务器地址： <a href="https://jrebel.qekang.com/{GUID}" target="_blank" rel="noopener">https://jrebel.qekang.com/{GUID}</a></p><p>PS：如果失效刷新GUID替换就可以！</p><ul><li>步骤3: 打开jrebel 激活面板 . 选择Connect to online licensing service .</li></ul><p><img src="/2023/09/12/JRebel%E7%AF%87/16d5c388273e8ea0" srcset="/img/loading.gif" alt="img"></p><p>最后点击Change license即可破解成功啦~</p>]]></content>
    
    
    <categories>
      
      <category>IDEA插件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JRebel篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HuTool篇</title>
    <link href="/2023/09/12/HuTool%E7%AF%87/"/>
    <url>/2023/09/12/HuTool%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="HuTool"><a href="#HuTool" class="headerlink" title="HuTool"></a>HuTool</h1><p>Hutool是一个小而全的Java工具类库，通过静态方法封装，降低相关API的学习成本，提高工作效率，使Java拥有函数式语言般的优雅，让Java语言也可以“甜甜的”。</p><p>Hutool中的工具方法来自于每个用户的精雕细琢，它涵盖了Java开发底层代码中的方方面面，它既是大型项目开发中解决小问题的利器，也是小型项目中的效率担当；</p><p>Hutool是项目中“util”包友好的替代，它节省了开发人员对项目中公用类和公用工具方法的封装时间，使开发专注于业务，同时可以最大限度的避免封装不完善带来的bug</p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.hutool<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hutool-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h2 id="HTTP模块"><a href="#HTTP模块" class="headerlink" title="HTTP模块"></a>HTTP模块</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 基于HuTool 多参考已有的工具类库，提高稳定性及效率</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 普通Get请求</span>        Map&lt;String, Object&gt; normalGetMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        normalGetMap.put(<span class="hljs-string">"type"</span>, <span class="hljs-string">"more"</span>);        normalGetMap.put(<span class="hljs-string">"category"</span>, <span class="hljs-string">"home"</span>);        normalGetMap.put(<span class="hljs-string">"shown_offset"</span>, <span class="hljs-string">"1593314417949658"</span>);        String normalGet = HttpUtil.get(<span class="hljs-string">"https://www.csdn.net/api/articles"</span>, normalGetMap);        System.out.println(normalGet);        <span class="hljs-comment">// 简单Get请求</span>        System.out.println(HttpUtil.get(<span class="hljs-string">"https://www.csdn.net/api/articles?type=more&amp;category=home&amp;shown_offset=1593314417949658"</span>));        <span class="hljs-comment">// Header型 Get请求</span>        String complexGet = HttpRequest.get(<span class="hljs-string">"https://kunpeng.csdn.net/ad/474"</span>)                .header(<span class="hljs-string">"k1"</span>, <span class="hljs-string">"v1"</span>).header(<span class="hljs-string">"k2"</span>, <span class="hljs-string">"v2"</span>).form(normalGetMap).execute().body();        <span class="hljs-comment">// 注意最终可获取 HttpResponse 对象</span>        HttpResponse httpResponse = HttpRequest.get(<span class="hljs-string">"https://kunpeng.csdn.net/ad/474"</span>)                .header(<span class="hljs-string">"k1"</span>, <span class="hljs-string">"v1"</span>).header(<span class="hljs-string">"k2"</span>, <span class="hljs-string">"v2"</span>).form(normalGetMap).execute();        <span class="hljs-comment">/**************************************** 分割线 ***********************************/</span>        <span class="hljs-comment">// 普通Post请求</span>        Map&lt;String, Object&gt; normalPostMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        normalPostMap.put(<span class="hljs-string">"coupon"</span>, <span class="hljs-keyword">true</span>);        String resultPost = HttpUtil.post(<span class="hljs-string">"https://msg.csdn.net/v1/web/message/view/unread"</span>, <span class="hljs-string">"&#123;\"coupon\":true&#125;"</span>);        String resultPostMap = HttpUtil.post(<span class="hljs-string">"https://msg.csdn.net/v1/web/message/view/unread"</span>, normalPostMap);        System.out.println(resultPost);        System.out.println(resultPostMap);        <span class="hljs-comment">// Header型 Post请求</span>        String response = HttpRequest.post(<span class="hljs-string">"https://msg.csdn.net/v1/web/message/view/unread"</span>)                .header(<span class="hljs-string">"cookie"</span>, <span class="hljs-string">"xxx"</span>).body(<span class="hljs-string">"&#123;\"coupon\":true&#125;"</span>).execute().body();        System.out.println(response);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>类库工具包</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HuTool篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>volatile和synchronized</title>
    <link href="/2023/09/12/volatile%E5%92%8Csynchronized/"/>
    <url>/2023/09/12/volatile%E5%92%8Csynchronized/</url>
    
    <content type="html"><![CDATA[<h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>volatile关键字是在一般面试中经常问到的一个点，大家对它的回答莫过于两点：</p><ul><li>保证内存可见性</li><li>防止指令重排</li></ul><p>那为了更有底气，那咱们就来深入看看吧</p><h3 id="JMM内存模型"><a href="#JMM内存模型" class="headerlink" title="JMM内存模型"></a>JMM内存模型</h3><p>咱们在聊volatile关键字的时候，首先需要了解JMM内存模型，它本身是一种抽象的概念并不真实存在，草图如下：</p><p><img src="/2023/09/12/volatile%E5%92%8Csynchronized/JMM.png" srcset="/img/loading.gif" alt="img"></p><p>JMM内存模型规定了线程的工作机理：<code>即所有的共享变量都存储在主内存，如果线程需要使用，则拿到主内存的副本，然后操作一番，再放到主内存里面去</code></p><p>这个可以引发一个思考，<strong>这是不是就是多线程并发情况下线程不安全的根源？</strong>假如所有线程都操作主内存的数据，是不是就不会有线程不安全的问题，随即引发下面的问题</p><h3 id="为什么需要JMM内存模型"><a href="#为什么需要JMM内存模型" class="headerlink" title="为什么需要JMM内存模型"></a>为什么需要JMM内存模型</h3><p>关于这个问题，我感觉过于硬核，我只能简单的想象<code>假如没有JMM，所有线程可以直接操作主内存的数据会怎么样</code></p><ul><li>上文说过，JMM模型并不是真实存在的，它只是一种规范，这种规范反而可以统一开发者的行为，如果没有规范，可能Java所提倡的一次编译，处处运行就凉凉了</li><li>另外我们都知道CPU 时间片轮转机制（就是在极短的时间切换进程，让用户无感知的享受多个进程运行的效果），线程在执行时候其实也是轮着来，假如A线程正在操作一个金钱数据，操作到一半，轮给B线程了，B线程把金额给改了，A线程最后又以错误的数据去入库等等，那问题不就大了去了？</li></ul><p>所以我想面对这样的场景，前辈们才模仿CPU解决缓存一致性的思路确定了JMM模型（能力不足，纯属猜测）</p><blockquote><p><em>在多处理器系统中，每个处理器都有自己的高速缓存，而他们又共享同一主存</em></p></blockquote><h3 id="volatile如何保证内存可见性"><a href="#volatile如何保证内存可见性" class="headerlink" title="volatile如何保证内存可见性"></a>volatile如何保证内存可见性</h3><p>我们来看一段代码：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VolatileTest</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> String key;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        key = <span class="hljs-string">"Happy Birthday To Me!"</span>;    &#125;&#125;</code></pre><p>通过对代码进行javap命令，获取其字节码，内容如下（可以忽略啦）：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">mine</span>.<span class="hljs-title">juc</span>.<span class="hljs-title">lock</span>.<span class="hljs-title">VolatileTest</span></span>  minor version: 0  major version: <span class="hljs-number">52</span>  flags: ACC_PUBLIC, ACC_SUPERConstant pool:   #1 = Methodref          #5.#21         // java/lang/Object."&lt;init&gt;":()V   #2 = String             #22            // Happy Birthday To Me!   #3 = Fieldref           #4.#23         // com/mine/juc/lock/VolatileTest.key:Ljava/lang/String;   #4 = Class              #24            // com/mine/juc/lock/VolatileTest   #5 = Class              #25            // java/lang/Object   #6 = Utf8               key   #7 = Utf8               Ljava/lang/String;   #8 = Utf8               &lt;init&gt;   #9 = Utf8               ()V  #10 = Utf8               Code  #11 = Utf8               LineNumberTable  #12 = Utf8               LocalVariableTable  #13 = Utf8               this  #14 = Utf8               Lcom/mine/juc/lock/VolatileTest;  #15 = Utf8               main  #16 = Utf8               ([Ljava/lang/String;)V  #17 = Utf8               args  #18 = Utf8               [Ljava/lang/String;  #19 = Utf8               SourceFile  #20 = Utf8               VolatileTest.java  #21 = NameAndType        #8:#9          // "&lt;init&gt;":()V  #22 = Utf8               Happy Birthday To Me!  #23 = NameAndType        #6:#7          // key:Ljava/lang/String;  #24 = Utf8               com/mine/juc/lock/VolatileTest  #25 = Utf8               java/lang/Object&#123;  <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> java.lang.String key;    descriptor: Ljava/lang/String;    flags: ACC_STATIC, ACC_VOLATILE  <span class="hljs-keyword">public</span> com.mine.juc.lock.VolatileTest();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span>         <span class="hljs-number">0</span>: aload_0         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V         <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span>      LineNumberTable:        line <span class="hljs-number">11</span>: <span class="hljs-number">0</span>      LocalVariableTable:        Start  Length  Slot  Name   Signature            <span class="hljs-number">0</span>       <span class="hljs-number">5</span>     <span class="hljs-number">0</span>  <span class="hljs-keyword">this</span>   Lcom/mine/juc/lock/VolatileTest;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;    descriptor: ([Ljava/lang/String;)V    flags: ACC_PUBLIC, ACC_STATIC    Code:      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span>         0: ldc           #2                  // String Happy Birthday To Me!         2: putstatic     #3                  // Field key:Ljava/lang/String;         <span class="hljs-number">5</span>: <span class="hljs-keyword">return</span>      LineNumberTable:        line <span class="hljs-number">16</span>: <span class="hljs-number">0</span>        line <span class="hljs-number">17</span>: <span class="hljs-number">5</span>      LocalVariableTable:        Start  Length  Slot  Name   Signature            <span class="hljs-number">0</span>       <span class="hljs-number">6</span>     <span class="hljs-number">0</span>  args   [Ljava/lang/String;&#125;SourceFile: <span class="hljs-string">"VolatileTest.java"</span></code></pre><p>请大家注意这一段代码：</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> java.lang.String key;    descriptor: Ljava/lang/String;    flags: ACC_STATIC, ACC_VOLATILE</code></pre><p>可以看到，volatile关键字在编译的时候会主动为变量增加标识：<code>ACC_VOLATILE</code>，再研究下去就过于硬核了（汇编指令），我可能硬不起来（手动狗头），以后我会再对它进行深入的研究，我们只用了解到，Java关键字volatile，是在编译阶段主动为变量增加了ACC_VOLATILE标识，以此保证了它的<code>内存可见性</code></p><p>即然volatile可以保证内存可见性，那至少有一个场景我们是可以放心使用的，即：<code>一写多读场景</code></p><p>另外，大家在验证volatile内存可见性的时候，不要使用 System.out.println() ，原因如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">println</span><span class="hljs-params">()</span> </span>&#123;    newLine();&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 是不是赫然看到一个synchronized，具体原因见下文</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">newLine</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;            ensureOpen();            textOut.newLine();            textOut.flushBuffer();            charOut.flushBuffer();            <span class="hljs-keyword">if</span> (autoFlush)                out.flush();        &#125;    &#125;    <span class="hljs-keyword">catch</span> (InterruptedIOException x) &#123;        Thread.currentThread().interrupt();    &#125;    <span class="hljs-keyword">catch</span> (IOException x) &#123;        trouble = <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre><h3 id="为什么会有指令重排"><a href="#为什么会有指令重排" class="headerlink" title="为什么会有指令重排"></a>为什么会有指令重排</h3><p>为了优化程序性能，编译器和处理器会对Java编译后的字节码和机器指令进行重排序，在单线程情况下不会影响结果，然而在多线程情况下，可能会出现莫名其妙的问题，案例见下文</p><h3 id="指令重排例子"><a href="#指令重排例子" class="headerlink" title="指令重排例子"></a>指令重排例子</h3><p><img src="/2023/09/12/volatile%E5%92%8Csynchronized/volatile.png" srcset="/img/loading.gif" alt="img"></p><p>运行这段代码我们可能会得到一个匪夷所思的结果:我们获得的单例对象是未初始化的。为什么会出现这种情况？因为<code>指令重排</code></p><p>首先要明确一点，同步代码块中的代码也是能够被指令重排的。然后来看问题的关键</p><pre><code class="hljs java">INSTANCE = <span class="hljs-keyword">new</span> Singleton();</code></pre><p>虽然在代码中只有一行,编译出的字节码指令可以用如下三行表示</p><ul><li>1.为对象分配内存空间</li><li>2.初始化对象</li><li>3.将INSTANCE变量指向刚分配的内存地址</li></ul><p>由于步骤2，3交换不会改变单线程环境下的执行结果，故而这种重排序是被允许的。也就是我们在初始化对象之前就把INSTANCE变量指向了该对象。而如果这时另一个线程刚好执行到代码所示的2处</p><pre><code class="hljs java"><span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>)</code></pre><p>那么这时候有意思的事情就发生了:虽然INSTANCE指向了一个未被初始化的对象，但是它确实不为null了，所以这个判断会返回false，之后它将return一个未被初始化的单例对象！</p><p>如下：</p><p><img src="/2023/09/12/volatile%E5%92%8Csynchronized/handle.png" srcset="/img/loading.gif" alt="img"></p><p>由于重排序是编译器和CPU自动进行的，如何禁止指令重排？</p><p>INSTANCE变量加个volatile关键字就行，这样编译器就会根据一定的规则禁止对volatile变量的读写操作重排序了。而编译出的字节码，也会在合适的地方插入内存屏障，比如volatile写操作之前和之后会分别插入一个StoreStore屏障和StoreLoad屏障，禁止CPU对指令的重排序越过这些屏障</p><h3 id><a href="#" class="headerlink" title></a></h3><h3 id="即然保证了内存可见，为什么还是线程不安全？"><a href="#即然保证了内存可见，为什么还是线程不安全？" class="headerlink" title="即然保证了内存可见，为什么还是线程不安全？"></a>即然保证了内存可见，为什么还是线程不安全？</h3><p>volatile 关键字虽然保证了内存可见，但是问题来了，见代码：</p><pre><code class="hljs java">index += <span class="hljs-number">1</span>;</code></pre><p>这短短一行代码在字节码级别其实分为了多个步骤进行，如获取变量，赋值，计算等等，如CPU基本执行原理一般，真正执行的是一个个命令，分为很多步骤</p><p>volatile 关键字可以保证的是单个读取操作是具有原子性的（每次读取都是从主内存获取最新的值）</p><p>但是如 index += 1;  实质是三个步骤，三次行为，因此它无法保证整块代码的原子性</p><h2 id="synchronize关键字"><a href="#synchronize关键字" class="headerlink" title="synchronize关键字"></a>synchronize关键字</h2><h3 id="驳斥关于类锁的概念"><a href="#驳斥关于类锁的概念" class="headerlink" title="驳斥关于类锁的概念"></a>驳斥关于类锁的概念</h3><p>首先驳斥一个关于类锁的概念，synchronize就是对象锁，在普通方法，静态方法，同步块时锁的对象分别是：</p><table><thead><tr><th>类型</th><th align="center">代码示例</th><th align="center">锁住的对象</th></tr></thead><tbody><tr><td>普通方法</td><td align="center">synchronized void test() { }</td><td align="center">当前对象</td></tr><tr><td>静态方法</td><td align="center">synchronized static void test() { }</td><td align="center">锁的是当前类的Class 对象</td></tr><tr><td>同步块</td><td align="center">void fun () {  synchronized (this) {} }</td><td align="center">锁的是（）中的对象</td></tr></tbody></table><p>大家都同意在同步代码块中，锁住的是括号里的对象，那么见以下代码：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">synchronized</span> (SynDemo<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;                    System.out.println(<span class="hljs-string">"真的有所谓的类锁？"</span>);                    <span class="hljs-keyword">try</span> &#123;                        Thread.sleep(<span class="hljs-number">3000</span>);                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;        &#125;).start();        Thread.sleep(<span class="hljs-number">500</span>);        answer();    &#125;    <span class="hljs-function"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">answer</span> <span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"答案清楚了吗"</span>);    &#125;&#125;<span class="hljs-comment">// 输出结果</span><span class="hljs-comment">// 真的有所谓的类锁？</span><span class="hljs-comment">// 间隔2秒多左右</span><span class="hljs-comment">// 答案清楚了吗</span></code></pre><p>所以实际上所谓的类锁，完全就是当前类的Class对象，所以不要被误导，synchronize就是对象锁</p><h3 id="synchronize实现原理"><a href="#synchronize实现原理" class="headerlink" title="synchronize实现原理"></a>synchronize实现原理</h3><p><code>JVM</code> 是通过进入、退出对象监视器(<code>Monitor</code> 来实现对方法、同步块的同步的</p><p>具体实现是在编译之后在同步方法调用前加入一个 <code>monitor.enter</code> 指令，在退出方法和异常处插入 <code>monitor.exit</code> 的指令。</p><p>其本质就是对一个对象监视器 <code>Monitor</code> 进行获取，而这个获取过程具有排他性从而达到了同一时刻只能一个线程访问的目的</p><p>而对于没有获取到锁的线程将会阻塞到方法入口处，直到获取锁的线程 <code>monitor.exit</code> 之后才能尝试继续获取锁。</p><p>流程图如下：</p><p><img src="/2023/09/12/volatile%E5%92%8Csynchronized/exec.png" srcset="/img/loading.gif" alt="1566131929317"></p><p>代码例子：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-keyword">synchronized</span> (Synchronize<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>&#123;        System.out.println(<span class="hljs-string">"Synchronize"</span>);    &#125;&#125;</code></pre><p>字节码：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">crossoverjie</span>.<span class="hljs-title">synchronize</span>.<span class="hljs-title">Synchronize</span> </span>&#123;  <span class="hljs-keyword">public</span> com.crossoverjie.synchronize.Synchronize();    Code:       <span class="hljs-number">0</span>: aload_0       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V       <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;    Code:       0: ldc           #2                  // class com/crossoverjie/synchronize/Synchronize       <span class="hljs-number">2</span>: dup       <span class="hljs-number">3</span>: astore_1       **<span class="hljs-number">4</span>: monitorenter**       5: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;       8: ldc           #4                  // String Synchronize      10: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V      <span class="hljs-number">13</span>: aload_1      **<span class="hljs-number">14</span>: monitorexit**      <span class="hljs-number">15</span>: goto          <span class="hljs-number">23</span>      <span class="hljs-number">18</span>: astore_2      <span class="hljs-number">19</span>: aload_1      <span class="hljs-number">20</span>: monitorexit      <span class="hljs-number">21</span>: aload_2      <span class="hljs-number">22</span>: athrow      <span class="hljs-number">23</span>: <span class="hljs-keyword">return</span>    Exception table:       from    to  target type           <span class="hljs-number">5</span>    <span class="hljs-number">15</span>    <span class="hljs-number">18</span>   any          <span class="hljs-number">18</span>    <span class="hljs-number">21</span>    <span class="hljs-number">18</span>   any&#125;</code></pre><h3 id="为什么会有两次monitorexit"><a href="#为什么会有两次monitorexit" class="headerlink" title="为什么会有两次monitorexit"></a>为什么会有两次<code>monitorexit</code></h3><p>同步代码块添加了一个隐式的try-finally，在finally中会调用<code>monitorexit</code>命令释放锁，目的是为了避免异常情况就无法释放锁</p><h3 id="synchronized锁的几种形式"><a href="#synchronized锁的几种形式" class="headerlink" title="synchronized锁的几种形式"></a>synchronized锁的几种形式</h3><p>之前大家都说千万不要用synchronized，效率太差啦，但是Hotspot团队对synchronized进行许多优化，提供了三种状态的锁：偏向锁、轻量级锁、重量级锁，这样一来synchronized性能就有了极大的提高</p><p>偏向锁：就是锁偏向某一个线程。主要是为了处理同一个线程多次获取同一个锁的情况，比如锁重入或者一个线程频繁操作同一个线程安全的容器，但是一旦出现线程之间竞争同一个锁，偏向锁就会撤销，升级为轻量级锁</p><p>轻量级锁：是基于CAS操作实现的。线程使用CAS尝试获取锁失败后，进行一段时间的忙等，也就是所谓的自旋操作。尝试一段时间仍无法获取锁才会升级为重量级锁</p><p>重量级锁：是基于底层操作系统实现的，每次获取锁失败都会直接让线程挂起，这会带来<code>用户态</code>和<code>内核态</code>的切换，性能开销比较大</p><p>打一个比方：大家在排队打饭，你有一个专属通道，叫做帅哥美女专属通道，只有你一个人可以自由的同行，这就叫偏向锁</p><p>突然有一天，我来了，我也自诩帅哥，所以我盯上了你的通道，但是你还在打饭，然后我就抢过去和你一起打饭，但是这样效率比较低，所以阿姨没问我的时候，我就玩会手机等你，这就叫轻量级锁</p><p>突然还有一天，我饿到不行，什么帅哥美女统统滚蛋，就我一个人先打饭，所有阿姨为我服务，给我服务完了再轮到你们，这就叫重量级锁</p><h3 id="synchronized除了上锁还有什么作用"><a href="#synchronized除了上锁还有什么作用" class="headerlink" title="synchronized除了上锁还有什么作用"></a>synchronized除了上锁还有什么作用</h3><ul><li>获得同步锁</li><li>清空工作内存</li><li>从主内存中拷贝对象副本到本地内存</li><li>执行代码</li><li>刷新主内存数据</li><li>释放同步锁</li></ul><p>这也就是上文提到的System.out.println()为何会影响内存可见性的原因了</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>字节码获取方法：</p><pre><code class="hljs properties"><span class="hljs-meta">用法</span>: <span class="hljs-string">javap &lt;options&gt; &lt;classes&gt;</span><span class="hljs-meta">其中,</span> <span class="hljs-string">可能的选项包括:</span>  <span class="hljs-meta">-help</span>  <span class="hljs-string">--help  -?        输出此用法消息</span>  <span class="hljs-meta">-version</span>                 <span class="hljs-string">版本信息</span>  <span class="hljs-meta">-v</span>  <span class="hljs-string">-verbose             输出附加信息</span>  <span class="hljs-meta">-l</span>                       <span class="hljs-string">输出行号和本地变量表</span>  <span class="hljs-meta">-public</span>                  <span class="hljs-string">仅显示公共类和成员</span>  <span class="hljs-meta">-protected</span>               <span class="hljs-string">显示受保护的/公共类和成员</span>  <span class="hljs-meta">-package</span>                 <span class="hljs-string">显示程序包/受保护的/公共类</span>                           <span class="hljs-meta">和成员</span> <span class="hljs-string">(默认)</span>  <span class="hljs-meta">-p</span>  <span class="hljs-string">-private             显示所有类和成员</span>  <span class="hljs-meta">-c</span>                       <span class="hljs-string">对代码进行反汇编</span>  <span class="hljs-meta">-s</span>                       <span class="hljs-string">输出内部类型签名</span>  <span class="hljs-meta">-sysinfo</span>                 <span class="hljs-string">显示正在处理的类的</span>                           <span class="hljs-meta">系统信息</span> <span class="hljs-string">(路径, 大小, 日期, MD5 散列)</span>  <span class="hljs-meta">-constants</span>               <span class="hljs-string">显示最终常量</span>  <span class="hljs-meta">-classpath</span> <span class="hljs-string">&lt;path&gt;        指定查找用户类文件的位置</span>  <span class="hljs-meta">-cp</span> <span class="hljs-string">&lt;path&gt;               指定查找用户类文件的位置</span>  <span class="hljs-meta">-bootclasspath</span> <span class="hljs-string">&lt;path&gt;    覆盖引导类文件的位置</span></code></pre><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>感谢以下博文及其作者：</p><p><a href="https://juejin.im/post/5ea913d35188256d4576d199?utm_source=gold_browser_extension#heading-23" target="_blank" rel="noopener">面试官没想到一个Volatile，我都能跟他扯半小时</a></p><p><a href="https://www.jianshu.com/p/e2054351bd95" target="_blank" rel="noopener">死磕Synchronized底层实现–概论</a></p>]]></content>
    
    
    <categories>
      
      <category>多线程并发篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>volatile和synchronized</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue初识</title>
    <link href="/2023/09/12/Vue%E5%88%9D%E8%AF%86/"/>
    <url>/2023/09/12/Vue%E5%88%9D%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue初始"><a href="#Vue初始" class="headerlink" title="Vue初始"></a>Vue初始</h1><h2 id="本地构建Vue环境"><a href="#本地构建Vue环境" class="headerlink" title="本地构建Vue环境"></a>本地构建Vue环境</h2><ul><li>安装Node.js 并配置完成</li></ul><blockquote><p>配置方式：<a href="https://blog.csdn.net/tjj3027/article/details/84751321" target="_blank" rel="noopener">https://blog.csdn.net/tjj3027/article/details/84751321</a> </p><p>​                     <a href="https://www.cnblogs.com/fighxp/p/7411608.html" target="_blank" rel="noopener">https://www.cnblogs.com/fighxp/p/7411608.html</a> </p><p>卸载，安装，设置数据源，配置环境变量，配置全局存储目录（node.js，F:\Node.js\node_global）</p></blockquote><ul><li>修改Node.js 文件源（npm config set registry <a href="https://registry.npm.taobao.org）" target="_blank" rel="noopener">https://registry.npm.taobao.org）</a></li><li>Vue 相关配置</li></ul><blockquote><p>Vue 3.0： <a href="https://segmentfault.com/a/1190000017020755" target="_blank" rel="noopener">https://segmentfault.com/a/1190000017020755</a> </p></blockquote><h2 id="Vue项目构建"><a href="#Vue项目构建" class="headerlink" title="Vue项目构建"></a>Vue项目构建</h2><blockquote><p>Vue 3.0： <a href="https://segmentfault.com/a/1190000017020755" target="_blank" rel="noopener">https://segmentfault.com/a/1190000017020755</a> </p></blockquote><h2 id="Vue-3-0-项目结构"><a href="#Vue-3-0-项目结构" class="headerlink" title="Vue 3.0 项目结构"></a>Vue 3.0 项目结构</h2><p><img src="/2023/09/12/Vue%E5%88%9D%E8%AF%86/image-20200121165935771.png" srcset="/img/loading.gif" alt="image-20200121165935771"></p><h2 id="Vue-集成ElementUI"><a href="#Vue-集成ElementUI" class="headerlink" title="Vue 集成ElementUI"></a>Vue 集成ElementUI</h2><pre><code class="hljs shell">npm i element-ui -S</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">/* main.js */</span><span class="hljs-comment">/* import  */</span><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">'./App.vue'</span><span class="hljs-comment">// 引入ElementUI</span><span class="hljs-keyword">import</span> ElementUI <span class="hljs-keyword">from</span> <span class="hljs-string">'element-ui'</span><span class="hljs-keyword">import</span> <span class="hljs-string">'element-ui/lib/theme-chalk/index.css'</span>Vue.use(ElementUI);Vue.config.productionTip = <span class="hljs-literal">false</span>;<span class="hljs-keyword">new</span> Vue(&#123;  render: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> h(App),&#125;).$mount(<span class="hljs-string">'#app'</span>);</code></pre><h2 id="Vue-集成axios"><a href="#Vue-集成axios" class="headerlink" title="Vue 集成axios"></a>Vue 集成axios</h2><pre><code class="hljs shell">npm install axios</code></pre><blockquote><p>在项目根目录创建文件 vue.config.js —&gt; 此举一来可以解决跨域问题，二来可以统一请求的域名统一性</p><pre><code class="hljs javascript"><span class="hljs-comment">// vue.config.js 基于服务端代理解决跨域问题</span><span class="hljs-built_in">module</span>.exports = &#123; devServer: &#123;     proxy: &#123;         <span class="hljs-comment">// /api前缀</span>         <span class="hljs-string">"/api"</span>: &#123;             <span class="hljs-comment">// 目标地址</span>             target: <span class="hljs-string">"https://news-at.zhihu.com/api"</span>,             changeOrigin: <span class="hljs-literal">true</span>,             ws: <span class="hljs-literal">true</span>,             pathRewrite: &#123;                 <span class="hljs-string">"^/api"</span>: <span class="hljs-string">""</span>             &#125;         &#125;     &#125; &#125;&#125;</code></pre><pre><code class="hljs main.js">&#96;&#96;&#96;javascript&#x2F;* import *&#x2F;import Vue from &#39;vue&#39;import App from &#39;.&#x2F;App.vue&#39;&#x2F;&#x2F; 引入axiosimport axios from &#39;axios&#39;import VueAxios from &#39;vue-axios&#39;Vue.use(VueAxios, axios);Vue.config.productionTip &#x3D; false;new Vue(&#123;  render: h &#x3D;&gt; h(App),&#125;).$mount(&#39;#app&#39;);</code></pre></blockquote><h2 id="Vue-集成Router"><a href="#Vue-集成Router" class="headerlink" title="Vue 集成Router"></a>Vue 集成Router</h2><pre><code class="hljs shell">npm i vue-router -S</code></pre><blockquote><p>建一个与main.js同级的 router.js文件，引入Router，配置各界面的路由</p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span><span class="hljs-keyword">import</span> Router <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-router'</span><span class="hljs-comment">// 组件模块</span><span class="hljs-keyword">import</span> News          <span class="hljs-keyword">from</span> <span class="hljs-string">'./components/News.vue'</span><span class="hljs-keyword">import</span> NewsContent   <span class="hljs-keyword">from</span> <span class="hljs-string">'./components/NewsContent.vue'</span><span class="hljs-keyword">import</span> Movies        <span class="hljs-keyword">from</span> <span class="hljs-string">'./components/Movies.vue'</span>Vue.use(Router)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Router(&#123; routes: [     &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">'/'</span>             , <span class="hljs-attr">name</span>: <span class="hljs-string">'news'</span>           , <span class="hljs-attr">component</span>: News &#125;,     &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">'/newsContent'</span>  , <span class="hljs-attr">name</span>: <span class="hljs-string">'newsContent'</span>    , <span class="hljs-attr">component</span>: NewsContent&#125;,     &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">'/movies'</span>       , <span class="hljs-attr">name</span>: <span class="hljs-string">'movies'</span>         , <span class="hljs-attr">component</span>: Movies&#125;, ]&#125;)</code></pre><pre><code class="hljs main.js">&#96;&#96;&#96;javascript&#x2F;* import *&#x2F;import Vue from &#39;vue&#39;import App from &#39;.&#x2F;App.vue&#39;&#x2F;&#x2F; 引入routerimport router from &quot;.&#x2F;router.js&quot;;Vue.config.productionTip &#x3D; false;new Vue(&#123;  render: h &#x3D;&gt; h(App),  &#x2F;&#x2F; 注册路由  router,&#125;).$mount(&#39;#app&#39;);</code></pre><pre><code class="hljs 界面中使用方式```">&#96;&#96;&#96;javascript&lt;router-link to&#x3D;&#39;&#x2F;home&#39;&gt;首页&lt;&#x2F;router-link&gt;&lt;router-link to&#x3D;&#39;&#x2F;foods&#39;&gt;美食&lt;&#x2F;router-link&gt;    &lt;router-view&gt; &lt;&#x2F;router-view&gt;&#x2F;&#x2F; JS 主动跳转&#x2F;&#x2F; GET方式this.$router.push(&#123;path:&#39;&#x2F;newsContent&#39;, query:&#123;id: id&#125;&#125;);&#x2F;&#x2F; POST方式this.$router.push(&#123;name:&#39;&#x2F;newsContent&#39;, params:&#123;id: id&#125;&#125;);</code></pre></blockquote><p><code>简单项目DEMO：</code></p><p>GitHub：<a href="https://github.com/kkzhilu/Kerwin-Vue" target="_blank" rel="noopener">https://github.com/kkzhilu/Kerwin-Vue</a> </p><p>分支   ： master</p><p>界面效果：</p><p><img src="/2023/09/12/Vue%E5%88%9D%E8%AF%86/image-20200121171607036.png" srcset="/img/loading.gif" alt="image-20200121171607036"></p>]]></content>
    
    
    <categories>
      
      <category>前端篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue初识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GitHub无法访问解决办法</title>
    <link href="/2023/09/12/GitHub%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <url>/2023/09/12/GitHub%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="GitHub无法访问解决办法"><a href="#GitHub无法访问解决办法" class="headerlink" title="GitHub无法访问解决办法"></a>GitHub无法访问解决办法</h1><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p>解析域名与IP映射，但前提一定要找准！</p><h2 id="GitHub原始项目"><a href="#GitHub原始项目" class="headerlink" title="GitHub原始项目"></a>GitHub原始项目</h2><p><a href="https://github.com/521xueweihan/GitHub520" target="_blank" rel="noopener">https://github.com/521xueweihan/GitHub520</a></p><h2 id="核心办法自我实践"><a href="#核心办法自我实践" class="headerlink" title="核心办法自我实践"></a>核心办法自我实践</h2><p>知乎链接：<a href="https://zhuanlan.zhihu.com/p/158938544" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/158938544</a></p><p>官方域名映射地址查询：<a href="https://github.com.ipaddress.com/" target="_blank" rel="noopener">https://github.com.ipaddress.com/</a></p><p><img src="/2023/09/12/GitHub%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/image-20210228160005643.png" srcset="/img/loading.gif" alt="image-20210228160005643"></p><p><strong>刷新DNS解析</strong></p><pre><code class="hljs bash">ipconfig /flushdns</code></pre>]]></content>
    
    
    <categories>
      
      <category>Tips篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GitHub无法访问解决办法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JSMap-跨页</title>
    <link href="/2023/09/12/JSMap-%E8%B7%A8%E9%A1%B5/"/>
    <url>/2023/09/12/JSMap-%E8%B7%A8%E9%A1%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="JSMap-跨页"><a href="#JSMap-跨页" class="headerlink" title="JSMap-跨页"></a>JSMap-跨页</h1><blockquote><p>认识提示:</p><ol><li>JavaScript 真正的万物皆为对象</li><li>JavaScript以键值对的方式构造对象</li><li>JS方法封装技巧 —&gt; 方法嵌套, this调用</li></ol></blockquote><h2 id="JS-Map-Code"><a href="#JS-Map-Code" class="headerlink" title="JS Map Code"></a>JS Map Code</h2><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * MAP对象，实现MAP功能</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 例子：</span><span class="hljs-comment"> * var map = new JsMap();</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * map.put("key", "value");</span><span class="hljs-comment"> * var val = map.get("key")</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">JsMap</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> p = &#123;        size: <span class="hljs-number">0</span>,        obj: &#123;&#125;    &#125;;    <span class="hljs-keyword">this</span>.clear = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        p.size = <span class="hljs-number">0</span>;        p.obj = &#123;&#125;;    &#125;;    <span class="hljs-keyword">this</span>.contains = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>&#123;        <span class="hljs-keyword">return</span> p.obj[key] != <span class="hljs-literal">null</span> || p.obj[key] !== <span class="hljs-literal">undefined</span>;    &#125;;    <span class="hljs-keyword">this</span>.get = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.contains(key)) &#123;            <span class="hljs-keyword">return</span> p.obj[key];        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125;    &#125;;    <span class="hljs-keyword">this</span>.put = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key, val</span>) </span>&#123;        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.contains(key)) &#123;            p.size++;        &#125;        p.obj[key] = val;    &#125;;    <span class="hljs-keyword">this</span>.size = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">return</span> p.size;    &#125;;    <span class="hljs-keyword">this</span>.keys = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">var</span> arr = [];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> p.obj) &#123;            <span class="hljs-keyword">if</span> (p.obj.hasOwnProperty(key)) &#123;                arr.push(key);            &#125;        &#125;;        <span class="hljs-keyword">return</span> arr;    &#125;;    <span class="hljs-keyword">this</span>.values = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">var</span> values = [];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>.keys()) &#123;            values.push(<span class="hljs-keyword">this</span>.get(key));        &#125;        <span class="hljs-keyword">return</span> values;    &#125;;    <span class="hljs-keyword">this</span>.remove = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.contains(key)) &#123;            p.size--;            <span class="hljs-keyword">delete</span> p.obj[key];        &#125;    &#125;;&#125;<span class="hljs-comment">// ******************</span>Var map = <span class="hljs-keyword">new</span> JsMap();.........</code></pre><h2 id="跨页处理"><a href="#跨页处理" class="headerlink" title="跨页处理"></a>跨页处理</h2><pre><code class="hljs javascript">&lt;script&gt;    <span class="hljs-comment">// 存储CheckBox选择项</span>    <span class="hljs-keyword">var</span> boxsMap = <span class="hljs-keyword">new</span> JsMap();    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 复选框点击事件</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeCheck</span>(<span class="hljs-params">totalBox</span>) </span>&#123;        <span class="hljs-keyword">var</span> currBox = $(totalBox);        $(<span class="hljs-string">'#table_scripts table'</span>).find(<span class="hljs-string">'td:first-child .cbx-case'</span>).each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">index, item</span>) </span>&#123;            <span class="hljs-keyword">var</span> box = $(item);            <span class="hljs-keyword">if</span> (currBox.is(<span class="hljs-string">':checked'</span>)) &#123;                <span class="hljs-comment">//...................</span>                boxsMap.put(script.scriptNo, script)            &#125; <span class="hljs-keyword">else</span> &#123;                boxsMap.remove(box.attr(<span class="hljs-string">"data-script-no"</span>))            &#125;        &#125;);        <span class="hljs-comment">// 判断是否显示Tips</span>        showBoxTips();    &#125;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * CheckBox点击事件</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clickRadio</span>(<span class="hljs-params">box</span>) </span>&#123;        <span class="hljs-keyword">var</span> currBox = $(box);        <span class="hljs-keyword">var</span> isCheck = currBox.is(<span class="hljs-string">':checked'</span>);        <span class="hljs-keyword">if</span> (isCheck) &#123;            <span class="hljs-comment">//...................</span>            boxsMap.put(script.scriptNo, script)        &#125; <span class="hljs-keyword">else</span> &#123;            boxsMap.remove(currBox.attr(<span class="hljs-string">"data-script-no"</span>));        &#125;        <span class="hljs-comment">// 判断是否显示Tips</span>        showBoxTips();    &#125;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 是否需要展示BoxTips | 已选择：XX</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showBoxTips</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">let</span> size = boxsMap.size();        <span class="hljs-keyword">var</span> $<span class="hljs-keyword">this</span> = $(<span class="hljs-string">'#BoxTips'</span>);        <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span>) &#123;            $<span class="hljs-keyword">this</span>.css(<span class="hljs-string">"visibility"</span>,<span class="hljs-string">"visible"</span>);            $<span class="hljs-keyword">this</span>.html(<span class="hljs-string">"已选择数量："</span> + size);        &#125; <span class="hljs-keyword">else</span> &#123;            $<span class="hljs-keyword">this</span>.css(<span class="hljs-string">"visibility"</span>,<span class="hljs-string">"hidden"</span>);        &#125;    &#125;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 回显数据</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">returnCheck</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">var</span> box  = $(<span class="hljs-string">"input[name='script-boxs']"</span>);        box.each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-keyword">var</span> key = $(<span class="hljs-keyword">this</span>).attr(<span class="hljs-string">"data-script-no"</span>);            <span class="hljs-keyword">if</span> (boxsMap.contains(key)) &#123;                $(<span class="hljs-keyword">this</span>).attr(<span class="hljs-string">"checked"</span>, <span class="hljs-string">"checked"</span>);            &#125;        &#125;);        <span class="hljs-comment">// 回显时处理 -&gt; caseBoxAll</span>        <span class="hljs-keyword">var</span> length = $(<span class="hljs-string">"input[name='script-boxs']:checked"</span>).length;        <span class="hljs-keyword">if</span> (box.length &gt; <span class="hljs-number">0</span> &amp;&amp; box.length === length) &#123;            $(<span class="hljs-string">'#caseBoxAll'</span>).attr(<span class="hljs-string">"checked"</span>, <span class="hljs-string">"checked"</span>);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 初始化CheckBox</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initJsMap</span>(<span class="hljs-params"></span>) </span>&#123;        boxsMap.clear();        showBoxTips();        <span class="hljs-comment">// 重新渲染CheckBox</span>        <span class="hljs-keyword">var</span> totalCheck = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"caseBoxAll"</span>);        totalCheck.checked = <span class="hljs-literal">false</span>;        <span class="hljs-keyword">var</span> boxs       = <span class="hljs-built_in">document</span>.getElementsByName(<span class="hljs-string">"script-boxs"</span>);        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; boxs.length; i++)&#123;            boxs[i].checked = <span class="hljs-literal">false</span>;        &#125;    &#125;&lt;<span class="hljs-regexp">/script&gt;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>前端篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JSMap-跨页</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java Bugs</title>
    <link href="/2023/09/12/Java%20Bugs/"/>
    <url>/2023/09/12/Java%20Bugs/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-Bugs"><a href="#Java-Bugs" class="headerlink" title="Java Bugs"></a>Java Bugs</h1><h2 id="IDEA-IO异常：java-io-IOException-Could-not-find-resource"><a href="#IDEA-IO异常：java-io-IOException-Could-not-find-resource" class="headerlink" title="IDEA IO异常：java.io.IOException: Could not find resource"></a>IDEA IO异常：java.io.IOException: Could not find resource</h2><pre><code class="hljs java"><span class="hljs-comment">// IDEA的Maven是不会编译src的java目录的xml文件，所以在Mybatis的配置文件中找不到xml文件</span><span class="hljs-comment">// 正确做法：凡是配置类文件都应该符合maven约束放到resource下，但是如果碰到傻逼项目真这么放了：</span><span class="hljs-comment">// pom -&gt; 启用src下编译即可</span>&lt;build&gt;    &lt;resources&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/java&lt;/directory&gt;            &lt;includes&gt;                &lt;include&gt;**<span class="hljs-comment">/*.xml&lt;/include&gt;</span><span class="hljs-comment">            &lt;/includes&gt;</span><span class="hljs-comment">        &lt;/resource&gt;</span><span class="hljs-comment">    &lt;/resources&gt;</span><span class="hljs-comment">&lt;/build&gt;</span></code></pre><h2 id="SpringBoot-线程池执行Bean注入异常"><a href="#SpringBoot-线程池执行Bean注入异常" class="headerlink" title="SpringBoot 线程池执行Bean注入异常"></a>SpringBoot 线程池执行Bean注入异常</h2><pre><code class="hljs java"> <span class="hljs-comment">/**</span><span class="hljs-comment">  * 错误示例:</span><span class="hljs-comment">  * 初始化 queue是其他类的属性, 很有可能造成空指针，因为  构造方法属于初始化，尚未赋值，此时就调用参数，必然造成空指针</span><span class="hljs-comment">  */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadQueue</span> <span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 创造工作线程读取度列</span>    service.execute(() -&gt; &#123;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            String take = queue.take();            System.out.println(Thread.currentThread() + <span class="hljs-string">"queue name is: "</span> + take);        &#125;    &#125;);&#125;<span class="hljs-comment">/*****************************************************************************************</span><span class="hljs-comment"> * 注意：</span><span class="hljs-comment"> * 如果线程池初始化，立即开始执行任务，使用其他类的属性，则很有可能在 属性赋值之前调用导致空指针</span><span class="hljs-comment"> * 解决方案: <span class="hljs-doctag">@PostConstruct</span></span><span class="hljs-comment"> *           CommandLineRunner接口</span><span class="hljs-comment"> */</span><span class="hljs-meta">@PostConstruct</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postConstruct</span> <span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadQueue</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CommandLineRunner</span> </span>&#123;&#125;</code></pre><h2 id="schannel-nextInitializeSecurityContext-failed-Unknown-error-0x80092013"><a href="#schannel-nextInitializeSecurityContext-failed-Unknown-error-0x80092013" class="headerlink" title="schannel: nextInitializeSecurityContext failed: Unknown error (0x80092013)"></a>schannel: nextInitializeSecurityContext failed: Unknown error (0x80092013)</h2><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">解决方法是，可以通过在Shell中打开存储库并运行这两个命令来恢复经典的OpenSSL行为   ---注意是存储库</span><span class="hljs-meta">$</span><span class="bash"> git config --global http.sslBackend <span class="hljs-string">"openssl"</span></span><span class="hljs-meta">$</span><span class="bash"> git config --global http.sslCAInfo [path to .pem file]</span></code></pre><h2 id="莫名其妙的java-lang-Throwable-java-lang-NullPointerException"><a href="#莫名其妙的java-lang-Throwable-java-lang-NullPointerException" class="headerlink" title="莫名其妙的java.lang.Throwable: java.lang.NullPointerException"></a>莫名其妙的java.lang.Throwable: java.lang.NullPointerException</h2><pre><code class="hljs java">Demo demo = <span class="hljs-keyword">new</span> Demo();demo.setName(<span class="hljs-string">"aaa"</span>);demo.setIds(list);System.out.println(demo);Map&lt;String, Demo&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();map.put(<span class="hljs-string">"key"</span>, demo);Demo key = map.get(<span class="hljs-string">"key"</span>);key.setIds(<span class="hljs-keyword">null</span>);System.out.println(key);System.out.println(demo);<span class="hljs-comment">// 打印内容----&gt;</span>Demo&#123;name=<span class="hljs-string">'aaa'</span>, ids=[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]&#125;Demo&#123;name=<span class="hljs-string">'aaa'</span>, ids=<span class="hljs-keyword">null</span>&#125;Demo&#123;name=<span class="hljs-string">'aaa'</span>, ids=<span class="hljs-keyword">null</span>&#125;</code></pre><pre><code class="hljs 非基本类型传递对象的引用->">## 为什么 Illegal combination of modifiers: &#39;final&#39; and &#39;volatile&#39;final：final关键字的语意是禁止对象的二次写入volatile：volatile关键字的语意是保证变量被写入时其结果其他线程可见 两者在本质上是互相矛盾的，因此IDEA环境下无法编译通过，会出现 Illegal combination of modifiers: &#39;final&#39; and &#39;volatile&#39;错误![image-20200413140649830](Java Bugs&#x2F;image-20200413140649830.png)## 为什么 split(&quot;.&quot;); &#x2F;&#x2F; 结果为[]**小心String.split(String regex)**字符串 String 的 split 方法，传入的分隔字符串是正则表达式！部分关键字（比如.[]()\| 等）需要转义。**反例：**&#96;&#96;&#96;java&quot;a.ab.abc&quot;.split(&quot;.&quot;); &#x2F;&#x2F; 结果为[]&quot;a|ab|abc&quot;.split(&quot;|&quot;); &#x2F;&#x2F; 结果为[&quot;a&quot;, &quot;|&quot;, &quot;a&quot;, &quot;b&quot;, &quot;|&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code></pre><p><strong>正例：</strong></p><pre><code class="hljs java"><span class="hljs-string">"a.ab.abc"</span>.split(<span class="hljs-string">"\\."</span>); <span class="hljs-comment">// 结果为["a", "ab", "abc"]</span><span class="hljs-string">"a|ab|abc"</span>.split(<span class="hljs-string">"\\|"</span>); <span class="hljs-comment">// 结果为["a", "ab", "abc"]</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>Tips篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java Bugs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript-回调函数</title>
    <link href="/2023/09/12/JavaScript-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
    <url>/2023/09/12/JavaScript-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-回调函数"><a href="#JavaScript-回调函数" class="headerlink" title="JavaScript-回调函数"></a>JavaScript-回调函数</h1><h2 id="函数也是对象"><a href="#函数也是对象" class="headerlink" title="函数也是对象"></a>函数也是对象</h2><pre><code class="hljs javascript"><span class="hljs-comment">// 可以这样创建函数</span><span class="hljs-keyword">var</span> fn = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">"arg1"</span>, <span class="hljs-string">"arg2"</span>, <span class="hljs-string">"return arg1 * arg2;"</span>);<span class="hljs-comment">// 6</span>fn(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);</code></pre><p>简单解释一下回调函数的使用场景： 你自己打包方法的时候发现用return来返回数据不行，那就用回调函数来接收返回的数据，</p><p>或者觉得这个方法就可以决定下一步该怎么做，就用回调函数 </p><p>JavaScript体系中非常鲜明的几个例子：ajax， setTimeout，setInterval </p><h2 id="自己来写一个回调函数"><a href="#自己来写一个回调函数" class="headerlink" title="自己来写一个回调函数"></a>自己来写一个回调函数</h2><pre><code class="hljs javascript"><span class="hljs-comment">// 调用：fun(1,2,call)</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params">num1, num2, callback</span>) </span>&#123;    <span class="hljs-keyword">var</span> result = num1 + num2;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span>(callback) === <span class="hljs-string">'function'</span>) &#123;        callback(result);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">call</span>(<span class="hljs-params">result</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(result)&#125;</code></pre><p>注：个人在之前学习的过程中，对于JavaScript其实没有系统的学习，完全是基于Java的底子利用方法进行业务的堆砌，这其实没</p><p>有充分发挥JavaScript的特性，后续比如说，利用JavaScript对象的本身特性，构建一个类似Java中HashMap的数据结构，又或者通</p><p>过对象的传递，传递值和方法，回调函数等等，当然这也仅仅是其中的一些皮毛</p><p>在之后的工作，发现模块耦合关系比较紧密，一步接一步的工作流程时，就可以考虑回调函数，回调能够降低模块之间的耦合度，</p><p>每个模块关注自己的核心业务，自己的事情做完，需要通知其它模块的时候，可以通过发送事件，其它模块监听你的模块事件，执</p><p>行回调；或暴露回调接口出去，调用方只要实现接口就可以收到你的业务通知（回调函数被执行） </p>]]></content>
    
    
    <categories>
      
      <category>前端篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript-回调函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript定时器及回调用法</title>
    <link href="/2023/09/12/JavaScript%E5%AE%9A%E6%97%B6%E5%99%A8%E5%8F%8A%E5%9B%9E%E8%B0%83%E7%94%A8%E6%B3%95/"/>
    <url>/2023/09/12/JavaScript%E5%AE%9A%E6%97%B6%E5%99%A8%E5%8F%8A%E5%9B%9E%E8%B0%83%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript定时器及回调用法"><a href="#JavaScript定时器及回调用法" class="headerlink" title="JavaScript定时器及回调用法"></a>JavaScript定时器及回调用法</h1><h3 id="循环定时任务"><a href="#循环定时任务" class="headerlink" title="循环定时任务"></a>循环定时任务</h3><pre><code class="hljs javascript"><span class="hljs-comment">// 假设现在有这样一个需求：我需要请求一个接口，根据返回结果判断需不需要重复请求，直到达到某一条件为止,停止请求执行某操作</span>&lt;script type=<span class="hljs-string">"text/javascript"</span>&gt;    <span class="hljs-keyword">var</span> timer;    <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tim</span>(<span class="hljs-params"></span>)</span>&#123;        timer = setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;            index++;            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.random())            <span class="hljs-keyword">if</span> (index === <span class="hljs-number">5</span>) &#123;                <span class="hljs-built_in">window</span>.clearInterval(timer)            &#125;        &#125;, <span class="hljs-number">500</span>);    &#125;&lt;<span class="hljs-regexp">/script&gt;</span></code></pre><h3 id="循环请求并获取返回值-拿到返回值后执行操作"><a href="#循环请求并获取返回值-拿到返回值后执行操作" class="headerlink" title="循环请求并获取返回值 - 拿到返回值后执行操作"></a>循环请求并获取返回值 - 拿到返回值后执行操作</h3><h4 id="回调函数方法"><a href="#回调函数方法" class="headerlink" title="回调函数方法"></a>回调函数方法</h4><pre><code class="hljs java">&lt;script&gt;    <span class="hljs-function">function <span class="hljs-title">getSomething</span><span class="hljs-params">(cb)</span> </span>&#123;         <span class="hljs-keyword">var</span> r = <span class="hljs-number">0</span>;         setTimeout(function() &#123;             r = <span class="hljs-number">2</span>;             cb(r);         &#125;, <span class="hljs-number">100</span>);    &#125;    <span class="hljs-function">function <span class="hljs-title">compute</span><span class="hljs-params">(x)</span> </span>&#123;     alert(x * <span class="hljs-number">2</span>);    &#125;    getSomething(compute);&lt;/script&gt;</code></pre><h4 id="promise方法"><a href="#promise方法" class="headerlink" title="promise方法"></a>promise方法</h4><pre><code class="hljs java"><span class="hljs-function">function <span class="hljs-title">getSomething</span><span class="hljs-params">()</span> </span>&#123;     <span class="hljs-keyword">var</span> r = <span class="hljs-number">0</span>;     <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Promise(function(resolve) &#123;         setTimeout(function() &#123;          r = <span class="hljs-number">2</span>;          resolve(r);         &#125;, <span class="hljs-number">10</span>);     &#125;);&#125;<span class="hljs-function">function <span class="hljs-title">compute</span><span class="hljs-params">(x)</span> </span>&#123; alert(x * <span class="hljs-number">2</span>);&#125;getSomething().then(compute);</code></pre><h4 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h4><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSomething</span>(<span class="hljs-params"></span>) </span>&#123;     <span class="hljs-keyword">var</span> r = <span class="hljs-number">0</span>;     setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;         r = <span class="hljs-number">2</span>;         it.next(r);     &#125;, <span class="hljs-number">10</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> *<span class="hljs-title">compute</span>(<span class="hljs-params">it</span>) </span>&#123;     <span class="hljs-keyword">var</span> x = <span class="hljs-keyword">yield</span> getSomething();     alert(x * <span class="hljs-number">2</span>);&#125;<span class="hljs-keyword">var</span> it = compute();it.next();</code></pre><h4 id="promise-generator"><a href="#promise-generator" class="headerlink" title="promise + generator"></a>promise + generator</h4><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSomething</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> r = <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;            r = <span class="hljs-number">2</span>;            resolve(r);        &#125;, <span class="hljs-number">10</span>);    &#125;);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">compute</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> x = <span class="hljs-keyword">yield</span> getSomething();    alert(x * <span class="hljs-number">2</span>);&#125;<span class="hljs-keyword">var</span> it = compute();it.next().value.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;    it.next(value);&#125;);</code></pre><h4 id="ES7-终极方案"><a href="#ES7-终极方案" class="headerlink" title="ES7 - 终极方案"></a>ES7 - 终极方案</h4><pre><code class="hljs javascript">&lt;script type=<span class="hljs-string">"text/javascript"</span>&gt;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSomething</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">var</span> r = <span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;            setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;                r = <span class="hljs-number">2</span>;                resolve(r);            &#125;, <span class="hljs-number">10</span>);        &#125;);    &#125;    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compute</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">var</span> x = <span class="hljs-keyword">await</span> getSomething();        alert(x * <span class="hljs-number">2</span>);    &#125;    <span class="hljs-comment">// 直接调用compute()方法 -&gt; x为同步请求返回结果，输出4</span>    compute(); <span class="hljs-comment">// 表示getSomething获取返回值后执行resolve状态 -&gt;  </span>    <span class="hljs-comment">// 当.then()前的方法执行完后再执行then()内部的程序，这样就避免了，数据没获取到等的问题</span>    getSomething().then(compute);&lt;<span class="hljs-regexp">/script&gt;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>前端篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript定时器及回调用法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java远程DeBug解决方案</title>
    <link href="/2023/09/12/Java%E8%BF%9C%E7%A8%8BDeBug%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2023/09/12/Java%E8%BF%9C%E7%A8%8BDeBug%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="Java远程DEBUG解决方案"><a href="#Java远程DEBUG解决方案" class="headerlink" title="Java远程DEBUG解决方案"></a>Java远程DEBUG解决方案</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>JPDA（Java Platform Debugger Architecture）是Sun公司开发的 java平台调试体系，它主要有三个层次组成，即 Java 虚拟机工具接口（JVMTI），Java 调试线协议（JDWP）以及 Java 调试接口（JDI）</p><p>JVMTI（JVMDI）: jdk1.4 之前称为JVMDI，之后改为了JVMTI，它是虚拟机的本地接口，其相当于 Thread 的 sleep、yield native 方法</p><p>JDWP（Java Debug Wire Protocol）：java调试网络协议，其描述了调试信息的格式，以及在被调试的进程（server）和调试器（client）之间传输的请求</p><p>JDI：java调试接口，虚拟机的高级接口，调试器（client）自己实现 JDI 接口，比如 idea、eclipse 等</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>参考文章：<a href="https://www.cnblogs.com/wl-blog/p/15838574.html" target="_blank" rel="noopener">https://www.cnblogs.com/wl-blog/p/15838574.html</a></p><p>执行步骤：</p><ol><li>服务启动时增加命令（开启DEBUG相关模块、指定服务器端口）</li><li>开启服务所在的远程服务器相关端口</li><li>本地IDE新建远程DEBUG模块，配置相关参数即可</li></ol><p>注意事项：</p><ol><li><code>DEBUG执行的代码块一定要相同（整体代码可以不一样）</code></li><li><code>断点执行一定要完全执行结束，不然会占据相当高的内存空间（也可重启解决）</code></li></ol><h2 id="京东到家实践参考"><a href="#京东到家实践参考" class="headerlink" title="京东到家实践参考"></a>京东到家实践参考</h2><p>参考文章：<a href="https://confluence.corp.imdada.cn/pages/viewpage.action?pageId=85747261" target="_blank" rel="noopener">https://confluence.corp.imdada.cn/pages/viewpage.action?pageId=85747261</a></p><ol><li><p>服务启动时增加命令（开启DEBUG相关模块）</p><p>Tomcat：-agentlib:jdwp=transport=dt_socket,address=8088,suspend=n,server=y</p><pre><code class="hljs sh"><span class="hljs-built_in">export</span> maxParameterCount=<span class="hljs-string">"1000"</span><span class="hljs-built_in">export</span> acceptCount=<span class="hljs-string">"1000"</span><span class="hljs-built_in">export</span> maxSpareThreads=<span class="hljs-string">"750"</span><span class="hljs-built_in">export</span> maxThreads=<span class="hljs-string">"1000"</span><span class="hljs-built_in">export</span> minSpareTHreads=<span class="hljs-string">"50"</span><span class="hljs-built_in">export</span> URIEncoding=<span class="hljs-string">"UTF-8"</span><span class="hljs-built_in">export</span> JAVA_OPTS=<span class="hljs-string">"-Djava.library.path=/usr/local/lib -server -Xms2048m -Xmx4096m -XX:MaxMetaspaceSize=256m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/export/Logs -Djava.awt.headless=true -Dsun.net.client.defaultConnectTimeout=60000 -Dsun.net.client.defaultReadTimeout=60000 -Djmagick.systemclassloader=no -Dnetworkaddress.cache.ttl=300 -Dsun.net.inetaddr.ttl=300 -Dump.key.prefix=pre_ -agentlib:jdwp=transport=dt_socket,address=8088,suspend=n,server=y"</span></code></pre></li></ol><p>   Application：setsid <code>java -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005</code> -jar</p>   <pre><code class="hljs sh">// 案例、关注第三行nohup <span class="hljs-string">"<span class="hljs-variable">$JAVACMD</span>"</span> <span class="hljs-variable">$&#123;TTL_AGENT:-&#125;</span> <span class="hljs-variable">$&#123;PFINDER_AGENT:-&#125;</span> <span class="hljs-variable">$JAVA_OPTS</span>\  <span class="hljs-variable">$OPTS_MEMORY</span> \  -agentlib:jdwp=transport=dt_socket,server=y,<span class="hljs-built_in">suspend</span>=n,address=5005 \  -XX:-OmitStackTraceInFastThrow\  -classpath <span class="hljs-string">"<span class="hljs-variable">$CLASSPATH</span>"</span> \  -Dbasedir=<span class="hljs-string">"<span class="hljs-variable">$BASEDIR</span>"</span> \  -Dfile.encoding=<span class="hljs-string">"UTF-8"</span> \  -Dcom.sun.management.jmxremote\    -Dcom.sun.management.jmxremote.port=52001\    -Dcom.sun.management.jmxremote.authenticate=<span class="hljs-literal">false</span>\    -Dcom.sun.management.jmxremote.ssl=<span class="hljs-literal">false</span>\</code></pre><ol start="2"><li><p>服务启动时增加命令（开启DEBUG相关模块、指定服务器端口）</p><p>由于京东云对外暴露的接口只有80和443，所以5005端口无法直接访问</p><p>因此，配置负载均衡进行转发（<code>TCP协议</code>）</p><p><img src="/2023/09/12/Java%E8%BF%9C%E7%A8%8BDeBug%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20221101161032494.png" srcset="/img/loading.gif" alt="image-20221101161032494"></p></li><li><p>本地IDE新建远程DEBUG模块，配置相关参数即可</p><p>Host可以直接IP或者域名都可，端口理论上是任意的，只要能匹配上即可，例如这里就是80，上面是5005转发至80端口</p><p><img src="/2023/09/12/Java%E8%BF%9C%E7%A8%8BDeBug%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20221101161123024.png" srcset="/img/loading.gif" alt="image-20221101161123024"></p></li></ol><p>   切换至远程DEBUG，开启调试后，控制台会输出相应日志：</p><p>   Connected to the target VM, address: ‘stockcentero2o-remotedebug.o2ostock.svc.lf06.n.jd.local:80’, transport: ‘socket’</p>]]></content>
    
    
    <categories>
      
      <category>Tips篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java远程DeBug解决方案</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程并发基础</title>
    <link href="/2023/09/12/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/09/12/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="多线程并发基础"><a href="#多线程并发基础" class="headerlink" title="多线程并发基础"></a>多线程并发基础</h1><p>什么是进程和线程</p><p>CPU核心数和线程数的关系（核心数和逻辑处理器 1：2）</p><p>CPU时间片轮转机制（RR调度）</p><p>并行和并发（时间单位）</p><p>线程数量的限制（系统限制   栈空间，文件描述符，句柄）</p><p>多线程处理任务时一定比单线程快吗</p><p>Java代码运行时涉及到的模块</p><pre><code class="hljs java"><span class="hljs-comment">//Java 虚拟机线程系统的管理接口</span>ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();<span class="hljs-comment">// 不需要获取同步的monitor和synchronizer信息，仅仅获取线程和线程堆栈信息</span>ThreadInfo[] threadInfos =    threadMXBean.dumpAllThreads(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>);<span class="hljs-comment">// 遍历线程信息，仅打印线程ID和线程名称信息</span><span class="hljs-keyword">for</span> (ThreadInfo threadInfo : threadInfos) &#123;    System.out.println(<span class="hljs-string">"["</span> + threadInfo.getThreadId() + <span class="hljs-string">"] "</span>                       + threadInfo.getThreadName());&#125;</code></pre><p>finalize()方法为什么有可能不会被执行</p><p>Java新建线程的方式有几种</p><p>Runable和Thread的理解，Thread是对线程的抽象，Runable是对任务的抽象</p><p>为什么线程中suspend()，stop()，resume()方法不推荐使用</p><p>interrupt()，isInterupted()，interupted( 检测中断标志位并把标志位True改为false ) 方法的区别</p><p>JDK中线程是协作式还是抢占式，CPU呢</p><p>在线程中用变量作为中断或者执行的标识好不好</p><pre><code class="hljs java">Thread.currThread.is.....</code></pre><p>为什么线程sleep出现异常是抛出异常而不是终止线程呢（catch异常后，线程依然在运行？）</p><p>线程如果调用两次start方法，会怎么样？</p><p>线程的生命周期</p><p>yield()方法的实质，会让出锁吗</p><p>join()方法的实质，和countDownLauch是不是有点像（线程顺序执行）</p><p>为什么对象锁可以起作用？（同一个类，启动两个实例，对象是不是就是各自的，为什么还能起作用）</p><p>类锁的实质，锁加到哪里去了</p><p>（为什么static 方法，static 对象加锁，互不影响）</p><p>为什么synchronized不能锁int，synchronized的本质是什么</p><p>错误的枷锁 —》锁的对象本身发生变化</p><ul><li>System.identityHashCode(obj)  Java Decompiler反编译工具</li><li>Inteager i++ 对象会发生赋值吗</li></ul><p>volatile关键字（可见性，不保证原子性） ===》一写多读</p><p>ThreadLocal 线程变量副本 ==》实现了线程的隔离  Spring事务时使用了ThreadLocal（为了存储数据库联接）</p><p>ThreadLocal 内存泄漏：</p><ul><li>强引用</li><li>软引用</li><li>弱引用</li><li>虚引用</li></ul><p>ThreadLocal  =》内部Entry为什么定义为弱引用</p><p>ThreadLocal  =》线程不安全的情况：多个线程持有同一个变量，互相影响</p><p>线程协作：20190418_1、线程基础、线程之间的共享和协作_04-金狮   一半左右</p>]]></content>
    
    
    <categories>
      
      <category>多线程并发篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程并发基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.824（三）GFS</title>
    <link href="/2023/09/12/6.824%EF%BC%88%E4%B8%89%EF%BC%89GFS/"/>
    <url>/2023/09/12/6.824%EF%BC%88%E4%B8%89%EF%BC%89GFS/</url>
    
    <content type="html"><![CDATA[<h1 id="GFS"><a href="#GFS" class="headerlink" title="GFS"></a>GFS</h1><br><h2 id="分布式存储系统为什么很难"><a href="#分布式存储系统为什么很难" class="headerlink" title="分布式存储系统为什么很难"></a>分布式存储系统为什么很难</h2><ul><li>为了性能 -》需要分片</li><li>为了解决错误 -》需要容错</li><li>为了容错，需要复制 -》为了复制，需要解决一致性</li><li>为了一致性 -》 性能降低</li></ul><p>因此分布式系统的构建，其中的难点就是一个死循环，而如何打破这种死循环，就需要平衡各方面的因素，以及设计更好的数据格式来处理相应的问题，比如用日志而非数据库存储状态提高效率，比如追求弱一致性而非强一致性</p><br><h2 id="GFS架构"><a href="#GFS架构" class="headerlink" title="GFS架构"></a>GFS架构</h2><br><h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><p><img src="/2023/09/12/6.824%EF%BC%88%E4%B8%89%EF%BC%89GFS/%E6%88%AA%E5%9B%BE.png" srcset="/img/loading.gif" alt="img"></p><ul><li>每一个GFS中的文件会被分成大小为64MB的块，这样的块被存储在不同的块服务器上</li><li>每一个块会有三个它自己的备份，备份被存储在其它的块服务器上</li><li>GFS系统中只有一个主机服务器，同时主机服务器的状态被备份在其它的服务器上</li><li>主机服务器主要处理文件的命名空间以及文件与块的映射，而其它块服务器用来发送数据给客户</li></ul><br><h3 id="主机状态及管理"><a href="#主机状态及管理" class="headerlink" title="主机状态及管理"></a>主机状态及管理</h3><br><ul><li>所有状态数据都存放在主机服务器的内存中，包括：<ul><li>文件名与它的每个文件块标识之间的映射，需要被持久化到主机服务器的硬盘上</li><li>文件块标识，包括：<ul><li>块的版本号，需要被持久化到主机服务器的硬盘上</li><li>块和它的备份所在的块服务器的位置</li><li>块所在的块服务器是否是主要服务器</li><li>块的租用时间</li></ul></li></ul></li><li>需要持久化的状态数据会被写进日志，同时写入服务器硬盘的还有对主机状态的定期检查点</li><li>对于整个系统而言也会定时创建快照</li></ul><h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><br><p><img src="/2023/09/12/6.824%EF%BC%88%E4%B8%89%EF%BC%89GFS/image-20200817061814140.png" srcset="/img/loading.gif" alt="image-20200817061814140"></p><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><ul><li>客户向主机服务器发送文件名和偏移量。</li><li>主机服务器根据文件名和偏移量查找对应的块</li><li>主机服务器并将含有最新版本号的块和它的备份的标识符和所在的块服务器地址返回给客户</li><li>客户将块标识符和块服务器位置缓存到本地</li><li>客户向离他最近的块服务器发送读请求</li><li>块服务器将数据返回给客户</li></ul><h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><ul><li>客户向主机服务器询问目标文件的尾部所在的块</li><li>如果没有相应的块或者租约到期：<ul><li>如果没有任何块服务器含有该块的最新版本，返回错误给客户</li><li>随机选取一个含有该块最新版本的块服务器作为主块服务器，其它含有最新版本的块服务器则称为从块服务器</li><li>将块的版本号+1，并写入操作日志</li><li>将新的版本号和一些相关信息发送给块服务器们</li><li>副本服务器将新版本写入硬盘中</li></ul></li><li>主机服务器将主块服务器和从块服务器返回给客户</li><li>客户端将数据发送给所有对应的块服务器</li><li>当所有对应的块服务器收到客户端发来的数据之后，客户端向主块服务器发送写请求</li><li>主块服务器检查当前的块的租用时间是否到期，以及块的空间是否足够</li><li>主块服务器挑选偏移量并将数据写入一个新的文件（Linux）</li><li>主块服务器通知其它从块服务器以相同顺序执行相同操作</li><li>只有当所有从块服务器的写请求都返回成功，主块服务器才会返回成功给客户，否则返回error</li><li>返回给用户结果，成功或是失败</li><li>当客户碰到错误时，他会重新发送同样请求给主服务器</li></ul>]]></content>
    
    
    <categories>
      
      <category>分布式篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>6.824（三）GFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写一个本地缓存</title>
    <link href="/2023/09/12/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98/"/>
    <url>/2023/09/12/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h1 id="基于ConcurrentHashMap的本地缓存"><a href="#基于ConcurrentHashMap的本地缓存" class="headerlink" title="基于ConcurrentHashMap的本地缓存"></a>基于ConcurrentHashMap的本地缓存</h1><p>在系统中，有些数据，数据量小，但是访问十分频繁（例如国家标准行政区域数据），针对这种场景，需要将数据搞到应用的本地缓存中，以提升系统的访问效率，减少无谓的数据库访问（数据库访问占用数据库连接，同时网络消耗比较大），但是有一点需要注意，就是缓存的占用空间以及缓存的失效策略</p><p>博文：<a href="https://www.jianshu.com/p/4194483127fe" target="_blank" rel="noopener">https://www.jianshu.com/p/4194483127fe</a></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mine.localcache;<span class="hljs-keyword">import</span> java.util.Date;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">import</span> java.util.Timer;<span class="hljs-keyword">import</span> java.util.TimerTask;<span class="hljs-keyword">import</span> java.util.concurrent.ConcurrentHashMap;<span class="hljs-comment">/**</span><span class="hljs-comment"> * ******************************</span><span class="hljs-comment"> * author：      柯贤铭</span><span class="hljs-comment"> * createTime:   2019/7/15 9:56</span><span class="hljs-comment"> * description:  基于ConcurrentHashMap的本地缓存解决方案</span><span class="hljs-comment"> *               博文：https://www.jianshu.com/p/4194483127fe</span><span class="hljs-comment"> * version:      V1.0</span><span class="hljs-comment"> * ******************************</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LocalCache</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 默认有效时长,单位:秒</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFUALT_TIMEOUT = <span class="hljs-number">3600</span> * <span class="hljs-number">1000</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> SECOND_TIME = <span class="hljs-number">1000</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; map;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Timer timer;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 初始化</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">static</span> &#123;        timer = <span class="hljs-keyword">new</span> Timer();        map = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 私有构造函数,工具类不允许实例化</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">LocalCache</span><span class="hljs-params">()</span> </span>&#123;&#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 清除缓存任务类</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CleanWorkerTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TimerTask</span> </span>&#123;        <span class="hljs-keyword">private</span> String key;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CleanWorkerTask</span><span class="hljs-params">(String key)</span> </span>&#123;            <span class="hljs-keyword">this</span>.key = key;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            LocalCache.remove(key);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 增加缓存</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(String key, Object value)</span> </span>&#123;        map.put(key, value);        timer.schedule(<span class="hljs-keyword">new</span> CleanWorkerTask(key), DEFUALT_TIMEOUT);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 增加缓存</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> timeout 有效时长</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(String key, Object value, <span class="hljs-keyword">int</span> timeout)</span> </span>&#123;        map.put(key, value);        timer.schedule(<span class="hljs-keyword">new</span> CleanWorkerTask(key), timeout * SECOND_TIME);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 增加缓存</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> expireTime 过期时间</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(String key, Object value, Date expireTime)</span> </span>&#123;        map.put(key, value);        timer.schedule(<span class="hljs-keyword">new</span> CleanWorkerTask(key), expireTime);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 批量增加缓存</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> m</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putAll</span><span class="hljs-params">(Map&lt;String, Object&gt; m)</span> </span>&#123;        map.putAll(m);        <span class="hljs-keyword">for</span> (String key : m.keySet()) &#123;            timer.schedule(<span class="hljs-keyword">new</span> CleanWorkerTask(key), DEFUALT_TIMEOUT);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 批量增加缓存</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> m</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putAll</span><span class="hljs-params">(Map&lt;String, Object&gt; m, <span class="hljs-keyword">int</span> timeout)</span> </span>&#123;        map.putAll(m);        <span class="hljs-keyword">for</span> (String key : m.keySet()) &#123;            timer.schedule(<span class="hljs-keyword">new</span> CleanWorkerTask(key), timeout * SECOND_TIME);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 批量增加缓存</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> m</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putAll</span><span class="hljs-params">(Map&lt;String, Object&gt; m, Date expireTime)</span> </span>&#123;        map.putAll(m);        <span class="hljs-keyword">for</span> (String key : m.keySet()) &#123;            timer.schedule(<span class="hljs-keyword">new</span> CleanWorkerTask(key), expireTime);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取缓存</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-keyword">return</span> map.get(key);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 查询缓存是否包含key</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsKey</span><span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-keyword">return</span> map.containsKey(key);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 删除缓存</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(String key)</span> </span>&#123;        map.remove(key);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 删除缓存</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> o</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object o)</span> </span>&#123;        map.remove(o);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 返回缓存大小</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> map.size();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 清除所有缓存</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (size() &gt; <span class="hljs-number">0</span>) &#123;            map.clear();        &#125;        <span class="hljs-comment">// 取消延时任务,重新创建Timer</span>        timer.cancel();        timer = <span class="hljs-keyword">new</span> Timer();    &#125;&#125;</code></pre><h2 id="测试Demo"><a href="#测试Demo" class="headerlink" title="测试Demo"></a>测试Demo</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20000</span>; i++) &#123;            LocalCache.put(i + <span class="hljs-string">""</span>, <span class="hljs-string">"test for "</span> + i , <span class="hljs-number">20</span>);        &#125;        System.out.println(<span class="hljs-string">"ok"</span>);        Thread.sleep(<span class="hljs-number">10</span> * <span class="hljs-number">1000</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20000</span>; i++) &#123;            System.out.println(LocalCache.get(i + <span class="hljs-string">""</span>));        &#125;        Thread.sleep(<span class="hljs-number">15</span> * <span class="hljs-number">1000</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20000</span>; i++) &#123;            System.out.println(LocalCache.get(i + <span class="hljs-string">""</span>));        &#125;    &#125;&#125;</code></pre><h2 id="总结分析"><a href="#总结分析" class="headerlink" title="总结分析"></a>总结分析</h2><pre><code class="hljs lasso">该缓存是基于ConcurrentHashMap配合Timer实现的本地缓存策略，但是它有其瓶颈，比如：LRU：Least Recently Used，最近最少使用 算法实现等都均未实现，不过可以用作学习和参考使用生产级别推荐使用：Guava <span class="hljs-keyword">cache</span>构建本地缓存</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>手写一个本地缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ajax前后端交互</title>
    <link href="/2023/09/12/Ajax%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/"/>
    <url>/2023/09/12/Ajax%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/</url>
    
    <content type="html"><![CDATA[<h1 id="Ajax前后端交互"><a href="#Ajax前后端交互" class="headerlink" title="Ajax前后端交互"></a>Ajax前后端交互</h1><h2 id="注意：使用-RequestBody注解时需要注意，获取的实体类，或者集合，Map并不是真正的对象，hashmap或者Array等，而是linkehashMap等结构所以真正使用的时候注意进行转换，如："><a href="#注意：使用-RequestBody注解时需要注意，获取的实体类，或者集合，Map并不是真正的对象，hashmap或者Array等，而是linkehashMap等结构所以真正使用的时候注意进行转换，如：" class="headerlink" title="注意：使用@RequestBody注解时需要注意，获取的实体类，或者集合，Map并不是真正的对象，hashmap或者Array等，而是linkehashMap等结构所以真正使用的时候注意进行转换，如："></a>注意：使用@RequestBody注解时需要注意，获取的实体类，或者集合，Map并不是真正的对象，hashmap或者Array等，而是linkehashMap等结构所以真正使用的时候注意进行转换，如：</h2><pre><code class="hljs java"><span class="hljs-comment">/*</span><span class="hljs-comment"> * 注：(List&lt;MbtiAnswer&gt;) map.get("list") 转化得到的是LinkHashMap,而不是真正的集合</span><span class="hljs-comment"> * 因此需要把list数组转化为JsonString，再转化为List集合</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> BaseResult <span class="hljs-title">getResult</span> <span class="hljs-params">(@RequestBody HashMap&lt;String, Object&gt; map)</span> </span>&#123;    String jsonArray = JSONArray.toJSONString(map.get(<span class="hljs-string">"list"</span>));    <span class="hljs-comment">// 获取答案集合列表</span>    List&lt;MbtiAnswer&gt; list = JSONArray.parseArray(jsonArray, MbtiAnswer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;&#125;</code></pre><h3 id="JSON请求"><a href="#JSON请求" class="headerlink" title="JSON请求"></a>JSON请求</h3><pre><code class="hljs javascript">$.ajax(&#123;    type: <span class="hljs-string">'get'</span>,    url: <span class="hljs-string">'$&#123;base.contextPath&#125;/giving/index/del'</span>,    dataType: <span class="hljs-string">'json'</span>,    data: &#123;<span class="hljs-attr">ids</span>: arr&#125;,    success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>&#123;        …    &#125;,    error: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>&#123;        …    &#125;&#125;)<span class="hljs-keyword">var</span> data = &#123;&#125;;....$.ajax(&#123;    url:<span class="hljs-string">'$&#123;pageContext.request.contextPath &#125;/rest/jsonBody'</span>,    type:<span class="hljs-string">'POST'</span>,    dataType:<span class="hljs-string">'json'</span>,    contentType:<span class="hljs-string">'application/json;charset=UTF-8'</span>,    data:<span class="hljs-built_in">JSON</span>.stringify(data),    success:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data, status</span>)</span>&#123;        <span class="hljs-built_in">console</span>.log(data);    &#125;&#125;);</code></pre><h3 id="接收List集合参数"><a href="#接收List集合参数" class="headerlink" title="接收List集合参数"></a>接收List<Integer>集合参数</Integer></h3><pre><code class="hljs java">$.ajax(&#123;    type: <span class="hljs-string">'get'</span>,    url: <span class="hljs-string">'$&#123;base.contextPath&#125;/giving/index/del'</span>,    dataType: <span class="hljs-string">'json'</span>,    data: &#123;ids: arr&#125;,    success: function (result) &#123;        …    &#125;,    error: function (result) &#123;        …    &#125;&#125;)    <span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/index/del"</span>, method = RequestMethod.GET)<span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> ReturnMsg <span class="hljs-title">del</span> <span class="hljs-params">(@RequestParam(value = <span class="hljs-string">"ids[]"</span>)</span>List &lt;Integer&gt; ids)</span>&#123;    …&#125;</code></pre><h3 id="接收List、User-集合参数"><a href="#接收List、User-集合参数" class="headerlink" title="接收List、User[]集合参数"></a>接收List<User>、User[]集合参数</User></h3><pre><code class="hljs java"><span class="hljs-keyword">var</span> userList = <span class="hljs-keyword">new</span> Array();userList.push(&#123;name: <span class="hljs-string">"张三"</span>,pwd: <span class="hljs-string">"123"</span>&#125;);userList.push(&#123;name: <span class="hljs-string">"李四"</span>,pwd: <span class="hljs-string">"223"</span>&#125;);$.ajax(&#123;    type: <span class="hljs-string">"POST"</span>,    url: <span class="hljs-string">"$&#123;base.contextPath&#125;/user/index/add"</span>,    data: JSON.stringify(userList),<span class="hljs-comment">//将对象序列化成JSON字符串</span>    dataType:<span class="hljs-string">"json"</span>,    contentType : <span class="hljs-string">'application/json;charset=utf-8'</span>, <span class="hljs-comment">//设置请求头信息</span>    success: function(result)&#123;        …    &#125;,    error: function(result)&#123;        …    &#125;&#125;);<span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/index/add"</span>, method = RequestMethod.POST)<span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> ReturnMsg <span class="hljs-title">addOrEdit</span><span class="hljs-params">(@RequestBody List&lt;User&gt; userList)</span> </span>&#123;    …&#125;</code></pre><h3 id="接收Map"><a href="#接收Map" class="headerlink" title="接收Map"></a>接收Map</h3><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/index/add"</span>, method = RequestMethod.POST)  <span class="hljs-meta">@ResponseBody</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> ReturnMsg <span class="hljs-title">addOrEdit</span><span class="hljs-params">(@RequestBody List&lt;Map&lt;String,Object&gt;&gt; listMap)</span> </span>&#123;    …  &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ajax前后端交互</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.824（二）RPC and Threads</title>
    <link href="/2023/09/12/6.824%EF%BC%88%E4%BA%8C%EF%BC%89RPC%20and%20Threads/"/>
    <url>/2023/09/12/6.824%EF%BC%88%E4%BA%8C%EF%BC%89RPC%20and%20Threads/</url>
    
    <content type="html"><![CDATA[<h1 id="RPC-and-Threads"><a href="#RPC-and-Threads" class="headerlink" title="RPC and Threads"></a>RPC and Threads</h1><h2 id="Why-Use-Go"><a href="#Why-Use-Go" class="headerlink" title="Why Use Go?"></a>Why Use Go?</h2><ul><li>good support for threads  （对于线程的良好支持）</li><li>convenient RPC（方便的RPC调用包）</li><li>type safe（类型安全）</li><li>garbage-collected (no use after freeing problems)（拥有垃圾回收机制，不需要考虑内存释放的问题）</li><li>threads + GC is particularly attractive!（线程的使用方式配合GC非常有吸引力）</li><li>relatively simple（相比于C++更简单，相比于Java更简洁）</li></ul><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><br><h3 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h3><ul><li>线程是一个很有用但是却可能会很难用的结构化工具。在go语言中它被称作是goroutine，在其它语言中则被称作线程</li><li>程序可以用多个线程在同一时间做很多事情</li><li>每个线程拥有自己的状态，包括程序计数器，寄存器和栈，且线程间可以互相通讯</li></ul><br><h3 id="为什么使用线程"><a href="#为什么使用线程" class="headerlink" title="为什么使用线程"></a>为什么使用线程</h3><ul><li>分布式系统中必须实现的并发性<ul><li>I/O并发<ul><li>一个客户端同时向多个服务器发送请求并等待服务器的回复。</li><li>一个服务器同时处理多个客户端的请求。</li><li>当某个客户端请求被阻塞（比如等待数据读取）时，服务器可以处理另外一个客户端的请求</li></ul></li></ul></li><li>可以充分利用多核CPU的性能</li><li>更加的便利，如某些动作仅需要在后台执行即可（不希望把一些动作放到主程序中执行）</li></ul><br><h3 id="线程的替代方案"><a href="#线程的替代方案" class="headerlink" title="线程的替代方案"></a>线程的替代方案</h3><p>线程的使用会增加额外的编程难度，同时线程的创建和切换也会带来一定的开销，因此还有一种基于<code>事件驱动编程模型</code>，比如Windows系统中鼠标的点击，键盘的按下等，都是基于事件驱动实现的，即监听一个动作，监听到之后就去执行。</p><p>设想：我们经常会说Redis的主线程只有一个（为什么单线程的Redis那么快），那么Redis是否就使用了上述的<code>事件驱动编程模型</code>呢？</p><p>查阅了一番资料发现，果然和设想的一样，Redis的事件模型主要是两个，一个是监听<code>读</code>，一个是监听<code>写</code>，以此达到更高的执行效率，那么有没有最完美的性能实现方案？</p><p>答案是：合理控制线程数量，在<code>多线程的架构</code>基础上使用<code>事件驱动编程模型</code>。</p><br><h3 id="使用线程的挑战"><a href="#使用线程的挑战" class="headerlink" title="使用线程的挑战"></a>使用线程的挑战</h3><ul><li><p>数据共享：线程间数据可以通讯，因此在频繁读写中很容易造成线程竞争，导致数据不按预期的结果输出</p><p>可以通过加锁的方式解决</p><p>我们可以用过以下代码对Go程序进行检测，是否有变量在多线程中被使用</p><pre><code class="hljs go"><span class="hljs-keyword">go</span> run -race demo.<span class="hljs-keyword">go</span><span class="hljs-keyword">go</span> build -race demo.<span class="hljs-keyword">go</span></code></pre></li><li><p>线程间的相互协作</p><p>比如A线程需要等待B线程，又或者生产消费模型等等，这些在Java中有JUC包提供相应功能，在Go语言中可以使用channel, sync.Cond 或者 sync.WaitGroup来实现进程间的协作</p></li><li><p>死锁：通过加锁的方式解决数据共享问题容易产生新的死锁问题</p></li></ul><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><br><h3 id="RPC简介"><a href="#RPC简介" class="headerlink" title="RPC简介"></a>RPC简介</h3><ul><li>RPC = Remote Procedure Call，即远程过程调用。它是分布式系统得以实现的关键机制之一</li><li>为了客户端/服务器通信易于编程，隐藏网络协议的详细信息的方法</li></ul><br><h2 id="RPC可能会碰到的问题"><a href="#RPC可能会碰到的问题" class="headerlink" title="RPC可能会碰到的问题"></a>RPC可能会碰到的问题</h2><ul><li>可能会碰到诸如丢包，断网，服务器运行缓慢，服务器崩溃的情况</li><li>客户端并不知道远程服务器是否接收到了请求，是否正常返回结果：<ul><li>可能服务器没有收到请求。</li><li>可能服务器在发送响应之前崩溃了。</li><li>可能服务器在发送响应之前网络崩溃了。</li></ul></li></ul><br><h3 id="针对RPC调用问题的简单应对方案"><a href="#针对RPC调用问题的简单应对方案" class="headerlink" title="针对RPC调用问题的简单应对方案"></a>针对RPC调用问题的简单应对方案</h3><ul><li>客户端尝试等待响应一段时间</li><li>如果一段时间过后没有响应则重新发送之前的请求</li><li>重复几次上述两个步骤</li><li>如果仍然没有响应，放弃本次请求并返回错误信息</li><li>上述方案适用于只读的操作或者是重复运行对结果没有影响的操作（比如检查数据库的某条数据是否存在）</li></ul><br><h3 id="对RPC碰到的问题的更好的应对方案"><a href="#对RPC碰到的问题的更好的应对方案" class="headerlink" title="对RPC碰到的问题的更好的应对方案"></a>对RPC碰到的问题的更好的应对方案</h3><ul><li>服务器检查重复的客户端请求，并针对当前请求返回上次执行后的结果，而不用重复执行当前请求<ul><li>客户端可以在发送每个请求的时候加入一个唯一的id给服务器端进行检查</li></ul></li><li>如何设定id的值：<ul><li>每一个客户端有一个独立的id（可能是一个随机的大整数）</li><li>每一个客户端的RPC请求都有自己的序号</li><li>每一个客户端一次只能发送一个RPC请求，这样根据新请求的序列号，服务器可以丢掉所有之前发过来的序列号小于当前新请求序列号的请求</li></ul></li><li>当原本的请求还在执行时，服务器如何检查重复的请求：<ul><li>可以在执行每个RPC请求时加入标记，确定是等待还是忽略当前的请求</li></ul></li><li>如果服务器崩溃或者重启了：<ul><li>如果重复信息是放在内存里，服务器重启之后会重新处理重复的请求</li><li>可以考虑将重复的信息持久化到硬盘上</li><li>同时还可以考虑将持久化后的重复信息复制到备份服务器上</li></ul></li><li>GO的RPC库采用的就是上述的应对方案的简单形式：<ul><li>go的RPC只发送请求一次，所以服务器端看不到重复的请求</li><li>go的RPC调用如果没有收到响应则会返回错误</li></ul></li></ul><h2 id="持续脑图"><a href="#持续脑图" class="headerlink" title="持续脑图"></a>持续脑图</h2><p>文件分享地址：<a href="https://www.processon.com/view/link/5f1db0230791291b99680fa0" target="_blank" rel="noopener">https://www.processon.com/view/link/5f1db0230791291b99680fa0</a></p><p>![](6.824（二）RPC and Threads/5f1d524a7d9c0835d3923fe2.png)</p>]]></content>
    
    
    <categories>
      
      <category>分布式篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>6.824（二）RPC and Threads</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS网站变灰代码</title>
    <link href="/2023/09/12/CSS%E7%BD%91%E7%AB%99%E5%8F%98%E7%81%B0%E4%BB%A3%E7%A0%81/"/>
    <url>/2023/09/12/CSS%E7%BD%91%E7%AB%99%E5%8F%98%E7%81%B0%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="清明悼念"><a href="#清明悼念" class="headerlink" title="清明悼念"></a>清明悼念</h1><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>2020年4月4日，举国悼念，所有网站均变成灰色的CSS代码，如下：</p><pre><code class="hljs css"><span class="hljs-selector-class">.gray</span> &#123;    <span class="hljs-attribute">-webkit-filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);    <span class="hljs-attribute">-moz-filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);    <span class="hljs-attribute">-ms-filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);    <span class="hljs-attribute">-o-filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);    <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);    <span class="hljs-attribute">filter</span>: progid:DXImageTransform.Microsoft.<span class="hljs-built_in">BasicImage</span>(grayscale=<span class="hljs-number">1</span>);&#125;</code></pre><p>对body元素增加样式即可</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>“如果有后人来撰写今天的历史，那他们将发现没有任何文字词藻能够写尽这场灾难的残酷，也没有任何语言修辞能描述人类为生</p><p>存所付出的艰苦卓绝的努力。</p><p>我们将怀揣火种走过黑暗长夜，跨过战友的遗骸，踏过荆棘和深渊，最终在累累尸骨上重新点燃种族延续的火炬。</p><p>我知道你们并不需要历史来记载功勋，也无谓那些空虚华美的称颂。</p><p>只要山川河流、千万英灵，见证过我们前仆后继的跋涉和永不放弃的努力。”</p><p>​                                                                                                                                                                                                                                                <strong>—— 敬平凡的人类</strong></p>]]></content>
    
    
    <categories>
      
      <category>前端篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS网站变灰代码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docsify篇</title>
    <link href="/2023/09/12/Docsify%E7%AF%87/"/>
    <url>/2023/09/12/Docsify%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="Docsify"><a href="#Docsify" class="headerlink" title="Docsify"></a>Docsify</h1><p>docsify 是一个动态生成文档网站的工具。不同于 GitBook、Hexo 的地方是它不会生成将 .md 转成 .html 文件，所有转换工作都是在运行时进行。</p><p>这将非常实用，如果只是需要快速的搭建一个小型的文档网站，或者不想因为生成的一堆 .html 文件“污染” commit 记录，只需要创建一个 index.html 就可以开始写文档而且直接部署在 GitHub Pages。</p><h2 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h2><p><a href="https://docsify.js.org/#/zh-cn/quickstart" target="_blank" rel="noopener">https://docsify.js.org/#/zh-cn/quickstart</a></p><h2 id="提前准备"><a href="#提前准备" class="headerlink" title="提前准备"></a>提前准备</h2><blockquote><p>安装Node.js   进行相关配置即可</p></blockquote><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><pre><code class="hljs angelscript"><span class="hljs-number">1.</span>合适位置创建文件夹，作为根目录<span class="hljs-number">2.</span>文件夹下(cmd 当前文件夹)执行 npm i docsify-cli -g   <span class="hljs-number">3.</span>docsify init ./docs</code></pre><h2 id="开始写文档"><a href="#开始写文档" class="headerlink" title="开始写文档"></a><a href="https://docsify.js.org/#/zh-cn/quickstart?id=开始写文档" target="_blank" rel="noopener">开始写文档</a></h2><p>初始化成功后，可以看到 <code>./docs</code> 目录下创建的几个文件</p><ul><li><code>index.html</code> 入口文件</li><li><code>README.md</code> 会做为主页内容渲染</li><li><code>.nojekyll</code> 用于阻止 GitHub Pages 会忽略掉下划线开头的文件</li></ul><p>直接编辑 <code>docs/README.md</code> 就能更新网站内容</p><h2 id="个人建议的基本配置"><a href="#个人建议的基本配置" class="headerlink" title="个人建议的基本配置"></a>个人建议的基本配置</h2><blockquote><ol><li>开启封面，好看的封面</li><li>文档书写时注意一级，二级标题，图片等</li><li>必要位置的Logo，文档标题，html标题等等</li><li>开启全局搜索功能</li><li>代码高亮</li></ol></blockquote><h2 id="基本配置Demo"><a href="#基本配置Demo" class="headerlink" title="基本配置Demo"></a>基本配置Demo</h2><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Kerwin's Demo<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"IE=edge,chrome=1"</span> /&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"description"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"Description"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"vue.css"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"icon"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://img.alicdn.com/tfs/TB1kCs_er_I8KJjy1XaXXbsxpXa-419-495.png"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"image/png"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    <span class="hljs-built_in">window</span>.$docsify = &#123;</span><span class="actionscript">      name: <span class="hljs-string">'This is Kerwin Demo'</span>,</span><span class="actionscript">      repo: <span class="hljs-string">'Kerwin'</span>,</span><span class="actionscript">  coverpage: <span class="hljs-literal">true</span>,</span><span class="actionscript">  search: <span class="hljs-string">'auto'</span>,</span>  search : [<span class="actionscript">        <span class="hljs-string">'/'</span></span>  ],  search: &#123;<span class="actionscript">  placeholder: <span class="hljs-string">'搜索'</span>,</span><span class="actionscript">  noData: <span class="hljs-string">'No Results!'</span></span>  &#125;    &#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"docsify.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"//unpkg.com/docsify/lib/plugins/search.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"//unpkg.com/prismjs/components/prism-java.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"//unpkg.com/prismjs/components/prism-python.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"//unpkg.com/prismjs/components/prism-sql.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h2 id="GitHub部署"><a href="#GitHub部署" class="headerlink" title="GitHub部署"></a>GitHub部署</h2><p>网上搜索资料即可，比较简单</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><pre><code class="hljs 1c">docsify serve docs  <span class="hljs-comment">// 运行即可</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>工具篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docsify篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MarkDown画图篇</title>
    <link href="/2023/09/12/MarkDown%E7%94%BB%E5%9B%BE%E7%AF%87/"/>
    <url>/2023/09/12/MarkDown%E7%94%BB%E5%9B%BE%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="MarkDown画图技巧"><a href="#MarkDown画图技巧" class="headerlink" title="MarkDown画图技巧"></a>MarkDown画图技巧</h1><h2 id="横向流程图源码格式"><a href="#横向流程图源码格式" class="headerlink" title="横向流程图源码格式"></a>横向流程图源码格式</h2><pre><code class="hljs mermaid">graph LRA[方形] --&gt;B(圆角)  B --&gt; C&#123;条件a&#125;  C --&gt;|a&#x3D;1| D[结果1]  C --&gt;|a&#x3D;2| E[结果2]  C --&gt;|a&#x3D;3| B  F[横向流程图]</code></pre><h2 id="竖向流程图源码格式"><a href="#竖向流程图源码格式" class="headerlink" title="竖向流程图源码格式"></a>竖向流程图源码格式</h2><pre><code class="hljs mermaid">graph TDA[方形] --&gt;B(圆角)    B --&gt; C&#123;条件a&#125;    C --&gt;|a&#x3D;1| D[结果1]    C --&gt;|a&#x3D;2| E[结果2]    F[竖向流程图]</code></pre><h2 id="标准流程图源码格式"><a href="#标准流程图源码格式" class="headerlink" title="标准流程图源码格式"></a>标准流程图源码格式</h2><pre><code class="hljs flow">st&#x3D;&gt;start: 开始框op&#x3D;&gt;operation: 处理框cond&#x3D;&gt;condition: 判断框(是或否?)sub1&#x3D;&gt;subroutine: 子流程io&#x3D;&gt;inputoutput: 输入输出框e&#x3D;&gt;end: 结束框st-&gt;op-&gt;condcond(yes)-&gt;io-&gt;econd(no)-&gt;sub1(right)-&gt;op</code></pre><h2 id="注释画图实战"><a href="#注释画图实战" class="headerlink" title="注释画图实战"></a>注释画图实战</h2><pre><code class="hljs mermaid"> sequenceDiagram   Note over Boot: 启动类   Note over PDFThread: 线程类   Note over PDFWorker: 执行类 Boot-&gt;&gt;PDFThread: Boot类启动线程   PDFThread-&gt;&gt;PDFWorker: 线程类调用真正工作Worker   loop 队列处理       PDFThread-&gt;PDFThread: 考虑成功与失败情况处理方案   end      PDFWorker--&gt;&gt;PDFThread: Worker响应执行结果Note right of PDFWorker: 注意参数校验 &lt;br&#x2F;&gt;文件格式校验</code></pre>]]></content>
    
    
    <categories>
      
      <category>工具篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MarkDown画图篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MybatisCodeHelper篇</title>
    <link href="/2023/09/12/MybatisCodeHelper%E7%AF%87/"/>
    <url>/2023/09/12/MybatisCodeHelper%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="MybatisCodeHelper"><a href="#MybatisCodeHelper" class="headerlink" title="MybatisCodeHelper"></a>MybatisCodeHelper</h1><h2 id="什么是MybatisCodeHelper"><a href="#什么是MybatisCodeHelper" class="headerlink" title="什么是MybatisCodeHelper"></a>什么是MybatisCodeHelper</h2><ul><li><p>MyBatis-Plugin插件的功能简介如下.  </p></li><li><p>提供Mapper接口与配置文件中对应SQL的导航.</p></li><li><p>编辑XML文件时自动补全.</p></li><li><p>根据Mapper接口, 使用快捷键生成xml文件及SQL标签.</p></li><li><p>ResultMap中的property支持自动补全，支持级联(属性A.属性B.属性C).</p></li><li><p>快捷键生成@Param注解.</p></li><li><p>XML中编辑SQL时, 括号自动补全.</p></li><li><p>XML中编辑SQL时, 支持参数自动补全(基于@Param注解识别参数).</p></li><li><p>自动检查Mapper XML文件中ID冲突.</p></li><li><p>自动检查Mapper XML文件中错误的属性值.</p></li><li><p>支持Find Usage.</p></li><li><p>支持重构从命名.</p></li><li><p>支持别名.</p></li><li><p>自动生成ResultMap属性.</p></li><li><p>快捷键: Option + Enter(Mac) | Alt + Enter(Windows).   </p></li></ul><p>总的来说，这是一款功能非常强大的mybatis  IDEA插件</p><p>破解版参考个人百度云盘及onedrive存储</p><p>云盘：Java成神之路 / IDEA-Mybatis破解插件</p><p><strong><em>激活：随意输入内容即可激活</em></strong></p><p><strong><em>自动方法创建：需要预先定义  resultMap，Base_Column_List， 才能实现代码自动填充并生成（可以直接连接数据库生成所有，体验所有功能）</em></strong></p>]]></content>
    
    
    <categories>
      
      <category>IDEA插件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MybatisCodeHelper篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FastJson使用记录</title>
    <link href="/2023/09/12/FastJson%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/09/12/FastJson%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="FastJson-getBytes"><a href="#FastJson-getBytes" class="headerlink" title="FastJson getBytes"></a>FastJson getBytes</h1><blockquote><p>在使用FastJson过程中出现了</p><pre><code class="hljs java">Exception in thread <span class="hljs-string">"main"</span> com.alibaba.fastjson.JSONException: can not cast to <span class="hljs-keyword">int</span>, value : [-<span class="hljs-number">119</span>,<span class="hljs-number">80</span>,<span class="hljs-number">78</span>,<span class="hljs-number">71</span>,<span class="hljs-number">13</span>]</code></pre><p>异常，现来分析其报错原因</p></blockquote><h2 id="getBytes-异常"><a href="#getBytes-异常" class="headerlink" title="getBytes 异常"></a>getBytes 异常</h2><pre><code class="hljs java"><span class="hljs-comment">// ImgUtilApp 具备 byte[] 变量</span>ImgUtilApp imgUtilApp = <span class="hljs-keyword">new</span> ImgUtilApp();imgUtilApp.setBytes(bytes);<span class="hljs-comment">// FastJson</span>JSONObject fastJson = (JSONObject) JSON.toJSON(imgUtilApp);System.out.println(fastJson.getBytes(<span class="hljs-string">"bytes"</span>));<span class="hljs-comment">// 异常:</span>Exception in thread <span class="hljs-string">"main"</span> com.alibaba.fastjson.JSONException: can not cast to <span class="hljs-keyword">int</span>, value : [-<span class="hljs-number">119</span>,<span class="hljs-number">80</span>,<span class="hljs-number">78</span>,<span class="hljs-number">71</span>,<span class="hljs-number">13</span>]</code></pre><h2 id="getBytes-源码"><a href="#getBytes-源码" class="headerlink" title="getBytes 源码"></a>getBytes 源码</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] castToBytes(Object value) &#123;    <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-keyword">byte</span>[]) &#123;        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">byte</span>[])((<span class="hljs-keyword">byte</span>[])value);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> String) &#123;        <span class="hljs-keyword">return</span> IOUtils.decodeBase64((String)value);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> JSONException(<span class="hljs-string">"can not cast to int, value : "</span> + value);    &#125;&#125;<span class="hljs-comment">// 从代码可以看出只支持 byte[]类型获取，或者 String -&gt; Base64 转成 byte[]</span></code></pre><h2 id="正确使用方式"><a href="#正确使用方式" class="headerlink" title="正确使用方式"></a>正确使用方式</h2><pre><code class="hljs java">JSONObject fastJson = (JSONObject) JSON.toJSON(imgUtilApp);fastJson.put(<span class="hljs-string">"bytesDemo"</span>, bytes);System.out.println(fastJson.getBytes(<span class="hljs-string">"bytesDemo"</span>));<span class="hljs-comment">// 主动put byte[]类型，方可直接取出</span></code></pre><h2 id="问题产生原因"><a href="#问题产生原因" class="headerlink" title="问题产生原因"></a>问题产生原因</h2><ul><li>没有深刻认识标准JSON的数据结构，JsonObject，JsonArray，Inteager，String，Boolean…..</li><li>byte[] 在进行parse的时候会被主动解析成 JsonArray，因此它的类型已经被改变</li><li>看到 getBytes Api 想当然的以为和 getString 一样的顺滑，但是忽略了本身数据结构的特性导致该问题的产生</li></ul>]]></content>
    
    
    <categories>
      
      <category>Tips篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FastJson使用记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.824（一）初识分布式</title>
    <link href="/2023/09/12/6.824%EF%BC%88%E4%B8%80%EF%BC%89%E5%88%9D%E8%AF%86%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    <url>/2023/09/12/6.824%EF%BC%88%E4%B8%80%EF%BC%89%E5%88%9D%E8%AF%86%E5%88%86%E5%B8%83%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="初始分布式"><a href="#初始分布式" class="headerlink" title="初始分布式"></a>初始分布式</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本系列是源于<code>「码农翻身」</code>所属知识星球发起的读书活动，由大佬 <code>@我的UDP不丢包</code> 推荐而来，这次的读书活动有一些另类，我们抛弃了传统的书籍，开始攻略最高学府的研究生顶级课程 &lt;6.824&gt;，该课程是很多年前的蠕虫病毒发明者<code>Robert Morris</code>大佬授课，归属于<code>麻省理工大学</code>，授课方式主要是：视频 + Lab实验（Go语言） + 论文，全程英语，难度较大。</p><h2 id="分布式系统的判断依据"><a href="#分布式系统的判断依据" class="headerlink" title="分布式系统的判断依据"></a>分布式系统的判断依据</h2><ul><li>multiple cooperating computers （多台计算机协作）</li><li>storage for big web sites, MapReduce, peer-to-peer sharing （大规模数据集运算，如：MapReduce，或点对点共享）</li><li>lots of critical infrastructure is distributed （系统的绝大部分基础设施是分布式的）</li></ul><blockquote><p><code>MapReduce</code>：大规模数据集计算系统，比如计算从1加到1000亿，可以单台计算机计算，也可以利用该技术分散到多台计算机计算然后合并结果，极大的提高效率</p></blockquote><h2 id="为什么需要分布式系统"><a href="#为什么需要分布式系统" class="headerlink" title="为什么需要分布式系统"></a>为什么需要分布式系统</h2><ul><li>to increase capacity via parallelism （通过并行增加系统性能）</li><li>to tolerate faults via replication （通过复制备份增加系统容错）</li><li>to place computing physically close to external entities （可以将计算放在离外部实体更近的地方）</li><li>to achieve security via isolation （可以通过隔离增加系统的安全）</li></ul><blockquote><p><code>容错：</code>针对于容错，主要是两点，一是可用性，二是可恢复性</p><p>对于分布式系统来说，一般不会全部服务器同时瘫痪，因此无论是服务可用还是数据安全，都比单体服务更有保障。</p></blockquote><h2 id="分布式的难点"><a href="#分布式的难点" class="headerlink" title="分布式的难点"></a>分布式的难点</h2><ul><li>需要额外注意并发编程，对开发人员的能力要求直线上升</li><li>系统内的相互作用非常复杂</li><li>意想不到的错误：局部错误</li><li>预期性能和实际性能往往不符</li></ul><blockquote><p><code>局部错误</code>：假设一台机器每天出故障的概率是千分之一，在单体应用中，可能很长时间可以工作，但是在分布式系统中，设备数量急剧上升，每天都可能有设备出现故障，这就是所谓的局部错误，很难排查，也几乎无法避免</p></blockquote><p>此处展示一张单体应用和分布式应用的对比图，图片出自：《极客时间 · 左耳听风》</p><p><img src="/2023/09/12/6.824%EF%BC%88%E4%B8%80%EF%BC%89%E5%88%9D%E8%AF%86%E5%88%86%E5%B8%83%E5%BC%8F/8fecccec610626a3e348318b1fd17791.png" srcset="/img/loading.gif" alt></p><h2 id="分布式系统的解决方案"><a href="#分布式系统的解决方案" class="headerlink" title="分布式系统的解决方案"></a>分布式系统的解决方案</h2><h3 id="宏观目标"><a href="#宏观目标" class="headerlink" title="宏观目标"></a>宏观目标</h3><p>我们需要设计一系列能够屏蔽分布式系统复杂性的抽象</p><blockquote><p><code>为什么要设立此目标？</code></p><p>因为分布式系统本身已足够复杂，因此必须简化使用方式</p><p><code>简化使用方式和抽象有什么关系？</code></p><p>我目前认可的最完美抽象是：文件</p><p>“UNIX文件本质上就是一大袋字节。” —— 《UNIX编程艺术》</p><p>在Unix中，任何可读/写也就是有I/O的设备，无论是文件，socket，驱动，在打开设备之后都有一个对应的文件描述符。Unix将对这些设备的读写简化在read/write中，换言之，你只需要把打开的文件描述符传给这两个函数，操作系统内核知道如何根据这个文件描述符得到具体设备信息，内部隐藏了对各种设备进行读写的细节，所有这些对用户都是透明的，你只需要打开它，得到fd，再进行相应的操作就够了。</p></blockquote><h3 id="研究角度"><a href="#研究角度" class="headerlink" title="研究角度"></a>研究角度</h3><ul><li>实现方式。<ul><li>RPC远程调用，线程和并发控制</li></ul></li><li>性能：<ul><li>通常我们想要提供一个性能可以扩展的系统。</li><li>可以通过简单增加系统的电脑数量来增强并行能力，从而部分扩展系统的性能：<ul><li>当没有复杂交互的时候这么做很有效</li><li>可以不用请昂贵的程序员来重新设计系统。</li></ul></li><li>简单增加系统内电脑数量并不能一直增加系统性能：<ul><li>当电脑数量变得很多的时候，负载不均，系统内每台电脑性能不均，无法并行执行的代码，初始化的交互都会降低系统的性能。</li><li>来自共享资源的访问也会造成性能瓶颈，比如网络通讯或者数据库等</li></ul></li><li>同时性能也并不能总是靠增加系统内电脑数量达成：<ul><li>比如来自单一用户请求的快速响应时间</li><li>比如所有用户都想要更新同一个数据。</li><li>通常这些情况需要更好的程序设计而不是更多的电脑。</li></ul></li></ul></li><li>容错：<ul><li>大量的服务器 + 大型的系统通常代表着总有错误会发生</li><li>我们需要向应用程序隐藏这些错误</li><li>我们通常想要让系统拥有可用性和可恢复性<ul><li>可用性：即使错误发生了，系统还是可以继续运行</li><li>可恢复性：当错误被修复之后，系统可以恢复运行</li></ul></li><li>通常可以用备用的服务器来增加容错</li></ul></li><li>一致性：<ul><li>通常想要达成正确工作的系统十分困难：<ul><li>服务器和它的备份服务器之间很难保持一致，代价太高</li><li>客户端可能会在中途出错。</li><li>服务器可能会在处理之后回复之前崩溃</li><li>不佳的网络可能会使得正常的服务器无法提供服务</li></ul></li><li>一致性和性能通常是矛盾的：<ul><li>高一致性需要各种基础设置之间大量的通信</li><li>许多设计为了提升性能被迫只提供弱一致性</li></ul></li></ul></li></ul><blockquote><p><code>一致性</code>：一致性问题貌似是最难以解决的问题，因为它本质包含了性能，容错，数据一致性等等诸多要素</p><p>我们前文说过，为了考虑容错容灾机制，需要数据进行备份，那么在分布式系统中，A服务修改了A数据库的值，B数据库的值要不要跟着改，是立即跟着改，还是延迟跟着改，在同步修改中出问题了怎么办，在异步修改中出问题了怎么办</p><p>最终业界也很难解决相应的问题，因此现在主流的方式是：<code>最终一致性</code></p><p>即允许短时间内数据不一致，通过最终一致性保证性能和数据安全的兼顾</p></blockquote><h2 id="持续脑图"><a href="#持续脑图" class="headerlink" title="持续脑图"></a>持续脑图</h2><p>文件分享地址：<a href="https://www.processon.com/view/link/5f1db0230791291b99680fa0" target="_blank" rel="noopener">https://www.processon.com/view/link/5f1db0230791291b99680fa0</a></p><p><img src="/2023/09/12/6.824%EF%BC%88%E4%B8%80%EF%BC%89%E5%88%9D%E8%AF%86%E5%88%86%E5%B8%83%E5%BC%8F/5f1d524a7d9c0835d3923fe2.png" srcset="/img/loading.gif" alt></p><h2 id="下一章内容"><a href="#下一章内容" class="headerlink" title="下一章内容"></a>下一章内容</h2><p>接下来的一章，我们将进行 &lt;6.824&gt; 中的Lab 1，即实现一个简单的<code>MapReduce</code>系统，该系统将采用Go语言构建</p><p>Go语言是近些年非常热门的语言之一，其价值个人感觉大于被炒的火热的Python</p><h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><p>Go官方镜像站：<a href="https://golang.google.cn/dl/" target="_blank" rel="noopener">https://golang.google.cn/dl/</a></p><p>Go语言IDE：<a href="https://www.jetbrains.com/go/download/other.html" target="_blank" rel="noopener">https://www.jetbrains.com/go/download/other.html</a></p><p>Go语言环境搭建教程：<a href="https://www.cnblogs.com/qicun/p/11378354.html" target="_blank" rel="noopener">https://www.cnblogs.com/qicun/p/11378354.html</a></p><p>Go语言初识 + HelloWorld：<a href="https://devhints.io/go" target="_blank" rel="noopener">https://devhints.io/go</a></p><p>MIT课程表主页：<a href="https://pdos.csail.mit.edu/6.824/index.html" target="_blank" rel="noopener">https://pdos.csail.mit.edu/6.824/index.html</a></p><p>B站中文翻译视频地址：<a href="https://www.bilibili.com/video/BV1R7411t71W" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1R7411t71W</a></p><h2 id="本章要求"><a href="#本章要求" class="headerlink" title="本章要求"></a>本章要求</h2><ul><li>了解分布式系统的由来及面临的挑战</li><li>了解&lt;6.824&gt;课程中涉及的分布式系统解决方案</li><li>搭建Go语言环境，写出HelloWorld即可（语法层面及MR实现将在下章学习）</li></ul>]]></content>
    
    
    <categories>
      
      <category>分布式篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>6.824（一）初识分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PhantomJS篇</title>
    <link href="/2023/09/12/PhantomJS%E7%AF%87/"/>
    <url>/2023/09/12/PhantomJS%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="PhantomJS-篇"><a href="#PhantomJS-篇" class="headerlink" title="PhantomJS 篇"></a>PhantomJS 篇</h1><p>PhantomJS 组件常用在爬虫领域，但是它也有其非常灵活的一面，即用作截取网页长图，或者将网页内容存储为PDF</p><h2 id="PhantomJS-下载"><a href="#PhantomJS-下载" class="headerlink" title="PhantomJS 下载"></a>PhantomJS 下载</h2><p><a href="https://phantomjs.org/download.html" target="_blank" rel="noopener">地址</a></p><p><a href="https://phantomjs.org/api/webpage/" target="_blank" rel="noopener">API文档库</a></p><h2 id="Windows使用"><a href="#Windows使用" class="headerlink" title="Windows使用"></a>Windows使用</h2><p>下载完成后，直接解压即可直接进行使用，同时调用PhantomJS.exe时需要配合JS一同使用，以转出PNG图片或者PDF为例</p><pre><code class="hljs JS文件```">&#96;&#96;&#96;javascript&#x2F;&#x2F; JS -&gt; 可直接运行生成PDF或者PNG   HTML转PDF需求解决方案：HTML -&gt; PNG -&gt; PDF或者HTML -&gt; PDFvar page &#x3D; require(&#39;webpage&#39;).create(),    system &#x3D; require(&#39;system&#39;),    address, output, size;if (system.args.length &lt; 3 || system.args.length &gt; 5) &#123;    console.log(&#39;Usage: rasterize.js URL filename&#39;);    phantom.exit(1);&#125; else &#123;&#x2F;&#x2F; 目标地址    address &#x3D; system.args[1];&#x2F;&#x2F; 输出地址    output  &#x3D; system.args[2];&#x2F;&#x2F; 尺寸 1200*7000size    &#x3D; system.args[3].split(&#39;*&#39;);    console.log(page.settings.userAgent );page.settings.loadImages &#x3D; true;    page.paperSize &#x3D; &#123;width: size[0], height: size[1], orientation: &#39;portrait&#39;, border: &#39;0.5cm&#39; &#125;;    console.log(&quot;open page now&quot;);    page.open(address, function (status) &#123;        console.log(status);        &#x2F;&#x2F; 预留一定的渲染时间        window.setTimeout(function () &#123;            page.render(output);            page.close();            console.log(&#39;Render ok&#39;);            phantom.exit();        &#125;, 3000);    &#125;);&#125;;</code></pre><pre><code class="hljs 命令如下```">&#96;&#96;&#96;shellF:\browsers\phantomjs-2.1.1-windows\bin&gt;phantomjs.exe html2pdf.js &quot;参数一:URL&quot; &quot;参数二:输出文件地址可以为xxx.png或者xxx.pdf&quot; &quot;尺寸如:1200*6500&quot;</code></pre><blockquote><p>命令参数根据JS文件调整即可  输出文件为 .pdf 即输出PDF文件，为.png即输出截图图片</p><p>与此同时JS文件中的尺寸大小可以直接调整为如A4纸等等</p></blockquote><h2 id="JS文件Tips"><a href="#JS文件Tips" class="headerlink" title="JS文件Tips"></a>JS文件Tips</h2><pre><code class="hljs javascript"><span class="hljs-comment">// 如果想要强行对PDF内容进行分页，对需要分页的内容增加以下样式即可</span>.pdf-page &#123;page-<span class="hljs-keyword">break</span>-before: always;page-<span class="hljs-keyword">break</span>-after: always;page-<span class="hljs-keyword">break</span>-inside: avoid;&#125;</code></pre><h2 id="Linux环境使用"><a href="#Linux环境使用" class="headerlink" title="Linux环境使用"></a>Linux环境使用</h2><p>PhantomJS 安装步骤：</p><ul><li>下载安装包并解压</li><li>安装依赖软件： yum -y install wget fontconfig</li><li>设置环境变量：ln -s /目标地址/bin   /usr/bin/</li><li>phantomjs -v 检测是否安装成功</li><li>安装中文字体：<br>centos中执行 ：yum install bitmap-fonts bitmap-fonts-cjk<br>ubuntu中执行：sudo apt-get install ttf-wqy-zenhei              #文泉驿-正黑 （全平台兼容字体）</li></ul><p>其余使用方式同windows一致，通过 phantomjs xxx.js 参数一 参数二….</p><p>值得注意的是：Linux的PDF渲染效果不如Windows,Mac好</p><h2 id="PNG图片转PDF代码技巧"><a href="#PNG图片转PDF代码技巧" class="headerlink" title="PNG图片转PDF代码技巧"></a>PNG图片转PDF代码技巧</h2><blockquote><p>可以直接将PNG图片完美塞入到PDF中，缺点即不可直接复制文字</p></blockquote><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 生成PDF --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.itextpdf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>itextpdf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.5.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PDFUtils</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">imgToPdf</span> <span class="hljs-params">(String imgUrl, String pdfUrl)</span> <span class="hljs-keyword">throws</span> IOException, DocumentException </span>&#123;        Document doc = <span class="hljs-keyword">new</span> Document(PageSize.A4, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>);        PdfWriter.getInstance(doc, <span class="hljs-keyword">new</span> FileOutputStream(pdfUrl));        doc.open();        <span class="hljs-comment">// Img</span>        Image png = Image.getInstance(imgUrl);        png.setAlignment(Image.MIDDLE);        doc.setPageSize(<span class="hljs-keyword">new</span> Rectangle(png.getPlainWidth(), png.getPlainHeight() + <span class="hljs-number">300F</span>));        doc.newPage();        doc.add(png);        doc.close();    &#125;&#125;</code></pre><h2 id="中文乱码问题"><a href="#中文乱码问题" class="headerlink" title="中文乱码问题"></a>中文乱码问题</h2><p>在使用Ubuntu服务器作为截图以及渲染PDF介质时，会遇到很坑的中文乱码问题，一般解决办法是下载安装文泉驿宋体，但是经过</p><p>测试，在苹果手机，电脑等依然会是乱码，因此针对ubuntu服务器，可以使用文泉驿正黑字体解决乱码问题：</p><pre><code class="hljs shell">sudo apt-get install ttf-wqy-zenhei      #文泉驿-正黑 （全平台兼容字体）</code></pre><p>Ubuntu如果需要安装其他字体，参考步骤：</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 安装字体管理工具</span>sudo apt-get install font-manager<span class="hljs-meta">#</span><span class="bash"> 查看现有字体（可查看到字体安装位置）</span>fc-list</code></pre><p>安装字体：</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 安装字体</span><span class="hljs-meta">#</span><span class="bash"> 方式一：</span><span class="hljs-meta">#</span><span class="bash"> 在/usr/share/fonts目录下，新建如 chinese文件夹，将需要的tff文件复制进文件夹，如微软雅黑等</span><span class="hljs-meta">#</span><span class="bash"> 然后执行如下命令：</span>mkfontscalemkfontdirfc-cache -fv （刷新字体缓存）<span class="hljs-meta">#</span><span class="bash"> 方式二，通过软件安装：</span>sudo apt-get install ttf-wqy-microhei   #文泉驿-微米黑sudo apt-get install ttf-wqy-zenhei     #文泉驿-正黑 （全平台兼容字体）sudo apt-get install xfonts-wqy         #文泉驿-点阵宋体<span class="hljs-meta">#</span><span class="bash"> 注意通过软件安装的方式，其实也是在/usr/share/fonts目录下新建了文件夹并移入了tff字体，因此卸载逻辑和下面一致</span></code></pre><p>卸载字体：</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 卸载字体的方式非常简单，例如我们新建了chinese目录，只需要 rm -rf ....chinese（包含字体的目录）</span><span class="hljs-meta">#</span><span class="bash"> 再刷新字体缓存即可</span>rm -rf /usr/share/fonts/demofc-cache -fv</code></pre>]]></content>
    
    
    <categories>
      
      <category>工具篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PhantomJS篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>限流篇</title>
    <link href="/2023/09/12/%E9%99%90%E6%B5%81%E7%AF%87/"/>
    <url>/2023/09/12/%E9%99%90%E6%B5%81%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="请求限流"><a href="#请求限流" class="headerlink" title="请求限流"></a>请求限流</h1><p><strong>开发高并发系统时，有三把利器用来保护系统：缓存、降级和限流</strong></p><p><strong>通过限流，我们可以很好地控制系统的qps，从而达到保护系统的目的。</strong></p><h2 id="计数算法（不常用）"><a href="#计数算法（不常用）" class="headerlink" title="计数算法（不常用）"></a>计数算法（不常用）</h2><pre><code class="hljs java"><span class="hljs-comment">// 模拟的伪代码</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    AtomicLong atomicLong = <span class="hljs-keyword">new</span> AtomicLong(<span class="hljs-number">0L</span>);    <span class="hljs-keyword">long</span> interval = <span class="hljs-number">1000</span>;    <span class="hljs-keyword">long</span> maxNums  = <span class="hljs-number">50</span>;    String request = <span class="hljs-string">"/test/app"</span>;    <span class="hljs-keyword">long</span> targetTime = System.currentTimeMillis();    <span class="hljs-keyword">int</span> pass = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> fail = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;        <span class="hljs-keyword">boolean</span> response = getResponse(targetTime, interval, atomicLong, maxNums, request);        <span class="hljs-keyword">if</span> (response) &#123;            pass++;        &#125; <span class="hljs-keyword">else</span> &#123;            fail++;        &#125;        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">200</span>) &#123;            Thread.sleep(<span class="hljs-number">1000</span>);        &#125;    &#125;    System.out.println(<span class="hljs-string">"Pass: "</span> + pass + <span class="hljs-string">"  fail: "</span> + fail);&#125;<span class="hljs-comment">/***</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> targetTime  请求时间</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> interval    间隔时间</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> atomicLong  计数器</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> maxNums     最大请求量</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> request     请求|模拟接口名</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 计数器算法 - 故名思意</span><span class="hljs-comment"> * 通过一段时间内对指定接口进行计数，判断是否超过最大限制</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">getResponse</span> <span class="hljs-params">(<span class="hljs-keyword">long</span> targetTime, <span class="hljs-keyword">long</span> interval, AtomicLong atomicLong, <span class="hljs-keyword">long</span> maxNums, String request)</span> </span>&#123;    <span class="hljs-keyword">long</span> now = System.currentTimeMillis();    <span class="hljs-keyword">if</span> (targetTime &lt;= now &amp;&amp; now &lt;= targetTime + interval) &#123;        <span class="hljs-keyword">long</span> index = atomicLong.getAndAdd(<span class="hljs-number">1</span>);        <span class="hljs-keyword">return</span> index &lt;= maxNums;    &#125; <span class="hljs-keyword">else</span> &#123;        atomicLong.set(<span class="hljs-number">0L</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre><blockquote><p>计数算法的实现和我们想当然的结果一致，比如 15s - 16s 这个区间，我们想当然的以某一次请求为起点，比如15s，则设置间隔为1秒，通过判断请求时间是否在 15 - 16 之间，如果在则累加，判断是否超过最大限制，不在则数据重置</p><p>但它存在的致命的问题即：</p><ol><li>无法归纳出下一次请求对上一次请求的时间变化  这点是不合理的</li><li>由于原因1的影响，用户很有可能在 15.59999的极限请求100次，在16.00001的极限请求100次</li></ol><p><img src="/2023/09/12/%E9%99%90%E6%B5%81%E7%AF%87/4f9b2b97db30494a5b2f0a1da9560451" srcset="/img/loading.gif" alt="2016-09-01_20:35:21.jpg"></p><p>因此: 计数算法存在严重的临界值问题，原因是由于计数依据 -&gt; 时间导致的</p></blockquote><h2 id="滑动窗口（不常用）"><a href="#滑动窗口（不常用）" class="headerlink" title="滑动窗口（不常用）"></a>滑动窗口（不常用）</h2><p>滑动窗口的本质和计数一致，只不过通过把一个时间分区，即扩大精度，让请求数量的计算更加合理</p><p><img src="/2023/09/12/%E9%99%90%E6%B5%81%E7%AF%87/270324-20180926164034427-1114283823.jpg" srcset="/img/loading.gif" alt="img"></p><blockquote><p>在上图中，整个红色的矩形框表示一个时间窗口，在我们的例子中，一个时间窗口就是一分钟。然后我们将时间窗口进行划分，比如图中，我们就将滑动窗口 划成了6格，所以每格代表的是10秒钟。每过10秒钟，我们的时间窗口就会往右滑动一格。每一个格子都有自己独立的计数器counter，比如当一个请求 在0:35秒的时候到达，那么0:30~0:39对应的counter就会加1。</p><p>那么滑动窗口怎么解决刚才的临界问题的呢？我们可以看上图，0:59到达的100个请求会落在灰色的格子中，而1:00到达的请求会落在橘黄色的格 子中。当时间到达1:00时，我们的窗口会往右移动一格，那么此时时间窗口内的总请求数量一共是200个，超过了限定的100个，所以此时能够检测出来触发了限流</p></blockquote><h2 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h2><p><img src="/2023/09/12/%E9%99%90%E6%B5%81%E7%AF%87/285763-20171204115253966-2047866938.png" srcset="/img/loading.gif" alt="img"></p><blockquote><p>漏桶算法有<strong>两种</strong>实现:</p><p>一，<strong>不允许突发流量的情况</strong>，即以速率为标准是否进行限流</p><p>二,  <strong>允许突发流量的情况</strong>，即以容量为标准是否进行限流（<code>这样请求其实在等待，因此处理速率是定值，一般不采用</code>）</p><p>但无论啥哪种方式，漏水的速率是一定的，因此我们说 —》漏桶算法可以<strong>平滑网络上的突发流量</strong>（对于突发处理效率一般）</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">// 模拟的伪代码 -&gt; 允许突发流量</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LeakyBucket</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        Integer pass = <span class="hljs-number">0</span>;        Integer fail = <span class="hljs-number">0</span>;        Bucket bucket = <span class="hljs-keyword">new</span> Bucket();        bucket.start();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;            Integer num = Bucket.current;            <span class="hljs-keyword">if</span> (num++ &lt; Bucket.maxValue) &#123;                Bucket.current++;                pass++;            &#125; <span class="hljs-keyword">else</span> &#123;                fail++;            &#125;            Thread.sleep(<span class="hljs-number">50</span>);        &#125;        System.out.println(<span class="hljs-string">"Pass: "</span> + pass + <span class="hljs-string">" fail: "</span> + fail);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bucket</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;        <span class="hljs-comment">// 容量</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Integer maxValue = <span class="hljs-number">20</span>;        <span class="hljs-comment">// 速率 3次/s</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Integer rate     = <span class="hljs-number">3</span>;        <span class="hljs-comment">// 当前量</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Integer current  = <span class="hljs-number">0</span>;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    Thread.sleep(<span class="hljs-number">1000</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                <span class="hljs-keyword">if</span> (current &gt; <span class="hljs-number">0</span>) &#123;                    current = Math.max(<span class="hljs-number">0</span>, current -= rate);                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h2><p>和漏桶算法相反，令牌桶算法的本质是，有一个令牌的桶，以恒定的速率（变种算法也可以根据情况改变速率）往一个桶里面丢令牌，如果可以获取到令牌，则可执行，否则被限流等待</p><pre><code class="hljs 好处：可以很好的解决突发情况```">![1570512804791](限流篇&#x2F;1570512804791.png)## 轮子 -&gt; Guava RateLimiter&#96;&#96;&#96;xml &lt;!-- guava库 --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.google.guava&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;guava&lt;&#x2F;artifactId&gt;    &lt;version&gt;27.0.1-jre&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre><pre><code class="hljs java"><span class="hljs-comment">// RateLimiter具有预消费的能力 -&gt; 即可以一次性拿走超过当前最大令牌的数量，但是下次等待时间会额外增加</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GuavaRateLimiter</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;                <span class="hljs-comment">// 线程池</span>        ExecutorService exec = Executors.newCachedThreadPool();        <span class="hljs-comment">// 速率是每秒只有3个许可</span>        <span class="hljs-keyword">final</span> RateLimiter rateLimiter = RateLimiter.create(<span class="hljs-number">3.0</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> no = i;            Runnable runnable = () -&gt; &#123;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-comment">//获取许可</span>                    rateLimiter.acquire();                    System.out.println(<span class="hljs-string">"Accessing: "</span> + no + <span class="hljs-string">",time:"</span> + <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"yy-MM-dd HH:mm:ss"</span>).format(<span class="hljs-keyword">new</span> Date()));                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;;                        <span class="hljs-comment">//执行线程</span>            exec.execute(runnable);        &#125;                <span class="hljs-comment">//退出线程池</span>        exec.shutdown();    &#125;&#125;</code></pre><blockquote><p>根据令牌桶算法，桶中的令牌是持续生成存放的，有请求时需要先从桶中拿到令牌才能开始执行，谁来持续生成令牌存放呢？</p><p>一种解法是，开启一个定时任务，由定时任务持续生成令牌。这样的问题在于会极大的消耗系统资源，如，某接口需要分别对每个用户做访问频率限制，假设系统中存在6W用户，则至多需要开启6W个定时任务来维持每个桶中的令牌数，这样的开销是巨大的。</p><p>另一种解法则是延迟计算，其实现思路为，若当前时间晚于nextFreeTicketMicros，则计算该段时间内可以生成多少令牌，将生成的令牌加入令牌桶中并更新数据。这样一来，只需要在获取令牌时计算一次即可</p></blockquote><h2 id="分布式限流"><a href="#分布式限流" class="headerlink" title="分布式限流"></a>分布式限流</h2><blockquote><p>分布式环境下限流方案</p><p>如nginx 采取 hash ip策略，则用单机方式可以</p><p>如轮询策略，则可以借用第三方实现分布式限流，如 redis  -&gt; 基本思路即利用 lua 脚本，通过原子性的方式获取请求是否超过限制    lua脚本逻辑也很简单，即利用redis的 过期设置key-value</p></blockquote><pre><code class="hljs lua"><span class="hljs-comment">-- Demo: 下标从 1 开始</span><span class="hljs-keyword">local</span> key = KEYS[<span class="hljs-number">1</span>]<span class="hljs-keyword">local</span> now = <span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">1</span>])<span class="hljs-keyword">local</span> ttl = <span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">2</span>])<span class="hljs-keyword">local</span> expired = <span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">3</span>])<span class="hljs-comment">-- 最大访问量</span><span class="hljs-keyword">local</span> <span class="hljs-built_in">max</span> = <span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">4</span>])<span class="hljs-comment">-- 清除过期的数据</span><span class="hljs-comment">-- 移除指定分数区间内的所有元素，expired 即已经过期的 score</span><span class="hljs-comment">-- 根据当前时间毫秒数 - 超时毫秒数，得到过期时间 expired</span>redis.call(<span class="hljs-string">'zremrangebyscore'</span>, key, <span class="hljs-number">0</span>, expired)<span class="hljs-comment">-- 获取 zset 中的当前元素个数</span><span class="hljs-keyword">local</span> current = <span class="hljs-built_in">tonumber</span>(redis.call(<span class="hljs-string">'zcard'</span>, key))<span class="hljs-keyword">local</span> <span class="hljs-built_in">next</span> = current + <span class="hljs-number">1</span><span class="hljs-keyword">if</span> <span class="hljs-built_in">next</span> &gt; <span class="hljs-built_in">max</span> <span class="hljs-keyword">then</span>  <span class="hljs-comment">-- 达到限流大小 返回 0</span>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">else</span>  <span class="hljs-comment">-- 往 zset 中添加一个值、得分均为当前时间戳的元素，[value,score]</span>  redis.call(<span class="hljs-string">"zadd"</span>, key, now, now)  <span class="hljs-comment">-- 每次访问均重新设置 zset 的过期时间，单位毫秒</span>  redis.call(<span class="hljs-string">"pexpire"</span>, key, ttl)  <span class="hljs-keyword">return</span> <span class="hljs-built_in">next</span><span class="hljs-keyword">end</span></code></pre><pre><code class="hljs java"><span class="hljs-comment">// 调用方法Demo 仅仅举例而已 对应上述lua脚本</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldLimited</span><span class="hljs-params">(String key, <span class="hljs-keyword">long</span> max, <span class="hljs-keyword">long</span> timeout, TimeUnit timeUnit)</span> </span>&#123;    <span class="hljs-comment">// 最终的 key 格式为：</span>    <span class="hljs-comment">// limit:自定义key:IP</span>    <span class="hljs-comment">// limit:类名.方法名:IP</span>    key = REDIS_LIMIT_KEY_PREFIX + key;    <span class="hljs-comment">// 统一使用单位毫秒</span>    <span class="hljs-keyword">long</span> ttl = timeUnit.toMillis(timeout);    <span class="hljs-comment">// 当前时间毫秒数</span>    <span class="hljs-keyword">long</span> now = Instant.now().toEpochMilli();    <span class="hljs-keyword">long</span> expired = now - ttl;    <span class="hljs-comment">// 注意这里必须转为 String,否则会报错 java.lang.Long cannot be cast to java.lang.String</span>    Long executeTimes = stringRedisTemplate.execute(limitRedisScript, Collections.singletonList(key), now + <span class="hljs-string">""</span>, ttl + <span class="hljs-string">""</span>, expired + <span class="hljs-string">""</span>, max + <span class="hljs-string">""</span>);    <span class="hljs-keyword">if</span> (executeTimes != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">if</span> (executeTimes == <span class="hljs-number">0</span>) &#123;            log.error(<span class="hljs-string">"【&#123;&#125;】在单位时间 &#123;&#125; 毫秒内已达到访问上限，当前接口上限 &#123;&#125;"</span>, key, ttl, max);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            log.info(<span class="hljs-string">"【&#123;&#125;】在单位时间 &#123;&#125; 毫秒内访问 &#123;&#125; 次"</span>, key, ttl, executeTimes);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><blockquote><p>在接口请求时候，我们可以用上述的算法控制限流，在代码层，如批量生成excel文件等业务中，为了避免同一时间文件产生过多导致IO，CPU飙增，也可以用限流的思路，通过JUC的信号量控制线程的数量，达到类似限流的目的</p></blockquote><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p>开源中国：<a href="https://segmentfault.com/a/1190000012875897" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012875897</a></p><p>简书：<a href="https://www.jianshu.com/p/5d4fe4b2a726" target="_blank" rel="noopener">https://www.jianshu.com/p/5d4fe4b2a726</a></p><p>掘金：<a href="https://juejin.im/post/5d8036a3e51d4561ff6668c3" target="_blank" rel="noopener">https://juejin.im/post/5d8036a3e51d4561ff6668c3</a></p><p>GitHub：限流Demo</p><ul><li><a href="https://github.com/xkcoding/spring-boot-demo?utm_source=gold_browser_extension" target="_blank" rel="noopener">https://github.com/xkcoding/spring-boot-demo?utm_source=gold_browser_extension</a></li><li><a href="https://github.com/kkzhilu/KerwinBoots/tree/boot_ratelimit_guava" target="_blank" rel="noopener">https://github.com/kkzhilu/KerwinBoots/tree/boot_ratelimit_guava</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>限流篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跨域问题</title>
    <link href="/2023/09/12/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    <url>/2023/09/12/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="前端交互篇-跨域"><a href="#前端交互篇-跨域" class="headerlink" title="前端交互篇 - 跨域"></a>前端交互篇 - 跨域</h1><h2 id="SpringBoot-Cors解决跨域问题-本地请求其他域名时cookie无法传输"><a href="#SpringBoot-Cors解决跨域问题-本地请求其他域名时cookie无法传输" class="headerlink" title="SpringBoot - Cors解决跨域问题 - 本地请求其他域名时cookie无法传输"></a>SpringBoot - Cors解决跨域问题 - 本地请求其他域名时cookie无法传输</h2><pre><code class="hljs java">SpringBoot 利用Cors解决跨域问题<span class="hljs-number">1</span>.依赖&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;<span class="hljs-number">2</span>.WebConfig配置类<span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCorsMappings</span><span class="hljs-params">(CorsRegistry registry)</span> </span>&#123;        registry.addMapping(<span class="hljs-string">"/**"</span>)               <span class="hljs-comment">// 表示本应用的所有方法都会去处理跨域请求</span>                .allowedOrigins(<span class="hljs-string">"*"</span>)             <span class="hljs-comment">// 例如允许：http://localhost:8081请求</span>                .allowedMethods(<span class="hljs-string">"*"</span>)             <span class="hljs-comment">// 表示允许通过的请求数</span>                .allowedHeaders(<span class="hljs-string">"*"</span>)             <span class="hljs-comment">// 表示允许通过的请求头</span>                .allowCredentials(<span class="hljs-keyword">true</span>);         <span class="hljs-comment">// 允许前端传递cookie</span>    &#125;&#125;<span class="hljs-number">3</span>.HTML测试代码&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=<span class="hljs-string">"utf-8"</span>&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body onload=<span class="hljs-string">"testCors()"</span>&gt;&lt;/body&gt;&lt;script src="js/jquery-3.2.1.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;&lt;script type=<span class="hljs-string">"text/javascript"</span>&gt;<span class="hljs-function">function <span class="hljs-title">testCors</span><span class="hljs-params">()</span> </span>&#123;$.ajax(&#123;   type:<span class="hljs-string">'POST'</span>,   url:<span class="hljs-string">'http://127.0.0.1:10909/apis/test'</span>,   xhrFields:&#123;withCredentials:<span class="hljs-keyword">true</span>&#125;,   success:function(result)&#123;alert(result)   &#125;,       error: function (err) &#123;       alert(<span class="hljs-string">"异常"</span>)       &#125;   &#125;); &#125;&lt;/script&gt;&lt;/html&gt;</code></pre><h2 id="过滤器-CROS协议"><a href="#过滤器-CROS协议" class="headerlink" title="过滤器- CROS协议"></a>过滤器- CROS协议</h2><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@WebFilter</span>(filterName = <span class="hljs-string">"corsFilter"</span>, urlPatterns = <span class="hljs-string">"/*"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CorsFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest req, ServletResponse res, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        HttpServletResponse response = (HttpServletResponse) servletResponse;        HttpServletRequest reqs = (HttpServletRequest) servletRequest;        String origin = reqs.getHeader(<span class="hljs-string">"Origin"</span>);        <span class="hljs-keyword">if</span>(StringUtils.isEmpty(origin)) &#123;            origin = reqs.getHeader(<span class="hljs-string">"Referer"</span>);        &#125;        response.setHeader(<span class="hljs-string">"Access-Control-Allow-Origin"</span>, origin);        response.setHeader(<span class="hljs-string">"Access-Control-Allow-Credentials"</span>, <span class="hljs-string">"true"</span>);        response.setHeader(<span class="hljs-string">"Access-Control-Allow-Methods"</span>, <span class="hljs-string">"POST, GET, OPTIONS, DELETE"</span>);        response.setHeader(<span class="hljs-string">"Access-Control-Max-Age"</span>, <span class="hljs-string">"3600"</span>);        response.setHeader(<span class="hljs-string">"Access-Control-Allow-Headers"</span>, <span class="hljs-string">"Origin, No-Cache, X-Requested-With, If-Modified-Since, Pragma, Last-Modified, Cache-Control, Expires, Content-Type, X-E4M-With,Authorization,Token"</span>);        filterChain.doFilter(servletRequest, servletResponse);    &#125;&#125;<span class="hljs-comment">// 重点 cookie处设置 根目录 -&gt; nginx,com结尾网站都可用</span>Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">"auth_todo_token"</span>, MD5Util.MD5(username+password)+MD5Util.MD5(password+username));cookie.setPath(<span class="hljs-string">"/"</span>);cookie.setDomain(<span class="hljs-string">"nginx.com"</span>);<span class="hljs-comment">// 重点：本地开发host配置 -&gt; 正式上线后项目Domain依据真实后缀修改即可</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>    test.nginx.com<span class="hljs-number">47.93</span><span class="hljs-number">.6</span><span class="hljs-number">.66</span>   server.nginx.com<span class="hljs-comment">// Html - Ajax请求：</span>$.ajax(&#123;type:<span class="hljs-string">'POST'</span>,url:<span class="hljs-string">'http://server.nginx.com:10909/apis/loginAccess'</span>,<span class="hljs-comment">// 重点：携带跨域cookie</span>xhrFields: &#123;withCredentials: <span class="hljs-keyword">true</span>&#125;,.....&#125;);</code></pre><h2 id="最佳方案-Nginx解决跨域问题"><a href="#最佳方案-Nginx解决跨域问题" class="headerlink" title="最佳方案 - Nginx解决跨域问题"></a>最佳方案 - Nginx解决跨域问题</h2><pre><code class="hljs java">跨域问题产生原因: 域名[主域名与子域名也算]不同端口不同协议不同特注：Ip与域名之间网络交互，也属于跨域，如：<span class="hljs-number">123.23</span><span class="hljs-number">.23</span><span class="hljs-number">.12</span> 和 www.a.com因此通过nginx进行反向代理解决该问题如: nginx部署静态资源 -&gt; 地址为 <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>/html/index.html                       接口地址为： <span class="hljs-number">111.111</span><span class="hljs-number">.111</span><span class="hljs-number">.111</span>:<span class="hljs-number">8080</span>/apis/test                       则可以通过nginx 将<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> 配置前缀的方式代理真实接口地址即：<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>/apis<span class="hljs-comment">/* ===&gt;  111.111.111.111:8080/apis/test</span><span class="hljs-comment"></span><span class="hljs-comment">然后本地界面请求即不会产生跨域问题, 部署详情见nginx篇</span></code></pre><h2 id="升级方案-oauth2-0"><a href="#升级方案-oauth2-0" class="headerlink" title="升级方案 - oauth2.0"></a>升级方案 - oauth2.0</h2><blockquote><p>JWT的思路，即无状态用户认证</p></blockquote><pre><code class="hljs java">利用oauth2<span class="hljs-number">.0</span> token验证的方式, 网关层代理及nginx代理解决跨域问题和权限验证的问题</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>跨域问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GiHub下载过慢解决办法</title>
    <link href="/2023/09/12/GiHub%E4%B8%8B%E8%BD%BD%E8%BF%87%E6%85%A2%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <url>/2023/09/12/GiHub%E4%B8%8B%E8%BD%BD%E8%BF%87%E6%85%A2%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="GiHub下载过慢解决办法"><a href="#GiHub下载过慢解决办法" class="headerlink" title="GiHub下载过慢解决办法"></a>GiHub下载过慢解决办法</h1><h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><p>传统的由Gitee复制镜像、从Gitee拉取</p><h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><p>切换网络连接为手机移动网络，可以显著提速</p><h2 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h2><p>切换IP映射（效果较差）</p>]]></content>
    
    
    <categories>
      
      <category>Tips篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GiHub下载过慢解决办法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kerwin&#39;s Open Source</title>
    <link href="/2023/09/12/Kerwin&#39;s%20Open%20Source/"/>
    <url>/2023/09/12/Kerwin&#39;s%20Open%20Source/</url>
    
    <content type="html"><![CDATA[<h1 id="Kerwin’s-Open-Source"><a href="#Kerwin’s-Open-Source" class="headerlink" title="Kerwin’s Open Source"></a>Kerwin’s Open Source</h1><h2 id="Open-Source"><a href="#Open-Source" class="headerlink" title="Open Source"></a>Open Source</h2><h3 id="08-23-会议纪要"><a href="#08-23-会议纪要" class="headerlink" title="08.23 会议纪要"></a>08.23 会议纪要</h3><p>本项目核心的目标：</p><ol><li>作为国内国外的开源项目桥梁，把好的国外项目翻译引进，把好的国内项目翻译并推出</li><li>促进国内的开源氛围，做开源社区</li></ol><p>梳理本周进度及下周进度，注意点：</p><ol><li>优弧负责项目入选标准，以及人员招募，翻译项目流程机制</li><li>小蝴蝶负责开源计划和翻译计划的奖励机制等</li><li>小帅，xmanlin，尤毅 负责标签分类细节等</li><li>老王和俊宁继续装修项目以及整理好卡片模块，必要时俊宁可以切过去协助翻译相关事情</li><li>俊宁还需负责github机器人的调研</li><li>Kerwin负责确定最终项目输出的版式，以及利用代码对项目进行合并，分类，以及issues模板，issues标签模板，安抚已提交自荐的人员</li></ol><p>所有人需要完成的事：</p><ol><li>各自输出一篇开源项目的介绍，尽量优先国内知名企业的开源库</li></ol><p>共识：以每个项目的md为元数据，进行自动构建</p><h3 id="08-31-09-06-任务安排"><a href="#08-31-09-06-任务安排" class="headerlink" title="08.31-09.06 任务安排"></a>08.31-09.06 任务安排</h3><p>Open Source Todo List：</p><ol><li><p>迁移掘金老翻译项目的翻译，认领，审阅的流程至Open-Source-Translation中，包括部分MD文档和WiKi</p></li><li><p>确定自家项目介绍的最终文档模板，并新建至issues模板中，同时审阅现有的issues Label是否合理等等</p></li><li><p>模仿翻译项目的发布操作流程，撰写相关的md，wiki内容，必要的话新建一部分issues模板，和工作点2需要进行合作</p></li><li><p>在最终文档模板中指定区域开辟出一块内容用来构建MD元数据，放置分类标签，Star等额外信息，用程序对所有MD进行自动分类和排序，合并等</p></li><li><p>整体界面探索和文案撰写，目前阶段感觉内容比较贫乏，需要考虑能不能加入新的板块，比如（大公司项目友链，互推，项目初心的文案，或者知名项目的重大版本进度等等）</p></li><li><p>GitHub机器人 + 国内镜像</p></li><li><p>规范各个项目commit massage规范和提交检测</p></li><li><p>封装推荐模板（如小帅的杂志风推荐案例）</p></li><li><p>推广及扩散方案</p><p><strong>上述没提到的，但是需要做的事，可自行提出</strong></p></li></ol><p>| 人员         | 负责项 | 说明                      |<br>|  |  | - |<br>| Kerwin       | 1      |                           |<br>| xmanlin      | 2      | 2，3需要紧密合作          |<br>| 小帅         | 3      | 2，3需要紧密合作          |<br>| Kerwin       | 4      |                           |<br>| Cookieboty   | 5      |                           |<br>| 俊宁         | 6      |                           |<br>| isboyjc      | 7      | 对外的项目统一commit 规范 |<br>| Cookieboty   | 8      |                           |<br>| 小蝴蝶，小浩 | 9      |                           |</p><p><strong>具体进度统计链接</strong>：<a href="https://juejin-im.feishu.cn/docs/doccnCo5EWfQlb4SEpcxlpb7Ypc" target="_blank" rel="noopener">https://juejin-im.feishu.cn/docs/doccnCo5EWfQlb4SEpcxlpb7Ypc</a></p><h3 id="09-07-09-13-任务安排"><a href="#09-07-09-13-任务安排" class="headerlink" title="09.07-09.13 任务安排"></a>09.07-09.13 任务安排</h3><p>Open Source Todo List：</p><ol><li><p>迁移掘金老翻译项目的翻译，认领，审阅的流程至Open-Source-Translation中，包括部分MD文档和WiKi</p></li><li><p>确定自家项目介绍的最终文档模板，并新建至issues模板中，同时审阅现有的issues Label是否合理等等</p></li><li><p>模仿翻译项目的发布操作流程，撰写相关的md，wiki内容，必要的话新建一部分issues模板，和工作点2需要进行合作</p></li><li><p>在最终文档模板中指定区域开辟出一块内容用来构建MD元数据，放置分类标签，Star等额外信息，用程序对所有MD进行自动分类和排序，合并等</p></li><li><p>整体界面探索和文案撰写，目前阶段感觉内容比较贫乏，需要考虑能不能加入新的板块，比如（大公司项目友链，互推，项目初心的文案，或者知名项目的重大版本进度等等）</p></li><li><p>GitHub机器人 + 国内镜像</p></li><li><p>规范各个项目commit massage规范和提交检测</p></li><li><p>封装推荐模板（如小帅的杂志风推荐案例）</p></li><li><p>推广及扩散方案</p><p><strong>上述没提到的，但是需要做的事，可自行提出</strong></p></li></ol><p>| 人员         | 负责项 | 说明                      |<br>|  |  | - |<br>| Kerwin       | 1      |                           |<br>| xmanlin      | 2      | 2，3需要紧密合作          |<br>| 小帅         | 3      | 2，3需要紧密合作          |<br>| Kerwin       | 4      |                           |<br>| Cookieboty   | 5      |                           |<br>| 俊宁         | 6      |                           |<br>| isboyjc      | 7      | 对外的项目统一commit 规范 |<br>| Cookieboty   | 8      |                           |<br>| 小蝴蝶，小浩 | 9      |                           |</p><p><strong>具体进度统计链接</strong>：<a href="https://juejin-im.feishu.cn/docs/doccnCo5EWfQlb4SEpcxlpb7Ypc" target="_blank" rel="noopener">https://juejin-im.feishu.cn/docs/doccnCo5EWfQlb4SEpcxlpb7Ypc</a></p><h3 id="09-02-项目流程会议纪要"><a href="#09-02-项目流程会议纪要" class="headerlink" title="09.02 项目流程会议纪要"></a>09.02 项目流程会议纪要</h3><pre><code class="hljs bash">1. 提交模板（必填，例如 简介，分类，选填，例如效果截图）===》提供多个模板以供选择===》分类：语言 / 标签（学习，工具，UI类型）---language：C语言tags:：Nginx篇............---2. 项目评估标准：基于现有的WIKI和优弧碰一下（禁止引流）目标画像：大公司的新项目，大公司的主打项目，个人优质项目待确定：是否有star底限3. 期刊发布说明（考虑专题模式）：注意：开发者对自己项目审核进度和结果了解需求很旺盛每一期的特点是什么，特色是什么，尽量企业和个人混着来4.分类：结合现有语言分类，重新细化标签分类，配合第一点的模板，导出最终结果注意项：1. 可读性好2. 整体的连贯性3. 必要的超链，尽量所有的操作类都有相应超链或者issues模板翻译项目的启发：1.  A  -&gt;  开发者发布待翻译的文档2.  B   -&gt;  认领，进行翻译待考虑，是否加入类似的赏金举措（积分）：由我们自己或者开发者来提说，某一个项目非常好由另外一个熟悉的人来认领，写项目的介绍和推荐====》全范围挖掘好的开源库  +   着重跟进N个开源库（持续跟进，里程碑事件，版本迭代，重大版本影响等 =》 文章，沸点，单独的界面）====》探索 · 开放 · 开源</code></pre><h3 id="09-07-09-13-任务安排-1"><a href="#09-07-09-13-任务安排-1" class="headerlink" title="09.07-09.13 任务安排"></a>09.07-09.13 任务安排</h3><p>Open Source Todo List：</p><ol><li>回顾上周未完成项</li><li>SEO</li><li>人员招募标准</li><li>每人一期项目</li><li>优弧重点项目推进</li></ol><h3 id="09-09-会议纪要"><a href="#09-09-会议纪要" class="headerlink" title="09.09 会议纪要"></a>09.09 会议纪要</h3><p>推荐文稿的流程</p><ul><li>撰写推荐文稿</li><li>提issues，链接到文稿（掘金文章）</li><li>审核打标</li><li>PR</li></ul><p>标签：<br>              队列中   审核中   通过<br>已查看<br>             队列中   审核中   退回修改   通过</p><p>更改：未来  ==》排期中</p><p>人员招募的规则：</p><ol><li>推荐或自荐一篇合格的文稿</li><li>对其他的文稿进行一个评价</li></ol><p>核心决定大的方向等 + 审核部分决策 + 参与者提意见，部分的执行<br>===》审核以上才能算作真正的贡献者<br>===》参与者奖励待定</p><h2 id="重点项目跟进（TODO）"><a href="#重点项目跟进（TODO）" class="headerlink" title="重点项目跟进（TODO）"></a>重点项目跟进（TODO）</h2><p>相关信息：</p><table><thead><tr><th>项目</th><th>自荐地址</th><th>项目所属</th><th>体量</th><th>负责人信息</th></tr></thead><tbody><tr><td><a href="https://github.com/didi/DoraemonKit" target="_blank" rel="noopener">地址</a></td><td><a href="https://github.com/juejin-im/open-source/issues/22" target="_blank" rel="noopener">地址</a></td><td>滴滴</td><td>15.5k</td><td>微信号：jintsky<br>邮     箱：<a href="mailto:704167880@qq.com">704167880@qq.com</a></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="人员引入（TODO）"><a href="#人员引入（TODO）" class="headerlink" title="人员引入（TODO）"></a>人员引入（TODO）</h2><ul><li>Taro   已发：<a href="https://github.com/juejin-im/open-source/issues/23" target="_blank" rel="noopener">https://github.com/juejin-im/open-source/issues/23</a></li></ul><h2 id="掘金内容评审"><a href="#掘金内容评审" class="headerlink" title="掘金内容评审"></a>掘金内容评审</h2><h3 id="第三期-可视化"><a href="#第三期-可视化" class="headerlink" title="第三期 可视化"></a>第三期 可视化</h3><blockquote><p>以下是我个人的看法</p></blockquote><p><strong>一等奖（3）：</strong></p><ul><li>（<code>真正的落地</code>）<a href="https://juejin.im/post/6865591917279870990" target="_blank" rel="noopener">不依赖任何库打造属于自己的可视化数据地图 | 🏆 技术专题第三期征文</a></li><li>（<code>实践加思考的结晶</code>）<a href="https://juejin.im/post/6867451018482122760" target="_blank" rel="noopener">看房子的思考——房产数据可视化 | 🏆 技术专题第三期征文</a></li><li>（<font color="red">待定：有些偏题</font>）<a href="https://juejin.im/post/6864410873709592584" target="_blank" rel="noopener">基于React+Koa实现一个h5页面可视化编辑器－Dooring | 🏆 技术专题第三期征文</a></li></ul><p><strong>二等奖（3）：</strong></p><ul><li>（<code>基于G2构建开源库</code>）<a href="https://juejin.im/post/6868570812195176461" target="_blank" rel="noopener">如何用G2构建简单易用的图表库？| 🏆 技术专题第三期征文</a></li><li>（<code>解决实际问题</code>）<a href="https://juejin.im/post/6866236107982372878" target="_blank" rel="noopener">大数据地图渲染方案全面简介 | 🏆 技术专题第三期征文</a></li><li>（<code>实战</code>）<a href="https://juejin.im/post/6868511625016508429" target="_blank" rel="noopener">聊聊流程图可视化和G6 | 🏆 技术专题第三期征文</a></li></ul><p><strong>三等奖（5）：</strong></p><ul><li><a href="https://juejin.im/post/6867032433834622984" target="_blank" rel="noopener">大批量数据下的基于arcgis和echarts的管网流向渲染优化|🏆 技术专题第三期征文</a></li><li><a href="https://juejin.im/post/6867436612486168584" target="_blank" rel="noopener">让GIS三维可视化变得简单-Cesium地球初始化 | 🏆 技术专题第三期征文</a></li><li><a href="https://juejin.im/post/6866352135412711438" target="_blank" rel="noopener">D3.js入门教程 | 🏆 技术专题第三期征文</a></li><li><a href="https://juejin.im/post/6865313884967075853" target="_blank" rel="noopener">在Vue和React中使用ECharts的多种方法|🏆 技术专题第三期征文</a></li><li><a href="https://juejin.im/post/6864459121828888584" target="_blank" rel="noopener">使用AntV G6实现流程图编辑 | 🏆 技术专题第三期征文</a></li></ul><p><strong>新人鼓励奖（10）：</strong></p><ul><li><a href="https://juejin.im/post/6868456047984508935" target="_blank" rel="noopener">G6基于类XML语法的节点定义 | 🏆 技术专题第三期征文</a></li><li><a href="https://juejin.im/post/6865114610396364807" target="_blank" rel="noopener">小白用svg画饼图 | 🏆 技术专题第三期征文</a></li><li><a href="https://juejin.im/post/6868456776677720077" target="_blank" rel="noopener">如何在 React 中使用 G6 | 🏆 技术专题第三期征文</a></li><li><a href="https://juejin.im/post/6844904050861801486/" target="_blank" rel="noopener">响应式 Echarts Flutter 组件 | 🏆 技术专题第三期征文</a></li><li><a href="https://juejin.im/post/6868150550266019853" target="_blank" rel="noopener">拥有自己的图表库 | 🏆 技术专题第三期征文</a></li><li><a href="https://juejin.im/post/6868139738243530765" target="_blank" rel="noopener">使用 Docker 探索 Superset BI 数据可视化平台，动真格、二次开发新的可视化组件之集成 Echarts 图表 | 🏆 技术专题第三期征文</a></li><li><a href="https://juejin.im/post/6867421471497519117" target="_blank" rel="noopener">阿里云轻量级开源前端图编排组件 | 🏆 技术专题第三期征文</a></li><li><a href="https://juejin.im/post/6867719745282506759" target="_blank" rel="noopener">前端拓扑图编辑器插件选型对比 | 🏆 技术专题第三期征文</a></li><li><a href="https://juejin.im/post/6864142544260104200" target="_blank" rel="noopener">实现一个通用的可视化中间件需要怎么做? | 🏆 技术专题第三期征文</a></li><li><a href="https://juejin.im/post/6867740226367225864" target="_blank" rel="noopener">全栈搬砖指北之位置信息可视化之OpenLayers|🏆 技术专题第三期征文</a></li></ul><p><strong>不合格：</strong></p><ul><li>（<code>不完整</code>）<a href="https://juejin.im/post/6868652727958765582" target="_blank" rel="noopener">掘金15W沸点简单分析(三) | 🏆 技术专题第三期征文</a></li><li>（<code>没有按要求，且好像是翻译的文章</code>）<a href="https://juejin.im/post/6866960310650011662" target="_blank" rel="noopener">属性签名——高维数据可视化方法| 🏆 技术专题第三期</a></li><li>（<code>过于简略</code>）<a href="https://juejin.im/post/6865574039398645774" target="_blank" rel="noopener">使用AntV G6制作可‘追寻’上下游的关系图 | 🏆 技术专题第三期征文</a></li><li>（<code>篇幅过短，代码过多</code>）<a href="https://juejin.im/post/6868463482615005191" target="_blank" rel="noopener">如何让 G6 节点支持统计图表 | 🏆 技术专题第三期征文</a></li></ul><h3 id="第五期-微服务（推广文）"><a href="#第五期-微服务（推广文）" class="headerlink" title="第五期 微服务（推广文）"></a>第五期 微服务（推广文）</h3><p><strong>封面图</strong></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3081122ac2c498fab4e7d37c6cfef4d~tplv-k3u1fbpfcp-zoom-1.image" srcset="/img/loading.gif" alt></p><p>掘友们，大家好呀。</p><p>第三期技术专题<a href="https://juejin.im/post/6864072407461101582" target="_blank" rel="noopener">技术专题第三期 | 数据可视化的那些事</a>在大家积极的参与下圆满结束。本期入选征文中，有关于 AntV、ECharts、D3的入门与实战的，有关于可视化编辑器实现的，有关于GIS地图可视化经验分享的，更有房产数据可视化这种结合具体场景的文章，同时第四期技术专题 <a href="https://juejin.im/post/6869996232249442311" target="_blank" rel="noopener"> 技术专题第四期 | 聊聊微前端的那些事</a>也如火如荼的展开了，那我们后端Boys也不能屈居人后不是？</p><p> <strong>这一次，掘金酱诚邀您与我们分享您对微服务的理解，在微服务方面的实战经验，您在实际工作场景中的应用，以及对微服务的理解与期望。</strong></p><p>在软件工程的鸿蒙时代，所有代码都融在一起，我们把它称之为单体架构时代，那个时代开发速度很慢，项目可以跑很远，一个工程应对所有场景。随着业务的发展，系统变得异常复杂，诸多大佬通过结构化思考，发现对于大规模协同开发，最有效的手段就是对系统进行抽象和分享，因此MVC架构设计正式登上历史舞台。</p><p>但是，<strong>思考从不停歇。</strong></p><p>新的架构设计：SOA ，大概兴起于 2000 年左右，当初 ERP、CRM、OA 之类的信息系统都是一套套部署起来的，不同系统往往由不同的供应商分别开发的，技术差别也很大，各个系统孤零零的，于是企业有了应用集成和数据集成的需求，SOA 就出来了，各个系统对外提供粗粒度的服务供外部系统访问，所有的服务都集中在一个 ESB 上，但是这种集成方式开发代价大、通信效率低，且有单点故障的风险， 实际上在企业中并没有得到大规模应用。</p><p>互联网时代来临之后，公司业务规模增长快，变更多且频繁，同时互联网技术团队强烈关注 DevOps 和持续交付这样的研发理念，传统的架构无法满足迭代速度、系统扩展性、资源利用率优化等需求，微服务架构就闪亮登场了，通过解耦，解决掉各种难题。亚马逊、Netflix 和 Facebook 等主要的互联网公司，就是微服务架构实践的先驱，他们取得了很好的效果，也产生了一系列的最佳实践。</p><p>在微服务中，每一个服务都是一个组件，可以独立开发，独立部署，独立伸缩。</p><p>天哪！你用Go，我用Java，咱们竟然可以完美的融合在一起，还有什么比这更美妙？</p><p>但是请等一下！你知道一个完整的微服务架构落地需要涉及多少环节吗？请参考<strong>网易云容器服务团队</strong>的案例：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/926475b40cc74b068baf1b1c680cfc87~tplv-k3u1fbpfcp-zoom-1.image" srcset="/img/loading.gif" alt></p><p>在以微服务架构构建大型系统时必然会遇到诸多的问题，诸如：</p><ul><li><p>服务之间调用出错如何排查</p></li><li><p>微服务如何集成CI/CD</p></li><li><p>微服务组件如何实现注册、发现</p></li><li><p>微服务的隔离和熔断</p></li><li><p>如何实现集群部署，弹性伸缩</p></li><li><p>如何减少服务间数据传输的时间损耗、网络开销</p></li><li><p>等等</p></li></ul><p>所以微服务是不是软件工程架构的终止，而阅读本文的你又是如何从0到1的构建整个微服务架构？亦或是解决了其中的一个痛点问题？我们希望能够看到你的文章。</p><p><strong>可以参考的技术主题</strong></p><ul><li>遗留系统改造成微服务</li><li>微服务框架的技术选型深入对比</li><li>微服务架构体系中痛点问题的解决方案</li><li>微服务架构体系中运维人员的酸甜苦辣</li><li>微服务架构体系中服务及流量监控</li><li>微服务架构体系中的自动化测试</li><li>微服务架构体系中的CI/CD</li><li>微服务的未来</li></ul><h3 id="第五期-分布式（推广文）"><a href="#第五期-分布式（推广文）" class="headerlink" title="第五期 分布式（推广文）"></a>第五期 分布式（推广文）</h3><p><strong>封面图</strong></p><p>![](Kerwin’s Open Source/如何掌握分布式.jpg)</p><p>掘友们，大家好呀。</p><p>第三期技术专题<a href="https://juejin.im/post/6864072407461101582" target="_blank" rel="noopener">技术专题第三期 | 数据可视化的那些事</a>在大家积极的参与下圆满结束。本期入选征文中，有关于 AntV、ECharts、D3的入门与实战的，有关于可视化编辑器实现的，有关于GIS地图可视化经验分享的，更有房产数据可视化这种结合具体场景的文章，同时第四期技术专题 <a href="https://juejin.im/post/6869996232249442311" target="_blank" rel="noopener"> 技术专题第四期 | 聊聊微前端的那些事</a>也如火如荼的展开了，那我们后端Boys也不能屈居人后不是？</p><p> <strong>这一次，掘金酱诚邀您与我们分享您对分布式的理解，在分布式方面的实战经验，您在实际工作场景中的应用，以及对分布式的理解与期望。</strong></p><p>20世纪90年代，业界采用了基于接口/构件的架构设计方式，很自然的演化出了SOA，基于服务的架构，但随着时间的发展，程序设计越来越追求轻量级，慢慢的如WSDL，XML被JSON，RESTful等方式替代，但是SOA的思想一直延续着，也就是如今所说的分布式服务架构。</p><p>然而，分布式的世界中涉及到大量的协议（raft、2pc、lease、quorum等）、大量的理论（FLP， CAP等）、大量的系统（GFS、MongoDB、MapReduce、Spark、RabbitMQ等），两个字总结就是：<strong>硬核！</strong></p><p>![image-20200912094140823](Kerwin’s Open Source/image-20200912094140823.png)</p><p>我们需要使用分布式系统主要有两个原因：</p><ul><li><strong>增加系统容量</strong></li><li><strong>加强系统可用</strong></li></ul><p>但就是为了上述的两个理由，引入了更多的复杂性，例如：</p><ul><li>架构设计变得异常复杂。</li><li>分布式系统下部署流程变得更复杂。</li><li>系统的吞吐量会变大，但是响应时间会变长。</li><li>运维复杂度会因为服务变多而变得很复杂。</li><li>测试和查错的复杂度增大。</li><li>技术多元化，这会带来维护和运维的复杂度。</li><li>管理分布式系统中的服务和调度变得困难和复杂。</li></ul><p>这可能就是技术发展的必然吧：<strong>解决一个问题，常常会引入新的问题。</strong></p><p>比如，为了提高可用性，引入了冗余；而冗余又带来了副本之间的一致性问题，所以引入了中心化副本协议（primary/secondary)；那么接下来就要考虑primary（节点）故障时候的选举问题。</p><p>还有的时候整个设计形成了一个闭环：我们需要<strong>提高性能</strong>，因此设计了<strong>分片缓存</strong>，然而<strong>为了保证数据的正确性</strong>，我们又需要考虑<strong>数据的一致性</strong>，然后为了<strong>数据的一致性</strong>，又不得不<strong>放弃一定的性能</strong>。</p><pre><code class="hljs java"><span class="hljs-comment">// 人间不值得。</span></code></pre><p>![image-20200912095032264](Kerwin’s Open Source/image-20200912095032264.png)</p><p>但是生活还得继续🤪，所以我们来一起聊一聊分布式吧。</p><p><strong>可以参考的技术主题</strong></p><ul><li>如何学好分布式（我们不要说明书哦😂）</li><li>手写一个分布式系统（如6.824中的简化版MapReduce）</li><li>单体架构改造为分布式系统的实战经验</li><li>如何解决分布式事务</li><li>如何解决分布式系统中数据一致性的问题</li><li>分布式系统的服务调度</li><li>分布式系统的运维管理方案</li><li>其他分布式系统中的核心问题等等</li></ul><h3 id="第六期-后端征文意见"><a href="#第六期-后端征文意见" class="headerlink" title="第六期 后端征文意见"></a>第六期 后端征文意见</h3><p>话题类：</p><ul><li>这些年我在编程道路上吃过的亏</li><li>金九银十之后的反思</li><li>你心中的后端技能图谱</li><li>聊聊你最拿手的技术</li><li>聊聊你解决的印象最深的BUG</li></ul><p>技术类：</p><ul><li>项目中数据库的设计方案</li><li>谈谈缓存的妙用及问题（在项目中的帮助</li></ul><h3 id="第七期-缓存（推广文）"><a href="#第七期-缓存（推广文）" class="headerlink" title="第七期 缓存（推广文）"></a>第七期 缓存（推广文）</h3><p><strong>封面图</strong></p><p>![](Kerwin’s Open Source/缓存.png)</p><p>掘友们，大家好呀。</p><p>第五期技术专题<a href="https://juejin.im/post/6888208307924762638" target="_blank" rel="noopener">技术专题第五期 | 聊聊分布式的那些事</a>以及第六期技术专题<a href="https://juejin.im/post/6889264500977958920/?utm_source=gold_browser_extension" target="_blank" rel="noopener">技术专题第六期 | 谈谈 React 17 的那些事！</a>正在热火朝天的进行中，这两大技术专题分别属于后端领域以及前端领域，那我们第七期就没有明显的领域限制啦。</p><p><strong>本期我们来聊一聊缓存的妙用和问题，说一说你是如何利用缓存解决问题，也谈一谈因为缓存又带来了哪些新的问题！</strong></p><p>回顾一下<strong>缓存</strong>的原始意义：是指访问速度比一般<strong>随机存取存储器（RAM）</strong>快的一种高速存储器，通常它不像系统主存那样使用<strong>DRAM</strong>技术，而使用昂贵但较快速的<strong>SRAM</strong>技术，缓存的设置是所有现代计算机系统发挥高性能的重要因素之一。可以看到<strong>缓存</strong>的最初使用是作用于系统级的，但随着一代代工程师的挖掘和实战，缓存慢慢的走进了更多的生态之中，比如：浏览器缓存，后端体系中如MyBatis框架中的一级、二级缓存、基于Redis搭建的缓存服务等等，甚至为了保证网络质量不佳情况时APP的正常使用，我们也会为所有的 API 加上缓存，从另一个方面说，缓存已经成为互联网生态中必不可少的一部分。</p><p>总结一句话：<strong>缓存是提高性能最好的方式</strong>。</p><p>在缓存的设计与使用中，存在多种多样的技巧和方案，本文抛砖引玉，以<strong>Cache Aside 更新模式</strong>为例来介绍一下最常用的缓存设计方案，主要逻辑即考虑：失效、命中、更新时的动作。</p><ul><li>失效：应用程序先从 Cache 取数据，如果没有得到，则从数据库中取数据，成功后，放到缓存中。</li><li>命中：应用程序从 Cache 中取数据，取到后返回。</li><li>更新：先把数据存到数据库中，成功后，再让缓存失效。</li></ul><p>![image-20201105083103344](Kerwin’s Open Source/image-20201105083103344.png)</p><p>如此一来，便可以建立起一个简单的缓存服务，为接口提高最高效率的查询速度。</p><p>但是朋友们，重点来了，这样做真的是完美方案吗？我们会问这样的几个问题：</p><ul><li>为什么不是写完数据库后更新缓存</li><li>如何保证缓存的命中</li><li>如何保证数据的强一致性</li><li>如何设计缓存的淘汰策略</li><li>如何有效的水平拓展缓存服务</li><li>如何配合缓存设计最大吞吐量的系统</li><li>如何做好针对缓存的监控</li><li>如何设计多级缓存</li></ul><p>啊，思考这些问题一下子头都秃了，掘友们，掘金酱的头发就等着你们来拯救啦！希望小伙伴们踊跃的参与到本期的技术征文之中，可以参考的技术主题如下：</p><ul><li>缓存设计方案中临界问题的研究和探讨</li><li>通用的缓存设计方案</li><li>在实际项目中如何利用缓存提高系统性能</li><li>因为使用缓存带来了什么问题，你又是如何解决的</li><li>如何利用缓存解决网络质量差时前端渲染问题</li></ul>]]></content>
    
    
    <categories>
      
      <category>开源篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kerwin&#39;s Open Source</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lambda初次使用很慢？从JIT到类加载再到实现原理</title>
    <link href="/2023/09/12/Lambda%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8%E5%BE%88%E6%85%A2%EF%BC%9F%E4%BB%8EJIT%E5%88%B0%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%86%8D%E5%88%B0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <url>/2023/09/12/Lambda%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8%E5%BE%88%E6%85%A2%EF%BC%9F%E4%BB%8EJIT%E5%88%B0%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%86%8D%E5%88%B0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Lambda初次使用很慢？从JIT到类加载再到实现原理"><a href="#Lambda初次使用很慢？从JIT到类加载再到实现原理" class="headerlink" title="Lambda初次使用很慢？从JIT到类加载再到实现原理"></a>Lambda初次使用很慢？从JIT到类加载再到实现原理</h1><h2 id="问题回顾"><a href="#问题回顾" class="headerlink" title="问题回顾"></a>问题回顾</h2><p>描述的话不多说，直接上图：</p><p><img src="/2023/09/12/Lambda%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8%E5%BE%88%E6%85%A2%EF%BC%9F%E4%BB%8EJIT%E5%88%B0%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%86%8D%E5%88%B0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/image-20200629234626454.png" srcset="/img/loading.gif" alt="image-20200629234626454"></p><p>看到输出结果了吗？为什么第一次和第二次的时间相差如此之多？咱们一起琢磨琢磨，<strong>也可以先去看看结论再回过头看分析</strong></p><blockquote><p>注：并非仅第二次快，而是除了第一次，之后的每一次都很快</p></blockquote><h2 id="给与猜想"><a href="#给与猜想" class="headerlink" title="给与猜想"></a>给与猜想</h2><ol><li>是否和操作系统预热有关？</li><li>是否和JIT（即时编译）有关？</li><li>是否和ClassLoader类加载有关？</li><li>是否和<code>Lambda</code>有关，并非<code>foreach</code>的问题</li></ol><h2 id="验证猜想"><a href="#验证猜想" class="headerlink" title="验证猜想"></a>验证猜想</h2><h3 id="操作系统预热"><a href="#操作系统预热" class="headerlink" title="操作系统预热"></a>操作系统预热</h3><p>操作系统预热这个概念是我咨询一位大佬得到的结论，在百度 / Google 中并未搜索到相应的词汇，但是在模拟测试中，我用 <font color="red">普通遍历</font> 的方式进行测试：</p><p><img src="/2023/09/12/Lambda%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8%E5%BE%88%E6%85%A2%EF%BC%9F%E4%BB%8EJIT%E5%88%B0%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%86%8D%E5%88%B0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/image-20200630003352129.png" srcset="/img/loading.gif" alt="image-20200630003352129"></p><p>基本上每次都是前几次速度较慢，后面的速度更快，因此 <font color="red">可能</font> 有这个因素影响，但差距并不会很大，因此该结论并不能作为问题的答案。</p><h3 id="JIT-即时编译"><a href="#JIT-即时编译" class="headerlink" title="JIT 即时编译"></a>JIT 即时编译</h3><p>首先介绍一下什么是JIT即时编译：</p><blockquote><p>当 JVM 的初始化完成后，类在调用执行过程中，执行引擎会把字节码转为机器码，然后在操作系统中才能执行。在字节码转换为机器码的过程中，虚拟机中还存在着一道编译，那就是<code>即时编译</code>。</p><p>最初，JVM 中的字节码是由解释器（ Interpreter ）完成编译的，当虚拟机发现某个方法或代码块的运行特别频繁的时候，就会把这些代码认定为<code>热点代码</code>。</p><p>为了提高热点代码的执行效率，在运行时，即时编译器（JIT，Just In Time）会把这些代码编译成与本地平台相关的机器码，并进行各层次的优化，然后保存到内存中</p></blockquote><p>再来一个概念，<code>回边计数器</code></p><blockquote><p>回边计数器用于统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为 “回边”（Back Edge）</p><p>建立回边计数器的主要目的是为了触发 OSR（On StackReplacement）编译，即栈上编译，在一些循环周期比较长的代码段中，当循环达到回边计数器阈值时，<code>JVM 会认为这段是热点代码</code>，JIT 编译器就会将这段代码编译成机器语言并缓存，在该循环时间段内，会直接将执行代码替换，执行缓存的机器语言</p></blockquote><p>从上述的概念中，我们应该可以得到一个结论：第一条所谓的操作系统预热 <font color="red">大概率不正确</font>，因为普通遍历方法执行N次，后续执行的时间占用比较小，很可能是因为JIT导致的。</p><p>那 JIT即时编译 是否是最终的答案？我们想办法把 JIT 关掉来测试一下，通过查询资料发现了如下内容：</p><p><strong><em>Procedure</em></strong></p><ul><li><p>Use the <strong>-D</strong> option on the JVM command line to set the <strong>java.compiler</strong> property to NONE or the empty string.</p><p>Type the following command at a shell or command prompt:</p><pre><code class="hljs bash">java -Djava.compiler=NONE &lt;class&gt;</code></pre></li></ul><blockquote><p>注：该段内容来自IBM官方资料，地址见 &lt;收获&gt; ，咱们先不要停止思考</p></blockquote><p>通过配置 IDEA JVM 参数：</p><p><img src="/2023/09/12/Lambda%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8%E5%BE%88%E6%85%A2%EF%BC%9F%E4%BB%8EJIT%E5%88%B0%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%86%8D%E5%88%B0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/image-20200630005126426.png" srcset="/img/loading.gif" alt="image-20200630005126426"></p><p>执行问题中的代码测试结果如下：</p><pre><code class="hljs bash"><span class="hljs-comment"># 禁用前</span>foreach time one: 38分割线...foreach time two: 1<span class="hljs-comment"># 禁用后</span>foreach time one: 40分割线...foreach time two: 5</code></pre><p>我测试了很多次，结果都很相近，因此得到可以得到另一个结论：<code>JIT</code>并非引发该问题的原因（但是它的确能提高执行效率）</p><h3 id="难道和类加载有关？"><a href="#难道和类加载有关？" class="headerlink" title="难道和类加载有关？"></a>难道和类加载有关？</h3><p>在进行类加载验证时，我依然无法放弃 <code>JIT</code> ，因此查阅了很多资料，知道了某个命令可以查看 <code>JIT</code>编译的耗时情况，命令如下：</p><pre><code class="hljs bash">java -XX:+CITime com.code.jvm.preheat.Demo &gt;&gt; log.txt</code></pre><p>解释一下命令的意思</p><pre><code class="hljs bash"><span class="hljs-comment"># 执行的目录</span>C:\Users\Kerwin\Desktop\Codes\Kerwin-Code-Study\target\classes&gt;<span class="hljs-comment"># 命令含义：Prints time spent in JIT Compiler. (Introduced in 1.4.0.)</span><span class="hljs-comment"># 打印JIT编译所消耗的时间</span>-XX:+CITime<span class="hljs-comment"># 代表我指定的类</span>com.code.jvm.preheat.Demo<span class="hljs-comment"># 输出至log.txt文件，方便观看</span>&gt;&gt; log.txt</code></pre><p>展示一下某一次结果的全部内容：</p><pre><code class="hljs bash">foreach time one: 35分割线...foreach time two: 1Accumulated compiler <span class="hljs-built_in">times</span> (<span class="hljs-keyword">for</span> compiled methods only)  Total compilation time   :  0.044 s    Standard compilation   :  0.041 s, Average : 0.000    On stack replacement   :  0.003 s, Average : 0.002    Detailed C1 Timings       Setup time:         0.000 s ( 0.0%)       Build IR:           0.010 s (38.8%)         Optimize:            0.001 s ( 2.3%)         RCE:                 0.000 s ( 0.7%)       Emit LIR:           0.010 s (40.7%)         LIR Gen:           0.002 s ( 9.3%)         Linear Scan:       0.008 s (31.0%)       LIR Schedule:       0.000 s ( 0.0%)       Code Emission:      0.003 s (12.4%)       Code Installation:  0.002 s ( 8.2%)       Instruction Nodes:   9170 nodes  Total compiled methods   :    162 methods    Standard compilation   :    160 methods    On stack replacement   :      2 methods  Total compiled bytecodes :  13885 bytes    Standard compilation   :  13539 bytes    On stack replacement   :    346 bytes  Average compilation speed: 312157 bytes/s  nmethod code size        : 168352 bytes  nmethod total size       : 276856 bytes</code></pre><p>分别测试的结果如下：</p><table><thead><tr><th>类型</th><th>Total compilation time（JIT编译总耗时）</th></tr></thead><tbody><tr><td>两次 foreach（lambda） 循环</td><td>0.044 s</td></tr><tr><td>两次 foreach （普通）循环</td><td>0.016 s</td></tr><tr><td>两次 增强for循环</td><td>0.015 s</td></tr><tr><td>一次 foreach（lambda） 一次增强for循环</td><td>0.046 s</td></tr></tbody></table><p>通过上述测试结果，反正更加说明了一个问题：<font color="red">只要有 Lambda 参与的程序，编译时间总会长一些</font></p><p>再次通过查询资料，了解了新的命令</p><pre><code class="hljs bash">java -verbose:class -verbose:jni -verbose:gc -XX:+PrintCompilation com.code.jvm.preheat.Demo</code></pre><p>解释一下命令的意思</p><pre><code class="hljs bash"><span class="hljs-comment"># 输出jvm载入类的相关信息</span>-verbose:class<span class="hljs-comment"># 输出native方法调用的相关情况</span>-verbose:jni<span class="hljs-comment"># 输出每次GC的相关情况</span>-verbose:gc<span class="hljs-comment"># 当一个方法被编译时打印相关信息</span>-XX:+PrintCompilation</code></pre><p>对包含Lambda和不包含的分别执行命令，得到的结果如下：</p><p>从日志文件大小来看，就相差了十几kb</p><blockquote><p>注：文件过大，仅展示部分内容</p></blockquote><pre><code class="hljs bash"><span class="hljs-comment"># 包含Lambda</span>[Loaded java.lang.invoke.LambdaMetafactory from D:\JDK\jre1.8\lib\rt.jar]<span class="hljs-comment"># 中间省略了很多内容，LambdaMetafactory 是最明显的区别（仅从名字上发现）</span>[Loaded java.lang.invoke.InnerClassLambdaMetafactory<span class="hljs-variable">$1</span> from D:\JDK\jre1.8\lib\rt.jar]   5143  220       4       java.lang.String::equals (81 bytes)[Loaded java.lang.invoke.LambdaForm<span class="hljs-variable">$MH</span>/471910020 from java.lang.invoke.LambdaForm]   5143  219       3       jdk.internal.org.objectweb.asm.ByteVector::&lt;init&gt; (13 bytes)[Loaded java.lang.invoke.LambdaForm<span class="hljs-variable">$MH</span>/531885035 from java.lang.invoke.LambdaForm]   5143  222       3       jdk.internal.org.objectweb.asm.ByteVector::putInt (74 bytes)   5143  224       3       com.code.jvm.preheat.Demo$<span class="hljs-variable">$Lambda</span><span class="hljs-variable">$1</span>/834600351::accept (8 bytes)   5143  225       3       com.code.jvm.preheat.Demo::lambda<span class="hljs-variable">$getTime</span><span class="hljs-variable">$0</span> (6 bytes)   5144  226       4       com.code.jvm.preheat.Demo$<span class="hljs-variable">$Lambda</span><span class="hljs-variable">$1</span>/834600351::accept (8 bytes)   5144  223       1       java.lang.Integer::intValue (5 bytes)   5144  221       3       jdk.internal.org.objectweb.asm.ByteVector::putByteArray (49 bytes)   5144  224       3       com.code.jvm.preheat.Demo$<span class="hljs-variable">$Lambda</span><span class="hljs-variable">$1</span>/834600351::accept (8 bytes)   made not entrant   5145  227 %     4       java.util.ArrayList::forEach @ 27 (75 bytes)   5146    3       3       java.lang.String::equals (81 bytes)   made not entrantforeach time one: 50分割线...   5147  227 %     4       java.util.ArrayList::forEach @ -2 (75 bytes)   made not entrantforeach time two: 1[Loaded java.lang.Shutdown from D:\JDK\jre1.8\lib\rt.jar][Loaded java.lang.Shutdown<span class="hljs-variable">$Lock</span> from D:\JDK\jre1.8\lib\rt.jar]<span class="hljs-comment"># 不包含Lambda</span>   5095   45       1       java.util.ArrayList::access<span class="hljs-variable">$100</span> (5 bytes)   5095   46       1       java.lang.Integer::intValue (5 bytes)   5096   47       3       java.util.ArrayList<span class="hljs-variable">$Itr</span>::hasNext (20 bytes)   5096   49       3       java.util.ArrayList<span class="hljs-variable">$Itr</span>::checkForComodification (23 bytes)   5096   48       3       java.util.ArrayList<span class="hljs-variable">$Itr</span>::next (66 bytes)   5096   50       4       java.util.ArrayList<span class="hljs-variable">$Itr</span>::hasNext (20 bytes)   5096   51       4       java.util.ArrayList<span class="hljs-variable">$Itr</span>::checkForComodification (23 bytes)   5096   52       4       java.util.ArrayList<span class="hljs-variable">$Itr</span>::next (66 bytes)   5097   47       3       java.util.ArrayList<span class="hljs-variable">$Itr</span>::hasNext (20 bytes)   made not entrant   5097   49       3       java.util.ArrayList<span class="hljs-variable">$Itr</span>::checkForComodification (23 bytes)   made not entrant   5097   48       3       java.util.ArrayList<span class="hljs-variable">$Itr</span>::next (66 bytes)   made not entrant   5099   53 %     4       com.code.jvm.preheat.Demo::getTimeFor @ 11 (47 bytes)   5101   50       4       java.util.ArrayList<span class="hljs-variable">$Itr</span>::hasNext (20 bytes)   made not entrantforeach time one: 7分割线...   5102   54       3       java.util.ArrayList<span class="hljs-variable">$Itr</span>::hasNext (20 bytes)   5102   55       4       java.util.ArrayList<span class="hljs-variable">$Itr</span>::hasNext (20 bytes)   5103   53 %     4       com.code.jvm.preheat.Demo::getTimeFor @ -2 (47 bytes)   made not entrantforeach time two: 1   5103   54       3       java.util.ArrayList<span class="hljs-variable">$Itr</span>::hasNext (20 bytes)   made not entrant[Loaded java.lang.Shutdown from D:\JDK\jre1.8\lib\rt.jar][Loaded java.lang.Shutdown<span class="hljs-variable">$Lock</span> from D:\JDK\jre1.8\lib\rt.jar]</code></pre><p>我们可以结合JIT编译时间，结合JVM载入类的日志发现两个结论：</p><ol><li>凡是使用了Lambda，JVM会额外加载 <code>LambdaMetafactory</code>类，且耗时较长</li><li>在<code>第二次调用Lambda方法</code>时，JVM就不再需要额外加载 <code>LambdaMetafactory</code>类，因此执行较快</li></ol><p>完美印证了之前提出的问题：<font color="red">为什么第一次 foreach 慢，以后都很快</font>，但这就是真相吗？我们继续往下看</p><h3 id="排除-foreach-的干扰"><a href="#排除-foreach-的干扰" class="headerlink" title="排除 foreach 的干扰"></a>排除 foreach 的干扰</h3><p>先来看看 <code>ArrayList</code>中 <code>foreach</code>方法的实现：</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> E&gt; action)</span> </span>&#123;    Objects.requireNonNull(action);    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> expectedModCount = modCount;    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)    <span class="hljs-keyword">final</span> E[] elementData = (E[]) <span class="hljs-keyword">this</span>.elementData;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size = <span class="hljs-keyword">this</span>.size;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;        action.accept(elementData[i]);    &#125;    <span class="hljs-keyword">if</span> (modCount != expectedModCount) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();    &#125;&#125;</code></pre><p>乍一看，好像也没什么特别，我们来试试把 Consumer 预先定义好，代码如下：</p><p><img src="/2023/09/12/Lambda%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8%E5%BE%88%E6%85%A2%EF%BC%9F%E4%BB%8EJIT%E5%88%B0%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%86%8D%E5%88%B0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/image-20200630015101773.png" srcset="/img/loading.gif" alt="image-20200630015101773"></p><p>可以发现速度很快，检查 <code>JIT编译时间</code>，检查<code>类加载</code>情况，发现耗时短，且无<code>LambdaMetafactory</code>加载</p><p>根据刚才得到的结论，我们试试把 <code>Consumer</code> 用 <code>Lambda</code>的方式定义一下</p><pre><code class="hljs bash">Consumer consumer = o -&gt; &#123;    int curr = (int) o;&#125;;<span class="hljs-comment"># 执行结果耗时</span>foreach time: 3</code></pre><p>再来看看编译时间和类加载，<font color="red">赫然发现：JIT编译时间较长，且有LambdaMetafactory加载</font></p><h2 id="重新探究Lambda的实现原理"><a href="#重新探究Lambda的实现原理" class="headerlink" title="重新探究Lambda的实现原理"></a>重新探究Lambda的实现原理</h2><p><code>Lambda</code>表达式实现原理的细节，我之后会再出一篇新的文章，今天就先说一下结论：</p><ul><li>匿名内部类在编译阶段会多出一个类，而<code>Lambda</code>不会，它仅会多生成一个函数</li><li>该函数会在运行阶段，会通过<code>LambdaMetafactory</code>工厂来生成一个class，进行后续的调用</li></ul><p><strong><em>为什么<code>Lamdba</code>要如此实现？</em></strong></p><p>匿名内部类有一定的缺陷：</p><ol><li>编译器为每个匿名内部类生成一个新的类文件，生成许多类文件是不可取的，因为每个类文件在使用之前都需要加载和验证，这会影响应用程序的启动性能，加载可能是一个昂贵的操作，包括磁盘I/O和解压缩JAR文件本身。</li><li>如果lambdas被转换为匿名内部类，那么每个lambda都有一个新的类文件。由于每个匿名内部类都将被加载，它将占用JVM的元空间，如果JVM将每个此类匿名内部类中的代码编译为机器码，那么它将存储在代码缓存中。</li><li>此外，这些匿名内部类将被实例化为单独的对象。因此，匿名内部类会增加应用程序的内存消耗。</li><li>最重要的是，从一开始就选择使用匿名内部类来实现lambdas，这将限制未来lambda实现更改的范围，以及它们根据未来JVM改进而演进的能力。</li></ol><blockquote><p>内容参考：<a href="https://www.infoq.com/articles/Java-8-Lambdas-A-Peek-Under-the-Hood/" target="_blank" rel="noopener">https://www.infoq.com/articles/Java-8-Lambdas-A-Peek-Under-the-Hood/</a></p></blockquote><h2 id="真相"><a href="#真相" class="headerlink" title="真相"></a>真相</h2><p>在理解了匿名内部类以及<code>Lambda</code>表达式的实现原理后，对<code>Lambda</code>耗时长的原因反而更懵逼，毕竟匿名内部类的生成一个新类和<code>Lambda</code>生成一个新方法所耗时间差别不会太多，然后运行期间同样有Class产生，耗时也不应该有太大的区别，到底哪里出现了问题呢？</p><p>再次通过科学上网，最终找到了答案：</p><blockquote><p>You are obviously encountering the first-time initialization overhead of lambda expressions. As already mentioned in the comments, the classes for lambda expressions are generated at runtime rather than being loaded from your class path.</p><p>However, being generated isn’t the cause for the slowdown. After all, generating a class having a simple structure can be even faster than loading the same bytes from an external source. And the inner class has to be loaded too. But when the application hasn’t used lambda expressions before, even the framework for generating the lambda classes has to be loaded (Oracle’s current implementation uses ASM under the hood). This is the actual cause of the slowdown, loading and initialization of a dozen internally used classes, not the lambda expression itself.</p></blockquote><p>大概翻译过来如下：</p><p><strong>显然，您遇到了lambda表达式的首次初始化开销。正如注释中已经提到的，lambda表达式的类是在运行时生成的，而不是从类路径加载的。</strong></p><p><strong>然而，生成类并不是速度变慢的原因。毕竟，生成一个结构简单的类比从外部源加载相同的字节还要快。内部类也必须加载。但是，当应用程序以前没有使用lambda表达式时，甚至必须加载用于生成lambda类的框架（Oracle当前的实现在幕后使用ASM）。这是导致十几个内部使用的类（而不是lambda表达式本身）减速、加载和初始化的真正原因。</strong></p><p><font color="red">真相：</font>应用程序初次使用Lambda时，<font color="red"><strong>必须加载用于生成Lambda类的框架</strong></font>，因此需要更多的编译，加载的时间</p><p>回过头去看看类加载的日志，赫然发现了<code>ASM框架</code>的引入：</p><pre><code class="hljs bash">[Loaded jdk.internal.org.objectweb.asm.ClassVisitor from F:\Java_JDK\JDK1.8\jre\lib\rt.jar][Loaded jdk.internal.org.objectweb.asm.ClassWriter from F:\Java_JDK\JDK1.8\jre\lib\rt.jar][Loaded jdk.internal.org.objectweb.asm.ByteVector from F:\Java_JDK\JDK1.8\jre\lib\rt.jar][Loaded jdk.internal.org.objectweb.asm.Item from F:\Java_JDK\JDK1.8\jre\lib\rt.jar][Loaded jdk.internal.org.objectweb.asm.MethodVisitor from F:\Java_JDK\JDK1.8\jre\lib\rt.jar][Loaded jdk.internal.org.objectweb.asm.MethodWriter from F:\Java_JDK\JDK1.8\jre\lib\rt.jar][Loaded jdk.internal.org.objectweb.asm.Type from F:\Java_JDK\JDK1.8\jre\lib\rt.jar][Loaded jdk.internal.org.objectweb.asm.Label from F:\Java_JDK\JDK1.8\jre\lib\rt.jar][Loaded jdk.internal.org.objectweb.asm.Frame from F:\Java_JDK\JDK1.8\jre\lib\rt.jar][Loaded jdk.internal.org.objectweb.asm.AnnotationVisitor from F:\Java_JDK\JDK1.8\jre\lib\rt.jar][Loaded jdk.internal.org.objectweb.asm.AnnotationWriter from F:\Java_JDK\JDK1.8\jre\lib\rt.jar]</code></pre><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul><li>导致 foreach 测试时数据不正常的罪魁祸首是：<code>Lambda表达式</code></li><li><code>Lambda表达式</code> 在应用程序中首次使用时，需要额外加载ASM框架，因此需要更多的编译，加载的时间</li><li><code>Lambda表达式</code>的底层实现并非匿名内部类的语法糖，而是其优化版</li><li>foreach 的底层实现其实和增强 for循环没有本质区别，一个是外部迭代器，一个是内部迭代器而已</li><li>通过 foreach + Lambda 的写法，效率并不低，只不过需要提前进行<code>预热(加载框架)</code></li></ul><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ul><li>JIT 即时编译的概念和相关命令</li><li>IBM 官方资料库，<a href="https://www.ibm.com/support/knowledgecenter/SSYKE2_8.0.0/welcome/welcome_javasdk_version.html" target="_blank" rel="noopener">地址</a></li><li>Oracle 关于JVM命令大全，<a href="https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html" target="_blank" rel="noopener">地址</a>  |   国内博主翻译版本 <a href="https://www.cnblogs.com/jack204/archive/2012/07/02/2572932.html" target="_blank" rel="noopener">地址</a></li><li>Lambda底层实现文章，<a href="https://www.infoq.com/articles/Java-8-Lambdas-A-Peek-Under-the-Hood/" target="_blank" rel="noopener">地址</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lambda初次使用很慢？从JIT到类加载再到实现原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Google无法同步解决方案</title>
    <link href="/2023/09/12/Google%E6%97%A0%E6%B3%95%E5%90%8C%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2023/09/12/Google%E6%97%A0%E6%B3%95%E5%90%8C%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p> 解决chrome不能自动同步问题，可以进行手动同步 </p><ol><li><p>首先确保账号登录正常</p></li><li><p>chrome地址栏中输入： chrome://sync-internals/</p></li><li><p>进行如图操作</p></li><li><p>如果点击disable sync 再次点击 request 等待一会还是没有反应，且网络正常的话，尝试关闭打开一次浏览器再操作</p><p><img src="/2023/09/12/Google%E6%97%A0%E6%B3%95%E5%90%8C%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/v2-90cc694c8aad390178597c74555de45a_720w.jpg" srcset="/img/loading.gif" alt="img"> </p><p><img src="/2023/09/12/Google%E6%97%A0%E6%B3%95%E5%90%8C%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/v2-ffe9532cef3c43d7db269f75d5d72187_720w.jpg" srcset="/img/loading.gif" alt="img"> </p><p><img src="/2023/09/12/Google%E6%97%A0%E6%B3%95%E5%90%8C%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/v2-e6e0516dd30ffcce4fa2b751a5b799e5_720w.jpg" srcset="/img/loading.gif" alt="img"> </p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Tips篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Google无法同步解决方案</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker篇</title>
    <link href="/2023/09/12/Docker%E7%AF%87/"/>
    <url>/2023/09/12/Docker%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker篇"><a href="#Docker篇" class="headerlink" title="Docker篇"></a>Docker篇</h1><h3 id="CentOS-安装Docker-菜鸟教程"><a href="#CentOS-安装Docker-菜鸟教程" class="headerlink" title="CentOS 安装Docker - 菜鸟教程"></a>CentOS 安装Docker - 菜鸟教程</h3><pre><code class="hljs angelscript">安装须知:<span class="hljs-number">1.</span>Docker支持以下的CentOS版本：CentOS <span class="hljs-number">7</span> (<span class="hljs-number">64</span>-bit)CentOS <span class="hljs-number">6.5</span> (<span class="hljs-number">64</span>-bit) 或更高的版本<span class="hljs-number">2.</span>Docker 要求 CentOS 系统的内核版本高于 <span class="hljs-number">3.10</span> ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。通过 uname -r 命令查看你当前的内核版本</code></pre><p>安装一些必要的系统工具：</p><pre><code class="hljs gml">sudo yum install -<span class="hljs-symbol">y</span> yum-utils device-mapper-<span class="hljs-symbol">persistent</span>-data lvm2</code></pre><p>添加软件源信息：</p><pre><code class="hljs vim">sudo yum-config-manager --<span class="hljs-built_in">add</span>-repo http://mirrors.aliyun.<span class="hljs-keyword">com</span>/docker-<span class="hljs-keyword">ce</span>/linux/centos/docker-<span class="hljs-keyword">ce</span>.repo</code></pre><p>更新 yum 缓存：</p><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo yum makecache fast</span></code></pre><p>安装 Docker-ce：</p><pre><code class="hljs cmake">sudo yum -y <span class="hljs-keyword">install</span> docker-ce</code></pre><p>启动 Docker 后台服务</p><pre><code class="hljs crmsh">sudo systemctl <span class="hljs-literal">start</span> docker</code></pre><p>测试运行 hello-world</p><pre><code class="hljs autoit">[root<span class="hljs-symbol">@runoob</span> ~]<span class="hljs-meta"># docker run hello-world</span>会自动下载一个镜像运行</code></pre><p>注意配置CDN加速：</p><p>鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决，我使用的是网易的镜像地址：<a href="http://hub-mirror.c.163.com。" target="_blank" rel="noopener">http://hub-mirror.c.163.com。</a></p><p>新版的 Docker 使用 /etc/docker/daemon.json（Linux） 或者 %programdata%\docker\config\daemon.json（Windows） 来配置 Daemon。</p><p>请在该配置文件中加入（没有该文件的话，请先建一个）：</p><pre><code class="hljs vala">&#123;  <span class="hljs-string">"registry-mirrors"</span> : [<span class="hljs-string">"https://docker.mirrors.ustc.edu.cn"</span>]&#125;sudo systemctl daemon-reloadsudo systemctl restart docker<span class="hljs-meta"># 阿里云对此有额外限制，需要启动阿里云给予的专属加速链接</span>参考内容：https:<span class="hljs-comment">//www.cnblogs.com/sxdcgaq8080/p/9198748.html</span>阿里云-控制台-搜索镜像加速器即可看到详情</code></pre><h3 id="Docker正式使用常见命令"><a href="#Docker正式使用常见命令" class="headerlink" title="Docker正式使用常见命令"></a>Docker正式使用常见命令</h3><p>Docker-Hub注册：<a href="https://hub.docker.com/signup" target="_blank" rel="noopener">https://hub.docker.com/signup</a> </p><p>Docker验证登录</p><pre><code class="hljs ebnf"><span class="hljs-attribute">docker login</span></code></pre><p>Docker寻找镜像</p><pre><code class="hljs ebnf"><span class="hljs-attribute">docker search tomcat</span></code></pre><p>Docker拉取镜像</p><pre><code class="hljs ebnf"><span class="hljs-attribute">docker pull tomcat</span></code></pre><p>Docker查看本地镜像</p><pre><code class="hljs ebnf"><span class="hljs-attribute">docker images</span></code></pre><p>Docker删除镜像和容器</p><pre><code class="hljs properties"><span class="hljs-meta">docker删除镜像</span>:<span class="hljs-string"></span><span class="hljs-attr">docker</span> <span class="hljs-string">rmi 镜像ID</span><span class="hljs-attr">如果是本地的包含tag的话需要指明</span><span class="hljs-attr">docker</span> <span class="hljs-string">rmi 806857264/kerwin_docker:kerwin_tomcat_8080</span><span class="hljs-attr">docker删除容器：</span><span class="hljs-attr">首先需要停止容器</span><span class="hljs-attr">docker</span> <span class="hljs-string">stop 【id名字】</span><span class="hljs-attr">docker</span> <span class="hljs-string">rm 【id名字】</span></code></pre><p>Docker查看正在运行的容器</p><pre><code class="hljs properties"><span class="hljs-attr">docker</span> <span class="hljs-string">ps</span><span class="hljs-attr">查看所有容器</span><span class="hljs-attr">docker</span> <span class="hljs-string">ps -a</span></code></pre><p>Docker交互模式进入到目标文件目录</p><pre><code class="hljs armasm"><span class="hljs-symbol">docker</span> exec -<span class="hljs-keyword">it </span>d585d5151285 /<span class="hljs-keyword">bin/bash </span>  交互模式进入到目标文件目录，可以进行修改等，如进入到tomcat目录 <span class="hljs-symbol">d585d5151285</span>为容器ID</code></pre><p>停止容器/重启容器</p><pre><code class="hljs properties"><span class="hljs-attr">docker</span> <span class="hljs-string">stop 【名字】</span><span class="hljs-attr">docker</span> <span class="hljs-string">start 【名字】</span><span class="hljs-attr">docker</span> <span class="hljs-string">restart 【名字】</span></code></pre><h3 id="Docker运行镜像-Tomcat"><a href="#Docker运行镜像-Tomcat" class="headerlink" title="Docker运行镜像 Tomcat"></a>Docker运行镜像 Tomcat</h3><pre><code class="hljs java">如tomcat为例:docker run --name tomcat-<span class="hljs-number">8080</span> -p <span class="hljs-number">8080</span>:<span class="hljs-number">8080</span> -v /home/docker_tomcat:/usr/local/tomcat/webapps -d tomcat重命名为tomcat-<span class="hljs-number">80</span>  端口映射 <span class="hljs-number">8080</span>-&gt;<span class="hljs-number">8080</span> 宿主机文件交互目录 运行的镜像为tomcat :ro赋予可读权限</code></pre><h3 id="Docker部署Mysql"><a href="#Docker部署Mysql" class="headerlink" title="Docker部署Mysql"></a>Docker部署Mysql</h3><pre><code class="hljs java">docker pull mysql:<span class="hljs-number">5.7</span># root 123456docker run -it --rm --name mysql -e MYSQL_ROOT_PASSWORD=<span class="hljs-number">123456</span> -p <span class="hljs-number">3306</span>:<span class="hljs-number">3306</span> -d mysql:<span class="hljs-number">5.7</span># 进入容器内，连接mysql，刷新用户信息开放远程连接docker exec -it xxxxxx bashmysql -uroot -p123456 或 (mysql -uroot -p )ALTER user <span class="hljs-string">'root'</span>@<span class="hljs-string">'%'</span> IDENTIFIED WITH mysql_native_password BY <span class="hljs-string">'123456'</span>;  FLUSH PRIVILEGES;</code></pre><h3 id="Docker部署Redis"><a href="#Docker部署Redis" class="headerlink" title="Docker部署Redis"></a>Docker部署Redis</h3><pre><code class="hljs java">redis.conf 配置文件 --- 创建：/home/docker/redis/conf创建：/home/docker/redis/conf/redis.conf  内容如下创建：/home/docker/redis/data#设置进程锁文件pidfile /redis/redis.pid  #端口port <span class="hljs-number">6379</span>#客户端超时时间timeout <span class="hljs-number">1500</span>  #日志级别loglevel debug  #设置数据库的数量，默认数据库为0，可以使用SELECT &lt;dbid&gt;命令在连接上指定数据库iddatabases <span class="hljs-number">8</span>  ##指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合#save &lt;seconds&gt; &lt;changes&gt;#Redis默认配置文件中提供了三个条件：save <span class="hljs-number">900</span> <span class="hljs-number">1</span>save <span class="hljs-number">300</span> <span class="hljs-number">10</span>save <span class="hljs-number">60</span> <span class="hljs-number">10000</span>  #指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，#可以关闭该#选项，但会导致数据库文件变的巨大rdbcompression yes  #指定本地数据库文件名dbfilename dump.rdb#指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能#会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有#的数据会在一段时间内只存在于内存中appendonly no#指定更新日志条件，共有3个可选值：#no：表示等操作系统进行数据缓存同步到磁盘（快）#always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）#everysec：表示每秒同步一次（折衷，默认值）appendfsync everysec#redis配置外网访问：<span class="hljs-keyword">protected</span>-mode no #配置密码requirepass <span class="hljs-number">123456</span> 运行命令:如redis为例：docker run -d --privileged=<span class="hljs-keyword">true</span> -p <span class="hljs-number">56379</span>:<span class="hljs-number">6379</span> -v /docker/redis/conf/redis.conf:/etc/redis/redis.conf -v /docker/redis/data:/data --name redis_56379 redis redis-server /etc/redis/redis.conf --appendonly yes --requirepass <span class="hljs-number">123456</span>映射ip <span class="hljs-number">56379</span>-&gt;<span class="hljs-number">6379</span> 映射宿主机文件夹（配置文件和数据） 启动redis-server 按配置文件启动 密码规定为<span class="hljs-number">123456</span></code></pre><h3 id="Docker部署Nginx"><a href="#Docker部署Nginx" class="headerlink" title="Docker部署Nginx"></a>Docker部署Nginx</h3><pre><code class="hljs groovy">docker pull nginx创建对应文件夹，进行目录映射运行nginx镜像：docker run --name nginx<span class="hljs-number">-80</span> -d -p <span class="hljs-number">80</span>:<span class="hljs-number">80</span> -v <span class="hljs-regexp">/home/</span>docker_nginx<span class="hljs-regexp">/html:/</span>usr<span class="hljs-regexp">/share/</span>nginx<span class="hljs-regexp">/html -v /</span>home<span class="hljs-regexp">/docker_nginx/</span>nginx.<span class="hljs-string">conf:</span><span class="hljs-regexp">/etc/</span>nginx<span class="hljs-regexp">/nginx.conf:ro -v /</span>home<span class="hljs-regexp">/docker_nginx/</span>conf.<span class="hljs-string">d:</span><span class="hljs-regexp">/etc/</span>nginx/conf.d nginxip映射<span class="hljs-number">80</span>，文件夹映射，注意nginx.<span class="hljs-string">conf:</span>ro 可读权限，conf.d目录下存放对应的配置即可</code></pre><p>Nginx配置说明：</p><p><img src="/2023/09/12/Docker%E7%AF%87/image-20191121191436791.png" srcset="/img/loading.gif" alt="image-20191121191436791"></p><pre><code class="hljs jade">nginx.conf  核心配置，可不用修改user  nginx;worker_processes  1;error_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log warn;pid        &#x2F;var&#x2F;run&#x2F;nginx.pid;events &#123;    worker_connections  1024;&#125;http &#123;    include       &#x2F;etc&#x2F;nginx&#x2F;mime.types;    default_type  application&#x2F;octet-stream;    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;                                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;                                                            &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;     access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log  main;     sendfile        on;     #tcp_nopush     on;     keepalive_timeout  65;     #gzip  on;     include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf;&#125;</code></pre><p>Nginx - conf.d目录下配置，针对每一个域名的具体配置</p><pre><code class="hljs java">说明：一个域名对应一个文件，如kkzhilu.cn.conf为例upstream tomcat &#123;    # 内网IP，然后限制8080端口对外访问，即可保证用户只从nginx进入，提高访问上限    # 或，localhost -&gt; 注意不要使用127.0.0.1，docker内无法识别    # 另外，如微服务架构的话，限制端口，也可以保证用户只能从网关层进入，保证后台服务的安全    server  <span class="hljs-number">172.21</span><span class="hljs-number">.0</span><span class="hljs-number">.8</span>:<span class="hljs-number">8080</span>;&#125; server &#123;    listen       <span class="hljs-number">80</span>;        # 监听域名例如想要代理两个网站，需要配合本机host，请求商host，代理请求的域名    server_name  localhost;     location / &#123;      proxy_pass http:<span class="hljs-comment">//tomcat;</span>    &#125;&#125;<span class="hljs-comment">// 详情请看 /Nginx-配置实战</span></code></pre><p>参考博文：</p><p>docker 快速部署tomcat：<a href="https://blog.csdn.net/weixin_39835887/article/details/84516595" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39835887/article/details/84516595</a> </p><p>51博客:<a href="https://blog.51cto.com/11134648/2160257" target="_blank" rel="noopener">https://blog.51cto.com/11134648/2160257</a> </p><p>菜鸟教程</p><p>how2j</p><p>博客园创建安装基本命令等：<a href="https://www.cnblogs.com/lsgxeva/p/8746644.html" target="_blank" rel="noopener">https://www.cnblogs.com/lsgxeva/p/8746644.html</a> </p><p>镜像制作：<a href="https://www.cnblogs.com/iloverain/p/8980275.html" target="_blank" rel="noopener">https://www.cnblogs.com/iloverain/p/8980275.html</a> </p><p>docker 快速部署redis：<a href="https://blog.csdn.net/wcuuchina/article/details/86355362" target="_blank" rel="noopener">https://blog.csdn.net/wcuuchina/article/details/86355362</a> </p><h3 id="Docker制作镜像推送到仓库"><a href="#Docker制作镜像推送到仓库" class="headerlink" title="Docker制作镜像推送到仓库"></a>Docker制作镜像推送到仓库</h3><pre><code class="hljs java">博文地址：https:<span class="hljs-comment">//www.cnblogs.com/yaohong/p/9221800.html</span><span class="hljs-number">1</span>.制作镜像，可以从公网随意拉一个容器，本地运行，再把它变成镜像即可<span class="hljs-number">2</span>.比如我拉取了tomcat镜像，配置之后会变成容器<span class="hljs-number">3</span>.把最终的运行容器变成镜像先停止容器运行，再执行：docker commit -m <span class="hljs-string">"my_tomcat"</span> -a <span class="hljs-string">"kerwin"</span> tomcat-<span class="hljs-number">8080</span>  kerwin_tomcat_8080:v1<span class="hljs-number">.0</span>-m 描述，-a作者 后面是镜像名，然后的推送之后的镜像名最后是版本号打标，通过images拿到对应镜像的id，再给它重新打标docker tag <span class="hljs-number">179396596</span>cbd <span class="hljs-number">806857264</span>/kerwin_docker:kerwin_tomcat_8080docker                    --- 命令tag                       --- 命令<span class="hljs-number">179396596</span>cbd              --- 镜像id<span class="hljs-number">806857264</span>/kerwin_docker:  --- 用户名和仓库名（仓库没有的话自动创建，所以不用自己去建）kerwin_tomcat_8080        --- 取的是commit的最终镜像名最后是pushdocker push <span class="hljs-number">806857264</span>/kerwin_docker:kerwin_tomcat_8080kerwin_tomcat_8080 就是上文打标的目标镜像去官网：https:<span class="hljs-comment">//cloud.docker.com/repository/list</span>检查即可注：为什么要commit推送， 因为在容器内部修改的，配置的文件，在关闭启动之后，会消失，所以，如果有改动内部文件，则需要制作新的镜像，然后推送，如果仅仅是宿主机目录的变化的话，是不需要重新制作镜像的</code></pre><h3 id="Docker部署第三方Jar包"><a href="#Docker部署第三方Jar包" class="headerlink" title="Docker部署第三方Jar包"></a>Docker部署第三方Jar包</h3><pre><code class="hljs dockerfile">指导博文：https://www.cnblogs.com/bxssjava/p/<span class="hljs-number">9978449</span>.html第一步：准备好一个正常完好的jar第二步：Dockerfile文件 注意不要有后缀<span class="hljs-keyword">FROM</span> openjdk:<span class="hljs-number">8</span>-jdk-alpine<span class="hljs-keyword">VOLUME</span><span class="bash"> /tmp</span><span class="hljs-keyword">ADD</span><span class="bash"> target/demo_test_nginx-0.0.1-SNAPSHOT.jar app.jar</span><span class="hljs-keyword">RUN</span><span class="bash"> sh -c <span class="hljs-string">'touch /app.jar'</span></span><span class="hljs-keyword">ENV</span> JAVA_OPTS=<span class="hljs-string">""</span><span class="hljs-keyword">ENTRYPOINT</span><span class="bash"> [<span class="hljs-string">"java"</span>,<span class="hljs-string">"-Djava.security.egd=file:/dev/./urandom"</span>,<span class="hljs-string">"-jar"</span>,<span class="hljs-string">"/app.jar"</span>]</span>第三步：在linux服务器指定的目录下，放好jar和dockerfile文件第四步：docker build -t 【镜像名字】 .注意上面的.  表示此目录第五步：正常运行即可如:docker <span class="hljs-keyword">run</span><span class="bash"> --name demo-10909 -p 10909:10909 -d viando/demo</span></code></pre><h3 id="Docker-自动化部署-shell命令"><a href="#Docker-自动化部署-shell命令" class="headerlink" title="Docker 自动化部署 - shell命令"></a>Docker 自动化部署 - shell命令</h3><pre><code class="hljs shell">创建  docker.sh文件，写入以下命令，将之和jar以及Dockerfile放在一个目录,必要的时候修改 app名，容器名或者镜像名即可注意必要情况修改端口映射<span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><span class="hljs-meta">#</span><span class="bash">JAR 名称 - 替换即可</span>APP_NAME=demo_test_nginx-0.0.1-SNAPSHOT.jar<span class="hljs-meta">#</span><span class="bash">容器名称 - 替换即可</span>CONTAINER_NAME=demo-10909<span class="hljs-meta">#</span><span class="bash">镜像名称 - 替换即可</span>IAMGE_NAME=viando/demo<span class="hljs-meta">#</span><span class="bash">使用说明，用来提示输入参数</span>usage() &#123;    echo "Usage: sh 执行脚本.sh [start|build] desc: start is for run jar and build is build images for docker"    exit 1&#125;<span class="hljs-meta">#</span><span class="bash">启动方法-包含build过程</span>start()&#123;  build  docker run --name $CONTAINER_NAME -v /home/log:/log -p 10909:10909 -d $IAMGE_NAME  <span class="hljs-meta">  #</span><span class="bash">挂载日志</span>&#125;<span class="hljs-meta">#</span><span class="bash">构建image方法</span>build()&#123;  docker stop $CONTAINER_NAME  docker rm   $CONTAINER_NAME  docker rmi  $IAMGE_NAME  <span class="hljs-meta">  #</span><span class="bash">构建</span>  docker build -t $IAMGE_NAME .&#125;<span class="hljs-meta">#</span><span class="bash">根据输入参数，选择执行对应方法，不输入则执行使用说明</span>case "$1" in  "start")    start    ;;  "build")    build    ;;  *)    usage    ;;esac</code></pre><blockquote><p>注意 .sh shell 文件 编码格式为 Unix(LF)格式</p></blockquote><h3 id="Docker-自动化-shell-获取容器ID"><a href="#Docker-自动化-shell-获取容器ID" class="headerlink" title="Docker 自动化 - shell 获取容器ID"></a>Docker 自动化 - shell 获取容器ID</h3><pre><code class="hljs shell">DOCKER_ID=$(docker ps | grep "rpcapp" | awk '&#123;print $1&#125;')<span class="hljs-meta">#</span><span class="bash"> 打印ID观察</span>echo $DOCKER_IDdocker exec -it $DOCKER_ID bash</code></pre><blockquote><p>注意 .sh shell 文件 编码格式为 Unix(LF)格式</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>中间件篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Guava的两种本地缓存策略</title>
    <link href="/2023/09/12/Guava%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/"/>
    <url>/2023/09/12/Guava%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="Guava的两种本地缓存策略"><a href="#Guava的两种本地缓存策略" class="headerlink" title="Guava的两种本地缓存策略"></a>Guava的两种本地缓存策略</h1><p>缓存在很多场景下都需要使用，如果电商网站的商品类别的查询，订单查询，用户基本信息的查询等等，针对这种读多写少的业务，都可以考虑使用到缓存。在一般的缓存系统中，除了分布式缓存，还会有多级缓存，在提升一定性能的前提下，可以在一定程度上避免缓存击穿或缓存雪崩，也能降低分布式缓存的负载。</p><h2 id="GuavaCache的优点"><a href="#GuavaCache的优点" class="headerlink" title="GuavaCache的优点"></a>GuavaCache的优点</h2><p>1）很好的封装了get、put操作，能够集成数据源。一般我们在业务中操作缓存都会操作缓存和数据源两部分。例如：put数据时，先插入DB再删除原来的缓存，get数据时，先查缓存，命中则返回，没有命中时需要查询DB，再把查询结果放入缓存中。Guava封装了这么多步骤，只需要调用一次get/put方法即可</p><p>2）它是线程安全的缓存，与ConcurrentMap相似，但前者增加了更多的元素失效策略，后者只能显示的移除元素</p><p>3）GuavaCache提供了三种基本的缓存回收方式：基于容量回收、定时回收和基于引用回收。定时回收有两种：按照写入时间，最早写入的最先回收；按照访问时间，最早访问的最早回收</p><p>4）它可以监控加载/命中情况</p><h2 id="Cache类型本地缓存"><a href="#Cache类型本地缓存" class="headerlink" title="Cache类型本地缓存"></a>Cache类型本地缓存</h2><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mine.localcache.guava;<span class="hljs-keyword">import</span> com.google.common.cache.Cache;<span class="hljs-keyword">import</span> com.google.common.cache.CacheBuilder;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">import</span> java.util.concurrent.Callable;<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<span class="hljs-comment">/**</span><span class="hljs-comment"> * ******************************</span><span class="hljs-comment"> * author：      柯贤铭</span><span class="hljs-comment"> * createTime:   2019/7/30 14:21</span><span class="hljs-comment"> * description:  Guava 本地缓存 -&gt; Cache类型</span><span class="hljs-comment"> *               用于SpringBoot项目中,启用单例模式 项目启动时进行初始化</span><span class="hljs-comment"> * pay attention -&gt; A. 注意不要重复实例化, 最好交由IOC管理</span><span class="hljs-comment"> *                  B. 注意如果是写操作则获取缓存值后拷贝一份副本，然后传递该副本，进行修改操作</span><span class="hljs-comment"> *                  C. 支持自定义call回调</span><span class="hljs-comment"> * version:      V1.0</span><span class="hljs-comment"> * ******************************</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CacheUtil</span> </span>&#123;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 构造方法 - 进行初始化</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> maxSize      最大容量</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> invalidTime  刷新时间 | 基于分钟级别</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CacheUtil</span><span class="hljs-params">(<span class="hljs-keyword">long</span> maxSize, <span class="hljs-keyword">long</span> invalidTime)</span> </span>&#123;        init(maxSize, invalidTime);    &#125;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 初始化</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span> <span class="hljs-params">(<span class="hljs-keyword">long</span> maxSize, <span class="hljs-keyword">long</span> invalidTime)</span> </span>&#123;        <span class="hljs-comment">// 缓存</span>        cache = CacheBuilder.newBuilder()                <span class="hljs-comment">// 设置缓存在写入invalidTime分钟后失效</span>                .expireAfterWrite(invalidTime, TimeUnit.MINUTES)                <span class="hljs-comment">// 设置缓存个数</span>                .maximumSize(maxSize)                .concurrencyLevel(Runtime.getRuntime().availableProcessors())                .recordStats()                .build();    &#125;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * Guava Cache类型缓存</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> Cache cache;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 对外暴露的方法 -&gt; 从缓存中取value，没取到会返回null</span><span class="hljs-comment">     *</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getValue</span> <span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-keyword">return</span> cache.getIfPresent(key);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 对外暴露的方法 -&gt; 从缓存中取value，没取到会执行call</span><span class="hljs-comment">     *</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getValue</span> <span class="hljs-params">(String key, Callable callable)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">return</span> cache.get(key, callable);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 对外暴露的方法 -&gt; put</span><span class="hljs-comment">     *</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putValue</span> <span class="hljs-params">(String key, Object value)</span> </span>&#123;        cache.put(key, value);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 对外暴露的方法 -&gt; putMap</span><span class="hljs-comment">     *</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putMap</span> <span class="hljs-params">(String key, Map map)</span> </span>&#123;        cache.putAll(map);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 对外暴露的方法 -&gt; 判断是否存在key</span><span class="hljs-comment">     *</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">constainsKey</span> <span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-keyword">return</span> cache.asMap().containsKey(key);    &#125;&#125;</code></pre><h2 id="Loading类型缓存"><a href="#Loading类型缓存" class="headerlink" title="Loading类型缓存"></a>Loading类型缓存</h2><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mine.localcache.guava;<span class="hljs-keyword">import</span> com.google.common.cache.CacheBuilder;<span class="hljs-keyword">import</span> com.google.common.cache.CacheLoader;<span class="hljs-keyword">import</span> com.google.common.cache.LoadingCache;<span class="hljs-keyword">import</span> com.google.common.util.concurrent.ListenableFuture;<span class="hljs-keyword">import</span> com.google.common.util.concurrent.ListeningExecutorService;<span class="hljs-keyword">import</span> com.google.common.util.concurrent.MoreExecutors;<span class="hljs-keyword">import</span> java.util.concurrent.ExecutionException;<span class="hljs-keyword">import</span> java.util.concurrent.LinkedBlockingQueue;<span class="hljs-keyword">import</span> java.util.concurrent.ThreadPoolExecutor;<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<span class="hljs-comment">/**</span><span class="hljs-comment"> * ******************************</span><span class="hljs-comment"> * author：      柯贤铭</span><span class="hljs-comment"> * createTime:   2019/7/30 14:21</span><span class="hljs-comment"> * description:  Guava 本地缓存 -&gt; LoadingCache类型</span><span class="hljs-comment"> *               用于SpringBoot项目中,启用单例模式 项目启动时进行初始化</span><span class="hljs-comment"> *               博文参考: https://www.cnblogs.com/csonezp/p/10011031.html</span><span class="hljs-comment"> * pay attention -&gt; A. 注意不要重复实例化, 最好交由IOC管理</span><span class="hljs-comment"> *                  B. 注意重写与之匹配的数据源获取方法 - getFromDB</span><span class="hljs-comment"> *                  C. 注意如果是写操作则获取缓存值后拷贝一份副本，然后传递该副本，进行修改操作</span><span class="hljs-comment"> *                  D. 注意绝对不要返回null值作为value, 会引发InvalidCacheLoadException异常</span><span class="hljs-comment"> *                     对于该情况可以自定义处理方式, 主动将其捕获</span><span class="hljs-comment"> *                  E. 此类型缓存提倡自动加载缓存数据, 因此尽量避免手动put</span><span class="hljs-comment"> *                     如果需要更灵活的方案可以使用Cache类型</span><span class="hljs-comment"> *                  F. 灵活设置参数, 启用自动失效策略或者自动刷新策略</span><span class="hljs-comment"> * version:      V1.0</span><span class="hljs-comment"> * ******************************</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoadingCacheUtil</span> </span>&#123;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 构造方法 - 进行初始化</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> maxSize      最大容量</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> refreshTime  刷新时间 | 基于分钟级别</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LoadingCacheUtil</span><span class="hljs-params">(<span class="hljs-keyword">long</span> maxSize, <span class="hljs-keyword">long</span> refreshTime)</span> </span>&#123;        init(maxSize, refreshTime);    &#125;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 初始化</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span> <span class="hljs-params">(<span class="hljs-keyword">long</span> maxSize, <span class="hljs-keyword">long</span> refreshTime)</span> </span>&#123;        <span class="hljs-comment">// 刷新线程池 -&gt; 如果数据都没了则启用后台线程进行刷新,让用户无感知 -&gt; 核心线程数 1, 最大线程数 2</span>        backgroundRefreshPools = MoreExecutors.listeningDecorator(<span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS, <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;&gt;()));        <span class="hljs-comment">// 缓存</span>        cache = CacheBuilder.newBuilder()                <span class="hljs-comment">// 缓存刷新时间</span>                .refreshAfterWrite(refreshTime, TimeUnit.MINUTES)                <span class="hljs-comment">// 设置缓存在写入invalidTime分钟后失效</span>                <span class="hljs-comment">//.expireAfterWrite(refreshTime, TimeUnit.MINUTES)</span>                <span class="hljs-comment">// 设置缓存个数</span>                .maximumSize(maxSize)                .concurrencyLevel(Runtime.getRuntime().availableProcessors())                .recordStats()                .build(<span class="hljs-keyword">new</span> CacheLoader&lt;String, Object&gt;() &#123;                    <span class="hljs-comment">// 当本地缓存命没有中时，调用load方法获取结果并将结果缓存</span>                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">load</span><span class="hljs-params">(String appKey)</span> </span>&#123;                        <span class="hljs-keyword">return</span> getFromDB(appKey);                    &#125;                    <span class="hljs-comment">// 刷新时，开启一个新线程异步刷新，老请求直接返回旧值，防止耗时过长</span>                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> ListenableFuture&lt;Object&gt; <span class="hljs-title">reload</span><span class="hljs-params">(String key, Object oldValue)</span> </span>&#123;                        <span class="hljs-keyword">return</span> backgroundRefreshPools.submit(() -&gt; getFromDB(key));                    &#125;                    <span class="hljs-comment">// 数据库进行查询</span>                    <span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">getFromDB</span> <span class="hljs-params">(String key)</span> </span>&#123;                        <span class="hljs-comment">// return entryMapper.selectByName(name)</span>                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;                    &#125;                &#125;);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 后台处理线程池</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> ListeningExecutorService backgroundRefreshPools;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * Guava LoadingCache类型缓存</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> LoadingCache cache;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 对外暴露的方法 -&gt; 从缓存中取value，没取到会自动重载缓存,如果载入为null则触发异常</span><span class="hljs-comment">     *</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getValue</span> <span class="hljs-params">(String key)</span> <span class="hljs-keyword">throws</span> ExecutionException </span>&#123;        <span class="hljs-keyword">return</span> cache.get(key);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 对外暴露的方法 -&gt; 判断是否存在key</span><span class="hljs-comment">     *</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">constainsKey</span> <span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-keyword">return</span> cache.asMap().containsKey(key);    &#125;&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>1.本地缓存其实很多种数据结构都支持，比如线程安全的ConcurrentHashMap，用该结构配合TimerTask定时清除key，也可以实现，但是一是自己写的代码肯定没有谷歌工具厉害，另外一点，缓存更重要的特性不是可存可取，而是可以自动的去识别哪些key更活跃，哪些key不活跃，删除掉，<br>因此基于LRU算法，Google提供的Guava就可以很好的满足这一点</p></li><li><p>2.Cache类型缓存更像ConcurrentHashMap，有点随便存随便取的意思，同时支持定时回收，也支持get不到缓存内容时走call回调接口去数据，总的来说非常方便</p></li><li><p>3.LoadingCache类型缓存相比而言用的更加规范一些,它提供的思想是有一套完整的DB方案，提供定时刷新缓存,提供默认load方法，reload方法，相比于Cache，它要求更加严格，比如缓存内容不可返回null等等,也不建议手动put数据，而是专门通过DB的途径去刷新数据，因此真正的生产环境用的会更多一些</p></li></ul><blockquote><p>QQ：806857264</p><p>GitHub：<a href="https://github.com/kkzhilu" target="_blank" rel="noopener">https://github.com/kkzhilu</a></p><p>如有什么问题，望指正，互相交流</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Guava的两种本地缓存策略</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git-IDEA-技巧</title>
    <link href="/2023/09/12/Git-IDEA-%E6%8A%80%E5%B7%A7/"/>
    <url>/2023/09/12/Git-IDEA-%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="Git-IDEA-技巧"><a href="#Git-IDEA-技巧" class="headerlink" title="Git-IDEA-技巧"></a>Git-IDEA-技巧</h1><h2 id="GitHub高级搜索"><a href="#GitHub高级搜索" class="headerlink" title="GitHub高级搜索"></a>GitHub高级搜索</h2><h3 id="仓库名搜索"><a href="#仓库名搜索" class="headerlink" title="仓库名搜索"></a>仓库名搜索</h3><pre><code class="hljs applescript"><span class="hljs-keyword">in</span>:<span class="hljs-built_in">name</span> spring boot</code></pre><h3 id="Stars-forks-搜索"><a href="#Stars-forks-搜索" class="headerlink" title="Stars | forks 搜索"></a>Stars | forks 搜索</h3><pre><code class="hljs vim"># 注意 <span class="hljs-keyword">star</span><span class="hljs-variable">s:</span>&gt;<span class="hljs-number">3000</span> 中间要连起来,不要有空格in:name spring boot <span class="hljs-keyword">star</span><span class="hljs-variable">s:</span>&gt;<span class="hljs-number">3000</span>                 ...fork<span class="hljs-variable">s:</span>&gt;<span class="hljs-number">1000</span></code></pre><h3 id="ReadMe搜索"><a href="#ReadMe搜索" class="headerlink" title="ReadMe搜索"></a>ReadMe搜索</h3><pre><code class="hljs avrasm"><span class="hljs-symbol">in:</span>readme spring boot</code></pre><h3 id="描述搜索"><a href="#描述搜索" class="headerlink" title="描述搜索"></a>描述搜索</h3><pre><code class="hljs avrasm"><span class="hljs-symbol">in:</span>description 微服务</code></pre><h3 id="语言限定"><a href="#语言限定" class="headerlink" title="语言限定"></a>语言限定</h3><pre><code class="hljs avrasm"><span class="hljs-symbol">language:</span>java</code></pre><h3 id="Push时间限定"><a href="#Push时间限定" class="headerlink" title="Push时间限定"></a>Push时间限定</h3><pre><code class="hljs angelscript">Pushed:&gt;<span class="hljs-number">2019</span><span class="hljs-number">-10</span></code></pre><h2 id="Git-项目构建-添加-gitignore文件"><a href="#Git-项目构建-添加-gitignore文件" class="headerlink" title="Git 项目构建 添加.gitignore文件"></a>Git 项目构建 添加.gitignore文件</h2><h3 id="gitignore-Content"><a href="#gitignore-Content" class="headerlink" title=".gitignore Content"></a>.gitignore Content</h3><pre><code class="hljs python">HELP.mdtarget/!.mvn/wrapper/maven-wrapper.jar!**/src/main/**!**/src/test/**<span class="hljs-comment">### STS ###</span>.apt_generated.classpath.factorypath.project.settings.springBeans.sts4-cache<span class="hljs-comment">### IntelliJ IDEA ###</span>.idea*.iws*.iml*.ipr<span class="hljs-comment">### NetBeans ###</span>/nbproject/private//nbbuild//dist//nbdist//.nb-gradle/build/<span class="hljs-comment">### VS Code ###</span>.vscode/</code></pre><h3 id="Git-初次提交-操作步骤"><a href="#Git-初次提交-操作步骤" class="headerlink" title="Git 初次提交 操作步骤"></a>Git 初次提交 操作步骤</h3><pre><code class="hljs java"><span class="hljs-comment">// 1. 第一步 commit，push .gitignore 文件</span><span class="hljs-comment">// 2. 之后再提交即不用重复处理非必要文件</span><span class="hljs-comment">// 3. 如果 .gitignore 不起作用的处理办法:</span><span class="hljs-comment">// 清理相关缓存</span>git rm -r --cached .git add .<span class="hljs-comment">// 再进行提交</span>    <span class="hljs-comment">// 同时：注意初次提交时是否提交了多余的内容</span></code></pre><h3 id="Windows-Cmd-集成-Git-Bash"><a href="#Windows-Cmd-集成-Git-Bash" class="headerlink" title="Windows Cmd 集成 Git Bash"></a>Windows Cmd 集成 Git Bash</h3><pre><code class="hljs 安装">&#96;&#96;&#96;python# Path 变量添加如下路径:     测试验证：改变了系统级别CMD的功能，利用Java执行的linux 命令也可以支持F:\Git\Git\cmdF:\Git\Git\usr\binF:\Git\Git\mingw64\bin</code></pre><h3 id="Git合并多次提交结果为一次"><a href="#Git合并多次提交结果为一次" class="headerlink" title="Git合并多次提交结果为一次"></a>Git合并多次提交结果为一次</h3><p><a href="https://www.cnblogs.com/itplay/p/11732353.html" target="_blank" rel="noopener">原文介绍文章链接</a></p><h2 id="IDEA调试技巧"><a href="#IDEA调试技巧" class="headerlink" title="IDEA调试技巧"></a>IDEA调试技巧</h2><h3 id="断点指定条件"><a href="#断点指定条件" class="headerlink" title="断点指定条件"></a>断点指定条件</h3><p><img src="/2023/09/12/Git-IDEA-%E6%8A%80%E5%B7%A7/1573740941349.png" srcset="/img/loading.gif" alt="1573740941349"></p><h3 id="方法调用跳回"><a href="#方法调用跳回" class="headerlink" title="方法调用跳回"></a>方法调用跳回</h3><p><img src="/2023/09/12/Git-IDEA-%E6%8A%80%E5%B7%A7/1573741222341.png" srcset="/img/loading.gif" alt="1573741222341"></p><h3 id="多线程调试"><a href="#多线程调试" class="headerlink" title="多线程调试"></a>多线程调试</h3><p><img src="/2023/09/12/Git-IDEA-%E6%8A%80%E5%B7%A7/640.webp" srcset="/img/loading.gif" alt="img"></p><h3 id="调式中修改变量测试效果"><a href="#调式中修改变量测试效果" class="headerlink" title="调式中修改变量测试效果"></a>调式中修改变量测试效果</h3><p><img src="/2023/09/12/Git-IDEA-%E6%8A%80%E5%B7%A7/1573741336421.png" srcset="/img/loading.gif" alt="1573741336421"></p><h3 id="IDEA快捷键"><a href="#IDEA快捷键" class="headerlink" title="IDEA快捷键"></a>IDEA快捷键</h3><pre><code class="hljs elixir">ctrl + Alt + C         ---&gt; 抽取变量ctrl + Alt + V         ---&gt; 抽取表达式ctrl + Alt + M         ---&gt; 抽取方法Ctrl + O               ---&gt;  重写父类方法 Ctrl + H               ---&gt;  查看类的关系Shift + Alt + R        弹出重构菜单 原<span class="hljs-symbol">:Ctrl+Alt+Shift+T</span>Shift + Alt + E        Extract菜单，帮助快速提取代码等Shift + Alt + Z        操作菜单，if，<span class="hljs-keyword">do</span> <span class="hljs-keyword">while</span>等等IDEA ----&gt;  iter       增强<span class="hljs-keyword">for</span>循环自动填充list.fori  list.for    自动填充Annotate               鼠标右键显示代码最近是谁提交的DeBug时                选中某一行，然后 Evaluate Expression  Debug时执行代码KeyMap                 快捷键查找，如下图所示 可以通过快捷键进行查找ctrl + shift +  + | -  一键把缩略或者打开所有方法ctrl + + | -           缩略当前方法</code></pre><p><img src="/2023/09/12/Git-IDEA-%E6%8A%80%E5%B7%A7/1571794285538.png" srcset="/img/loading.gif" alt></p><h3 id="IDEA-全局搜索-替换功能"><a href="#IDEA-全局搜索-替换功能" class="headerlink" title="IDEA 全局搜索 | 替换功能"></a>IDEA 全局搜索 | 替换功能</h3><pre><code class="hljs java"><span class="hljs-comment">// 1. 全局搜索和全局替换 有文件类型筛选功能，指定路径范围， 作用范围等等</span><span class="hljs-comment">// 2. 全局搜索 全局替换支持正则表达式</span>如 通过正则全局替换： css\?v=.+?<span class="hljs-string">"   ---》  css"</span>js\?v=.+?<span class="hljs-string">"    ---》   js"</span>pdf\?v=.+?<span class="hljs-string">"   ---》  pdf"</span>    <span class="hljs-string">"/(.+?js)"</span>   <span class="hljs-string">"/(.+?css)"</span>    <span class="hljs-string">"/(.+?pdf)"</span>===&gt; <span class="hljs-string">"/$1?v=$&#123;oem_resource_version&#125;"</span>    这也给我们启示，不要重复造轮子，好好利用当下的现有工具</code></pre><h3 id="IDEA-便利设置"><a href="#IDEA-便利设置" class="headerlink" title="IDEA 便利设置"></a>IDEA 便利设置</h3><blockquote><p>Window -&gt; Editor Tabs -&gt; Tabs Placement，取消勾选 Show Tabs In Single Row选项</p></blockquote><h3 id="IDEA-全局检查"><a href="#IDEA-全局检查" class="headerlink" title="IDEA 全局检查"></a>IDEA 全局检查</h3><ol><li>全局扫描错误，异常，警告  Analyze Inspect Code… </li><li>Ctrl + Alt + Shift + I  -&gt; 输入需要插件的警告类型即可全局扫描</li></ol><h3 id="IDEA-导入-插件项目方法"><a href="#IDEA-导入-插件项目方法" class="headerlink" title="IDEA 导入 插件项目方法"></a>IDEA 导入 插件项目方法</h3><blockquote><pre><code class="hljs 注意:```插件项目需要平常无所谓的">1. 注意项目SDK，设置Platform Settings idea SDK，设置 Project SDK为idea SDK2. 添加Configurations为Plugin终极解决方案：如果始终无法导入，建议新建同名插件项目，然后进行文件替换注意 .iml文件，git相关文件即可### IDEA 快捷键打日志 </code></pre><p>快捷键：自定义，如 logp<br>内容：logger.info(“$METHOD_NAME$::”$ARGUMENTS$);<br>参数一：methodName();<br>参数二：groovyScript(“def result=’’; def params=&quot;${_1}&quot;.replaceAll(‘[\\[|\\]|\\s]’, ‘’).split(‘,’).toList();for(i = 0; i &lt; params.size(); i++) {if(i==0){result+=’+&quot; ‘ + params[i] + ‘ :&quot;+ ‘+params[i];}else{result+=’ +&quot;; ‘ + params[i] + ‘ :&quot;+ ‘+params[i];}}; return result;”, methodParameters());</p></blockquote><pre><code class="hljs markdown">![<span class="hljs-string">image-20201122213200577</span>](<span class="hljs-link">Git-IDEA-技巧/image-20201122213200577.png</span>)<span class="hljs-section">### IDEA 显示Git更新涉及的文件</span>可能无意间点到显示差异导致Git查看无法显示涉及的文件，IDEA搜索快捷键：Version Control Systems | File History | Show Details然后进入Git，选择更新的记录，使用快捷键即可![<span class="hljs-string">image-20210121203609799</span>](<span class="hljs-link">Git-IDEA-技巧/image-20210121203609799.png</span>)<span class="hljs-section">### Eclipse导入SpringBoot项目方法</span>基于Maven的方式导入之后，如果pom.xml报未知错误，是由于Maven版本不兼容导致，处理办法：<span class="hljs-code">```xml</span><span class="hljs-code">// 设置Maven版本为3.1.1 然后Update项目即可</span><span class="hljs-code">&lt;maven-jar-plugin.version&gt;3.1.1&lt;/maven-jar-plugin.version&gt;</span></code></pre><h2 id="Pycharm-环境构建-统一依赖文件"><a href="#Pycharm-环境构建-统一依赖文件" class="headerlink" title="Pycharm 环境构建 统一依赖文件"></a>Pycharm 环境构建 统一依赖文件</h2><pre><code class="hljs 统一设置为">![image-20191120153539863](Git-IDEA-技巧&#x2F;image-20191120153539863.png)- 更改pip源，注意刷新：https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;- 插件，快捷键参考IDEA即可## Maven 镜像### 配置阿里云镜像 - 并强制项目启用&#96;&#96;&#96;xml&lt;!--配置阿里云Maven镜像--&gt;&lt;mirror&gt;    &lt;id&gt;nexus-aliyun&lt;&#x2F;id&gt;    &lt;mirrorOf&gt;central&lt;&#x2F;mirrorOf&gt;    &lt;name&gt;Nexus aliyun&lt;&#x2F;name&gt;    &lt;url&gt;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&lt;&#x2F;url&gt;&lt;&#x2F;mirror&gt;</code></pre><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 启用阿里云镜像下载依赖 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>nexus-aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pluginRepositories</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">pluginRepository</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">pluginRepository</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pluginRepositories</span>&gt;</span></code></pre><h2 id="监听端口技巧"><a href="#监听端口技巧" class="headerlink" title="监听端口技巧"></a>监听端口技巧</h2><h3 id="伪造服务端监听端口"><a href="#伪造服务端监听端口" class="headerlink" title="伪造服务端监听端口"></a>伪造服务端监听端口</h3><pre><code class="hljs java"><span class="hljs-comment">// 伪造6379 redis-服务端，监听  jedis发送的协议内容</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SocketApp</span> </span>&#123;        <span class="hljs-comment">/***</span><span class="hljs-comment">     * 监听 6379 传输的数据</span><span class="hljs-comment">     * JVM端口需要进行设置</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>  </span>&#123;        <span class="hljs-keyword">try</span> &#123;            ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6379</span>);            Socket redis = serverSocket.accept();            <span class="hljs-keyword">byte</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">2048</span>];            redis.getInputStream().read(result);            System.out.println(<span class="hljs-keyword">new</span> String(result));        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span class="hljs-comment">// jedis连接-发送命令</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">"127.0.0.1"</span>);        jedis.set(<span class="hljs-string">"key"</span>, <span class="hljs-string">"This is value."</span>);        jedis.close();    &#125;&#125;<span class="hljs-comment">// 监听命令内容如下：</span>*<span class="hljs-number">3</span>$<span class="hljs-number">3</span>SET$<span class="hljs-number">3</span>key$<span class="hljs-number">14</span></code></pre><h2 id="开发技巧"><a href="#开发技巧" class="headerlink" title="开发技巧"></a>开发技巧</h2><h3 id="链接分享实战"><a href="#链接分享实战" class="headerlink" title="链接分享实战"></a>链接分享实战</h3><blockquote><p>分享处理技巧：</p><ol><li>为了不暴露真实的地址，利用转发比重定向更好</li><li>通过设计短链表，通过key映射真正的参数信息，进行页面请求转发即可</li><li>复杂界面请求多的情况下，接口需要一一处理支持分享功能</li></ol></blockquote><h3 id="复杂业务代码设计思路"><a href="#复杂业务代码设计思路" class="headerlink" title="复杂业务代码设计思路"></a>复杂业务代码设计思路</h3><blockquote><p>代码设计思路：</p><ol><li>业务场景代码设计和最基础的数据结构及算法设计相同，需要更多的注意边界条件</li><li>具体需求层次，实现顺序，考虑影响范围 -》 实现思路最好从具体出发，向全量范围拓展</li><li>自行拆解需求，满足更多的场景使用</li><li>永远不要相信所谓的前提条件，用户和测试永远不会按照最理想的情况运行</li></ol><p>最好结合图进行绘制和处理</p></blockquote><h3 id="新增简单功能需要注意的问题"><a href="#新增简单功能需要注意的问题" class="headerlink" title="新增简单功能需要注意的问题"></a>新增简单功能需要注意的问题</h3><blockquote><p>代码设计思路：</p><ol><li>此简单功能，有没有其他影响功能？如果有，则需要找出来一并修改</li><li>此功能有没有类似功能，搜索类似功能关键词，找到其涉及的所有功能</li><li>根据类似功能及相关涉及的功能进行优化，检查，避免简单需求有其定式思维，导致BUG的增加</li></ol></blockquote><h2 id="IDEA-样式收集"><a href="#IDEA-样式收集" class="headerlink" title="IDEA 样式收集"></a>IDEA 样式收集</h2><ul><li>IDEA  <a href="https://plugins.jetbrains.com/plugin/11938-one-dark-theme/versions" target="_blank" rel="noopener"> One-Dark-Theme </a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Tips篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git-IDEA-技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo篇</title>
    <link href="/2023/09/12/Hexo%E7%AF%87/"/>
    <url>/2023/09/12/Hexo%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo篇"><a href="#Hexo篇" class="headerlink" title="Hexo篇"></a>Hexo篇</h1><h2 id="Kerwin-Hexo-Configs"><a href="#Kerwin-Hexo-Configs" class="headerlink" title="Kerwin Hexo Configs"></a>Kerwin Hexo Configs</h2><pre><code class="hljs java"># Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: Kerwin Roadsubtitle:description: 一切都是有可能的，甚至那些不可能的也是.keywords: Java JUC Python Vue 高并发 多线程author: Kerwinlanguage: zh-Hanstimezone:# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http:<span class="hljs-comment">//www.kkzhilu.xyz</span>root: /permalink: :year/:month/:day/:title/permalink_defaults: :category/:title# Directorysource_dir: sourcepublic_dir: <span class="hljs-keyword">public</span>tag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: <span class="hljs-number">0</span>render_drafts: <span class="hljs-keyword">false</span>post_asset_folder: <span class="hljs-keyword">true</span>relative_link: <span class="hljs-keyword">false</span>future: <span class="hljs-keyword">true</span>highlight:  enable: <span class="hljs-keyword">true</span>  line_number: <span class="hljs-keyword">true</span>  auto_detect: <span class="hljs-keyword">false</span>  tab_replace:  # Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator:  path: <span class="hljs-string">''</span>  per_page: <span class="hljs-number">10</span>  order_by: -date  # Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: <span class="hljs-number">10</span>pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git  repo: https:<span class="hljs-comment">//github.com/kkzhilu/kkzhilu.github.io.git</span>  branch: master  search:  path: search.xml  field: post  format: html  limit: <span class="hljs-number">10000</span></code></pre><h2 id="Theme-Next-Configs"><a href="#Theme-Next-Configs" class="headerlink" title="Theme Next Configs"></a>Theme Next Configs</h2><pre><code class="hljs java"># ===============================================================# ========================= ATTENTION! ==========================# ===============================================================# NexT repository is moving here: https://github.com/theme-next# ===============================================================# It's rebase to v6.0.0 and future maintenance will resume there# ===============================================================# ---# Theme Core Configuration Settings# ---# Set to true, if you want to fully override the default configuration.# Useful if you don't want to inherit the theme _config.yml configurations.override: <span class="hljs-keyword">false</span># ---# Site Information Settings# ---# To get or check favicons visit: https://realfavicongenerator.net# Put your favicons into `hexo-site/source/` (recommend) or `hexo-site/themes/next/source/images/` directory.# Default NexT favicons placed in `hexo-site/themes/next/source/images/` directory.# And if you want to place your icons in `hexo-site/source/` root directory, you must remove `/images` prefix from pathes.# For example, you put your favicons into `hexo-site/source/images` directory.# Then need to rename &amp; redefine they on any other names, otherwise icons from Next will rewrite your custom icons in Hexo.favicon:  small: /images/favicon-<span class="hljs-number">16</span>x16-next.png  medium: /images/favicon-<span class="hljs-number">32</span>x32-next.png  apple_touch_icon: /images/apple-touch-icon-next.png  safari_pinned_tab: /images/logo.svg  #android_manifest: /images/manifest.json  #ms_browserconfig: /images/browserconfig.xml# Set default keywords (Use a comma to separate)keywords: <span class="hljs-string">"Java Road"</span># Set rss to false to disable feed link.# Leave rss as empty to use site's feed link.# Set rss to specific value if you have burned your feed already.rss:footer:  # Specify the date when the site was setup.  # If not defined, current year will be used.  since: <span class="hljs-number">2019</span>  # Icon between year and copyright info.  icon: user  # If not defined, will be used `author` from Hexo main config.  copyright: <span class="hljs-keyword">false</span>  # -  # Hexo link (Powered by Hexo).  powered: <span class="hljs-keyword">true</span>  theme:    # Theme &amp; scheme info link (Theme - NexT.scheme).    enable: <span class="hljs-keyword">true</span>    # Version info of NexT after scheme info (vX.X.X).    version: <span class="hljs-keyword">true</span>  # -  # Any custom text can be defined here.  #custom_text: Hosted by &lt;a target="_blank" href="https://pages.github.com"&gt;GitHub Pages&lt;/a&gt;# ---# SEO Settings# ---# Canonical, set a canonical link tag in your hexo, you could use it for your SEO of blog.# See: https://support.google.com/webmasters/answer/139066# Tips: Before you open this tag, remember set up your URL in hexo _config.yml ( ex. url: http://yourdomain.com )canonical: <span class="hljs-keyword">true</span># Change headers hierarchy on site-subtitle (will be main site description) and on all post/pages titles for better SEO-optimization.seo: <span class="hljs-keyword">false</span># If true, will add site-subtitle to index page, added in main hexo config.# subtitle: Subtitleindex_with_subtitle: <span class="hljs-keyword">false</span># ---# Menu Settings# ---# When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash from link value (/archives -&gt; archives).# Usage: `Key: /link/ || icon`# Key is the name of menu item. If translate for this menu will find in languages - this translate will be loaded; if not - Key name will be used. Key is case-senstive.# Value before `||` delimeter is the target link.# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, question icon will be loaded.menu:  home: / || home  #about: /about/ || about  tags: /tags/ || tags  categories: /categories/ || th  archives: /archives/ || archive  #schedule: /schedule/ || calendar  #sitemap: /sitemap.xml || sitemap  #commonweal: /404/ || heartbeat# Enable/Disable menu icons.menu_icons:  enable: <span class="hljs-keyword">true</span># ---# Scheme Settings# ---# Schemesscheme: Mist #scheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini# ---# Sidebar Settings# ---# Social Links.# Usage: `Key: permalink || icon`# Key is the link label showing to end users.# Value before `||` delimeter is the target permalink.# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded.social:  GitHub: https:<span class="hljs-comment">//github.com/kkzhilu || github</span>  E-Mail: ke.xian.ming<span class="hljs-meta">@qq</span>.com || envelope  #Google: https://plus.google.com/yourname || google  #Twitter: https://twitter.com/yourname || twitter  #FB Page: https://www.facebook.com/yourname || facebook  #VK Group: https://vk.com/yourname || vk  #StackOverflow: https://stackoverflow.com/yourname || stack-overflow  #YouTube: https://youtube.com/yourname || youtube  #Instagram: https://instagram.com/yourname || instagram  #Skype: skype:yourname?call|chat || skypesocial_icons:  enable: <span class="hljs-keyword">true</span>  icons_only: <span class="hljs-keyword">false</span>  transition: <span class="hljs-keyword">false</span># Blog rollslinks_icon: linklinks_title: Linkslinks_layout: block#links_layout: inline#links:  #Title: http://example.com/# Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site  directory(source/uploads): /uploads/avatar.gifavatar: /img/logo.jpg# Table Of Contents in the Sidebartoc:  enable: <span class="hljs-keyword">true</span>  # Automatically add list number to toc.  number: <span class="hljs-keyword">true</span>  # If true, all words will placed on next lines if header width longer then sidebar width.  wrap: <span class="hljs-keyword">false</span># Creative Commons 4.0 International License.# http://creativecommons.org/# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero#creative_commons: by-nc-sa#creative_commons:sidebar:  # Sidebar Position, available value: left | right (only for Pisces | Gemini).  position: left  #position: right  # Sidebar Display, available value (only for Muse | Mist):  #  - post    expand on posts automatically. Default.  #  - always  expand for all pages automatically  #  - hide    expand only when click on the sidebar toggle icon.  #  - remove  Totally remove sidebar including sidebar toggle.  display: post  #display: always  #display: hide  #display: remove  # Sidebar offset from top menubar in pixels (only for Pisces | Gemini).  offset: <span class="hljs-number">12</span>  # Back to top in sidebar (only for Pisces | Gemini).  b2t: <span class="hljs-keyword">false</span>  # Scroll percent label in b2t button.  scrollpercent: <span class="hljs-keyword">true</span>  # Enable sidebar on narrow view (only for Muse | Mist).  onmobile: <span class="hljs-keyword">false</span># ---# Post Settings# ---# Automatically scroll page to section which is under &lt;!-- more --&gt; mark.# Automatically scroll page to section which is under &lt;!-- more --&gt; mark.scroll_to_more: <span class="hljs-keyword">true</span># Automatically saving scroll position on each post/page in cookies.save_scroll: <span class="hljs-keyword">false</span># Automatically excerpt description in homepage as preamble text.excerpt_description: <span class="hljs-keyword">true</span># Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt:  enable: <span class="hljs-keyword">true</span>  length: <span class="hljs-number">120</span># Post meta display settingspost_meta:  item_text: <span class="hljs-keyword">true</span>  created_at: <span class="hljs-keyword">true</span>  updated_at: <span class="hljs-keyword">false</span>  categories: <span class="hljs-keyword">true</span># Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount:  item_text: <span class="hljs-keyword">true</span>  wordcount: <span class="hljs-keyword">true</span>  min2read: <span class="hljs-keyword">true</span>  totalcount: <span class="hljs-keyword">false</span>  separated_meta: <span class="hljs-keyword">true</span># Wechat Subscriberwechat_subscriber:  enabled: <span class="hljs-keyword">true</span>  qcode: /uploads/wechat.bmp  description: 欢迎光临宇宙尽头的烧烤店~# Reward#reward_comment: Donate comment here#wechatpay: /images/wechatpay.jpg#alipay: /images/alipay.jpg#bitcoin: /images/bitcoin.png# Declare license on postspost_copyright:  enable: <span class="hljs-keyword">false</span>  license: CC BY-NC-SA <span class="hljs-number">3.0</span>  license_url: https:<span class="hljs-comment">//creativecommons.org/licenses/by-nc-sa/3.0/</span># ---# Misc Theme Settings# ---# Reduce padding / margin indents on devices with narrow width.mobile_layout_economy: <span class="hljs-keyword">false</span># Android Chrome header panel color ($black-deep).android_chrome_color: <span class="hljs-string">"#222"</span># Custom Logo.# !!Only available for Default Scheme currently.# Options:#   enabled: [true/false] - Replace with specific image#   image: url-of-image   - Images's urlcustom_logo:  enabled: <span class="hljs-keyword">false</span>  image:# Code Highlight theme# Available value:#    normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: normal# ---# Font Settings# - Find fonts on Google Fonts (https://www.google.com/fonts)# - All fonts set here will have the following styles:#     light, light italic, normal, normal italic, bold, bold italic# - Be aware that setting too much fonts will cause site running slowly# - Introduce in 5.0.1# ---# CAUTION! Safari Version 10.1.2 bug: https://github.com/iissnan/hexo-theme-next/issues/1844# To avoid space between header and sidebar in Pisces / Gemini themes recommended to use Web Safe fonts for `global` (and `logo`):# Arial | Tahoma | Helvetica | Times New Roman | Courier New | Verdana | Georgia | Palatino | Garamond | Comic Sans MS | Trebuchet MS# ---font:  enable: <span class="hljs-keyword">false</span>  # Uri of fonts host. E.g. //fonts.googleapis.com (Default).  host:  # Font options:  # `external: true` will load this font family from `host` above.  # `family: Times New Roman`. Without any quotes.  # `size: xx`. Use `px` as unit.  # Global font settings used on &lt;body&gt; element.  global:    external: <span class="hljs-keyword">true</span>    family: Lato    size:  # Font settings for Headlines (h1, h2, h3, h4, h5, h6).  # Fallback to `global` font settings.  headings:    external: <span class="hljs-keyword">true</span>    family:    size:  # Font settings for posts.  # Fallback to `global` font settings.  posts:    external: <span class="hljs-keyword">true</span>    family:  # Font settings for Logo.  # Fallback to `global` font settings.  logo:    external: <span class="hljs-keyword">true</span>    family:    size:  # Font settings for &lt;code&gt; and code blocks.  codes:    external: <span class="hljs-keyword">true</span>    family:    size:# ---# Third Party Services Settings# ---# MathJax Supportmathjax:  enable: <span class="hljs-keyword">false</span>  per_page: <span class="hljs-keyword">false</span>  cdn: <span class="hljs-comment">//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML</span># Han Support docs: https://hanzi.pro/han: <span class="hljs-keyword">false</span># Swiftype Search API Key#swiftype_key:# Baidu Analytics ID#baidu_analytics:# Duoshuo ShortName#duoshuo_shortname:# Disqusdisqus:  enable: <span class="hljs-keyword">false</span>  shortname:  count: <span class="hljs-keyword">true</span># Hypercomments#hypercomments_id:# changyanchangyan:  enable: <span class="hljs-keyword">false</span>  appid:  appkey:# Valine.# You can get your appid and appkey from https://leancloud.cn# more info please open https://valine.js.orgvaline:  enable: <span class="hljs-keyword">false</span>  appid:  # your leancloud application appid  appkey:  # your leancloud application appkey  notify: false # mail notifier , https://github.com/xCss/Valine/wiki  verify: false # Verification code  placeholder: Just go go # comment box placeholder  avatar: mm # gravatar style  guest_info: nick,mail,link # custom comment header  pageSize: 10 # pagination size# Support for youyan comments system.# You can get your uid from http://www.uyan.cc#youyan_uid: your uid# Support for LiveRe comments system.# You can get your uid from https://livere.com/insight/myCode (General web site)#livere_uid: your uid# Gitment# Introduction: https://imsun.net/posts/gitment-introduction/# You can get your Github ID from https://api.github.com/users/&lt;Github username&gt;gitment:  enable: <span class="hljs-keyword">false</span>  mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway  count: true # Show comments count in post meta area  lazy: false # Comments lazy loading with a button  cleanly: false # Hide 'Powered by ...' on footer, and more  language: # Force language, or auto switch by theme  github_user: # MUST HAVE, Your Github ID  github_repo: # MUST HAVE, The repo you use to store Gitment comments  client_id: # MUST HAVE, Github client id for the Gitment  client_secret: # EITHER this or proxy_gateway, Github access secret token for the Gitment  proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect  redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled# Baidu Share# Available value:#    button | slide# Warning: Baidu Share does not support https.#baidushare:##  type: button# Share# This plugin is more useful in China, make sure you known how to use it.# And you can find the use guide at official webiste: http://www.jiathis.com/.# Warning: JiaThis does not support https.#jiathis:  ##uid: Get this uid from http://www.jiathis.com/#add_this_id:# Share#duoshuo_share: true# NeedMoreShare2# This plugin is a pure javascript sharing lib which is useful in China.# See: https://github.com/revir/need-more-share2# Also see: https://github.com/DzmVasileusky/needShareButton# iconStyle: default | box# boxForm: horizontal | vertical# position: top / middle / bottom + Left / Center / Right# networks: Weibo,Wechat,Douban,QQZone,Twitter,Linkedin,Mailto,Reddit,#           Delicious,StumbleUpon,Pinterest,Facebook,GooglePlus,Slashdot,#           Technorati,Posterous,Tumblr,GoogleBookmarks,Newsvine,#           Evernote,Friendfeed,Vkontakte,Odnoklassniki,Mailruneedmoreshare2:  enable: <span class="hljs-keyword">false</span>  postbottom:    enable: <span class="hljs-keyword">false</span>    options:      iconStyle: box      boxForm: horizontal      position: bottomCenter      networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook  <span class="hljs-keyword">float</span>:    enable: <span class="hljs-keyword">false</span>    options:      iconStyle: box      boxForm: horizontal      position: middleRight      networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook# Google Webmaster tools verification setting# See: https://www.google.com/webmasters/#google_site_verification:# Google Analytics#google_analytics:# Bing Webmaster tools verification setting# See: https://www.bing.com/webmaster/#bing_site_verification:# Yandex Webmaster tools verification setting# See: https://webmaster.yandex.ru/#yandex_site_verification:# CNZZ count#cnzz_siteid:# Application Insights# See https://azure.microsoft.com/en-us/services/application-insights/# application_insights:# Make duoshuo show UA# user_id must NOT be null when admin_enable is true!# you can visit http://dev.duoshuo.com get duoshuo user id.duoshuo_info:  ua_enable: <span class="hljs-keyword">true</span>  admin_enable: <span class="hljs-keyword">false</span>  user_id: <span class="hljs-number">0</span>  #admin_nickname: Author# Post widgets &amp; FB/VK comments settings.# ---# Facebook SDK Support.# https://github.com/iissnan/hexo-theme-next/pull/410facebook_sdk:  enable:       <span class="hljs-keyword">false</span>  app_id:       #&lt;app_id&gt;  fb_admin:     #&lt;user_id&gt;  like_button:  #true  webmaster:    #true# Facebook comments plugin# This plugin depends on Facebook SDK.# If facebook_sdk.enable is false, Facebook comments plugin is unavailable.facebook_comments_plugin:  enable:       <span class="hljs-keyword">false</span>  num_of_posts: 10    # min posts num is 1  width:        100%  # default width is 550px  scheme:       light # default scheme is light (light or dark)# VKontakte API Support.# To get your AppID visit https://vk.com/editapp?act=createvkontakte_api:  enable:       <span class="hljs-keyword">false</span>  app_id:       #&lt;app_id&gt;  like:         <span class="hljs-keyword">true</span>  comments:     <span class="hljs-keyword">true</span>  num_of_posts: <span class="hljs-number">10</span># Star rating support to each article.# To get your ID visit https://widgetpack.comrating:  enable: <span class="hljs-keyword">false</span>  id:     #&lt;app_id&gt;  color:  fc6423# ---# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors:  enable: <span class="hljs-keyword">false</span>  app_id: #&lt;app_id&gt;  app_key: #&lt;app_key&gt;# Another tool to show number of visitors to each article.# visit https://console.firebase.google.com/u/0/ to get apiKey and projectId# visit https://firebase.google.com/docs/firestore/ to get more information about firestorefirestore:  enable: <span class="hljs-keyword">false</span>  collection: articles #required, a string collection name to access firestore database  apiKey: #required  projectId: #required  bluebird: false #enable this if you want to include bluebird 3.5.1(core version) Promise polyfill# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count:  # count values only if the other configs are false  enable: <span class="hljs-keyword">false</span>  # custom uv span for the whole site  site_uv: <span class="hljs-keyword">true</span>  site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt;  site_uv_footer:  # custom pv span for the whole site  site_pv: <span class="hljs-keyword">true</span>  site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt;  site_pv_footer:  # custom pv span for one page only  page_pv: <span class="hljs-keyword">true</span>  page_pv_header: &lt;i class="fa fa-file-o"&gt;&lt;/i&gt;  page_pv_footer:# Tencent analytics ID# tencent_analytics:# Tencent MTA ID# tencent_mta:# Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEObaidu_push: <span class="hljs-keyword">false</span># Google Calendar# Share your recent schedule to others via calendar page## API Documentation:# https://developers.google.com/google-apps/calendar/v3/reference/events/listcalendar:  enable: <span class="hljs-keyword">false</span>  calendar_id: &lt;required&gt;  api_key: &lt;required&gt;  orderBy: startTime  offsetMax: <span class="hljs-number">24</span>  offsetMin: <span class="hljs-number">4</span>  timeZone:  showDeleted: <span class="hljs-keyword">false</span>  singleEvents: <span class="hljs-keyword">true</span>  maxResults: <span class="hljs-number">250</span># Algolia Searchalgolia_search:  enable: <span class="hljs-keyword">false</span>  hits:    per_page: <span class="hljs-number">10</span>  labels:    input_placeholder: Search <span class="hljs-keyword">for</span> Posts    hits_empty: <span class="hljs-string">"We didn't find any results for the search: $&#123;query&#125;"</span>    hits_stats: <span class="hljs-string">"$&#123;hits&#125; results found in $&#123;time&#125; ms"</span># Local search# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search:  enable: <span class="hljs-keyword">true</span>  # if auto, trigger search by changing input  # if manual, trigger search by pressing enter key or search button  trigger: auto  # show top n results per article, show all results by setting to -1  top_n_per_article: <span class="hljs-number">1</span># ---# Tags Settings# ---# External URL with BASE64 encrypt &amp; decrypt.# Usage: &#123;% exturl text url "title" %&#125;# Alias: &#123;% extlink text url "title" %&#125;exturl: <span class="hljs-keyword">false</span># Note tag (bs-callout).note:  # Note tag style values:  #  - simple    bs-callout old alert style. Default.  #  - modern    bs-callout new (v2-v3) alert style.  #  - flat      flat callout style with background, like on Mozilla or StackOverflow.  #  - disabled  disable all CSS styles import of note tag.  style: simple  icons: <span class="hljs-keyword">false</span>  border_radius: <span class="hljs-number">3</span>  # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).  # Offset also applied to label tag variables. This option can work with disabled note tag.  light_bg_offset: <span class="hljs-number">0</span># Label tag.label: <span class="hljs-keyword">true</span># Tabs tag.tabs:  enable: <span class="hljs-keyword">true</span>  transition:    tabs: <span class="hljs-keyword">false</span>    labels: <span class="hljs-keyword">true</span>  border_radius: <span class="hljs-number">0</span>#! ---#! DO NOT EDIT THE FOLLOWING SETTINGS#! UNLESS YOU KNOW WHAT YOU ARE DOING#! ---# Use velocity to animate everything.motion:  enable: <span class="hljs-keyword">false</span>  async: <span class="hljs-keyword">false</span>  transition:    # Transition variants:    # fadeIn | fadeOut | flipXIn | flipXOut | flipYIn | flipYOut | flipBounceXIn | flipBounceXOut | flipBounceYIn | flipBounceYOut    # swoopIn | swoopOut | whirlIn | whirlOut | shrinkIn | shrinkOut | expandIn | expandOut    # bounceIn | bounceOut | bounceUpIn | bounceUpOut | bounceDownIn | bounceDownOut | bounceLeftIn | bounceLeftOut | bounceRightIn | bounceRightOut    # slideUpIn | slideUpOut | slideDownIn | slideDownOut | slideLeftIn | slideLeftOut | slideRightIn | slideRightOut    # slideUpBigIn | slideUpBigOut | slideDownBigIn | slideDownBigOut | slideLeftBigIn | slideLeftBigOut | slideRightBigIn | slideRightBigOut    # perspectiveUpIn | perspectiveUpOut | perspectiveDownIn | perspectiveDownOut | perspectiveLeftIn | perspectiveLeftOut | perspectiveRightIn | perspectiveRightOut    post_block: fadeIn    post_header: slideDownIn    post_body: slideDownIn    coll_header: slideLeftIn    # Only for Pisces | Gemini.    sidebar: slideUpIn# Fancyboxfancybox: <span class="hljs-keyword">true</span># Progress bar in the top during page loading.pace: <span class="hljs-keyword">false</span># Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx#pace-theme-minimal# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-minimal# Canvas-nestcanvas_nest: <span class="hljs-keyword">true</span># three_wavesthree_waves: <span class="hljs-keyword">false</span># canvas_linescanvas_lines: <span class="hljs-keyword">false</span># canvas_spherecanvas_sphere: <span class="hljs-keyword">false</span># Only fit scheme Pisces# Canvas-ribbon# size: The width of the ribbon.# alpha: The transparency of the ribbon.# zIndex: The display level of the ribbon.canvas_ribbon:  enable: <span class="hljs-keyword">false</span>  size: <span class="hljs-number">300</span>  alpha: <span class="hljs-number">0.6</span>  zIndex: -<span class="hljs-number">1</span>  feed:  type: atom  path: atom.xml  limit: <span class="hljs-number">20</span>plugins: hexo-generate-feed# 看板娘live2d:  enable: <span class="hljs-keyword">true</span># Script Vendors.# Set a CDN address for the vendor you want to customize.# For example#    jquery: https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js# Be aware that you should use the same version as internal ones to avoid potential problems.# Please use the https protocol of CDN files when you enable https on your site.vendors:  # Internal path prefix. Please do not edit it.  _internal: lib  # Internal version: 2.1.3  jquery:  # Internal version: 2.1.5  # See: http://fancyapps.com/fancybox/  fancybox:  fancybox_css:  # Internal version: 1.0.6  # See: https://github.com/ftlabs/fastclick  fastclick:  # Internal version: 1.9.7  # See: https://github.com/tuupola/jquery_lazyload  lazyload:  # Internal version: 1.2.1  # See: http://VelocityJS.org  velocity:  # Internal version: 1.2.1  # See: http://VelocityJS.org  velocity_ui:  # Internal version: 0.7.9  # See: https://faisalman.github.io/ua-parser-js/  ua_parser:  # Internal version: 4.6.2  # See: http://fontawesome.io/  fontawesome:  # Internal version: 1  # https://www.algolia.com  algolia_instant_js:  algolia_instant_css:  # Internal version: 1.0.2  # See: https://github.com/HubSpot/pace  # Or use direct links below:  # pace: //cdn.bootcss.com/pace/1.0.2/pace.min.js  # pace_css: //cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css  pace:  pace_css:  # Internal version: 1.0.0  # https://github.com/hustcc/canvas-nest.js  canvas_nest:  # three  three:  # three_waves  # https://github.com/jjandxa/three_waves  three_waves:  # three_waves  # https://github.com/jjandxa/canvas_lines  canvas_lines:  # three_waves  # https://github.com/jjandxa/canvas_sphere  canvas_sphere:  # Internal version: 1.0.0  # https://github.com/zproo/canvas-ribbon  canvas_ribbon:  # Internal version: 3.3.0  # https://github.com/ethantw/Han  han:  # needMoreShare2  # https://github.com/revir/need-more-share2  needMoreShare2:# Assetscss: cssjs: jsimages: images# Theme versionversion: <span class="hljs-number">5.1</span><span class="hljs-number">.4</span></code></pre><h2 id="Hexo解决图片渲染问题"><a href="#Hexo解决图片渲染问题" class="headerlink" title="Hexo解决图片渲染问题"></a>Hexo解决图片渲染问题</h2><blockquote><ol><li>设置config</li></ol><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_config</span>.</span></span>ymlpost_asset_folder: <span class="hljs-literal">true</span></code></pre><ol start="2"><li>安装插件</li></ol><pre><code class="hljs maxima">npm install hexo-asset-<span class="hljs-built_in">image</span> --<span class="hljs-built_in">save</span></code></pre><ol start="3"><li>处理原理 –&gt; 同名文件夹，渲染时引入</li></ol><pre><code class="hljs 需要注意的问题：```不要使用含有特殊符号的名称作为文件名，比如：">### hexo-asset-image&#96;&#96;&#96;myblog\node_modules\hexo-asset-image\index.js </code></pre></blockquote><p>该JS中有地方需要进行修改：</p><pre><code class="hljs js"><span class="hljs-meta">'use strict'</span>;<span class="hljs-keyword">var</span> cheerio = <span class="hljs-built_in">require</span>(<span class="hljs-string">'cheerio'</span>);<span class="hljs-comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPosition</span>(<span class="hljs-params">str, m, i</span>) </span>&#123;  <span class="hljs-keyword">return</span> str.split(m, i).join(m).length;&#125;<span class="hljs-keyword">var</span> version = <span class="hljs-built_in">String</span>(hexo.version).split(<span class="hljs-string">'.'</span>);hexo.extend.filter.register(<span class="hljs-string">'after_post_render'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;  <span class="hljs-keyword">var</span> config = hexo.config;  <span class="hljs-keyword">if</span>(config.post_asset_folder)&#123;    <span class="hljs-keyword">var</span> link = data.permalink;<span class="hljs-keyword">if</span>(version.length &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">Number</span>(version[<span class="hljs-number">0</span>]) == <span class="hljs-number">3</span>)   <span class="hljs-keyword">var</span> beginPos = getPosition(link, <span class="hljs-string">'/'</span>, <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<span class="hljs-keyword">else</span>   <span class="hljs-keyword">var</span> beginPos = getPosition(link, <span class="hljs-string">'/'</span>, <span class="hljs-number">3</span>) + <span class="hljs-number">1</span>;<span class="hljs-comment">// In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html".</span><span class="hljs-keyword">var</span> endPos = link.lastIndexOf(<span class="hljs-string">'/'</span>) + <span class="hljs-number">1</span>;    link = link.substring(beginPos, endPos);    <span class="hljs-keyword">var</span> toprocess = [<span class="hljs-string">'excerpt'</span>, <span class="hljs-string">'more'</span>, <span class="hljs-string">'content'</span>];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; toprocess.length; i++)&#123;      <span class="hljs-keyword">var</span> key = toprocess[i];       <span class="hljs-keyword">var</span> $ = cheerio.load(data[key], &#123;        ignoreWhitespace: <span class="hljs-literal">false</span>,        xmlMode: <span class="hljs-literal">false</span>,        lowerCaseTags: <span class="hljs-literal">false</span>,        decodeEntities: <span class="hljs-literal">false</span>      &#125;);      $(<span class="hljs-string">'img'</span>).each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">if</span> ($(<span class="hljs-keyword">this</span>).attr(<span class="hljs-string">'src'</span>))&#123;<span class="hljs-comment">// For windows style path, we replace '\' to '/'.</span><span class="hljs-keyword">var</span> src = $(<span class="hljs-keyword">this</span>).attr(<span class="hljs-string">'src'</span>).replace(<span class="hljs-string">'\\'</span>, <span class="hljs-string">'/'</span>);<span class="hljs-keyword">if</span>(!<span class="hljs-regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;   !<span class="hljs-regexp">/^\s*\//</span>.test(src)) &#123;  <span class="hljs-comment">// For "about" page, the first part of "src" can't be removed.</span>  <span class="hljs-comment">// In addition, to support multi-level local directory.</span>  <span class="hljs-keyword">var</span> linkArray = link.split(<span class="hljs-string">'/'</span>).filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">elem</span>)</span>&#123;<span class="hljs-keyword">return</span> elem != <span class="hljs-string">''</span>;  &#125;);  <span class="hljs-keyword">var</span> srcArray = src.split(<span class="hljs-string">'/'</span>).filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">elem</span>)</span>&#123;<span class="hljs-keyword">return</span> elem != <span class="hljs-string">''</span> &amp;&amp; elem != <span class="hljs-string">'.'</span>;  &#125;);  <span class="hljs-keyword">if</span>(srcArray.length &gt; <span class="hljs-number">1</span>)srcArray.shift();  src = srcArray.join(<span class="hljs-string">'/'</span>);  $(<span class="hljs-keyword">this</span>).attr(<span class="hljs-string">'src'</span>, src);  <span class="hljs-built_in">console</span>.info&amp;&amp;<span class="hljs-built_in">console</span>.info(<span class="hljs-string">"update link as:--&gt;"</span> + src);&#125;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">console</span>.info&amp;&amp;<span class="hljs-built_in">console</span>.info(<span class="hljs-string">"no src attr, skipped..."</span>);<span class="hljs-built_in">console</span>.info&amp;&amp;<span class="hljs-built_in">console</span>.info($(<span class="hljs-keyword">this</span>));&#125;      &#125;);      data[key] = $.html();    &#125;  &#125;&#125;);</code></pre>]]></content>
    
    
    <categories>
      
      <category>工具篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx篇</title>
    <link href="/2023/09/12/Nginx%E7%AF%87/"/>
    <url>/2023/09/12/Nginx%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="Nginx篇"><a href="#Nginx篇" class="headerlink" title="Nginx篇"></a>Nginx篇</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>Nginx是一款轻量级的 Web服务器 / 反向代理服务器 / 电子邮件（IMAP/POP3）代理服务器，主要的优点是：</p><ol><li><p>支持高并发连接，尤其是静态界面，官方测试Nginx能够支撑5万并发连接</p></li><li><p>内存占用极低</p></li><li><p>配置简单，使用灵活，可以基于自身需要增强其功能，同时支持自定义模块的开发</p><p>使用灵活：可以根据需要，配置不同的负载均衡模式，URL地址重写等功能</p></li><li><p>稳定性高，在进行反向代理时，宕机的概率很低</p></li><li><p>支持热部署，应用启动重载非常迅速</p></li></ol><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><h3 id="Windows版"><a href="#Windows版" class="headerlink" title="Windows版"></a>Windows版</h3><p><strong>安装</strong></p><p>文件下载地址：<a href="http://nginx.org/en/docs/windows.html" target="_blank" rel="noopener">http://nginx.org/en/docs/windows.html</a></p><p>如果下载很慢可以用该链接：</p><p>百度云盘链接: <a href="https://pan.baidu.com/s/1r3mSEGhmz4HA46Cw9w6QTQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1r3mSEGhmz4HA46Cw9w6QTQ</a> 提取码: d8bi</p><p>解压即可</p><p><strong>基本命令</strong></p><pre><code class="hljs bash"><span class="hljs-comment"># 启动</span><span class="hljs-comment"># 建议使用第一种，第二种会使窗口一直处于执行中，不能进行其他命令操作</span>C:\server\nginx-1.19.2&gt; start nginxC:\server\nginx-1.19.2&gt; nginx.exe<span class="hljs-comment"># 停止</span><span class="hljs-comment"># stop是快速停止nginx，可能并不保存相关信息；quit是完整有序的停止nginx，并保存相关信息</span>C:\server\nginx-1.19.2&gt; nginx.exe -s stopC:\server\nginx-1.19.2&gt; nginx.exe -s quit<span class="hljs-comment"># 重载Nginx</span><span class="hljs-comment"># 当配置信息修改，需要重新载入这些配置时使用此命令</span>C:\server\nginx-1.19.2&gt; nginx.exe -s reload<span class="hljs-comment"># 重新打开日志文件</span>C:\server\nginx-1.19.2&gt; nginx.exe -s reopen<span class="hljs-comment"># 查看Nginx版本</span>C:\server\nginx-1.19.2&gt; nginx -v<span class="hljs-comment"># 查看配置文件是否正确</span>C:\server\nginx-1.19.2&gt; nginx -t</code></pre><p><strong>简单Demo</strong></p><ol><li><p>利用<code>SwitchHost</code>软件编辑域名和IP的映射关系，或到目录<code>C:\Windows\System32\drivers\etc</code>下，编辑<code>hosts</code>文件，增加配置如下（Mac 同理）</p><pre><code class="hljs bash">127.0.0.1  kerwin.demo.com</code></pre><p>PS：推荐使用软件<code>SwitchHost</code>，工作时几乎是必用的</p></li><li><p>修改配置，如图所示：</p><p><img src="/2023/09/12/Nginx%E7%AF%87/image-20200905185840840.png" srcset="/img/loading.gif" alt="image-20200905185840840"></p></li></ol><p>效果如图所示：</p><p><img src="/2023/09/12/Nginx%E7%AF%87/image-20200905185913004.png" srcset="/img/loading.gif" alt="image-20200905185913004"></p><h2 id="Nginx在架构体系中的作用"><a href="#Nginx在架构体系中的作用" class="headerlink" title="Nginx在架构体系中的作用"></a>Nginx在架构体系中的作用</h2><ul><li>网关 （面向客户的总入口）</li><li>虚拟主机（为不同域名 / ip  / 端口提供服务。如：VPS虚拟服务器）</li><li>路由（正向代理 / 反向代理）</li><li>静态服务器</li><li>负载集群（提供负载均衡）</li></ul><h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p>网关：可以简单的理解为用户请求和服务器响应的关口，即面向用户的总入口</p><p>网关可以拦截客户端所有请求，对该请求进行权限控制、负载均衡、日志管理、接口调用监控等，因此无论使用什么架构体系，都可以使用<code>Nginx</code>作为最外层的网关</p><h3 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h3><p><strong>虚拟主机的定义</strong>：虚拟主机是一种特殊的软硬件技术，它可以将网络上的每一台计算机分成多个虚拟主机，每个虚拟主机可以独立对外提供 www 服务，这样就可以实现一台主机对外提供多个 web 服务，每个虚拟主机之间是独立的，互不影响的。</p><p>通过 Nginx 可以实现虚拟主机的配置，Nginx 支持三种类型的虚拟主机配置</p><ul><li>基于 IP 的虚拟主机</li><li>基于域名的虚拟主机</li><li>基于端口的虚拟主机</li></ul><p>表现形式其实大家多见过，即：</p><pre><code class="hljs bash"><span class="hljs-comment"># 每个 server 就是一个虚拟主机</span>http &#123;    <span class="hljs-comment"># ...</span>    server&#123;        <span class="hljs-comment"># ...</span>    &#125;        <span class="hljs-comment"># ...</span>    server&#123;        <span class="hljs-comment"># ...</span>    &#125;&#125;</code></pre><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>在<code>Nginx</code>的配置文件中，我们经常可以看到这样的配置：</p><pre><code class="hljs bash">location / &#123;<span class="hljs-comment">#....</span>&#125;</code></pre><p><code>location</code>在此处就起到了路由的作用，比如我们在同一个虚拟主机内定义两个不同的路由，如下：</p><pre><code class="hljs bash">location / &#123;proxy_pass https://www.baidu.com/;&#125;location /api &#123;proxy_pass https://apinew.juejin.im/user_api/v1/user/get?aid=2608&amp;user_id=1275089220013336&amp;not_self=1; &#125;</code></pre><p>效果如下：</p><p><img src="/2023/09/12/Nginx%E7%AF%87/image-20200905192200164.png" srcset="/img/loading.gif" alt="image-20200905192200164"></p><p>因为路由的存在，为我们后续解决<code>跨域问题</code>提供了一定的思路，同时配置内容和API接口等更加方便</p><p>PS：路由的功能非常强大，<code>支持正则匹配</code></p><h4 id="正向与反向代理"><a href="#正向与反向代理" class="headerlink" title="正向与反向代理"></a>正向与反向代理</h4><p>此处额外解释一下<code>proxy_pass</code>的含义</p><p>在<code>Nginx</code>中配置<code>proxy_pass</code>代理转发时，如果在<code>proxy_pass</code>后面的url加 <code>/</code>，表示绝对根路径；</p><p>如果没有<code>/</code>，表示相对路径</p><p><strong>正向代理</strong></p><ol><li>代理客户;</li><li>隐藏真实的客户，为客户端收发请求，使真实客户端对服务器不可见;</li><li>一个局域网内的所有用户可能被一台服务器做了正向代理，由该台服务器负责 HTTP 请求;</li><li>意味着同服务器做通信的是正向代理服务器;</li></ol><p><strong>反向代理</strong></p><ol><li>代理服务器;</li><li>隐藏了真实的服务器，为服务器收发请求，使真实服务器对客户端不可见;</li><li>负载均衡服务器，将用户的请求分发到空闲的服务器上;</li><li>意味着用户和负载均衡服务器直接通信，即用户解析服务器域名时得到的是负载均衡服务器的 IP ;</li></ol><p><strong>共同点</strong></p><ol><li>都是做为服务器和客户端的中间层</li><li>都可以加强内网的安全性，阻止 web 攻击</li><li>都可以做缓存机制，提高访问速度</li></ol><p><strong>区别</strong></p><ol><li>正向代理其实是客户端的代理,反向代理则是服务器的代理。</li><li>正向代理中，服务器并不知道真正的客户端到底是谁；而在反向代理中，客户端也不知道真正的服务器是谁。</li><li>作用不同。正向代理主要是用来解决访问限制问题；而反向代理则是提供负载均衡、安全防护等作用。</li></ol><h4 id="Nginx代理不同网站图片"><a href="#Nginx代理不同网站图片" class="headerlink" title="Nginx代理不同网站图片"></a>Nginx代理不同网站图片</h4><p>我们利用Nginx可以很轻松代理指定的URL地址，但如果涉及变化的域名该如何处理呢？</p><pre><code class="hljs bash">location /http_proxy &#123;    <span class="hljs-comment"># 域名解析，避免域名无法被识别</span>    resolver 114.114.114.114 223.5.5.5 valid=3600s;    resolver_timeout 3s;        <span class="hljs-comment"># 转发至address参数结果上 参数名：address</span>    proxy_pass  <span class="hljs-string">"<span class="hljs-variable">$arg_address</span>"</span>;        <span class="hljs-comment"># 设置Header</span>    proxy_hide_header Origin;    proxy_set_header Host <span class="hljs-variable">$proxy_host</span>;    proxy_set_header  X-Real-IP  <span class="hljs-variable">$remote_addr</span>;    proxy_set_header  X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;    proxy_set_header X-NginX-Proxy <span class="hljs-literal">true</span>;&#125;</code></pre><p>访问地址（address 参数值可以填任意结果）：</p><pre><code class="hljs bash">http://localhost/http_proxy?address=https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9d30c81602941b69b3c347e5325405e~tplv-k3u1fbpfcp-watermark.image</code></pre><p>即可得到转发后的图片，如下图所示：</p><p><img src="/2023/09/12/Nginx%E7%AF%87/image-20210302015720602.png" srcset="/img/loading.gif" alt="image-20210302015720602"></p><h3 id="静态服务器"><a href="#静态服务器" class="headerlink" title="静态服务器"></a>静态服务器</h3><p>静态服务器是<code>Nginx</code>的强项，使用非常容易，在默认配置下本身就是指向了静态的HTML界面，如：</p><pre><code class="hljs bash">location / &#123;root   html;index  index.html index.htm;&#125;</code></pre><p>所以前端同学们，如果构建好了界面，可以进行相应的配置，把界面指向目标文件夹中即可，<code>root</code>指的是<code>html</code>文件夹</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>负载均衡功能是<code>Nginx</code>另一大杀手锏，一共有5种方式，着重介绍一下。</p><h4 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h4><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除，配置如下：</p><pre><code class="hljs bash">upstream tomcatserver &#123;server 192.168.0.1;server 192.168.0.2;&#125;</code></pre><p>轮询策略是默认的负载均衡策略</p><h4 id="指定权重"><a href="#指定权重" class="headerlink" title="指定权重"></a>指定权重</h4><p>即在轮询的基础之上，增加权重的概念，<code>weight</code>和访问比率成正比，用于后端服务器性能不均的情况，配置如下：</p><pre><code class="hljs bash">upstream tomcatserver &#123;server 192.168.0.1 weight=1;server 192.168.0.2 weight=10;&#125;</code></pre><h4 id="IP-Hash"><a href="#IP-Hash" class="headerlink" title="IP Hash"></a>IP Hash</h4><p>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题，配置如下：</p><pre><code class="hljs bash">upstream tomcatserver &#123;ip_hash;server 192.168.0.14:88;server 192.168.0.15:80;&#125;</code></pre><h4 id="fair"><a href="#fair" class="headerlink" title="fair"></a>fair</h4><p>第三方提供的负载均衡策略，按后端服务器的响应时间来分配请求，响应时间短的优先分配，生产环境中有各种情况可能导致响应时间波动，需要慎用</p><pre><code class="hljs bash">upstream tomcatserver &#123;server server1;server server2;fair;&#125;</code></pre><h4 id="url-hash"><a href="#url-hash" class="headerlink" title="url_hash"></a>url_hash</h4><p>第三方提供的负载均衡策略，按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器</p><pre><code class="hljs bash">upstream tomcatserver &#123;server squid1:3128;server squid2:3128;<span class="hljs-built_in">hash</span> <span class="hljs-variable">$request_uri</span>;hash_method crc32;&#125;</code></pre><h2 id="Nginx的模块化设计"><a href="#Nginx的模块化设计" class="headerlink" title="Nginx的模块化设计"></a>Nginx的模块化设计</h2><p>先来看看<code>Nginx</code>模块架构图：</p><p><img src="/2023/09/12/Nginx%E7%AF%87/image-20200905231750989.png" srcset="/img/loading.gif" alt="image-20200905231750989"></p><p>这5个模块由上到下重要性一次递减。</p><p>（1）核心模块；</p><p>核心模块是Nginx服务器正常运行必不可少的模块，如同操作系统的内核。它提供了Nginx最基本的核心服务。像进程管理、权限控制、错误日志记录等；</p><p>（2）标准HTTP模块；</p><p>标准HTTP模块支持标准的HTTP的功能，如：端口配置，网页编码设置，HTTP响应头设置等；</p><p>（3）可选HTTP模块；</p><p>可选HTTP模块主要用于扩展标准的HTTP功能，让Nginx能处理一些特殊的服务，如：解析GeoIP请求，SSL支持等；</p><p>（4）邮件服务模块；</p><p>邮件服务模块主要用于支持Nginx的邮件服务；</p><p>（5）第三方模块；</p><p>第三方模块是为了扩展Nginx服务器应用，完成开发者想要的功能，如：Lua支持，JSON支持等；</p><blockquote><p>模块化设计使得Nginx方便开发和扩展，功能很强大</p></blockquote><h2 id="Nginx的请求处理流程"><a href="#Nginx的请求处理流程" class="headerlink" title="Nginx的请求处理流程"></a>Nginx的请求处理流程</h2><p>基于上文中的<code>Nginx</code>模块化结构，我们很容易想到，在请求的处理阶段也会经历诸多的过程，<code>Nginx</code>将各功能模块组织成一条链，当有请求到达的时候，请求依次经过这条链上的部分或者全部模块，进行处理，每个模块实现特定的功能。</p><p>一个 HTTP Request 的处理过程：</p><ul><li>初始化 HTTP Request</li><li>处理请求头、处理请求体</li><li>如果有的话，调用与此请求（URL 或者 Location）关联的 handler</li><li>依次调用各 phase handler 进行处理</li><li>输出内容依次经过 filter 模块处理</li></ul><p><img src="/2023/09/12/Nginx%E7%AF%87/798214-20191223134103333-1313823621.png" srcset="/img/loading.gif" alt="img"></p><h2 id="Nginx的多进程模型"><a href="#Nginx的多进程模型" class="headerlink" title="Nginx的多进程模型"></a>Nginx的多进程模型</h2><p>Nginx 在启动后，会有一个 <code>master</code>进程和多个 <code>worker</code>进程。</p><p><code>master</code>进程主要用来管理<code>worker</code>进程，包括接收来自外界的信号，向各 worker 进程发送信号，监控 worker 进程的运行状态以及启动 worker 进程。</p><p> <code>worker</code>进程是用来处理来自客户端的请求事件。多个 worker 进程之间是对等的，它们同等竞争来自客户端的请求，各进程互相独立，一个请求只能在一个 worker 进程中处理。worker 进程的个数是可以设置的，一般会设置与机器 CPU 核数一致，这里面的原因与事件处理模型有关</p><p>Nginx 的进程模型，可由下图来表示：</p><p><img src="/2023/09/12/Nginx%E7%AF%87/8a4bf67b456016f07ea2679dca069051_articlex.png" srcset="/img/loading.gif" alt="img"></p><p>这种设计带来以下优点：</p><p><strong>1） 利用多核系统的并发处理能力</strong></p><p>现代操作系统已经支持多核 CPU 架构，这使得多个进程可以分别占用不同的 CPU 核心来工作。Nginx 中所有的 worker 工作进程都是完全平等的。这提高了网络性能、降低了请求的时延。</p><p><strong>2） 负载均衡</strong></p><p>多个 worker 工作进程通过进程间通信来实现负载均衡，即一个请求到来时更容易被分配到负载较轻的 worker 工作进程中处理。这也在一定程度上提高了网络性能、降低了请求的时延。</p><p><strong>3） 管理进程会负责监控工作进程的状态，并负责管理其行为</strong></p><p>管理进程不会占用多少系统资源，它只是用来启动、停止、监控或使用其他行为来控制工作进程。首先，这提高了系统的可靠性，当 worker 进程出现问题时，管理进程可以启动新的工作进程来避免系统性能的下降。其次，管理进程支持 Nginx 服务运行中的程序升级、配置项修改等操作，这种设计使得动态可扩展性、动态定制性较容易实现。</p><h3 id="Nginx如何解决惊群现象"><a href="#Nginx如何解决惊群现象" class="headerlink" title="Nginx如何解决惊群现象"></a>Nginx如何解决惊群现象</h3><p><strong>什么是惊群现象？</strong></p><p>惊群效应（thundering herd）是指多进程（多线程）在同时阻塞等待同一个事件的时候（休眠状态），如果等待的这个事件发生，那么他就会唤醒等待的所有进程（或者线程），但是最终却只能有一个进程（线程）获得这个时间的“控制权”，对该事件进行处理，而其他进程（线程）获取“控制权”失败，只能重新进入休眠状态，这种现象和性能浪费就叫做惊群效应。</p><p>上文中介绍了Nginx的多进程模型，而典型的多进程模型正如文中所说，多个worker进程之间是对等的，因此当一个请求到来的时候，所有进程会同时开始竞争，最终执行的又只有一个，这样势必会造成资源的浪费。</p><p>Nginx解决该问题的思路是：<strong>不让多个进程在同一时间监听接受连接的socket，而是让每个进程轮流监听</strong>，这样当有连接过来的时候，就只有一个进程在监听那肯定就没有惊群的问题。</p><p>具体做法是：利用一把进程间锁，每个进程中都<strong>尝试</strong>获得这把锁，如果获取成功将监听socket加入wait集合中，并设置超时等待连接到来，没有获得锁的进程则将监听socket从wait集合去除。</p><h2 id="事件驱动模型和异步非阻塞IO"><a href="#事件驱动模型和异步非阻塞IO" class="headerlink" title="事件驱动模型和异步非阻塞IO"></a>事件驱动模型和异步非阻塞IO</h2><p>承接上文，我们知道了Nginx的多进程模型后了解到，其工作进程实际上只有几个，但为什么依然能获得如此高的并发性能，当然与其采用的事件驱动模型和异步非阻塞IO的方式来处理请求有关。</p><p>Nginx服务器响应和处理Web请求的过程，是基于事件驱动模型的，它包含事件收集器、事件发送器和事件处理器等三部分基本单元，着重关注<code>事件处理器</code>，而一般情况下事件处理器有这么几种办法：</p><ul><li>事件发送器每传递过来一个请求，目标对象就创建一个新的进程</li><li>事件发送器每传递过来一个请求，目标对象就创建一个新的线程，来进行处理</li><li>事件发送器每传递过来一个请求，目标对象就将其放入一个待处理事件的列表，使用非阻塞I/O方式调用</li></ul><p>第三种方式，在编写程序代码时，逻辑比前面两种都复杂。大多数网络服务器采用了第三种方式，逐渐形成了所谓的<code>事件驱动处理库</code>。</p><p><code>事件驱动处理库</code>又被称为<code>多路IO复用方法</code>，最常见的包括以下三种：select模型，poll模型和epoll模型。</p><p>其中Nginx就默认使用的是<code>epoll</code>模型，同时也支持其他事件模型。</p><p><code>epoll</code>的帮助就在于其提供了一种机制，可以让进程同时处理多个并发请求，不用关心IO调用的具体状态。IO调用完全由事件驱动模型来管理，这样一来，当某个工作进程接收到客户端的请求以后，调用IO进行处理，如果不能立即得到结果，就去处理其他的请求；而工作进程在此期间也无需等待响应，可以去处理其他事情；当IO返回时，<code>epoll</code>就会通知此工作进程；该进程得到通知后，会来继续处理未完的请求</p><h2 id="Nginx配置的最佳实践"><a href="#Nginx配置的最佳实践" class="headerlink" title="Nginx配置的最佳实践"></a>Nginx配置的最佳实践</h2><p>在生产环境或者开发环境中Nginx一般会代理多个虚拟主机，如果把所有的配置文件写在默认的<code>nginx.conf</code>中，看起来会非常臃肿，因此建议将每一个虚拟文件单独放置一个文件夹，Nginx支持这样的配置，如下：</p><pre><code class="hljs bash">http &#123;<span class="hljs-comment"># 省略中间配置</span><span class="hljs-comment"># 引用该目录下以 .conf 文件结尾的配置</span>    include /etc/nginx/conf.d/*.conf;&#125;</code></pre><p>具体文件配置如：</p><pre><code class="hljs bash"><span class="hljs-comment"># Demo</span>upstream web_pro_testin &#123;server 10.42.46.70:6003 max_fails=3 fail_timeout=20s;ip_hash;&#125; server &#123;listen 80;server_name web.pro.testin.cn;location / &#123;proxy_pass http://web_pro_testin;proxy_redirect off;proxy_set_header Host <span class="hljs-variable">$host</span>;proxy_set_header X-Real-IP <span class="hljs-variable">$remote_addr</span>;    &#125;     location ~ ^/(WEB-INF)/ &#123;deny all;    &#125;&#125;</code></pre><h2 id="Nginx全量配置参数说明"><a href="#Nginx全量配置参数说明" class="headerlink" title="Nginx全量配置参数说明"></a>Nginx全量配置参数说明</h2><pre><code class="hljs bash"><span class="hljs-comment"># 运行用户</span>user www-data;    <span class="hljs-comment"># 启动进程,通常设置成和cpu的数量相等</span>worker_processes  6;<span class="hljs-comment"># 全局错误日志定义类型，[debug | info | notice | warn | error | crit]</span>error_log  logs/error.log;error_log  logs/error.log  notice;error_log  logs/error.log  info;<span class="hljs-comment"># 进程pid文件</span>pid        /var/run/nginx.pid;<span class="hljs-comment"># 工作模式及连接数上限</span>events &#123;    <span class="hljs-comment"># 仅用于linux2.6以上内核,可以大大提高nginx的性能</span>    use   epoll;         <span class="hljs-comment"># 单个后台worker process进程的最大并发链接数</span>    worker_connections  1024;             <span class="hljs-comment"># 客户端请求头部的缓冲区大小</span>    client_header_buffer_size 4k;        <span class="hljs-comment"># keepalive 超时时间</span>    keepalive_timeout 60;              <span class="hljs-comment"># 告诉nginx收到一个新连接通知后接受尽可能多的连接</span>    <span class="hljs-comment"># multi_accept on;            </span>&#125;<span class="hljs-comment">#设定http服务器，利用它的反向代理功能提供负载均衡支持</span>http &#123;    <span class="hljs-comment"># 文件扩展名与文件类型映射表义</span>    include       /etc/nginx/mime.types;        <span class="hljs-comment"># 默认文件类型</span>    default_type  application/octet-stream;        <span class="hljs-comment"># 默认编码</span>    charset utf-8;        <span class="hljs-comment"># 服务器名字的hash表大小</span>    server_names_hash_bucket_size 128;        <span class="hljs-comment"># 客户端请求头部的缓冲区大小</span>    client_header_buffer_size 32k;        <span class="hljs-comment"># 客户请求头缓冲大小</span>large_client_header_buffers 4 64k;<span class="hljs-comment"># 设定通过nginx上传文件的大小</span>    client_max_body_size 8m;        <span class="hljs-comment"># 开启目录列表访问，合适下载服务器，默认关闭。</span>    autoindex on;    <span class="hljs-comment"># sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，对于普通应用，</span>    <span class="hljs-comment"># 必须设为 on,如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，以平衡磁盘与网络I/O处理速度</span>    sendfile        on;        <span class="hljs-comment"># 此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用</span>    <span class="hljs-comment">#tcp_nopush     on;</span>    <span class="hljs-comment"># 连接超时时间（单秒为秒）</span>    keepalive_timeout  65;            <span class="hljs-comment"># gzip模块设置</span>    gzip on;               <span class="hljs-comment">#开启gzip压缩输出</span>    gzip_min_length 1k;    <span class="hljs-comment">#最小压缩文件大小</span>    gzip_buffers 4 16k;    <span class="hljs-comment">#压缩缓冲区</span>    gzip_http_version 1.0; <span class="hljs-comment">#压缩版本（默认1.1，前端如果是squid2.5请使用1.0）</span>    gzip_comp_level 2;     <span class="hljs-comment">#压缩等级</span>    gzip_types text/plain application/x-javascript text/css application/xml;    gzip_vary on;    <span class="hljs-comment"># 开启限制IP连接数的时候需要使用</span>    <span class="hljs-comment">#limit_zone crawler $binary_remote_addr 10m;</span>   <span class="hljs-comment"># 指定虚拟主机的配置文件，方便管理</span>    include /etc/nginx/conf.d/*.conf;    <span class="hljs-comment"># 负载均衡配置</span>    upstream mysvr &#123;        <span class="hljs-comment"># 请见上文中的五种配置</span>    &#125;   <span class="hljs-comment"># 虚拟主机的配置</span>    server &#123;                <span class="hljs-comment"># 监听端口</span>        listen 80;        <span class="hljs-comment"># 域名可以有多个，用空格隔开</span>        server_name www.jd.com jd.com;                <span class="hljs-comment"># 默认入口文件名称</span>        index index.html index.htm index.php;        root /data/www/jd;        <span class="hljs-comment"># 图片缓存时间设置</span>        location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$&#123;            expires 10d;        &#125;                 <span class="hljs-comment">#JS和CSS缓存时间设置</span>        location ~ .*.(js|css)?$&#123;            expires 1h;        &#125;                 <span class="hljs-comment"># 日志格式设定</span>        <span class="hljs-comment">#$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；</span>        <span class="hljs-comment">#$remote_user：用来记录客户端用户名称；</span>        <span class="hljs-comment">#$time_local： 用来记录访问时间与时区；</span>        <span class="hljs-comment">#$request： 用来记录请求的url与http协议；</span>        <span class="hljs-comment">#$status： 用来记录请求状态；成功是200，</span>        <span class="hljs-comment">#$body_bytes_sent ：记录发送给客户端文件主体内容大小；</span>        <span class="hljs-comment">#$http_referer：用来记录从那个页面链接访问过来的；</span>        log_format access <span class="hljs-string">'$remote_addr - $remote_user [$time_local] "$request" '</span>        <span class="hljs-string">'$status $body_bytes_sent "$http_referer" '</span>        <span class="hljs-string">'"$http_user_agent" $http_x_forwarded_for'</span>;                 <span class="hljs-comment"># 定义本虚拟主机的访问日志</span>        access_log  /usr/<span class="hljs-built_in">local</span>/nginx/logs/host.access.log  main;        access_log  /usr/<span class="hljs-built_in">local</span>/nginx/logs/host.access.404.log  log404;                 <span class="hljs-comment"># 对具体路由进行反向代理</span>        location /connect-controller &#123;             proxy_pass http://127.0.0.1:88;            proxy_redirect off;            proxy_set_header X-Real-IP <span class="hljs-variable">$remote_addr</span>;                         <span class="hljs-comment"># 后端的Web服务器可以通过X-Forwarded-For获取用户真实IP</span>            proxy_set_header X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;            proxy_set_header Host <span class="hljs-variable">$host</span>;            <span class="hljs-comment"># 允许客户端请求的最大单文件字节数</span>            client_max_body_size 10m;            <span class="hljs-comment"># 缓冲区代理缓冲用户端请求的最大字节数，</span>            client_body_buffer_size 128k;            <span class="hljs-comment"># 表示使nginx阻止HTTP应答代码为400或者更高的应答。</span>            proxy_intercept_errors on;            <span class="hljs-comment"># nginx跟后端服务器连接超时时间(代理连接超时)</span>            proxy_connect_timeout 90;            <span class="hljs-comment"># 后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据</span>            proxy_send_timeout 90;            <span class="hljs-comment"># 连接成功后，后端服务器响应的超时时间</span>            proxy_read_timeout 90;            <span class="hljs-comment"># 设置代理服务器（nginx）保存用户头信息的缓冲区大小</span>            proxy_buffer_size 4k;            <span class="hljs-comment"># 设置用于读取应答的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k</span>            proxy_buffers 4 32k;            <span class="hljs-comment"># 高负荷下缓冲大小（proxy_buffers*2）</span>            proxy_busy_buffers_size 64k;            <span class="hljs-comment"># 设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长</span>            <span class="hljs-comment"># 设定缓存文件夹大小，大于这个值，将从upstream服务器传</span>            proxy_temp_file_write_size 64k;        &#125;                <span class="hljs-comment"># 动静分离反向代理配置（多路由指向不同的服务端或界面）</span>        location ~ .(jsp|jspx|<span class="hljs-keyword">do</span>)?$ &#123;            proxy_set_header Host <span class="hljs-variable">$host</span>;            proxy_set_header X-Real-IP <span class="hljs-variable">$remote_addr</span>;            proxy_set_header X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;            proxy_pass http://127.0.0.1:8080;        &#125;    &#125;&#125;</code></pre><h2 id="Nginx还能做什么"><a href="#Nginx还能做什么" class="headerlink" title="Nginx还能做什么"></a>Nginx还能做什么</h2><h3 id="解决CORS跨域问题"><a href="#解决CORS跨域问题" class="headerlink" title="解决CORS跨域问题"></a>解决CORS跨域问题</h3><p>思路有两个：</p><ul><li>基于多路由，把跨域的两个请求发到各自的服务器，然后统一访问入口即可避免该问题</li><li>利用Nginx配置Headerd的功能，为其附上相应的请求头</li></ul><h3 id="适配-PC-或移动设备"><a href="#适配-PC-或移动设备" class="headerlink" title="适配 PC 或移动设备"></a>适配 PC 或移动设备</h3><p>根据用户设备不同返回不同样式的站点，以前经常使用的是纯前端的自适应布局，但无论是复杂性和易用性上面还是不如分开编写的好，比如我们常见的淘宝、京东……这些大型网站就都没有采用自适应，而是用分开制作的方式，根据用户请求的 <code>user-agent</code> 来判断是返回 PC 还是 H5 站点</p><h3 id="请求限流"><a href="#请求限流" class="headerlink" title="请求限流"></a>请求限流</h3><p>Nginx按请求速率限速模块使用的是漏桶算法，即能够强行保证请求的实时处理速度不会超过设置的阈值，如：</p><pre><code class="hljs bash">http &#123;    limit_req_zone <span class="hljs-variable">$binary_remote_addr</span> zone=one:10m rate=1r/s;    server &#123;        location /search/ &#123;            limit_req zone=one burst=5 nodelay;        &#125;    &#125;&#125;</code></pre><h3 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h3><p>如：图片防盗链，请求过滤，泛域名转发，配置HTTPS等等</p><p>可参考文章：<a href="https://juejin.im/post/6844904144235413512" target="_blank" rel="noopener">《Nginx 从入门到实践，万字详解！》</a></p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="Q1：Nginx一般用作什么？"><a href="#Q1：Nginx一般用作什么？" class="headerlink" title="Q1：Nginx一般用作什么？"></a>Q1：Nginx一般用作什么？</h3><blockquote><p>见上文中Nginx在架构体系中的作用，配合Nginx还能做什么作答即可</p></blockquote><h3 id="Q2：为什么要用Nginx？"><a href="#Q2：为什么要用Nginx？" class="headerlink" title="Q2：为什么要用Nginx？"></a>Q2：为什么要用Nginx？</h3><blockquote><p>理解网关的必要性，以及Nginx保证高可用，负载均衡的能力</p></blockquote><h3 id="Q3：为什么Nginx这么快？"><a href="#Q3：为什么Nginx这么快？" class="headerlink" title="Q3：为什么Nginx这么快？"></a>Q3：为什么Nginx这么快？</h3><p>如果一个server采用一个进程负责一个request的方式，那么进程数就是并发数。那么显而易见的，就是会有很多进程在等待中。等什么？最多的应该是等待网络传输。</p><p>而nginx 的异步非阻塞工作方式正是利用了这点等待的时间。在需要等待的时候，这些进程就空闲出来待命了。因此表现为少数几个进程就解决了大量的并发问题。</p><p>nginx是如何利用的呢，简单来说：同样的4个进程，如果采用一个进程负责一个request的方式，那么，同时进来4个request之后，每个进程就负责其中一个，直至会话关闭。期间，如果有第5个request进来了。就无法及时反应了，因为4个进程都没干完活呢，因此，一般有个调度进程，每当新进来了一个request，就新开个进程来处理。</p><p>nginx不这样，每进来一个request，会有一个worker进程去处理。但不是全程的处理，处理到什么程度呢？处理到可能发生阻塞的地方，比如向上游（后端）服务器转发request，并等待请求返回。那么，这个处理的worker不会这么傻等着，他会在发送完请求后，注册一个事件：“如果upstream返回了，告诉我一声，我再接着干”。于是他就休息去了。此时，如果再有request 进来，他就可以很快再按这种方式处理。而一旦上游服务器返回了，就会触发这个事件，worker才会来接手，这个request才会接着往下走。</p><p>由于web server的工作性质决定了每个request的大部份生命都是在网络传输中，实际上花费在server机器上的时间片不多。这是几个进程就解决高并发的秘密所在。</p><blockquote><p>总结：事件模型，异步非阻塞，多进程模型加上细节优化的共同作用</p></blockquote><h3 id="Q4：什么是正向代理和反向代理"><a href="#Q4：什么是正向代理和反向代理" class="headerlink" title="Q4：什么是正向代理和反向代理"></a>Q4：什么是正向代理和反向代理</h3><blockquote><p>见上文</p></blockquote><h3 id="Q5：Nginx负载均衡的算法有哪些？"><a href="#Q5：Nginx负载均衡的算法有哪些？" class="headerlink" title="Q5：Nginx负载均衡的算法有哪些？"></a>Q5：Nginx负载均衡的算法有哪些？</h3><blockquote><p>见上文</p></blockquote><h3 id="Q6：Nginx如何解决的惊群现象？"><a href="#Q6：Nginx如何解决的惊群现象？" class="headerlink" title="Q6：Nginx如何解决的惊群现象？"></a>Q6：Nginx如何解决的惊群现象？</h3><blockquote><p>见上文</p></blockquote><h3 id="Q7：Nginx为什么不用多线程模型？"><a href="#Q7：Nginx为什么不用多线程模型？" class="headerlink" title="Q7：Nginx为什么不用多线程模型？"></a>Q7：Nginx为什么不用多线程模型？</h3><blockquote><p>深入理解多进程模型加上异步非阻塞IO的好处以及多线程模型中上下文切换的劣势</p></blockquote><h3 id="Q8：Nginx压缩功能有什么坏处吗？"><a href="#Q8：Nginx压缩功能有什么坏处吗？" class="headerlink" title="Q8：Nginx压缩功能有什么坏处吗？"></a>Q8：Nginx压缩功能有什么坏处吗？</h3><blockquote><p>非常耗费服务器的CPU</p></blockquote><h3 id="Q9：Nginx有几种进程模型"><a href="#Q9：Nginx有几种进程模型" class="headerlink" title="Q9：Nginx有几种进程模型?"></a>Q9：Nginx有几种进程模型?</h3><blockquote><p>实际上有两种，多进程和单进程，但是实际工作中都是多进程的</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.im/post/6844903849988227086" target="_blank" rel="noopener">【前端词典】如何向老板解释反向代理</a></li><li><a href="https://www.jianshu.com/p/2b95794a3654" target="_blank" rel="noopener">[code.nginx] Nginx服务器的事件驱动模型</a></li><li><a href="https://www.cnblogs.com/baby123/p/12052583.html" target="_blank" rel="noopener">Nginx模块化设计</a></li><li><a href="https://www.nginx.cn/doc/" target="_blank" rel="noopener">Nginx中文文档</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>中间件篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日志套餐篇</title>
    <link href="/2023/09/12/%E6%97%A5%E5%BF%97%E5%A5%97%E9%A4%90%E7%AF%87/"/>
    <url>/2023/09/12/%E6%97%A5%E5%BF%97%E5%A5%97%E9%A4%90%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="日志套餐篇-log4j2-logback全量套餐"><a href="#日志套餐篇-log4j2-logback全量套餐" class="headerlink" title="日志套餐篇 - log4j2 logback全量套餐"></a>日志套餐篇 - log4j2 logback全量套餐</h1><blockquote><p>前情提要：</p><p>Log4j  Log4j2  logback是当下主流的日志框架</p><p>slf4j则是新一代的日志框架接口，logback直接实现了slf4j接口，另外logback是SpringBoot最新的默认日志框架</p><p>综合来看性能上依然推荐：log4j2（拥有logback全部特性）</p></blockquote><p><strong>注：</strong>鉴于log4j已经跟不上时代的要求，因此不做特别的介绍，其实log4j的配置，完全可以在log4j2上使用</p><h2 id="普通工程-建议集成log4j2"><a href="#普通工程-建议集成log4j2" class="headerlink" title="普通工程 - 建议集成log4j2"></a>普通工程 - 建议集成log4j2</h2><p>普通工程即：普通的java项目, 如个人的代码Demo或者准备打成jar使用的，推荐使用log4j2</p><p>必要依赖如下：</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- log4j2 必要依赖 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.12.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- log4j2 必要依赖 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.12.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- slf4j核心包 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- log4j-异步日志依赖 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.lmax<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>disruptor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--用于与slf4j保持桥接--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-slf4j-impl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.12.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>配置如下：</p><blockquote><p>Maven项目只需要在resource里面加入log4j2.xml配置文件即可</p></blockquote><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-comment">&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;</span><span class="hljs-comment">&lt;!--Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，你会看到log4j2内部各种详细输出--&gt;</span><span class="hljs-comment">&lt;!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Configuration</span> <span class="hljs-attr">status</span>=<span class="hljs-string">"WARN"</span> <span class="hljs-attr">monitorInterval</span>=<span class="hljs-string">"30"</span>&gt;</span>    <span class="hljs-comment">&lt;!--全局属性--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">Properties</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"APP_NAME"</span>&gt;</span>kerwinTools<span class="hljs-tag">&lt;/<span class="hljs-name">Property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"LOG_FILE_PATH"</span>&gt;</span>/log/$&#123;APP_NAME&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">Property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"PATTERN_FORMAT"</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %-5level [%t] %class&#123;36&#125; (%L) %M - %msg%xEx%n<span class="hljs-tag">&lt;/<span class="hljs-name">Property</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">Properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">Appenders</span>&gt;</span>        <span class="hljs-comment">&lt;!--输出到控制台--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Console</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"Console"</span> <span class="hljs-attr">target</span>=<span class="hljs-string">"SYSTEM_OUT"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">"$&#123;PATTERN_FORMAT&#125;"</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">Console</span>&gt;</span>        <span class="hljs-comment">&lt;!-- INFO_LOG --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">RollingFile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"INFO_LOG"</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">"$&#123;LOG_FILE_PATH&#125;/info.log"</span> <span class="hljs-attr">filePattern</span>=<span class="hljs-string">"$&#123;LOG_HOME&#125;/info.log_%d&#123;yyyy-MM-dd&#125;.log"</span>&gt;</span>            <span class="hljs-comment">&lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">Filters</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">ThresholdFilter</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"warn"</span> <span class="hljs-attr">onMatch</span>=<span class="hljs-string">"DENY"</span> <span class="hljs-attr">onMismatch</span>=<span class="hljs-string">"NEUTRAL"</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">ThresholdFilter</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"info"</span> <span class="hljs-attr">onMatch</span>=<span class="hljs-string">"ACCEPT"</span> <span class="hljs-attr">onMismatch</span>=<span class="hljs-string">"DENY"</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">Filters</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;PATTERN_FORMAT&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">PatternLayout</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">Policies</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">TimeBasedTriggeringPolicy</span> <span class="hljs-attr">interval</span>=<span class="hljs-string">"1"</span> <span class="hljs-attr">modulate</span>=<span class="hljs-string">"true"</span> /&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">Policies</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">DefaultRolloverStrategy</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">Delete</span> <span class="hljs-attr">basePath</span>=<span class="hljs-string">"$&#123;LOG_FILE_PATH&#125;"</span> <span class="hljs-attr">maxDepth</span>=<span class="hljs-string">"1"</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">IfFileName</span> <span class="hljs-attr">glob</span>=<span class="hljs-string">"info.log_*"</span> /&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">IfLastModified</span> <span class="hljs-attr">age</span>=<span class="hljs-string">"5d"</span> /&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">Delete</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">DefaultRolloverStrategy</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">RollingFile</span>&gt;</span>        <span class="hljs-comment">&lt;!-- DEBUG_LOG --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">RollingFile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"DEBUG_LOG"</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">"$&#123;LOG_FILE_PATH&#125;/debug.log"</span> <span class="hljs-attr">filePattern</span>=<span class="hljs-string">"$&#123;LOG_HOME&#125;/debug.log_%d&#123;yyyy-MM-dd&#125;.log"</span>&gt;</span>            <span class="hljs-comment">&lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">Filters</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">ThresholdFilter</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"error"</span> <span class="hljs-attr">onMatch</span>=<span class="hljs-string">"DENY"</span> <span class="hljs-attr">onMismatch</span>=<span class="hljs-string">"NEUTRAL"</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">ThresholdFilter</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"debug"</span> <span class="hljs-attr">onMatch</span>=<span class="hljs-string">"ACCEPT"</span> <span class="hljs-attr">onMismatch</span>=<span class="hljs-string">"DENY"</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">Filters</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;PATTERN_FORMAT&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">PatternLayout</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">Policies</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">TimeBasedTriggeringPolicy</span> <span class="hljs-attr">interval</span>=<span class="hljs-string">"1"</span> <span class="hljs-attr">modulate</span>=<span class="hljs-string">"true"</span> /&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">Policies</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">DefaultRolloverStrategy</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">Delete</span> <span class="hljs-attr">basePath</span>=<span class="hljs-string">"$&#123;LOG_FILE_PATH&#125;"</span> <span class="hljs-attr">maxDepth</span>=<span class="hljs-string">"1"</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">IfFileName</span> <span class="hljs-attr">glob</span>=<span class="hljs-string">"debug.log_*"</span> /&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">IfLastModified</span> <span class="hljs-attr">age</span>=<span class="hljs-string">"5d"</span> /&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">Delete</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">DefaultRolloverStrategy</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">RollingFile</span>&gt;</span>        <span class="hljs-comment">&lt;!-- ERROR_LOG --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">RollingFile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"ERROR_LOG"</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">"$&#123;LOG_FILE_PATH&#125;/error.log"</span> <span class="hljs-attr">filePattern</span>=<span class="hljs-string">"$&#123;LOG_HOME&#125;/error.log_%d&#123;yyyy-MM-dd&#125;.log"</span>&gt;</span>            <span class="hljs-comment">&lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">ThresholdFilter</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"error"</span> <span class="hljs-attr">onMatch</span>=<span class="hljs-string">"ACCEPT"</span> <span class="hljs-attr">onMismatch</span>=<span class="hljs-string">"DENY"</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;PATTERN_FORMAT&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">PatternLayout</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">Policies</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">TimeBasedTriggeringPolicy</span> <span class="hljs-attr">interval</span>=<span class="hljs-string">"1"</span> <span class="hljs-attr">modulate</span>=<span class="hljs-string">"true"</span> /&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">Policies</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">DefaultRolloverStrategy</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">Delete</span> <span class="hljs-attr">basePath</span>=<span class="hljs-string">"$&#123;LOG_FILE_PATH&#125;"</span> <span class="hljs-attr">maxDepth</span>=<span class="hljs-string">"1"</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">IfFileName</span> <span class="hljs-attr">glob</span>=<span class="hljs-string">"error.log_*"</span> /&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">IfLastModified</span> <span class="hljs-attr">age</span>=<span class="hljs-string">"5d"</span> /&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">Delete</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">DefaultRolloverStrategy</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">RollingFile</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">Appenders</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">Loggers</span>&gt;</span>        <span class="hljs-comment">&lt;!-- LOG everything at DEBUG level includeLocation 处理日志所在行号 --&gt;</span>        <span class="hljs-comment">&lt;!-- Root 同步日志 AsyncRoot 异步日志 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">AsyncRoot</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"DEBUG"</span> <span class="hljs-attr">includeLocation</span>=<span class="hljs-string">"true"</span>&gt;</span>            <span class="hljs-comment">&lt;!-- Console 日志, 注释即不打印到控制台 --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"Console"</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"INFO_LOG"</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"DEBUG_LOG"</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"ERROR_LOG"</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">AsyncRoot</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">Loggers</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Configuration</span>&gt;</span></code></pre><p><strong>注：</strong>日志打印的位置我并没用做特别的约束，所以它会在项目所存储的盘符自动建立${APP_NAME} 文件夹</p><p>效果如图所示：</p><p><img src="/2023/09/12/%E6%97%A5%E5%BF%97%E5%A5%97%E9%A4%90%E7%AF%87/1565711360530.png" srcset="/img/loading.gif" alt="1565711360530"></p><h2 id="如何验证Lo4j2开启异步日志"><a href="#如何验证Lo4j2开启异步日志" class="headerlink" title="如何验证Lo4j2开启异步日志"></a>如何验证Lo4j2开启异步日志</h2><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Configuration</span> <span class="hljs-attr">status</span>=<span class="hljs-string">"WARN"</span> <span class="hljs-attr">monitorInterval</span>=<span class="hljs-string">"30"</span>&gt;</span></code></pre><blockquote><p>注意Lo4j2的<code>Configuration</code>设置中<code>status=&quot;WARN&quot;</code>, 设置为 <code>TRACE</code>，即可让log4j打印内部日志，即可判断日志的细节</p></blockquote><h2 id="SpringBoot项目-个人练习建议集成logback"><a href="#SpringBoot项目-个人练习建议集成logback" class="headerlink" title="SpringBoot项目  - 个人练习建议集成logback"></a>SpringBoot项目  - 个人练习建议集成logback</h2><pre><code class="hljs java"><span class="hljs-comment">// 由于springboot默认支持logbak  因此无需任何依赖即可使用,当然需要一些默认的必备依赖 如 web等...</span></code></pre><p>application配置如下：</p><pre><code class="hljs properties"><span class="hljs-comment"># 约束mybis-dao级别为dao层</span><span class="hljs-meta">logging.level.com.cat.dao</span>=<span class="hljs-string">DEBUG</span><span class="hljs-meta">logging.config</span>=<span class="hljs-string">classpath:logback-spring.xml</span><span class="hljs-comment"># 文件输出位置即文件夹名称</span><span class="hljs-meta">logging.file</span>=<span class="hljs-string">/log/volcat-server</span></code></pre><p>配置文件如下：</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-comment">&lt;!-- 日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，如果设置为WARN，则低于WARN的信息都不会输出 --&gt;</span><span class="hljs-comment">&lt;!-- scan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true --&gt;</span><span class="hljs-comment">&lt;!-- scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 --&gt;</span><span class="hljs-comment">&lt;!-- de<span class="hljs-doctag">bug:</span>当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>  <span class="hljs-attr">scan</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">scanPeriod</span>=<span class="hljs-string">"10 seconds"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">contextName</span>&gt;</span>logback<span class="hljs-tag">&lt;/<span class="hljs-name">contextName</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 命名为logback-spring 可以读取spring中的配置信息, 以下即为读取spring的日志输出地址 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">springProperty</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">"context"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"log.path"</span> <span class="hljs-attr">source</span>=<span class="hljs-string">"logging.file"</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 在当前文件中约束配置地址 --&gt;</span>    <span class="hljs-comment">&lt;!--&lt;property name="log.path" value="/log/demo_test_nginx" /&gt;--&gt;</span>    <span class="hljs-comment">&lt;!--</span><span class="hljs-comment">       &lt;logger&gt;用来设置某一个包或者具体的某一个类的日志打印级别、</span><span class="hljs-comment">       以及指定&lt;appender&gt;。&lt;logger&gt;仅有一个name属性，</span><span class="hljs-comment">       一个可选的level和一个可选的addtivity属性。</span><span class="hljs-comment">       name:用来指定受此logger约束的某一个包或者具体的某一个类。</span><span class="hljs-comment">       level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，</span><span class="hljs-comment">             还有一个特俗值INHERITED或者同义词NULL，代表强制执行上级的级别。</span><span class="hljs-comment">             如果未设置此属性，那么当前logger将会继承上级的级别。</span><span class="hljs-comment">       addtivity:是否向上级logger传递打印信息。默认是true</span><span class="hljs-comment">   --&gt;</span>    <span class="hljs-comment">&lt;!-- 彩色日志 --&gt;</span>    <span class="hljs-comment">&lt;!-- 彩色日志依赖的渲染类 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">conversionRule</span> <span class="hljs-attr">conversionWord</span>=<span class="hljs-string">"clr"</span> <span class="hljs-attr">converterClass</span>=<span class="hljs-string">"org.springframework.boot.logging.logback.ColorConverter"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">conversionRule</span> <span class="hljs-attr">conversionWord</span>=<span class="hljs-string">"wex"</span> <span class="hljs-attr">converterClass</span>=<span class="hljs-string">"org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">conversionRule</span> <span class="hljs-attr">conversionWord</span>=<span class="hljs-string">"wEx"</span> <span class="hljs-attr">converterClass</span>=<span class="hljs-string">"org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter"</span> /&gt;</span>    <span class="hljs-comment">&lt;!-- 彩色日志格式 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"CONSOLE_LOG_PATTERN"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;CONSOLE_LOG_PATTERN:-%clr(%d&#123;yyyy-MM-dd HH:mm:ss&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125; %line)&#123;cyan&#125; %clr(:) %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;"</span>/&gt;</span>    <span class="hljs-comment">&lt;!--输出到控制台--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"CONSOLE"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span>        <span class="hljs-comment">&lt;!--此日志appender是为开发使用，配置为DEBUG级别, 控制台输出的日志级别是大于或等于此级别的日志信息--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>debug<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">Pattern</span>&gt;</span>$&#123;CONSOLE_LOG_PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">Pattern</span>&gt;</span>            <span class="hljs-comment">&lt;!-- 设置字符集 --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>    <span class="hljs-comment">&lt;!--输出到文件--&gt;</span>    <span class="hljs-comment">&lt;!-- 时间滚动输出 level为 DEBUG 日志 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"DEBUG_FILE"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 正在记录的日志文件的路径及文件名 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>$&#123;log.path&#125;/debug.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span>        <span class="hljs-comment">&lt;!--日志文件输出格式--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span> <span class="hljs-comment">&lt;!-- 设置字符集 --&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span>            <span class="hljs-comment">&lt;!-- 日志归档 --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/debug/debug-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">maxFileSize</span>&gt;</span>100MB<span class="hljs-tag">&lt;/<span class="hljs-name">maxFileSize</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span>            <span class="hljs-comment">&lt;!--日志文件保留天数--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>15<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 此日志文件只记录debug级别的 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>debug<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>DENY<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 时间滚动输出 level为 INFO 日志 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"INFO_FILE"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 正在记录的日志文件的路径及文件名 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>$&#123;log.path&#125;/info.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span>        <span class="hljs-comment">&lt;!--日志文件输出格式--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span>            <span class="hljs-comment">&lt;!-- 每天日志归档路径以及格式 --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/info/info-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">maxFileSize</span>&gt;</span>100MB<span class="hljs-tag">&lt;/<span class="hljs-name">maxFileSize</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span>            <span class="hljs-comment">&lt;!--日志文件保留天数--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>15<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 此日志文件只记录info级别的 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>info<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>DENY<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 时间滚动输出 level为 WARN 日志 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"WARN_FILE"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 正在记录的日志文件的路径及文件名 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>$&#123;log.path&#125;/warn.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span>        <span class="hljs-comment">&lt;!--日志文件输出格式--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span> <span class="hljs-comment">&lt;!-- 此处设置字符集 --&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/warn/warn-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">maxFileSize</span>&gt;</span>100MB<span class="hljs-tag">&lt;/<span class="hljs-name">maxFileSize</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span>            <span class="hljs-comment">&lt;!--日志文件保留天数--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>15<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 此日志文件只记录warn级别的 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>warn<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>DENY<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 时间滚动输出 level为 ERROR 日志 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"ERROR_FILE"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 正在记录的日志文件的路径及文件名 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>$&#123;log.path&#125;/error.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span>        <span class="hljs-comment">&lt;!--日志文件输出格式--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span> <span class="hljs-comment">&lt;!-- 此处设置字符集 --&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/error/error-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">maxFileSize</span>&gt;</span>100MB<span class="hljs-tag">&lt;/<span class="hljs-name">maxFileSize</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span>            <span class="hljs-comment">&lt;!--日志文件保留天数--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>15<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 此日志文件只记录ERROR级别的 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>ERROR<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>DENY<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>    <span class="hljs-comment">&lt;!--</span><span class="hljs-comment">        root节点是必选节点，用来指定最基础的日志输出级别，只有一个level属性</span><span class="hljs-comment">        level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，</span><span class="hljs-comment">        不能设置为INHERITED或者同义词NULL。默认是DEBUG</span><span class="hljs-comment">        可以包含零个或多个元素，标识这个appender将会添加到这个logger。</span><span class="hljs-comment">    --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"info"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"CONSOLE"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"DEBUG_FILE"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"INFO_FILE"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"WARN_FILE"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"ERROR_FILE"</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre><h2 id="SpringBoot项目-集成log4j2"><a href="#SpringBoot项目-集成log4j2" class="headerlink" title="SpringBoot项目  - 集成log4j2"></a>SpringBoot项目  - 集成log4j2</h2><p>必备依赖  - 既然是SpringBoot项目,那用官方的starter是最好的，版本什么的都不用管</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 去除logback日志依赖 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- 导入log4j2-starter --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- log4j2 异步打印必要依赖 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.lmax<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>disruptor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>applications配置</p><pre><code class="hljs ini"><span class="hljs-comment"># mybatis-dao相关的操作为DEBUG级别, 数据库日志会打印到debug文件中</span><span class="hljs-attr">logging.level.com.cat.dao</span>=DEBUG<span class="hljs-attr">logging.config</span>=classpath:log4j2.xml</code></pre><p>配置文件 - 沿用上面的配置文件即可，必要情况可以修改打印的日志级别，如</p><pre><code class="hljs xml">.....<span class="hljs-tag">&lt;<span class="hljs-name">Loggers</span>&gt;</span>    <span class="hljs-comment">&lt;!--过滤掉spring和mybatis的一些无用的DEBUG信息--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">Logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"org.springframework"</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"INFO"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">Logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"org.mybatis"</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"INFO"</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- LOG everything at INFO level --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">Root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"INFO"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"Console"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"INFO_LOG"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"DEBUG_LOG"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"ERROR_LOG"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">Root</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Loggers</span>&gt;</span></code></pre><h2 id="SpringBoot-log4j2-企业级方案"><a href="#SpringBoot-log4j2-企业级方案" class="headerlink" title="SpringBoot - log4j2 企业级方案"></a>SpringBoot - log4j2 企业级方案</h2><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">Configuration</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"LOG_HOME"</span>&gt;</span>/log/volcat-server<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">Appenders</span>&gt;</span>          <span class="hljs-comment">&lt;!-- 輸出到監視器 --&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">Console</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"Console"</span> <span class="hljs-attr">target</span>=<span class="hljs-string">"SYSTEM_OUT"</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">"%date&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; [%thread][%level] - %msg%n"</span> /&gt;</span>          <span class="hljs-tag">&lt;/<span class="hljs-name">Console</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">RollingFile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"error.log"</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">"$&#123;LOG_HOME&#125;/error.log"</span> <span class="hljs-attr">filePattern</span>=<span class="hljs-string">"$&#123;LOG_HOME&#125;/error.log_%d&#123;yyyy-MM-dd&#125;.log"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">"%date&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; [%thread][%level] - %msg%n"</span> /&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">Policies</span>&gt;</span>                  <span class="hljs-tag">&lt;<span class="hljs-name">TimeBasedTriggeringPolicy</span> <span class="hljs-attr">interval</span>=<span class="hljs-string">"1"</span> <span class="hljs-attr">modulate</span>=<span class="hljs-string">"true"</span> /&gt;</span>              <span class="hljs-tag">&lt;/<span class="hljs-name">Policies</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">DefaultRolloverStrategy</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">Delete</span> <span class="hljs-attr">basePath</span>=<span class="hljs-string">"$&#123;LOG_HOME&#125;"</span> <span class="hljs-attr">maxDepth</span>=<span class="hljs-string">"1"</span>&gt;</span>                       <span class="hljs-tag">&lt;<span class="hljs-name">IfFileName</span> <span class="hljs-attr">glob</span>=<span class="hljs-string">"error.log_*"</span> /&gt;</span>                       <span class="hljs-tag">&lt;<span class="hljs-name">IfLastModified</span> <span class="hljs-attr">age</span>=<span class="hljs-string">"5d"</span> /&gt;</span>              <span class="hljs-tag">&lt;/<span class="hljs-name">Delete</span>&gt;</span>              <span class="hljs-tag">&lt;/<span class="hljs-name">DefaultRolloverStrategy</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">RollingFile</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">RollingFile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"debug.log"</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">"$&#123;LOG_HOME&#125;/debug.log"</span> <span class="hljs-attr">filePattern</span>=<span class="hljs-string">"$&#123;LOG_HOME&#125;/debug.log_%d&#123;yyyy-MM-dd&#125;.log"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">"%date&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; [%thread][%level] - %msg%n"</span> /&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">Policies</span>&gt;</span>                  <span class="hljs-tag">&lt;<span class="hljs-name">TimeBasedTriggeringPolicy</span> <span class="hljs-attr">interval</span>=<span class="hljs-string">"1"</span> <span class="hljs-attr">modulate</span>=<span class="hljs-string">"true"</span> /&gt;</span>              <span class="hljs-tag">&lt;/<span class="hljs-name">Policies</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">DefaultRolloverStrategy</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">Delete</span> <span class="hljs-attr">basePath</span>=<span class="hljs-string">"$&#123;LOG_HOME&#125;"</span> <span class="hljs-attr">maxDepth</span>=<span class="hljs-string">"1"</span>&gt;</span>                       <span class="hljs-tag">&lt;<span class="hljs-name">IfFileName</span> <span class="hljs-attr">glob</span>=<span class="hljs-string">"debug.log_*"</span> /&gt;</span>                       <span class="hljs-tag">&lt;<span class="hljs-name">IfLastModified</span> <span class="hljs-attr">age</span>=<span class="hljs-string">"5d"</span> /&gt;</span>              <span class="hljs-tag">&lt;/<span class="hljs-name">Delete</span>&gt;</span>              <span class="hljs-tag">&lt;/<span class="hljs-name">DefaultRolloverStrategy</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">RollingFile</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">RollingFile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"message.log"</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">"$&#123;LOG_HOME&#125;/message.log"</span> <span class="hljs-attr">filePattern</span>=<span class="hljs-string">"$&#123;LOG_HOME&#125;/message.log_%d&#123;yyyy-MM-dd&#125;.log"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">"%date&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; [%thread][%level] - %msg%n"</span> /&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">Policies</span>&gt;</span>                  <span class="hljs-tag">&lt;<span class="hljs-name">TimeBasedTriggeringPolicy</span> <span class="hljs-attr">interval</span>=<span class="hljs-string">"1"</span> <span class="hljs-attr">modulate</span>=<span class="hljs-string">"true"</span> /&gt;</span>              <span class="hljs-tag">&lt;/<span class="hljs-name">Policies</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">DefaultRolloverStrategy</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">Delete</span> <span class="hljs-attr">basePath</span>=<span class="hljs-string">"$&#123;LOG_HOME&#125;"</span> <span class="hljs-attr">maxDepth</span>=<span class="hljs-string">"1"</span>&gt;</span>                       <span class="hljs-tag">&lt;<span class="hljs-name">IfFileName</span> <span class="hljs-attr">glob</span>=<span class="hljs-string">"message.log_*"</span> /&gt;</span>                       <span class="hljs-tag">&lt;<span class="hljs-name">IfLastModified</span> <span class="hljs-attr">age</span>=<span class="hljs-string">"5d"</span> /&gt;</span>              <span class="hljs-tag">&lt;/<span class="hljs-name">Delete</span>&gt;</span>              <span class="hljs-tag">&lt;/<span class="hljs-name">DefaultRolloverStrategy</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">RollingFile</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">RollingFile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"access.log"</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">"$&#123;LOG_HOME&#125;/access.log"</span> <span class="hljs-attr">filePattern</span>=<span class="hljs-string">"$&#123;LOG_HOME&#125;/access.log_%d&#123;yyyy-MM-dd&#125;.log"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">"%date&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; [%thread][%level] - %msg%n"</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">Policies</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">TimeBasedTriggeringPolicy</span> <span class="hljs-attr">interval</span>=<span class="hljs-string">"1"</span> <span class="hljs-attr">modulate</span>=<span class="hljs-string">"true"</span> /&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">Policies</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">DefaultRolloverStrategy</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">Delete</span> <span class="hljs-attr">basePath</span>=<span class="hljs-string">"$&#123;LOG_HOME&#125;"</span> <span class="hljs-attr">maxDepth</span>=<span class="hljs-string">"1"</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">IfFileName</span> <span class="hljs-attr">glob</span>=<span class="hljs-string">"access.log_*"</span> /&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">IfLastModified</span> <span class="hljs-attr">age</span>=<span class="hljs-string">"5d"</span> /&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">Delete</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">DefaultRolloverStrategy</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">RollingFile</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">Appenders</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">Loggers</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">Logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"sys.error"</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"ERROR"</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"error.log"</span> /&gt;</span>          <span class="hljs-tag">&lt;/<span class="hljs-name">Logger</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"sys.debug"</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"DEBUG"</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"debug.log"</span> /&gt;</span>          <span class="hljs-tag">&lt;/<span class="hljs-name">Logger</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"sys.message"</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"INFO"</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"message.log"</span> /&gt;</span>          <span class="hljs-tag">&lt;/<span class="hljs-name">Logger</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"sys.access"</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"INFO"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"access.log"</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">Logger</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">Loggers</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">Configuration</span>&gt;</span></code></pre><p><strong>Logit工具类</strong></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mine.log;<span class="hljs-keyword">import</span> org.slf4j.Logger;<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Logit</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger DEBUG_LOG = LoggerFactory.getLogger(<span class="hljs-string">"sys.debug"</span>);    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger WARN_LOG = LoggerFactory.getLogger(<span class="hljs-string">"sys.warn"</span>);    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger MESSAGE_LOG = LoggerFactory.getLogger(<span class="hljs-string">"sys.message"</span>);    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger ACCESS_LOG = LoggerFactory.getLogger(<span class="hljs-string">"sys.access"</span>);    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger ERROR_LOG = LoggerFactory.getLogger(<span class="hljs-string">"sys.error"</span>);    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger DB_LOG = LoggerFactory.getLogger(<span class="hljs-string">"db.sql"</span>);    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Logit</span><span class="hljs-params">()</span> </span>&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accessLog</span><span class="hljs-params">(String log)</span> </span>&#123;        ACCESS_LOG.info(log);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">messageLog</span><span class="hljs-params">(String log)</span> </span>&#123;        StackTraceElement[] stacks = (<span class="hljs-keyword">new</span> Throwable()).getStackTrace();        StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer(stacks[<span class="hljs-number">1</span>].getClassName());        sb.append(<span class="hljs-string">"."</span>);        sb.append(stacks[<span class="hljs-number">1</span>].getMethodName());        sb.append(<span class="hljs-string">"---"</span>);        sb.append(log);        MESSAGE_LOG.info(sb.toString());    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">messageLog</span><span class="hljs-params">(String log, String loglevel)</span> </span>&#123;        StackTraceElement[] stacks = (<span class="hljs-keyword">new</span> Throwable()).getStackTrace();        StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer(stacks[<span class="hljs-number">1</span>].getClassName());        sb.append(<span class="hljs-string">"."</span>);        sb.append(stacks[<span class="hljs-number">1</span>].getMethodName());        sb.append(<span class="hljs-string">"---"</span>);        sb.append(log);        <span class="hljs-keyword">if</span> (<span class="hljs-string">"debug"</span>.equalsIgnoreCase(loglevel)) &#123;            MESSAGE_LOG.debug(log);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"info"</span>.equalsIgnoreCase(loglevel)) &#123;            MESSAGE_LOG.info(log);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"warn"</span>.equalsIgnoreCase(loglevel)) &#123;            MESSAGE_LOG.warn(log);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"error"</span>.equalsIgnoreCase(loglevel)) &#123;            MESSAGE_LOG.error(log);        &#125; <span class="hljs-keyword">else</span> &#123;            MESSAGE_LOG.info(log);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debugLog</span><span class="hljs-params">(String log)</span> </span>&#123;        StackTraceElement[] stacks = (<span class="hljs-keyword">new</span> Throwable()).getStackTrace();        StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer(stacks[<span class="hljs-number">1</span>].getClassName());        sb.append(<span class="hljs-string">"."</span>);        sb.append(stacks[<span class="hljs-number">1</span>].getMethodName());        sb.append(<span class="hljs-string">"---"</span>);        sb.append(log);        debugPlog(sb.toString(), <span class="hljs-string">"debug"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debugLog</span><span class="hljs-params">(String log, String loglevel)</span> </span>&#123;        StackTraceElement[] stacks = (<span class="hljs-keyword">new</span> Throwable()).getStackTrace();        StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer(stacks[<span class="hljs-number">1</span>].getClassName());        sb.append(<span class="hljs-string">"."</span>);        sb.append(stacks[<span class="hljs-number">1</span>].getMethodName());        sb.append(<span class="hljs-string">"---"</span>);        sb.append(log);        debugPlog(sb.toString(), loglevel);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debugPlog</span><span class="hljs-params">(String log, String loglevel)</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-string">"debug"</span>.equalsIgnoreCase(loglevel)) &#123;            DEBUG_LOG.debug(log);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"info"</span>.equalsIgnoreCase(loglevel)) &#123;            DEBUG_LOG.info(log);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"warn"</span>.equalsIgnoreCase(loglevel)) &#123;            DEBUG_LOG.warn(log);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"error"</span>.equalsIgnoreCase(loglevel)) &#123;            DEBUG_LOG.error(log);        &#125; <span class="hljs-keyword">else</span> &#123;            DEBUG_LOG.debug(log);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">warnLog</span><span class="hljs-params">(String log)</span> </span>&#123;        StackTraceElement[] stacks = (<span class="hljs-keyword">new</span> Throwable()).getStackTrace();        StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer(stacks[<span class="hljs-number">1</span>].getClassName());        sb.append(<span class="hljs-string">"."</span>);        sb.append(stacks[<span class="hljs-number">1</span>].getMethodName());        sb.append(<span class="hljs-string">"---"</span>);        sb.append(log);        WARN_LOG.error(sb.toString());    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">errorLog</span><span class="hljs-params">(String log)</span> </span>&#123;        StackTraceElement[] stacks = (<span class="hljs-keyword">new</span> Throwable()).getStackTrace();        StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer(stacks[<span class="hljs-number">1</span>].getClassName());        sb.append(<span class="hljs-string">"."</span>);        sb.append(stacks[<span class="hljs-number">1</span>].getMethodName());        sb.append(<span class="hljs-string">"---"</span>);        sb.append(log);        errorPLog(sb.toString(), (Throwable)<span class="hljs-keyword">null</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">errorLog</span><span class="hljs-params">(String log, Throwable throwable)</span> </span>&#123;        StackTraceElement[] stacks = (<span class="hljs-keyword">new</span> Throwable()).getStackTrace();        StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer(stacks[<span class="hljs-number">1</span>].getClassName());        sb.append(<span class="hljs-string">"."</span>);        sb.append(stacks[<span class="hljs-number">1</span>].getMethodName());        sb.append(<span class="hljs-string">"---"</span>);        sb.append(log);        errorPLog(sb.toString(), throwable);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dbLog</span><span class="hljs-params">(String log, Object... objects)</span> </span>&#123;        StackTraceElement[] stacks = (<span class="hljs-keyword">new</span> Throwable()).getStackTrace();        StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer(stacks[<span class="hljs-number">1</span>].getClassName());        sb.append(<span class="hljs-string">"."</span>);        sb.append(stacks[<span class="hljs-number">1</span>].getMethodName());        sb.append(<span class="hljs-string">"---"</span>);        sb.append(log);        <span class="hljs-keyword">if</span> (objects != <span class="hljs-keyword">null</span> &amp;&amp; objects.length &gt; <span class="hljs-number">0</span>) &#123;            sb.append(<span class="hljs-string">"; parameter["</span>);            Object[] var4 = objects;            <span class="hljs-keyword">int</span> var5 = objects.length;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> var6 = <span class="hljs-number">0</span>; var6 &lt; var5; ++var6) &#123;                Object obj = var4[var6];                sb.append(obj);                sb.append(<span class="hljs-string">","</span>);            &#125;            sb.delete(sb.length() - <span class="hljs-number">1</span>, sb.length());            sb.append(<span class="hljs-string">"]"</span>);        &#125;        DB_LOG.debug(sb.toString());    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">errorPLog</span><span class="hljs-params">(String log, Throwable throwable)</span> </span>&#123;        <span class="hljs-keyword">if</span> (throwable == <span class="hljs-keyword">null</span>) &#123;            ERROR_LOG.error(log);        &#125; <span class="hljs-keyword">else</span> &#123;            ERROR_LOG.error(log, throwable);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log</span><span class="hljs-params">(String name, String log)</span> </span>&#123;        StackTraceElement[] stacks = (<span class="hljs-keyword">new</span> Throwable()).getStackTrace();        StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer(stacks[<span class="hljs-number">1</span>].getClassName());        sb.append(<span class="hljs-string">"."</span>);        sb.append(stacks[<span class="hljs-number">1</span>].getMethodName());        sb.append(<span class="hljs-string">"---"</span>);        sb.append(log);        logByName(name, sb.toString(), <span class="hljs-string">"debug"</span>, (Throwable)<span class="hljs-keyword">null</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log</span><span class="hljs-params">(String name, String log, String loglevel)</span> </span>&#123;        StackTraceElement[] stacks = (<span class="hljs-keyword">new</span> Throwable()).getStackTrace();        StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer(stacks[<span class="hljs-number">1</span>].getClassName());        sb.append(<span class="hljs-string">"."</span>);        sb.append(stacks[<span class="hljs-number">1</span>].getMethodName());        sb.append(<span class="hljs-string">"---"</span>);        sb.append(log);        logByName(name, sb.toString(), loglevel, (Throwable)<span class="hljs-keyword">null</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log</span><span class="hljs-params">(String name, String log, String loglevel, Throwable throwable)</span> </span>&#123;        StackTraceElement[] stacks = (<span class="hljs-keyword">new</span> Throwable()).getStackTrace();        StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer(stacks[<span class="hljs-number">1</span>].getClassName());        sb.append(<span class="hljs-string">"."</span>);        sb.append(stacks[<span class="hljs-number">1</span>].getMethodName());        sb.append(<span class="hljs-string">"---"</span>);        sb.append(log);        logByName(name, sb.toString(), loglevel, throwable);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">logByName</span><span class="hljs-params">(String name, String log, String loglevel, Throwable throwable)</span> </span>&#123;        <span class="hljs-keyword">if</span> (name != <span class="hljs-keyword">null</span>) &#123;            StackTraceElement[] stacks = (<span class="hljs-keyword">new</span> Throwable()).getStackTrace();            StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer(stacks[<span class="hljs-number">1</span>].getClassName());            sb.append(<span class="hljs-string">"."</span>);            sb.append(stacks[<span class="hljs-number">1</span>].getMethodName());            sb.append(<span class="hljs-string">"---"</span>);            sb.append(log);            Logger logger = LoggerFactory.getLogger(name);            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">if</span> (throwable == <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-keyword">if</span> (<span class="hljs-string">"debug"</span>.equalsIgnoreCase(loglevel)) &#123;                        logger.debug(log);                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"info"</span>.equalsIgnoreCase(loglevel)) &#123;                        logger.info(log);                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"warn"</span>.equalsIgnoreCase(loglevel)) &#123;                        logger.warn(log);                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"error"</span>.equalsIgnoreCase(loglevel)) &#123;                        logger.error(log);                    &#125; <span class="hljs-keyword">else</span> &#123;                        logger.debug(log);                    &#125;                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"debug"</span>.equalsIgnoreCase(loglevel)) &#123;                    logger.debug(log, throwable);                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"info"</span>.equalsIgnoreCase(loglevel)) &#123;                    logger.info(log, throwable);                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"warn"</span>.equalsIgnoreCase(loglevel)) &#123;                    logger.warn(log, throwable);                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"error"</span>.equalsIgnoreCase(loglevel)) &#123;                    logger.error(log, throwable);                &#125; <span class="hljs-keyword">else</span> &#123;                    logger.debug(log, throwable);                &#125;            &#125; <span class="hljs-keyword">catch</span> (Exception var8) &#123;                ;            &#125;        &#125;    &#125;&#125;</code></pre><p>使用说明 : </p><pre><code class="hljs java"><span class="hljs-comment">// 由于该方案配置的Logger 为 sys.error...等开头，因此  直接使用loger的方式会在控制台输出，但不会被记录到日志文件之中,有且仅有通过Logit打印的日志才会被记录到文件中，此方案减少了每个类都创建loger的尴尬，非常方便</span>Logit.errorLog(<span class="hljs-string">"在线用户插入失败"</span> + <span class="hljs-string">" parms: "</span> + userOnline, <span class="hljs-keyword">new</span> Throwable(e));</code></pre><p>GITHUB链接：<a href="https://github.com/kkzhilu/volcat-server" target="_blank" rel="noopener">https://github.com/kkzhilu/volcat-server</a> (不同分支即对应不同日志框架)</p><p>项目暂时为私有, 如果需要参考请联系我</p>]]></content>
    
    
    <categories>
      
      <category>Java篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日志套餐篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java语法糖之泛型</title>
    <link href="/2023/09/12/Java%E8%AF%AD%E6%B3%95%E7%B3%96%E4%B9%8B%E6%B3%9B%E5%9E%8B/"/>
    <url>/2023/09/12/Java%E8%AF%AD%E6%B3%95%E7%B3%96%E4%B9%8B%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="聊一聊-JAVA-泛型中的通配符-T，E，K，V，？"><a href="#聊一聊-JAVA-泛型中的通配符-T，E，K，V，？" class="headerlink" title="聊一聊-JAVA 泛型中的通配符 T，E，K，V，？"></a>聊一聊-JAVA 泛型中的通配符 T，E，K，V，？</h1><blockquote><p>原文来源：掘金</p><p>原文链接：<a href="https://juejin.im/post/5d5789d26fb9a06ad0056bd9?utm_source=gold_browser_extension" target="_blank" rel="noopener">https://juejin.im/post/5d5789d26fb9a06ad0056bd9?utm_source=gold_browser_extension</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许开发者在编译时检测到非法的类型。</p><p>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p><h2 id="泛型带来的好处"><a href="#泛型带来的好处" class="headerlink" title="泛型带来的好处"></a>泛型带来的好处</h2><p>在没有泛型的情况的下，通过对类型 Object 的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是本身就是一个安全隐患。</p><p>那么泛型的好处就是在编译的时候能够检查类型安全，并且所有的强制转换都是自动和隐式的。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlmapperGeneric</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<span class="hljs-keyword">private</span> T t;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T t)</span> </span>&#123; <span class="hljs-keyword">this</span>.t = t; &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> t; &#125;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// do nothing</span>    &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">    * 不指定类型</span><span class="hljs-comment">    */</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">noSpecifyType</span><span class="hljs-params">()</span></span>&#123;    GlmapperGeneric glmapperGeneric = <span class="hljs-keyword">new</span> GlmapperGeneric();    glmapperGeneric.set(<span class="hljs-string">"test"</span>);    <span class="hljs-comment">// 需要强制类型转换</span>    String test = (String) glmapperGeneric.get();    System.out.println(test);  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">    * 指定类型</span><span class="hljs-comment">    */</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">specifyType</span><span class="hljs-params">()</span></span>&#123;    GlmapperGeneric&lt;String&gt; glmapperGeneric = <span class="hljs-keyword">new</span> GlmapperGeneric();    glmapperGeneric.set(<span class="hljs-string">"test"</span>);    <span class="hljs-comment">// 不需要强制类型转换</span>    String test = glmapperGeneric.get();    System.out.println(test);  &#125;&#125;</code></pre><p>上面这段代码中的 specifyType 方法中 省去了强制转换，可以在编译时候检查类型安全，可以用在类，方法，接口上。</p><h2 id="泛型中通配符"><a href="#泛型中通配符" class="headerlink" title="泛型中通配符"></a>泛型中通配符</h2><p>我们在定义泛型类，泛型方法，泛型接口的时候经常会碰见很多不同的通配符，比如 T，E，K，V 等等，这些通配符又都是什么意思呢？</p><h3 id="常用的-T，E，K，V，？"><a href="#常用的-T，E，K，V，？" class="headerlink" title="常用的 T，E，K，V，？"></a>常用的 T，E，K，V，？</h3><p>本质上这些个都是通配符，没啥区别，只不过是编码时的一种约定俗成的东西。比如上述代码中的 T ，我们可以换成 A-Z 之间的任何一个 字母都可以，并不会影响程序的正常运行，但是如果换成其他的字母代替 T ，在可读性上可能会弱一些。<strong>通常情况下，T，E，K，V，？ 是这样约定的：</strong></p><ul><li>？ 表示不确定的 java 类型</li><li>T (type) 表示具体的一个java类型</li><li>K V (key value) 分别代表java键值中的Key Value</li><li>E (element) 代表Element</li></ul><h3 id="？-无界通配符"><a href="#？-无界通配符" class="headerlink" title="？ 无界通配符"></a>？ <strong>无界通配符</strong></h3><p>先从一个小例子看起，原文在 <a href="https://link.juejin.im?target=https%3A%2F%2Fcodeday.me%2Fbug%2F20180113%2F116421.html">这里</a> 。</p><p>我有一个父类 Animal 和几个子类，如狗、猫等，现在我需要一个动物的列表，我的第一个想法是像这样的：</p><pre><code class="hljs xml">List<span class="hljs-tag">&lt;<span class="hljs-name">Animal</span>&gt;</span> listAnimals</code></pre><p>但是老板的想法确实这样的：</p><pre><code class="hljs capnproto"><span class="hljs-built_in">List</span>&lt;? <span class="hljs-keyword">extends</span> Animal&gt; listAnimals</code></pre><p>为什么要使用通配符而不是简单的泛型呢？通配符其实在声明局部变量时是没有什么意义的，但是当你为一个方法声明一个参数时，它是非常重要的。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countLegs</span> <span class="hljs-params">(List&lt;? extends Animal &gt; animals )</span> </span>&#123;    <span class="hljs-keyword">int</span> retVal = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> ( Animal animal : animals )    &#123;        retVal += animal.countLegs();    &#125;    <span class="hljs-keyword">return</span> retVal;&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countLegs1</span> <span class="hljs-params">(List&lt; Animal &gt; animals )</span></span>&#123;    <span class="hljs-keyword">int</span> retVal = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> ( Animal animal : animals )    &#123;        retVal += animal.countLegs();    &#125;    <span class="hljs-keyword">return</span> retVal;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    List&lt;Dog&gt; dogs = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(); <span class="hljs-comment">// 不会报错</span>    countLegs( dogs );<span class="hljs-comment">// 报错</span>    countLegs1(dogs);&#125;</code></pre><p><img src="/2023/09/12/Java%E8%AF%AD%E6%B3%95%E7%B3%96%E4%B9%8B%E6%B3%9B%E5%9E%8B/image-20201104235544754.png" srcset="/img/loading.gif" alt="image-20201104235544754"></p><p>所以，对于不确定或者不关心实际要操作的类型，可以使用无限制通配符（尖括号里一个问号，即 &lt;?&gt; ），表示可以持有任何类型。像 countLegs 方法中，限定了上届，但是不关心具体类型是什么，所以对于传入的 Animal 的所有子类都可以支持，并且不会报错。而 countLegs1 就不行。</p><h3 id="上界通配符-lt-extends-E-gt"><a href="#上界通配符-lt-extends-E-gt" class="headerlink" title="上界通配符 &lt; ? extends E&gt;"></a>上界通配符 &lt; ? extends E&gt;</h3><blockquote><p>上届：用 extends 关键字声明，表示参数化的类型可能是所指定的类型，或者是此类型的子类。</p></blockquote><p>在类型参数中使用 extends 表示这个泛型中的参数必须是 E 或者 E 的子类，这样有两个好处：</p><ul><li>如果传入的类型不是 E 或者 E 的子类，编译不成功</li><li>泛型中可以使用 E 的方法，要不然还得强转成 E 才能使用</li></ul><pre><code class="hljs aspectj"><span class="hljs-keyword">private</span> &lt;K <span class="hljs-keyword">extends</span> A, E <span class="hljs-keyword">extends</span> B&gt; <span class="hljs-function">E <span class="hljs-title">test</span><span class="hljs-params">(K arg1, E arg2)</span></span>&#123;    E result = arg2;    arg2.compareTo(arg1);    <span class="hljs-comment">//.....</span>    <span class="hljs-keyword">return</span> result;&#125;复制代码</code></pre><blockquote><p>类型参数列表中如果有多个类型参数上限，用逗号分开</p></blockquote><h3 id="下界通配符-lt-super-E-gt"><a href="#下界通配符-lt-super-E-gt" class="headerlink" title="下界通配符 &lt; ? super E&gt;"></a>下界通配符 &lt; ? super E&gt;</h3><blockquote><p>下界: 用 super 进行声明，表示参数化的类型可能是所指定的类型，或者是此类型的父类型，直至 Object</p></blockquote><p>在类型参数中使用 super 表示这个泛型中的参数必须是 E 或者 E 的父类。</p><pre><code class="hljs scala"><span class="hljs-keyword">private</span> &lt;<span class="hljs-type">T</span>&gt; void test(<span class="hljs-type">List</span>&lt;? <span class="hljs-keyword">super</span> <span class="hljs-type">T</span>&gt; dst, <span class="hljs-type">List</span>&lt;<span class="hljs-type">T</span>&gt; src)&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-type">T</span> t : src) &#123;        dst.add(t);    &#125;&#125;public static void main(<span class="hljs-type">String</span>[] args) &#123;    <span class="hljs-type">List</span>&lt;<span class="hljs-type">Dog</span>&gt; dogs = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();    <span class="hljs-type">List</span>&lt;<span class="hljs-type">Animal</span>&gt; animals = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();    <span class="hljs-keyword">new</span> <span class="hljs-type">Test3</span>().test(animals,dogs);&#125;<span class="hljs-comment">// Dog 是 Animal 的子类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;&#125;</code></pre><p>dst 类型 “大于等于” src 的类型，这里的“大于等于”是指 dst 表示的范围比 src 要大，因此装得下 dst 的容器也就能装 src 。</p><h3 id="？-和-T-的区别"><a href="#？-和-T-的区别" class="headerlink" title="？ 和 T 的区别"></a>？ 和 T 的区别</h3><p><img src="/2023/09/12/Java%E8%AF%AD%E6%B3%95%E7%B3%96%E4%B9%8B%E6%B3%9B%E5%9E%8B/image-20201104235617914.png" srcset="/img/loading.gif" alt="image-20201104235617914">？和 T 都表示不确定的类型，区别在于我们可以对 T 进行操作，但是对 ？ 不行，比如如下这种 ：</p><pre><code class="hljs gcode"><span class="hljs-comment">// 可以</span>T t = operate<span class="hljs-comment">()</span>;<span class="hljs-comment">// 不可以</span>？ car = operate<span class="hljs-comment">()</span>;</code></pre><p>简单总结下：</p><p>T 是一个 确定的 类型，通常用于泛型类和泛型方法的定义，？是一个 不确定 的类型，通常用于泛型方法的调用代码和形参，不能用于定义类和泛型方法。</p><h4 id="区别1：通过-T-来-确保-泛型参数的一致性"><a href="#区别1：通过-T-来-确保-泛型参数的一致性" class="headerlink" title="区别1：通过 T 来 确保 泛型参数的一致性"></a>区别1：通过 T 来 确保 泛型参数的一致性</h4><pre><code class="hljs typescript"><span class="hljs-comment">// 通过 T 来 确保 泛型参数的一致性</span><span class="hljs-keyword">public</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Number</span>&gt; <span class="hljs-built_in">void</span>test(List&lt;T&gt; dest, List&lt;T&gt; src)<span class="hljs-comment">//通配符是 不确定的，所以这个方法不能保证两个 List 具有相同的元素类型</span><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span>test(List&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Number</span>&gt; dest, List&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Number</span>&gt; src)复制代码</code></pre><p>像下面的代码中，约定的 T 是 Number 的子类才可以，但是申明时是用的 String ，所以就会飘红报错。</p><p><img src="/2023/09/12/Java%E8%AF%AD%E6%B3%95%E7%B3%96%E4%B9%8B%E6%B3%9B%E5%9E%8B/image-20201104235641462.png" srcset="/img/loading.gif" alt="image-20201104235641462"></p><p>不能保证两个 List 具有相同的元素类型的情况</p><pre><code class="hljs haxe">GlmapperGeneric&lt;<span class="hljs-keyword">String</span>&gt; glmapperGeneric = <span class="hljs-keyword">new</span> <span class="hljs-type">GlmapperGeneric</span>&lt;&gt;();List&lt;<span class="hljs-keyword">String</span>&gt; dest = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();List&lt;Number&gt; src = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();glmapperGeneric.testNon(dest,src);复制代码</code></pre><p>上面的代码在编译器并不会报错，但是当进入到 testNon 方法内部操作时（比如赋值），对于 dest 和 src 而言，就还是需要进行类型转换。</p><h4 id="区别2：类型参数可以多重限定而通配符不行"><a href="#区别2：类型参数可以多重限定而通配符不行" class="headerlink" title="区别2：类型参数可以多重限定而通配符不行"></a>区别2：类型参数可以多重限定而通配符不行</h4><p><img src="/2023/09/12/Java%E8%AF%AD%E6%B3%95%E7%B3%96%E4%B9%8B%E6%B3%9B%E5%9E%8B/image-20201104235710004.png" srcset="/img/loading.gif" alt="image-20201104235710004"></p><p>使用 &amp; 符号设定多重边界（Multi Bounds)，指定泛型类型 T 必须是 MultiLimitInterfaceA 和 MultiLimitInterfaceB 的共有子类型，此时变量 t 就具有了所有限定的方法和属性。对于通配符来说，因为它不是一个确定的类型，所以不能进行多重限定。</p><h4 id="区别3：通配符可以使用超类限定而类型参数不行"><a href="#区别3：通配符可以使用超类限定而类型参数不行" class="headerlink" title="区别3：通配符可以使用超类限定而类型参数不行"></a>区别3：通配符可以使用超类限定而类型参数不行</h4><p>类型参数 T 只具有 一种 类型限定方式：</p><pre><code class="hljs actionscript">T <span class="hljs-keyword">extends</span> A</code></pre><p>但是通配符 ? 可以进行 两种限定：</p><pre><code class="hljs actionscript">? <span class="hljs-keyword">extends</span> A? <span class="hljs-keyword">super</span> A</code></pre><h2 id="Class-lt-T-gt-和-Class-lt-gt-区别"><a href="#Class-lt-T-gt-和-Class-lt-gt-区别" class="headerlink" title="Class&lt;T&gt; 和 Class&lt;?&gt; 区别"></a><code>Class&lt;T&gt;</code> 和 <code>Class&lt;?&gt;</code> 区别</h2><p>前面介绍了 ？ 和 T 的区别，那么对于，<code>Class&lt;T&gt;</code> 和 <code>&lt;Class&lt;?&gt;</code> 又有什么区别呢？<br><code>Class&lt;T&gt;</code> 和 <code>Class&lt;?&gt;</code></p><p>最常见的是在反射场景下的使用，这里以用一段发射的代码来说明下。</p><pre><code class="hljs reasonml"><span class="hljs-comment">// 通过反射的方式生成  multiLimit </span><span class="hljs-comment">// 对象，这里比较明显的是，我们需要使用强制类型转换</span>MultiLimit multiLimit = (MultiLimit)<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Class</span>.</span></span>for<span class="hljs-constructor">Name(<span class="hljs-string">"com.glmapper.bridge.boot.generic.MultiLimit"</span>)</span>.<span class="hljs-keyword">new</span><span class="hljs-constructor">Instance()</span>;复制代码</code></pre><p>对于上述代码，在运行期，如果反射的类型不是 MultiLimit 类，那么一定会报 java.lang.ClassCastException 错误。</p><p>对于这种情况，则可以使用下面的代码来代替，使得在在编译期就能直接 检查到类型的问题：</p><p><img src="/2023/09/12/Java%E8%AF%AD%E6%B3%95%E7%B3%96%E4%B9%8B%E6%B3%9B%E5%9E%8B/image-20201104235733862.png" srcset="/img/loading.gif" alt="image-20201104235733862"></p><p><code>Class&lt;T&gt;</code> 在实例化的时候，T 要替换成具体类。<code>Class&lt;?&gt;</code> 它是个通配泛型，? 可以代表任何类型，所以主要用于声明时的限制情况。比如，我们可以这样做申明：</p><pre><code class="hljs delphi"><span class="hljs-comment">// 可以</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">Class</span>&lt;?&gt; clazz;<span class="hljs-comment">// 不可以，因为 T 需要指定类型</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">Class</span>&lt;T&gt; clazzT;</code></pre><p>所以当不知道定声明什么类型的 Class 的时候可以定义一 个Class&lt;?&gt;。</p><p><img src="/2023/09/12/Java%E8%AF%AD%E6%B3%95%E7%B3%96%E4%B9%8B%E6%B3%9B%E5%9E%8B/image-20201104235755696.png" srcset="/img/loading.gif" alt="image-20201104235755696"></p><p>那如果也想 <code>public Class&lt;T&gt; clazzT;</code> 这样的话，就必须让当前的类也指定 T ，</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test3</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-keyword">public</span> Class&lt;?&gt; clazz;    <span class="hljs-comment">// 不会报错</span>    <span class="hljs-keyword">public</span> Class&lt;T&gt; clazzT;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java语法糖之泛型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RocketMQ-消息队列篇</title>
    <link href="/2023/09/12/RocketMQ-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AF%87/"/>
    <url>/2023/09/12/RocketMQ-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="RocketMQ-消息队列篇"><a href="#RocketMQ-消息队列篇" class="headerlink" title="RocketMQ-消息队列篇"></a>RocketMQ-消息队列篇</h1><h2 id="Windows安装部署"><a href="#Windows安装部署" class="headerlink" title="Windows安装部署"></a>Windows安装部署</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a><strong>下载</strong></h3><p>地址：[<a href="https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.5.2/rocketmq-all-4.5.2-bin-release.zip]" target="_blank" rel="noopener">https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.5.2/rocketmq-all-4.5.2-bin-release.zip]</a></p><p>选择‘Binary’进行下载</p><p>解压已下载工程</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><blockquote><p>新增系统变量<br>ROCKETMQ_HOME  -&gt;  F:\RocketMQ\rocketmq-4.5.2</p><p>JAVA_HOME             -&gt;  F:\Java_JDK\JDK1.8</p><p>Path 系统变量新增：Maven/bin目录</p><p>PS：RocketMQ 消息存储在C:\Users\Administrator\store store目录中  <code>文件占用较大，注意删除不必要的内容</code></p></blockquote><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><blockquote><p>start mqnamesrv.cmd</p><p>start mqbroker.cmd -n 127.0.0.1:9876 autoCreateTopicEnable=true</p></blockquote><h3 id="Rocket集成可视化监控插件"><a href="#Rocket集成可视化监控插件" class="headerlink" title="Rocket集成可视化监控插件"></a>Rocket集成可视化监控插件</h3><ol><li><p>任意目录（拉取项目，随便哪里都行）git clone <a href="https://github.com/apache/rocketmq-externals.git" target="_blank" rel="noopener">https://github.com/apache/rocketmq-externals.git</a></p></li><li><p>进入‘rocketmq-externals\rocketmq-console\src\main\resources’文件夹，打开‘application.properties’进行配置</p></li><li><p>其实就是一个SpringBoot服务，确定好端口，别重复即可</p><p>server.port=8100</p><p>rocketmq.config.namesrvAddr=127.0.0.1:9876</p></li></ol><ol start="4"><li><p>进入‘\rocketmq-externals\rocketmq-console’文件夹</p><p>执行‘mvn clean package -Dmaven.test.skip=true’，编译生成target</p><p>java -jar rocketmq-console-ng-1.0.1.jar</p></li><li><p>根据配置地址访问： <a href="http://127.0.0.1:8100" target="_blank" rel="noopener">http://127.0.0.1:8100</a></p></li></ol><pre><code class="hljs Rocket可视化监控插件">![1569294651705](RocketMQ-消息队列篇&#x2F;1569294651705.png)&gt; 4.5.2 版本 支持自动创建Topic&gt;&gt; 4.3.0 版本 必须通过监控程序配置Topic，否则执行程序报错，没有此路由### SpringBoot集成 RocketMQ&#96;&#96;&#96;xml&lt;!--RocketMQ--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.rocketmq&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;rocketmq-client&lt;&#x2F;artifactId&gt;    &lt;version&gt;4.5.2&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre><h2 id="RocketMQ基本概念"><a href="#RocketMQ基本概念" class="headerlink" title="RocketMQ基本概念"></a>RocketMQ基本概念</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>基于RocketMQ的分布式系统，一般可以分为四个集群：Name server、broker、producer、consumer</p><ol><li><p>name server</p><ul><li><p>提供轻量级的服务发现和路由服务；</p></li><li><p>每个节点都存放了全部的路由信息和对应的读写服务；</p></li><li><p>存储支持水平扩展</p></li></ul></li><li><p>broker</p><ul><li>提供满足TOPIC和QUEUE机制的消息存储服务；</li><li>有推和拉两种模式；</li><li>通过2或3拷贝实现高可用；</li><li>提供上亿消息的堆积能力；</li><li>提供故障恢复、统计功能和告警功能；</li></ul></li><li><p>producer</p><ul><li>支持分布式部署，通过负载平衡模块给broker发消息</li><li>支持快速失败</li><li>低延迟</li></ul></li><li><p>consumer</p><ol><li>支持推和拉两种模式</li><li>支持集群消费和广播消费</li></ol></li></ol><h3 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h3><h4 id="Name-Server"><a href="#Name-Server" class="headerlink" title="Name Server"></a>Name Server</h4><blockquote><p>提供Broker管理；Routing管理（路由管理）</p></blockquote><p>NameServer，很多时候称为命名发现服务，其在RocketMQ中起着中转承接的作用，是一个无状态的服务，多个NameServer之间不通信。任何Producer，Consumer，Broker与所有NameServer通信，向NameServer请求或者发送数据。而且都是单向的，Producer和Consumer请求数据，Broker发送数据。正是因为这种单向的通信，RocketMQ水平扩容变得很容易</p><ul><li>提供轻量级的服务发现和路由服务；</li><li>每个节点都存放了全部的路由信息和对应的读写服务；</li><li>存储支持水平扩展</li></ul><p>总结：相比于ZooKeeper提供的分布式锁，发布和订阅，数据一致性，选举等，在RocketMQ是不适用的，因此重写了一套更加轻量级的发现服务，主要用以存储 Broker相关信息以及当前Broker上的topic信息，路由信息等</p><h4 id="Broker-Server"><a href="#Broker-Server" class="headerlink" title="Broker Server"></a>Broker Server</h4><blockquote><p>提供Remoting Module、客户端管理、存储服务、HA服务(主从)、索引服务</p></blockquote><ul><li>提供满足TOPIC和QUEUE机制的消息存储服务；</li><li>有推和拉两种模式；</li><li>通过2或3拷贝实现高可用；</li><li>提供上亿消息的堆积能力；</li><li>提供故障恢复、统计功能和告警功能；</li></ul><h4 id="producer"><a href="#producer" class="headerlink" title="producer"></a>producer</h4><ul><li>支持分布式部署，通过负载平衡模块给broker发消息</li><li>支持快速失败</li><li>低延迟</li></ul><h4 id="consumer"><a href="#consumer" class="headerlink" title="consumer"></a>consumer</h4><ul><li>支持推和拉两种模式</li><li>支持集群消费和广播消费</li></ul><h3 id="核心角色介绍"><a href="#核心角色介绍" class="headerlink" title="核心角色介绍"></a>核心角色介绍</h3><h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><p>生产者发送业务系统产生的消息给broker, RocketMQ提供了多种发送方式：同步的、异步的、单向的</p><h4 id="生产者组"><a href="#生产者组" class="headerlink" title="生产者组"></a>生产者组</h4><p>具有相同角色的生产者被分到一组, 假如原始的生产者在事务后崩溃，broker会联系 同一生产者组中的不同生产者实例，继续提交或回滚事务</p><h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><p>一个消费者从broker拉取信息，并将信息返还给应用。为了我们应用的正确性，提供了两种消费者类型：</p><p>拉式消费者：拉式消费者从broker拉取消息，一旦一批消息被拉取，用户应用系统将发起消费过程。</p><p>推式消费者：推式消费者，从另一方面讲，囊括了消息的拉取、消费过程，并保持了内部的其他工作，留下了一个回调 接口给终端用户去实现，实现在消息到达时要执行的内容。</p><h4 id="消费者组"><a href="#消费者组" class="headerlink" title="消费者组"></a>消费者组</h4><p>具有相同角色的消费者被组在一起，称为消费者组，它完成了负载均衡和容错的目标</p><p>一个消费组中的消费者实例必须有确定的相同的订阅topic</p><h4 id="Topic（主题）"><a href="#Topic（主题）" class="headerlink" title="Topic（主题）"></a>Topic（主题）</h4><p>Topic是一个消息的目录，在这个目录中，生产者传送消息，消费者拉取消息，可以多个消费者订阅同一个topic，一个生产者也可以发送多个topic</p><p>PS：RocketMQ 基于发布订阅模式，发布订阅的核心即 Topic 主题</p><h4 id="Message（消息）"><a href="#Message（消息）" class="headerlink" title="Message（消息）"></a>Message（消息）</h4><p>消息是被传递的信息。一个消息必须有一个Topic，它可以理解为信件上的地址。一个消息也可以有一个可选的tag，和额外的key-value对。 例如：你可以设置业务中的键到你的消息中，在broker服务中查找消息，以便在开发期间诊断问题</p><h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>Topic被分割成一个或多个消息队列。队列分为3中角色：异步主、同步主、从。如果你不能容忍消息丢失，我们建议你部署同步主，并加一个从队列。 如果你容忍丢失，但你希望队列总是可用，你可以部署异步主和从队列。如果你想最简单，你只需要一个异步主，不需要从队列。 消息保存磁盘的方式也有两种，推荐使用的是异步保存，同步保存是昂贵的并会导致性能损失，如果你想要可靠性，我们推荐你使用同步主+从的方式。</p><h4 id="Tag（标签）"><a href="#Tag（标签）" class="headerlink" title="Tag（标签）"></a>Tag（标签）</h4><p>标签，用另外一个词来说，就是子主题，为用户提供额外的灵活性。具有相同Topic的消息可以有不同的tag。</p><h4 id="Broker（队列）"><a href="#Broker（队列）" class="headerlink" title="Broker（队列）"></a>Broker（队列）</h4><p>Broker是RocketMQ的一个主要组件，它接收生产者发送的消息，存储它们并准备处理消费者的拉取请求。它也存储消息相关的元数据， 包括消费组，消费成功的偏移量，主题、队列的信息。</p><h4 id="名称服务"><a href="#名称服务" class="headerlink" title="名称服务"></a>名称服务</h4><p>名称服务主要提供路由信息。生产者/消费者客户端寻找topic，并找到通信的队列列表。</p><h4 id="消息的顺序"><a href="#消息的顺序" class="headerlink" title="消息的顺序"></a>消息的顺序</h4><p>当<code>DefaultMQPushConsumer</code>被使用，你就要决定消费消息时，是顺序消费还是同时消费</p><ul><li>顺序消费</li></ul><p>　　顺序消费消息的意思是 消息将按照生产者发送到队列时的顺序被消费掉。如果你被强制要求使用全局的顺序，你要确保你的topic只有一个消息队列。</p><p>如果指定顺序消费，消息被同时消费的数量就是订阅这个topic的消费组的数量。</p><ul><li>同时消费</li></ul><p>　　当同时消费消息时，消息同时消费的最大数量取决于消费客户端指定的线程池的大小。</p><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><h5 id="Producer最佳实践"><a href="#Producer最佳实践" class="headerlink" title="Producer最佳实践"></a><strong>Producer最佳实践</strong></h5><ol><li><p>一个应用尽可能用一个 Topic，消息子类型用 tags 来标识，tags 可以由应用自由设置。<strong>只有发送消息设置了tags，消费方在订阅消息时，才可以利用 tags 在 broker 做消息过滤。</strong></p></li><li><p>每个消息在业务层面的唯一标识码，要设置到 keys 字段，方便将来定位消息丢失问题。由于是哈希索引，请务必保证 key 尽可能唯一，这样可以避免潜在的哈希冲突。</p><p>消息发送成功或者失败，要打印消息日志，务必要打印 sendresult 和 key 字段。</p></li><li><p><strong>对于消息不可丢失应用，务必要有消息重发机制。例如：消息发送失败，存储到数据库，能有定时程序尝试重发或者人工触发重发。</strong></p></li><li><p>某些应用如果不关注消息是否发送成功，请直接使用sendOneWay方法发送消息。</p></li></ol><h5 id="Consumer最佳实践"><a href="#Consumer最佳实践" class="headerlink" title="Consumer最佳实践"></a><strong>Consumer最佳实践</strong></h5><ol><li><strong>消费过程要做到幂等（即消费端去重）</strong></li><li>尽量使用批量方式消费方式，可以很大程度上提高消费吞吐量。</li><li>优化每条消息消费过程</li></ol><h2 id="MQ核心问题"><a href="#MQ核心问题" class="headerlink" title="MQ核心问题"></a>MQ核心问题</h2><h3 id="1-消息队列适合解决的问题"><a href="#1-消息队列适合解决的问题" class="headerlink" title="1.消息队列适合解决的问题"></a>1.消息队列适合解决的问题</h3><p>解决的核心问题主要是：异步、解耦、削峰</p><p>但是引入消息队列也会有很多额外的问题，比如系统复杂性会大大增加，同时需要解决重复下发，重复消费，消费顺序，消息丢失，重试机制等等问题，因此不能滥用，合适的场景用合适的技术</p><h3 id="2-消息模型：主题和队列的区别"><a href="#2-消息模型：主题和队列的区别" class="headerlink" title="2.消息模型：主题和队列的区别"></a>2.消息模型：主题和队列的区别</h3><p><strong><em>一、消息队列的演进</em></strong></p><p><strong>1、初始阶段</strong></p><p>最初的消息队列，就是一个严格意义上的队列。队列是一种数据结构，先进先出，在消息入队出队过程中，保证这些消息严格有序。<strong>早期的消息队列就是按照“队列”的数据结构设计的</strong>。</p><p>队列模型：</p><p><img src="/2023/09/12/RocketMQ-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AF%87/1513968-20190825142246523-84190382.jpg" srcset="/img/loading.gif" alt="img"></p><p>生产者（Producer）发消息就是入队操作，消费者（Consumer）收消息就是出队也就是删除操作，服务端存放消息的容器自然就称为“队列”。</p><ul><li>如果有多个<strong>生产者往同一个队列里面发送</strong>消息，这个队列中可以消费到的消息，就是这些生产者生产的所有消息的合集。消息的顺序就是这些生产者<strong>发送消息的自然顺序</strong>。</li><li>如果有<strong>多个消费者接收同一个队列</strong>的消息，这些消费者之间实际上是<strong>竞争的关系</strong>，每个消费者只能收到队列中的一部分消息，也就是说任何<strong>一条消息只能被其中的一个消费者收到</strong>。</li></ul><p><strong>2、发布 - 订阅模型阶段</strong></p><p>如果需要将<strong>一份消息数据分发给多个消费者</strong>，要求<strong>每个消费者都能收到全量的消息</strong>，例如，对于一份订单数据，风控系统、分析系统、支付系统等都需要接收消息。</p><p>这个时候，单个队列就满足不了需求，一个可行的解决方式是，为<strong>每个消费者创建一个单独的队列，让生产者发送多份</strong>。但是同样的一份消息数据被复制到多个队列中会<strong>浪费资源</strong>，更重要的是，生产者必须知道有多少个消费者。为每个消费者单独发送一份消息，这实际上<strong>违背了消息队列“解耦”</strong>这个设计初衷。</p><p>为了解决这个问题，演化出了另外一种消息模型：<strong>发布 - 订阅模型</strong>（Publish-Subscribe Pattern）</p><p><img src="/2023/09/12/RocketMQ-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AF%87/1513968-20190825143621470-571138599.jpg" srcset="/img/loading.gif" alt="img"></p><p>消息的发送方称为发布者（Publisher），消息的接收方称为订阅者（Subscriber），服务端存放消息的容器称为主题（Topic）。</p><ul><li>发布者将消息发送到主题中，订阅者在接收消息之前需要先“订阅主题”。</li><li>每份订阅中，订阅者都可以接收到主题的所有消息。</li></ul><p><strong>3、总结：</strong></p><ul><li>在很长的一段时间，队列模式和发布 - 订阅模式是并存的。</li><li>有些消息队列同时支持这两种消息模型，比如 ActiveMQ。</li><li>对比这两种模型，生产者就是发布者，消费者就是订阅者，队列就是主题，并没有本质的区别。它们最大的区别是：<strong>一份消息数据能不能被消费多次的问题</strong>。</li><li>实际上，在这种发布 - 订阅模型中，如果只有一个订阅者，那它和队列模型就基本是一样的了。也就是说，发布 - 订阅模型在功能层面上是可以兼容队列模型的。</li></ul><p><strong><em>二、RabbitMQ 的消息模型</em></strong></p><p>少数依然坚持<strong>使用队列模型</strong>的产品之一。</p><p>RabbitMQ 使用 <strong>Exchange 模块解决多个消费者的问题</strong>。Exchange 位于生产者和队列之间，生产者并不关心将消息发送给哪个队列，而是<strong>将消息发送给 Exchange</strong>，由 Exchange 上<strong>配置的策略</strong>来决定将消息投递到哪些队列中。</p><p><img src="/2023/09/12/RocketMQ-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AF%87/1513968-20190825145306466-1941619714.jpg" srcset="/img/loading.gif" alt="img"></p><ul><li>同一份消息如果需要被多个消费者来消费，需要<strong>配置 Exchange 将消息发送到多个队列</strong>，每个队列中都<strong>存放一份完整的消息数据</strong>，可以为一个消费者提供消费服务。</li></ul><p><strong><em>三、RocketMQ 的消息模型</em></strong></p><p>RocketMQ 使用的消息模型是标准的<strong>发布 - 订阅模型</strong>。在 RocketMQ 也有队列（Queue）这个概念。</p><p><strong>消息队列的消费机制：</strong></p><p>几乎所有的消息队列产品都使用一种非常朴素的“<strong>请求 - 确认”机制</strong>，确保消息不会在传递过程中由于网络或服务器故障丢失。</p><p>在生产端，生产者先将消息发送给服务端，也就是 Broker，服务端在收到消息并将消息写入主题或者队列中后，会<strong>给生产者发送确认的响应</strong>。如果生产者没有收到服务端的确认或者收到失败的响应，则会<strong>重新发送消息</strong>。</p><p>在消费端，消费者在收到消息并完成自己的消费业务逻辑（比如，将数据保存到数据库中）后，也会<strong>给服务端发送消费成功的确认</strong>，服务端只有收到消费确认后，才认为一条消息被成功消费，否则它会给消费者<strong>重新发送这条消息</strong>，直到收到对应的消费成功确认。</p><p>这个确认机制很好地<strong>保证了消息传递过程中的可靠性</strong>，但是，引入这个机制在消费端带来了一个问题：<strong>为了确保消息的有序性，在某一条消息被成功消费之前，下一条消息是不能被消费的</strong>，也就是说，每个主题在任意时刻，<strong>至多只能有一个消费者实例在进行消费</strong>，那就<strong>没法通过水平扩展消费者的数量来提升消费端总体的消费性能</strong>。</p><p><strong>为了解决这个问题，RocketMQ 在主题下面增加了队列的概念：</strong></p><p><strong><img src="/2023/09/12/RocketMQ-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AF%87/1513968-20190825151749079-2100411321.jpg" srcset="/img/loading.gif" alt="img"></strong></p><ul><li><strong>每个主题包含多个队列</strong>，通过多个队列来实现多实例并行生产和消费。需要注意的是，RocketMQ 只在队列上保证消息的有序性，主题层面是无法保证消息的严格顺序的。</li><li><strong>生产者会往所有队列发消息</strong>，但不是“同一条消息每个队列都发一次”，<strong>每条消息只会往某个队列里面发送一次</strong>。</li><li><strong>一个消费组，每个队列上只能串行消费，多个队列加一起就是并行消费了</strong>，并行度就是队列数量，队列数量越多并行度越大，所以水平扩展可以<strong>提升消费性能。</strong></li><li><strong>每队列每消费组维护一个消费位置（offset）</strong>，记录这个消费组在这个队列上消费到哪儿了。</li><li>订阅者是通过消费组（Consumer Group）来体现的。<strong>每个消费组都消费主题中一份完整的消息</strong>，不同消费组之间消费进度彼此不受影响，也就是说，一条消息被 Consumer Group1 消费过，也会再给 Consumer Group2 消费。</li><li><strong>消费组中包含多个消费者，同一个组内的消费者是竞争消费的关系</strong>，每个消费者负责消费组内的一部分消息。如果一条消息被消费者 Consumer1 消费了，那同组的其他消费者就不会再收到这条消息。</li><li>由于消息需要被不同的组进行多次消费，所以消费完的消息并不会立即被删除，这就需要 RocketMQ <strong>为每个消费组在每个队列上维护一个消费位置（Consumer Offset）</strong>，这个位置之前的消息都被消费过，之后的消息都没有被消费过，每成功消费一条消息，消费位置就加一。我们在使用消息队列的时候<strong>，丢消息的原因大多是由于消费位置处理不当导致的</strong>。</li></ul><p><strong><em>四、Kafka 的消息模型</em></strong></p><p>Kafka 的消息模型和 RocketMQ 是完全一样的，唯一的区别是，在 Kafka 中，队列这个概念的名称不一样，<strong>Kafka 中对应的名称是“分区（Partition）”</strong>，含义和功能是没有任何区别的。</p><p><strong><em>五、总结</em></strong></p><ul><li>常用的消息队列中，<strong>RabbitMQ 采用的是队列模型</strong>，但是它一样可以实现发布 - 订阅的功能。<strong>RocketMQ 和 Kafka 采用的是发布 - 订阅模型</strong>，并且二者的消息模型是基本一致的。</li></ul><h3 id="3-消息丢失怎么办-如何保证消息的可靠性传输"><a href="#3-消息丢失怎么办-如何保证消息的可靠性传输" class="headerlink" title="3.消息丢失怎么办? 如何保证消息的可靠性传输?"></a>3.消息丢失怎么办? 如何保证消息的可靠性传输?</h3><p><strong>首先如何验证消息是否丢失？</strong></p><ul><li>如果是 IT 基础设施比较完善的公司，一般都有分布式链路追踪系统，使用类似的追踪系统可以很方便地追踪每一条消息。</li><li>如果没有这样的追踪系统，我们可以利用消息队列的有序性来验证是否有消息丢失</li></ul><p>即保证消息消费顺序的情况下，根据消息的序号，在消费段判断是否连续</p><p>解决方案：</p><p><strong>消息从生产到消费的过程中，可以划分三个阶段：</strong></p><p><img src="/2023/09/12/RocketMQ-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AF%87/1513968-20190826173227384-497794758.jpg" srcset="/img/loading.gif" alt="img"></p><p><strong>1、生产阶段</strong></p><p>消息队列通过最常用的<strong>请求确认机制</strong>，来保证消息的可靠传递：当你代码调用发消息方法时，消息队列客户端会把消息发送到Broker，Broker收到消息后，会给客户端返回一个确认响应，表明消息已收到。客户端收到响应后，完成了一次正常消息的发送。</p><p>有些消息队列在长时间没收到发送确认响应后，会自动重试，如果重试失败，就会以返回值或者异常的方式告知用户。在编写发送消息的代码时，需要注意，<strong>正确处理返回值或者捕获异常</strong>，就可以保证这个阶段的消息不会丢失。</p><p><strong>同步发送时，只要注意捕获异常即可。</strong></p><p><strong>异步发送时，则需要在回调方法里进行检查。这个地方需要特别注意，很多丢消息的原因就是，我们使用了异步发送，却没有在回调中检查发送结果。</strong></p><p><strong>2、存储阶段</strong></p><p>在存储阶段正常情况下，只要Broker在正常运行，就不会出现丢消息的问题；但是如果Broker出现故障，比如进程死掉或者服务器宕机，还是可能会丢失消息的。</p><p>如果对消息的可靠性要求非常高，可以通过配置Broker参数来避免因为宕机丢消息：</p><ul><li>对于单个节点的 Broker，需要配置 Broker 参数，<strong>在收到消息后，将消息写入磁盘后再给 Producer 返回确认响应</strong>，这样即使发生宕机，由于消息已经被写入磁盘，就不会丢失消息，恢复后还可以继续消费。例如，在 RocketMQ 中，需要将刷盘方式 flushDiskType 配置为 SYNC_FLUSH 同步刷盘。</li><li>对于 Broker 是由多个节点组成的集群，需要将 Broker 集群配置成：<strong>至少将消息发送到 2 个以上的节点，再给客户端回复发送确认响应</strong>。这样当某个 Broker 宕机时，其他的 Broker 可以替代宕机的 Broker，也不会发生消息丢失。</li></ul><p><strong>3、消息阶段</strong></p><p>消费阶段采用和生产阶段类似的<strong>确认机制</strong>来保证消息的可靠传递，客户端从 Broker 拉取消息后，执行用户的消费业务逻辑，<strong>成功后，才会给 Broker 发送消费确认响应</strong>。如果 Broker 没有收到消费确认响应，下次拉消息的时候还会返回同一条消息，确保消息不会在网络传输过程中丢失，也不会因为客户端在执行消费逻辑中出错导致丢失。</p><p>在编写消费代码时需要注意的是：不要在收到消息后就立即发送消费确认，而是应该<strong>在执行完所有消费业务逻辑之后，再发送消费确认</strong>。</p><h3 id="4-处理消费过程中的重复消息"><a href="#4-处理消费过程中的重复消息" class="headerlink" title="4.处理消费过程中的重复消息"></a>4.处理消费过程中的重复消息</h3><p>在消息传递过程中，如果出现<strong>传递失败</strong>的情况，发送方会<strong>执行重试</strong>，重试过程中就有可能<strong>产生重复的消息</strong>。如果没有对重复消息进行处理，就可能导致系统的数据出现错误。</p><p>比如，一个消费订单消息，统计下单金额的微服务，如果没有正确处理重复消息，那就会出现重复统计，导致统计结果错误。</p><p><strong><em>一、消息重复的情况必然存在</em></strong></p><p>在MQTT协议中，给出了三种传递消息时能够提供的服务质量标准：</p><ul><li><strong>At most once</strong>：至多一次。最多会被送达一次，也就是说没有消息可靠性保证，允许丢消息。一般都是一些对消息可靠性要求不高的监控场景使用，比如每分钟上报一次机房温度数据，可以接受数据少量丢失。</li><li><strong>At least once</strong>：至少一次。至少会被送达一次，也就是说<strong>不允许丢消息</strong>，但是<strong>允许有少量重复消息出现</strong>。</li><li><strong>Exactly once</strong>：恰好一次。只会被送达一次，不允许丢失也不允许重复，这个是最高等级。</li></ul><p>这个服务质量标准不仅适用于 MQTT，对所有的消息队列都是适用的。常用的<strong>绝大部分消息队列提供的服务质量都是 At least once，包括 RocketMQ、RabbitMQ 和 Kafka</strong> 。也就是说，消息队列很难保证消息不重复。</p><p>注意：Kafka 支持的“Exactly once”和我们刚刚提到的消息传递的服务质量标准“Exactly once”是不一样的，它是 Kafka 提供的另外一个特性，Kafka 中支持的事务也和我们通常意义理解的事务有一定的差异。在 Kafka 中，事务和 Excactly once 主要是为了配合流计算使用的特性。</p><p><strong><em>二、用幂等性解决重复消息问题</em></strong></p><p>幂等本来是一个数学上的概念，它的定义是：如果一个函数f(x)满足：f(f(x)) = f(x)，则函数f(x)满足米幂等性。扩展到计算机领域，被用来描述一个操作、方法或者服务。</p><ul><li>一个幂等操作的特点是，其<strong>任意多次执行所产生的影响均与一次执行的影响相同</strong>。</li><li>一个幂等方法，使用同样的参数，对它进行多次调用和一次调用，对系统产生的影响是一样的。所以不用担心重复执行会对系统造成任何改变。</li></ul><p>举例：</p><p>1、在不考虑并发的情况下，“将账户 X 的余额设置为 100 元”，执行一次后对系统的影响是，账户 X 的余额变成了 100 元。只要提供的参数 100 元不变，那即使再执行多少次，账户 X 的余额始终都是 100 元，不会变化，这个操作就是一个幂等的操作。</p><p>2、“将账户 X 的余额加 100 元”，这个操作它就不是幂等的，每执行一次，账户余额就会增加 100 元，执行多次和执行一次对系统的影响（也就是账户的余额）是不一样的。</p><p>如果消费消息的业务逻辑具备幂等性，那就不用担心消息重复的问题，因为同一条消息，<strong>消费一次和消费多次对系统的影响是完全一样的</strong>。消费多次等于消费一次。从对系统的影响结果来说：At least once + 幂等消费 = Exactly once。</p><p>实现幂等操作最好的方式是，<strong>从业务逻辑设计上入手，将消费的业务逻辑设计成具备幂等性的操作</strong>。</p><p><strong>常用的设计幂等操作的方法</strong>：</p><p>（1）利用<strong>数据库的唯一约束</strong>实现幂等</p><p>上面提到的那个不具备幂等特性的转账的例子：将账户 X 的余额加 100 元。在这个例子中，我们可以通过改造业务逻辑，让它具备幂等性。</p><p>首先，我们可以限定，对于每个转账单每个账户只可以执行一次变更操作，在分布式系统中，这个限制实现的方法非常多，最简单的是我们在数据库中建一张转账流水表，这个表有三个字段：转账单 ID、账户 ID 和变更金额，然后给转账单 ID 和账户 ID 这两个字段联合起来创建一个唯一约束，这样对于相同的转账单 ID 和账户 ID，表里至多只能存在一条记录。</p><p>这样，我们消费消息的逻辑可以变为：“在转账流水表中<strong>增加一条转账记录，然后再根据转账记录，异步操作更新用户余额即可</strong>。”在转账流水表增加一条转账记录这个操作中，由于我们在这个表中预先定义了“账户 ID 转账单 ID”的唯一约束，<strong>对于同一个转账单同一个账户只能插入一条记录，后续重复的插入操作都会失败</strong>，这样就实现了一个幂等的操作。</p><p>基于这个思路，不光是可以使用关系型数据库，只要是支持类似“INSERT IF NOT EXIST”语义的存储类系统都可以用于实现幂等，比如，你可以用 Redis 的 SETNX 命令来替代数据库中的唯一约束，来实现幂等消费。</p><p>（2）为更新的数据设置前置条件</p><p>给数据变更设置一个前置条件，如果满足条件就更新数据，否则拒绝更新数据，在更新数据的时候，同时变更前置条件中需要判断的数据。这样，重复执行这个操作时，由于第一次更新数据的时候已经变更了前置条件中需要判断的数据，不满足前置条件，则不会重复执行更新数据操作。</p><p>比如，“将账户 X 的余额增加 100 元”这个操作并不满足幂等性，我们可以把这个操作加上一个前置条件，变为：“如果账户 X 当前的余额为 500 元，将余额加 100 元”，这个操作就具备了幂等性。对应到消息队列中的使用时，可以在发消息时在消息体中带上当前的余额，在消费的时候进行判断数据库中，当前余额是否与消息中的余额相等，只有相等才执行变更操作。</p><p>但是，如果我们要更新的数据不是数值，或者我们要做一个比较复杂的更新操作怎么办？用什么作为前置判断条件呢？更加通用的方法是，给你的<strong>数据增加一个版本号属性</strong>，每次更数据前，<strong>比较当前数据的版本号是否和消息中的版本号一致</strong>，如果不一致就拒绝更新数据，<strong>更新数据的同时将版本号 +1</strong>，一样可以实现幂等更新。</p><p>（3）记录并检查操作</p><p>如果上面提到的两种实现幂等方法都不能适用于你的场景，还有一种通用性最强，适用范围最广的实现幂等性方法：记录并检查操作，也称为“Token 机制或者 GUID（全局唯一 ID）机制”，实现的思路特别简单：<strong>在执行数据更新操作之前，先检查一下是否执行过这个更新操作</strong>。这种方法适用范围最广，但是实<strong>现难度和复杂度也比较高，一般不推荐使用</strong>。</p><p>具体的实现方法是，在发送消息时，给每条消息<strong>指定一个全局唯一的 ID</strong>，消费时，先根据这个 ID 检查这条消息是否有被消费过，如果没有消费过，才更新数据，然后<strong>将消费状态置为已消费</strong>。</p><p>在分布式系统中，这个方法其实是非常难实现的。首先，给每个消息指定一个全局唯一的 ID 就是一件不那么简单的事儿，方法有很多，但都不太好同时满足简单、高可用和高性能，或多或少都要有些牺牲。更加麻烦的是，在“检查消费状态，然后更新数据并且设置消费状态”中，<strong>三个操作必须作为一组操作保证原子性</strong>，才能真正实现幂等，否则就会出现 Bug。</p><p>比如说，对于同一条消息：“全局 ID 为 8，操作为：给 ID 为 666 账户增加 100 元”，有可能出现这样的情况：</p><ul><li>t0 时刻：Consumer A 收到条消息，检查消息执行状态，发现消息未处理过，开始执行“账户增加 100 元”；</li><li>t1 时刻：Consumer B 收到条消息，检查消息执行状态，发现消息未处理过，因为这个时刻，Consumer A 还未来得及更新消息执行状态。</li></ul><p>这样就会导致账户被错误地增加了两次 100 元，这是一个在分布式系统中非常容易犯的错误，一定要引以为戒。对于这个问题，当然我们可以用事务来实现，也可以用锁来实现，但是在分布式系统中，无论是分布式事务还是分布式锁都是比较难解决问题。</p><h3 id="5-利用事务消息实现分布式事务"><a href="#5-利用事务消息实现分布式事务" class="headerlink" title="5.利用事务消息实现分布式事务"></a>5.利用事务消息实现分布式事务</h3><p><strong><em>一、消息事务</em></strong></p><p>其实很多场景下，我们“发消息”这个过程，目的往往是<strong>通知另外一个系统或者模块去更新数据</strong>，消息队列中的“事务”，主要解决<strong>消息生产者和消息消费者的数据一致性问题</strong>。</p><p>用户在电商APP上购物时，先把商品加到购物车里，然后几件商品一起下单，最后支付，完成购物流程。</p><p>这个过程中有一个需要用到消息队列的步骤，订单系统创建订单后，发消息给购物车系统，将已下单的商品从购物车中删除。因为从购物车删除已下单商品这个步骤，并不是用户下单支付这个主要流程中必要的步骤，使用消息队列来异步清理购物车是更加合理。</p><p><img src="/2023/09/12/RocketMQ-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AF%87/1513968-20190826151153577-1447206679.jpg" srcset="/img/loading.gif" alt="img"></p><p>对于订单系统，它创建订单的过程实际执行了2个步骤的操作：</p><ul><li>在订单库中插入一条订单数据，创建订单；</li><li>发消息给消息队列，消息的内容就是刚刚创建的订单</li></ul><p>对于购物车系统：</p><ul><li>订阅相应的主题，接收订单创建的消息，然后清理购物车，在购物车中删除订单的商品。</li></ul><p>在分布式系统中，上面提到的步骤，任何一个都有可能失败，如果不做任何处理，那就有可能出现订单数据与购物车数据不一致的情况，比如：</p><ul><li>创建了订单，没有清理购物车；</li><li>订单没创建成功，购物车里面的商品却被清掉了。</li></ul><p>所以我们需要解决的问题为：在上述任意步骤都有可能失败的情况下，还要保证订单库和购物车库这两个库的数据一致性。</p><p><strong><em>二、分布式事务</em></strong></p><p>分布式事务就是要在分布式系统中实现事务。在分布式系统中，在保证可用性和不严重牺牲性能的前提下，光是要<strong>实现数据的一致性就已经非常困难了</strong>，显然实现严格的分布式事务是更加不可能完成的任务。所以目前大家所说的分布式事务，更多情况下，是在<strong>分布式系统中事务的不完整实现</strong>，在不同的应用场景中，有不同的实现，目的都是通过一些妥协来解决实际问题。</p><p>常见的分布式事务实现：</p><ul><li>2PC（Two-phase Commit，也叫二阶段提交）</li><li>TCC（Try-Confirm-Cancel）</li><li>事务消息</li></ul><p>每一种实现都有其特定的使用场景，也有各自的问题，都不是完美的解决方案。</p><p><strong>事务消息适用的场景</strong>主要是那些需要<strong>异步更新数据</strong>，并且<strong>对数据实时性要求不太高</strong>的场景。比如在创建订单后，如果出现短暂的几秒，购物车里的商品没有被及时情况，也不是完全不可接受的，只要最终购物车的数据和订单数据保持一致就可。</p><p><strong><em>三、消息队列实现分布式事务</em></strong></p><p><strong>事务消息需要消息队列提供相应的功能才能实现，kafka和RocketMQ都提供了事务相关功能。</strong></p><p><img src="/2023/09/12/RocketMQ-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AF%87/1513968-20190826155000602-1180010007.jpg" srcset="/img/loading.gif" alt="img"></p><p>对于订单系统：</p><ul><li>首先，订单系统在消息队列上开启一个事务。</li><li>然后订单系统给消息服务器发送一个“半消息”，这个半消息不是说消息内容不完整，它包含的内容就是完整的消息内容，半消息和普通消息的唯一区别是，在事务提交之前，对于消费者来说，这个消息是不可见的。</li><li>半消息发送成功后，订单系统就可以执行本地事务了，在订单库中创建一条订单记录，并提交订单库的数据库事务。</li><li>然后根据本地事务的执行结果决定提交或者回滚事务消息。如果订单创建成功，那就提交事务消息，购物车系统就可以消费到这条消息继续后续的流程。如果订单创建失败，那就回滚事务消息，购物车系统就不会收到这条消息。这样就基本实现了“要么都成功，要么都失败”的一致性要求。</li></ul><p>对于购物车系统：</p><ul><li>对于购物车系统收到订单创建成功消息清理购物车这个操作来说，失败的处理比较简单，<strong>只要成功执行购物车清理后再提交消费确认即可</strong>，如果失败，<strong>由于没有提交消费确认，消息队列会自动重试</strong>。</li></ul><p><strong>如果在第四步提交事务消息时失败了怎么办？Kafka 和 RocketMQ 给出了 2 种不同的解决方案：</strong></p><p>1、Kafka 的解决方案：</p><p>直接抛出异常，让用户自行处理。我们可以在业务代码中反复重试提交，直到提交成功，或者删除之前创建的订单进行补偿。</p><p>2、RocketMQ 的解决方案：</p><p>在 RocketMQ 中的事务实现中，增加了<strong>事务反查的机制</strong>来解决事务消息提交失败的问题。如果 Producer 也就是订单系统，在提交或者回滚事务消息时发生网络异常，RocketMQ 的 Broker 没有收到提交或者回滚的请求，Broker 会定期去 Producer 上<strong>反查这个事务对应的本地事务的状态</strong>，然后根据反查结果决定提交或者回滚这个事务。为了支撑这个事务反查机制，我们的业务代码需要<strong>实现一个反查本地事务状态的接口</strong>，告知 RocketMQ 本地事务是成功还是失败。</p><p>综合上面讲的通用事务消息的实现和 RocketMQ 的事务反查机制，使用 <strong>RocketMQ 事务消息功能实现分布式事务的流程</strong>如下图：</p><p><img src="/2023/09/12/RocketMQ-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AF%87/1513968-20190826160556408-194504282.jpg" srcset="/img/loading.gif" alt="img"></p><h3 id="6-消息队列中的顺序问题"><a href="#6-消息队列中的顺序问题" class="headerlink" title="6.消息队列中的顺序问题"></a>6.消息队列中的顺序问题</h3><p>当我们说顺序时，我们在说什么？</p><p>日常思维中，顺序大部分情况会和时间关联起来，即时间的先后表示事件的顺序关系。</p><p>比如事件A发生在下午3点一刻，而事件B发生在下午4点，那么我们认为事件A发生在事件B之前，他们的顺序关系为先A后B。</p><p>上面的例子之所以成立是因为他们有相同的参考系，即他们的时间是对应的同一个物理时钟的时间。如果A发生的时间是北京时间，而B依赖的时间是东京时间，那么先A后B的顺序关系还成立吗？</p><p><em>如果没有一个绝对的时间参考，那么A和B之间还有顺序吗，或者说怎么断定A和B的顺序？</em></p><p>显而易见的，如果A、B两个事件之间如果是有因果关系的，那么A一定发生在B之前（前因后果，有因才有果）。相反，在没有一个绝对的时间的参考的情况下，若A、B之间没有因果关系，那么A、B之间就没有顺序关系。</p><p><strong>那么，我们在说顺序时，其实说的是：</strong></p><ul><li><strong>有绝对时间参考的情况下，事件的发生时间的关系；</strong></li><li><strong>和没有时间参考下的，一种由因果关系推断出来的happening before的关系；</strong></li></ul><p>在分布式环境中讨论顺序</p><p>当把顺序放到分布式环境（多线程、多进程都可以认为是一个分布式的环境）中去讨论时：</p><ul><li>同一线程上的事件顺序是确定的，可以认为他们有相同的时间作为参考</li><li>不同线程间的顺序只能通过因果关系去推断</li></ul><p><img src="/2023/09/12/RocketMQ-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AF%87/471426-20180521095241718-1995021812.png" srcset="/img/loading.gif" alt="img"></p><p><em>（点表示事件，波浪线箭头表示事件间的消息）</em></p><p>上图中，进程P中的事件顺序为p1-&gt;p2-&gt;p3-&gt;p4（时间推断）。而因为p1给进程Q的q2发了消息，那么p1一定在q2之前（因果推断）。但是无法确定p1和q1之间的顺序关系。</p><p>推荐阅读《Time, Clocks, and the Ordering of Events in a Distributed System》，会透彻的分析分布式系统中的顺序问题。</p><p>消息中间件中的顺序消息</p><p>什么是顺序消息</p><p>有了上述的基础之后，我们回到本篇文章的主题中，聊一聊消息中间件中的顺序消息。</p><blockquote><p>顺序消息（FIFO 消息）是 MQ 提供的一种严格按照顺序进行发布和消费的消息类型。顺序消息由两个部分组成：顺序发布和顺序消费。</p><p>顺序消息包含两种类型：</p><p>分区顺序：一个Partition内所有的消息按照先进先出的顺序进行发布和消费</p><p>全局顺序：一个Topic内所有的消息按照先进先出的顺序进行发布和消费</p></blockquote><p>这是阿里云上对顺序消息的定义，把顺序消息拆分成了顺序发布和顺序消费。那么多线程中发送消息算不算顺序发布？</p><p>如上一部分介绍的，多线程中若没有因果关系则没有顺序。那么用户在多线程中去发消息就意味着用户不关心那些在不同线程中被发送的消息的顺序。即多线程发送的消息，不同线程间的消息不是顺序发布的，同一线程的消息是顺序发布的。这是需要用户自己去保障的。</p><p>而对于顺序消费，则需要保证哪些来自同一个发送线程的消息在消费时是按照相同的顺序被处理的（为什么不说他们应该在一个线程中被消费呢？）。</p><p>全局顺序其实是分区顺序的一个特例，即使Topic只有一个分区（以下不在讨论全局顺序，因为全局顺序将面临性能的问题，而且绝大多数场景都不需要全局顺序）。</p><p>如何保证顺序</p><p>在MQ的模型中，顺序需要由3个阶段去保障：</p><ol><li>消息被发送时保持顺序</li><li>消息被存储时保持和发送的顺序一致</li><li>消息被消费时保持和存储的顺序一致</li></ol><p>发送时保持顺序意味着对于有顺序要求的消息，用户应该在同一个线程中采用同步的方式发送。存储保持和发送的顺序一致则要求在同一线程中被发送出来的消息A和B，存储时在空间上A一定在B之前。而消费保持和存储一致则要求消息A、B到达Consumer之后必须按照先A后B的顺序被处理。</p><p>如下图所示：</p><p><img src="/2023/09/12/RocketMQ-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AF%87/471426-20180519131211273-554395305.png" srcset="/img/loading.gif" alt="img"></p><p>对于两个订单的消息的原始数据：a1、b1、b2、a2、a3、b3（绝对时间下发生的顺序）：</p><ul><li><p>在发送时，a订单的消息需要保持a1、a2、a3的顺序，b订单的消息也相同，但是a、b订单之间的消息没有顺序关系，这意味着a、b订单的消息可以在不同的线程中被发送出去</p></li><li><p>在存储时，需要分别保证a、b订单的消息的顺序，但是a、b订单之间的消息的顺序可以不保证</p></li><li><ul><li>a1、b1、b2、a2、a3、b3是可以接受的</li><li>a1、a2、b1、b2、a3、b3也是可以接受的</li><li>a1、a3、b1、b2、a2、b3是不能接受的</li></ul></li><li><p>消费时保证顺序的简单方式就是“什么都不做”，不对收到的消息的顺序进行调整，即只要一个分区的消息只由一个线程处理即可；当然，如果a、b在一个分区中，在收到消息后也可以将他们拆分到不同线程中处理，不过要权衡一下收益</p></li></ul><p>开源RocketMQ中顺序的实现<img src="/2023/09/12/RocketMQ-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AF%87/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" srcset="/img/loading.gif" alt="img"></p><p><img src="/2023/09/12/RocketMQ-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AF%87/471426-20180519131142686-668735225.png" srcset="/img/loading.gif" alt="img"></p><p>上图是RocketMQ顺序消息原理的介绍，将不同订单的消息路由到不同的分区中。文档只是给出了Producer顺序的处理，Consumer消费时通过一个分区只能有一个线程消费的方式来保证消息顺序，具体实现如下。</p><p><strong>Producer端</strong></p><p>Producer端确保消息顺序唯一要做的事情就是将消息路由到特定的分区，在RocketMQ中，通过MessageQueueSelector来实现分区的选择。</p><p><img src="/2023/09/12/RocketMQ-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AF%87/471426-20180519131230081-742966938.png" srcset="/img/loading.gif" alt="img">)<img src="/2023/09/12/RocketMQ-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AF%87/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" srcset="/img/loading.gif" alt="img"></p><ul><li>List<MessageQueue> mqs：消息要发送的Topic下所有的分区</MessageQueue></li><li>Message msg：消息对象</li><li>额外的参数：用户可以传递自己的参数</li></ul><p>比如如下实现就可以保证相同的订单的消息被路由到相同的分区：</p><pre><code class="hljs vbnet"><span class="hljs-built_in">long</span> orderId = ((<span class="hljs-keyword">Order</span>) <span class="hljs-built_in">object</span>).getOrderId;<span class="hljs-keyword">return</span> mqs.<span class="hljs-keyword">get</span>(orderId % mqs.size());</code></pre><p><strong>Consumer端</strong></p><p>RocketMQ消费端有两种类型：MQPullConsumer和MQPushConsumer。</p><p>MQPullConsumer由用户控制线程，主动从服务端获取消息，每次获取到的是一个MessageQueue中的消息。PullResult中的List msgFoundList自然和存储顺序一致，用户需要再拿到这批消息后自己保证消费的顺序。</p><p>对于PushConsumer，由用户注册MessageListener来消费消息，在客户端中需要保证调用MessageListener时消息的顺序性。RocketMQ中的实现如下：</p><p><img src="/2023/09/12/RocketMQ-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AF%87/471426-20180519131253178-1043342972.png" srcset="/img/loading.gif" alt="img"></p><p><img src="/2023/09/12/RocketMQ-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AF%87/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" srcset="/img/loading.gif" alt="img"></p><ol><li>PullMessageService单线程的从Broker获取消息</li><li>PullMessageService将消息添加到ProcessQueue中（ProcessMessage是一个消息的缓存），之后提交一个消费任务到ConsumeMessageOrderService</li><li>ConsumeMessageOrderService多线程执行，每个线程在消费消息时需要拿到MessageQueue的锁</li><li>拿到锁之后从ProcessQueue中获取消息</li></ol><p>保证消费顺序的核心思想是：</p><ul><li>获取到消息后添加到ProcessQueue中，单线程执行，所以ProcessQueue中的消息是顺序的</li><li>提交的消费任务时提交的是“对某个MQ进行一次消费”，这次消费请求是从ProcessQueue中获取消息消费，所以也是顺序的（无论哪个线程获取到锁，都是按照ProcessQueue中消息的顺序进行消费）</li></ul><p>顺序和异常的关系</p><p>顺序消息需要Producer和Consumer都保证顺序。Producer需要保证消息被路由到正确的分区，消息需要保证每个分区的数据只有一个线程消息，那么就会有一些缺陷：</p><ul><li>发送顺序消息无法利用集群的Failover特性，因为不能更换MessageQueue进行重试</li><li>因为发送的路由策略导致的热点问题，可能某一些MessageQueue的数据量特别大</li><li>消费的并行读依赖于分区数量</li><li>消费失败时无法跳过</li></ul><p>不能更换MessageQueue重试就需要MessageQueue有自己的副本，通过Raft、Paxos之类的算法保证有可用的副本，或者通过其他高可用的存储设备来存储MessageQueue。</p><p>热点问题好像没有什么好的解决办法，只能通过拆分MessageQueue和优化路由方法来尽量均衡的将消息分配到不同的MessageQueue。</p><p>消费并行度理论上不会有太大问题，因为MessageQueue的数量可以调整。</p><p>消费失败的无法跳过是不可避免的，因为跳过可能导致后续的数据处理都是错误的。不过可以提供一些策略，由用户根据错误类型来决定是否跳过，并且提供重试队列之类的功能，在跳过之后用户可以在“其他”地方重新消费到这条消息。</p>]]></content>
    
    
    <categories>
      
      <category>中间件篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RocketMQ-消息队列篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis篇</title>
    <link href="/2023/09/12/Redis%E7%AF%87/"/>
    <url>/2023/09/12/Redis%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis篇"><a href="#Redis篇" class="headerlink" title="Redis篇"></a>Redis篇</h1><h2 id="Windows-Redis"><a href="#Windows-Redis" class="headerlink" title="Windows Redis"></a>Windows Redis</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>链接: <a href="https://pan.baidu.com/s/1MJnzX_qRuNXJI09euzkPGA" target="_blank" rel="noopener">https://pan.baidu.com/s/1MJnzX_qRuNXJI09euzkPGA</a> 提取码: 2c6w 复制这段内容后打开百度网盘手机App，操作更方便哦</p><p>无脑下一步即可</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>出现错误：</p><p>creating server tcp listening socket 127.0.0.1:6379: bind No error</p><p>解决方案：</p><ol><li>redis-cli.exe</li><li>shutdown</li><li>exit</li><li>redis-server.exe redis.windows.conf</li></ol><p>启动：redis-server.exe redis.windows.conf</p><p>客户端启动：redis-cli.exe  (不修改配置的话默认即可)</p><p>​                        redis-cli.exe -h 127.0.0.1 -p 6379 -a password</p><h2 id="基本文件说明"><a href="#基本文件说明" class="headerlink" title="基本文件说明"></a>基本文件说明</h2><table><thead><tr><th>可执行文件</th><th>作用说明</th></tr></thead><tbody><tr><td>redis-server</td><td>redis服务</td></tr><tr><td>redis-cli</td><td>redis命令行工具</td></tr><tr><td>redis-benchmark</td><td>基准性能测试工具</td></tr><tr><td>redis-check-aof</td><td>AOF持久化文件检测和修复工具</td></tr><tr><td>redis-check-dump</td><td>RDB持久化文件检测和修复工具</td></tr><tr><td>redis-sentinel</td><td>启动哨兵</td></tr><tr><td>redis-trib</td><td>cluster集群构建工具</td></tr></tbody></table><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><table><thead><tr><th>命令</th><th align="left">说明</th></tr></thead><tbody><tr><td>keys  *</td><td align="left">redis允许模糊查询key　　有3个通配符  *、?、[]</td></tr><tr><td>del      key</td><td align="left">删除key</td></tr><tr><td>exists kxm</td><td align="left">判断是否存在</td></tr><tr><td>expire key 20</td><td align="left">设置过期时间 - 秒</td></tr><tr><td>pexpire key 20000</td><td align="left">设置过期时间 - 毫秒</td></tr><tr><td>move kxm 2</td><td align="left">移动key到指定位置库中  2号库</td></tr><tr><td>persist key</td><td align="left">移除过期时间，key将会永久存在   成功设置返回1  否则返回0</td></tr><tr><td>pttl key</td><td align="left">以毫秒为单位返回 key 的剩余的过期时间</td></tr><tr><td>ttl key</td><td align="left">以秒为单位，返回给定 key 的剩余生存时间</td></tr><tr><td>randomkey</td><td align="left">从当前数据库中随机返回一个 key</td></tr><tr><td>rename key newkxy</td><td align="left">更改key的名字，如果重复了会覆盖</td></tr><tr><td>renamenx kxm key</td><td align="left">仅当 newkey 不存在时，将 key 改名为 newkey</td></tr><tr><td>type key</td><td align="left">返回 key 所储存的值的类型</td></tr><tr><td>select 0</td><td align="left">选择第一个库</td></tr><tr><td>ping</td><td align="left">返回PONG 表示连接正常</td></tr><tr><td>quit</td><td align="left">关闭当前连接</td></tr></tbody></table><h2 id="字符串命令"><a href="#字符串命令" class="headerlink" title="字符串命令"></a>字符串命令</h2><p>| 命令                           | 说明                                                         |<br>|  |  |<br>| set key aaa                    | 设置指定 key 的值                                            |<br>| get key                        | 获取指定 key 的值                                            |<br>| getrange key 0 1               | 返回 key 中字符串值的子字符  包含 0 和 1 包含关系            |<br>| getset key aaaaaaaa            | 将给定 key 的值设为 value ，并返回 key 的旧值(old value)     |<br>| mget key kxm                   | 获取所有(一个或多个)给定 key 的值                            |<br>| setex test 5 “this is my test” | 将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位) |<br>| setnx test test                | 只有在 key 不存在时设置 key 的值 （用于分布式锁）            |<br>| strlen test                    | 返回 key 所储存的字符串值的长度                              |<br>| mset key1 “1” key2 “2”         | 同时设置一个或多个 key-value 对                              |<br>| msetnx key3 “a” key2 “b”       | 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在   其中一个失败则全部失败 |<br>| incr key                       | 将 key 中储存的数字值增一 -&gt;  key的值 比如为 数字类型字符串  返回增加后的结果 |<br>| incrby num 1000                | 将 key 中储存的数字值增指定的值 -&gt;  key的值 比如为 数字类型字符串  返回增加后的结果 |<br>| decr key                       | 同 -&gt; 减一                                                   |<br>| decrby num 500                 | 同 -&gt; 减指定值                                               |<br>| append key 1123123             | 如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾  返回字符串长度 |</p><h2 id="哈希-Hash-命令"><a href="#哈希-Hash-命令" class="headerlink" title="哈希(Hash)命令"></a>哈希(Hash)命令</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>hdel key field1 [field2]</td><td>删除一个或多个哈希表字段</td></tr><tr><td>hexistskey field</td><td>查看哈希表 key 中，指定的字段是否存在</td></tr><tr><td>hget key field</td><td>获取存储在哈希表中指定字段的值</td></tr><tr><td>hgetall key</td><td>获取在哈希表中指定 key 的所有字段和值</td></tr><tr><td>hincrby hash yeary 1</td><td>为哈希表 key 中的指定字段的整数值加上增量 increment</td></tr><tr><td>hkeys hash</td><td>获取所有哈希表中的字段</td></tr><tr><td>hlen hash</td><td>获取哈希表中字段的数量</td></tr><tr><td>hmget hash name year</td><td>获取所有给定字段的值</td></tr><tr><td>hmset hash name “i am kxm” year 24</td><td>同时将多个 field-value (域-值)对设置到哈希表 key 中</td></tr><tr><td>hset hash name kxm</td><td>将哈希表 key 中的字段 field 的值设为 value</td></tr><tr><td>hsetnx key field value</td><td>只有在字段 field 不存在时，设置哈希表字段的值</td></tr><tr><td>hvals hash</td><td>获取哈希表中所有值</td></tr><tr><td>hexists hash name</td><td>是否存在</td></tr></tbody></table><blockquote><p>编码:  field value 值由 ziplist 及 hashtable 两种编码格式</p><p>字段较少的时候采用ziplist，字段较多的时候会变成hashtable编码</p></blockquote><h2 id="列表-List-命令"><a href="#列表-List-命令" class="headerlink" title="列表(List)命令"></a>列表(List)命令</h2><p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）</p><p>一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)</p><p>容量 -&gt; 集合,有序集合也是如此</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>lpush list php</td><td>将一个值插入到列表头部  返回列表长度</td></tr><tr><td>lindex list 0</td><td>通过索引获取列表中的元素</td></tr><tr><td>blpop  key1 [key2 ] timeout</td><td>移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</td></tr><tr><td>brpop  key1 [key2 ] timeout</td><td>移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</td></tr><tr><td>linsert list before 3 4</td><td>在值 3 前插入 4   前即为顶</td></tr><tr><td>linsert list after 4 5</td><td>在值4 后插入5</td></tr><tr><td>llen list</td><td>获取列表长度</td></tr><tr><td>lpop list</td><td>移出并获取列表的第一个元素</td></tr><tr><td>lpush list c++ c</td><td>将一个或多个值插入到列表头部</td></tr><tr><td>lrange list 0 1</td><td>获取列表指定范围内的元素  包含0和1   -1 代表所有 （lrange list 0 -1）</td></tr><tr><td>lrem list 1 c</td><td>移除list 集合中 值为 c 的  一个元素，  1 代表count 即移除几个</td></tr><tr><td>lset list 0 “this is update”</td><td>通过索引设置列表元素的值</td></tr><tr><td>ltrim list 1 5</td><td>对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除</td></tr><tr><td>rpop list</td><td>移除列表的最后一个元素，返回值为移除的元素</td></tr><tr><td>rpush list newvalue3</td><td>从底部添加新值</td></tr><tr><td>rpoplpush list list2</td><td>转移列表的数据</td></tr></tbody></table><h2 id="集合-Set-命令"><a href="#集合-Set-命令" class="headerlink" title="集合(Set)命令"></a>集合(Set)命令</h2><p>Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据</p><p>| 命令                                                         | 说明                                                |<br>|  | — |<br>| sadd set java php c c++ python                               | 向集合添加一个或多个成员                            |<br>| scard set                                                    | 获取集合的成员数                                    |<br>| sdiff key1 [key2]                                            | 返回给定所有集合的差集  数学含义差集                |<br>| sdiffstore curr set newset  （sdiffstore destination key1 [key2]） | 把set和 newset的差值存储到curr中                    |<br>| sinter set newset                                            | 返回给定所有集合的交集                              |<br>| sinterstore curr set newset  （sinterstoredestination key1 [key2]） | 同                                                  |<br>| sismember set c#                                             | 判断 member 元素是否是集合 key 的成员               |<br>| smembers set                                                 | 返回集合中的所有成员                                |<br>| srandmember set 2                                            | 随机抽取两个key (抽奖实现美滋滋)                    |<br>| smove set newtest java （smove source destination member）   | 将 member 元素从 source 集合移动到 destination 集合 |<br>| sunion set newset                                            | 返回所有给定集合的并集                              |<br>| srem set java                                                | 删除                                                |<br>| spop set                                                     | 从集合中弹出一个元素                                |<br>| sdiff | sinter | sunion                                    | 操作：集合间运算：差集                              |</p><h2 id="有序集合-sorted-set-命令"><a href="#有序集合-sorted-set-命令" class="headerlink" title="有序集合(sorted set)命令"></a>有序集合(sorted set)命令</h2><p>Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。</p><p>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p><p>有序集合的成员是唯一的,但分数(score)却可以重复。</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>zadd sort 1 java 2 python</td><td>向有序集合添加一个或多个成员，或者更新已存在成员的分数</td></tr><tr><td>zcard sort</td><td>获取有序集合的成员数</td></tr><tr><td>zcount sort 0 1</td><td>计算在有序集合中指定区间分数的成员数</td></tr><tr><td>zincrby sort 500 java</td><td>有序集合中对指定成员的分数加上增量 increment</td></tr><tr><td>zscore sort java</td><td>返回有序集中，成员的分数值</td></tr><tr><td>zrange sort 0 -1</td><td>获取指定序号的值，-1代表全部</td></tr><tr><td>zrangebyscore sort 0 5</td><td>分数符合范围的值</td></tr><tr><td>zrangebyscore sort 0 5 limit 0 1</td><td>分页 limit  0代表页码，1代表每页显示数量</td></tr><tr><td>zrem sort java</td><td>移除元素</td></tr><tr><td>zremrangebyrank sort 0 1</td><td>按照排名范围删除元素</td></tr><tr><td>zremrangebyscore sort 0 1</td><td>按照分数范围删除元素</td></tr><tr><td>zrevrank sort c#</td><td>返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</td></tr></tbody></table><h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><p>开启两个客户端</p><p>A客户端订阅频道： subscribe redisChat                                      （频道名字为 redisChat）</p><p>B客户端发布内容： publish redisChat “Hello, this is my wor”   （内容是 hello….）</p><p>A客户端即为自动收到内容， 原理图如下:</p><p><img src="/2023/09/12/Redis%E7%AF%87/Redis%E7%AF%87%5Cpubsub1.png" srcset="/img/loading.gif" alt="img"></p><p><img src="/2023/09/12/Redis%E7%AF%87/Redis%E7%AF%87%5Cpubsub2.png" srcset="/img/loading.gif" alt="img"></p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>pubsub channels</td><td>查看当前redis  有多少个频道</td></tr><tr><td>pubsub numsub chat1</td><td>查看某个频道的订阅者数量</td></tr><tr><td>unsubscrible chat1</td><td>退订指定频道</td></tr><tr><td>psubscribe java.*</td><td>订阅一组频道</td></tr></tbody></table><h2 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h2><p>Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：</p><ul><li>批量操作在发送 EXEC 命令前被放入队列缓存</li><li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行</li><li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中</li></ul><p>一个事务从开始到执行会经历以下三个阶段：</p><ul><li>开始事务</li><li>命令入队</li><li>执行事务</li></ul><pre><code class="hljs 注意：redis事务和数据库事务不同，redis事务出错后最大的特点是，一剩下的命令会继续执行，二出错的数据不会回滚```">| 命令      | 说明                                                         || --- |  || multi     | 标记一个事务开始                                             || exec      | 执行事务                                                     || discard   | 事务开始后输入命令入队过程中，中止事务                       || watch key | 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断 || unwatch   | 取消 WATCH 命令对所有 key 的监视                             |## Redis 服务器命令| 命令     | 说明                    || -- | ----- || flushall | 删除所有数据库的所有key || flushdb  | 删除当前数据库的所有key || save     | 同步保存数据到硬盘      |## Redis 数据备份与恢复Redis **SAVE** 命令用于创建当前数据库的备份如果需要恢复数据，只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可。获取 redis 目录可以使用 **CONFIG** 命令## Redis 性能测试redis 性能测试的基本命令如下：</code></pre><p>redis目录执行：redis-benchmark [option] [option value]</p><p>// 会返回各种操作的性能报告（100连接，10000请求）<br>redis-benchmark -h 127.0.0.1 -p 6379 -c 100 -n 10000</p><p>// 100个字节作为value值进行压测<br>redis-benchmark -h 127.0.0.1 -p 6379 -q -d 100</p><pre><code class="hljs">## Java Redis### Jedis ```xml&lt;!-- jedis --&gt;&lt;dependency&gt;    &lt;groupId&gt;redis.clients&lt;/groupId&gt;    &lt;artifactId&gt;jedis&lt;/artifactId&gt;    &lt;version&gt;2.8.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><p><strong>Jedis配置</strong></p><pre><code class="hljs properties"><span class="hljs-comment">############# redis Config #############</span><span class="hljs-comment"># Redis数据库索引（默认为0）</span><span class="hljs-meta">spring.redis.database</span>=<span class="hljs-string">0</span><span class="hljs-comment"># Redis服务器地址</span><span class="hljs-meta">spring.redis.host</span>=<span class="hljs-string">120.79.88.17</span><span class="hljs-comment"># Redis服务器连接端口</span><span class="hljs-meta">spring.redis.port</span>=<span class="hljs-string">6379</span><span class="hljs-comment"># Redis服务器连接密码（默认为空）</span><span class="hljs-meta">spring.redis.password</span>=<span class="hljs-string">123456</span><span class="hljs-comment"># 连接池中的最大空闲连接</span><span class="hljs-meta">spring.redis.jedis.pool.max-idle</span>=<span class="hljs-string">8</span><span class="hljs-comment"># 连接池中的最小空闲连接</span><span class="hljs-meta">spring.redis.jedis.pool.min-idle</span>=<span class="hljs-string">0</span></code></pre><p><strong>JedisConfig</strong></p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JedisConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CachingConfigurerSupport</span> </span>&#123;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;spring.redis.host&#125;"</span>)    <span class="hljs-keyword">private</span> String host;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;spring.redis.port&#125;"</span>)    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> port;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;spring.redis.password&#125;"</span>)    <span class="hljs-keyword">private</span> String password;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;spring.redis.max-idle&#125;"</span>)    <span class="hljs-keyword">private</span> Integer maxIdle;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;spring.redis.min-idle&#125;"</span>)    <span class="hljs-keyword">private</span> Integer minIdle;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> JedisPool <span class="hljs-title">redisPoolFactory</span><span class="hljs-params">()</span></span>&#123;        JedisPoolConfig jedisPoolConfig = <span class="hljs-keyword">new</span> JedisPoolConfig();        jedisPoolConfig.setMaxIdle(maxIdle);        jedisPoolConfig.setMinIdle(minIdle);        jedisPoolConfig.setMaxWaitMillis(<span class="hljs-number">3000L</span>);        <span class="hljs-keyword">int</span> timeOut = <span class="hljs-number">3</span>;        <span class="hljs-keyword">return</span>  <span class="hljs-keyword">new</span> JedisPool(jedisPoolConfig, host, port, timeOut, password);    &#125;&#125;</code></pre><p><strong>基础使用</strong></p><pre><code class="hljs java"><span class="hljs-meta">@RunWith</span>(SpringRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">SpringBootTest</span>(<span class="hljs-title">classes</span> </span>= KerwinBootsApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">ApplicationTests</span> </span>&#123;    <span class="hljs-meta">@Resource</span>    JedisPool jedisPool;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testJedis</span> <span class="hljs-params">()</span> </span>&#123;        Jedis jedis = jedisPool.getResource();        jedis.set(<span class="hljs-string">"year"</span>, String.valueOf(<span class="hljs-number">24</span>));    &#125;&#125;</code></pre><h3 id="SpringBoot-redis-staeter-RedisTemplate"><a href="#SpringBoot-redis-staeter-RedisTemplate" class="headerlink" title="SpringBoot redis staeter RedisTemplate"></a>SpringBoot redis staeter RedisTemplate</h3><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- redis --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- redis 2.X 更换为commons-pool2 连接池 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><pre><code class="hljs properties"><span class="hljs-comment">############# redis Config #############</span><span class="hljs-comment"># Redis数据库索引（默认为0）</span><span class="hljs-meta">spring.redis.database</span>=<span class="hljs-string">0</span><span class="hljs-comment"># Redis服务器地址</span><span class="hljs-meta">spring.redis.host</span>=<span class="hljs-string">120.79.88.17</span><span class="hljs-comment"># Redis服务器连接端口</span><span class="hljs-meta">spring.redis.port</span>=<span class="hljs-string">6379</span><span class="hljs-comment"># Redis服务器连接密码（默认为空）</span><span class="hljs-meta">spring.redis.password</span>=<span class="hljs-string">123456</span><span class="hljs-comment"># 连接池最大连接数（使用负值表示没有限制）</span><span class="hljs-meta">spring.redis.jedis.pool.max-active</span>=<span class="hljs-string">200</span><span class="hljs-comment"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span><span class="hljs-meta">spring.redis.jedis.pool.max-wait</span>=<span class="hljs-string">1000ms</span><span class="hljs-comment"># 连接池中的最大空闲连接</span><span class="hljs-meta">spring.redis.jedis.pool.max-idle</span>=<span class="hljs-string">8</span><span class="hljs-comment"># 连接池中的最小空闲连接</span><span class="hljs-meta">spring.redis.jedis.pool.min-idle</span>=<span class="hljs-string">0</span><span class="hljs-comment"># 连接超时时间（毫秒）</span><span class="hljs-meta">spring.redis.timeout</span>=<span class="hljs-string">1000ms</span></code></pre><pre><code class="hljs java"><span class="hljs-comment">//  Cache注解配置类</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisCacheConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> KeyGenerator <span class="hljs-title">simpleKeyGenerator</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> (o, method, objects) -&gt; &#123;            StringBuilder stringBuilder = <span class="hljs-keyword">new</span> StringBuilder();            stringBuilder.append(o.getClass().getSimpleName());            stringBuilder.append(<span class="hljs-string">"."</span>);            stringBuilder.append(method.getName());            stringBuilder.append(<span class="hljs-string">"["</span>);            <span class="hljs-keyword">for</span> (Object obj : objects) &#123;                stringBuilder.append(obj.toString());            &#125;            stringBuilder.append(<span class="hljs-string">"]"</span>);            <span class="hljs-keyword">return</span> stringBuilder.toString();        &#125;;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CacheManager <span class="hljs-title">cacheManager</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RedisCacheManager(                RedisCacheWriter.nonLockingRedisCacheWriter(redisConnectionFactory),                <span class="hljs-comment">// 默认策略，未配置的 key 会使用这个</span>                <span class="hljs-keyword">this</span>.getRedisCacheConfigurationWithTtl(<span class="hljs-number">15</span>),                <span class="hljs-comment">// 指定 key 策略</span>                <span class="hljs-keyword">this</span>.getRedisCacheConfigurationMap()        );    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> Map&lt;String, RedisCacheConfiguration&gt; <span class="hljs-title">getRedisCacheConfigurationMap</span><span class="hljs-params">()</span> </span>&#123;        Map&lt;String, RedisCacheConfiguration&gt; redisCacheConfigurationMap  = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">16</span>);        redisCacheConfigurationMap.put(<span class="hljs-string">"redisTest"</span>, <span class="hljs-keyword">this</span>.getRedisCacheConfigurationWithTtl(<span class="hljs-number">15</span>));        <span class="hljs-keyword">return</span> redisCacheConfigurationMap;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> RedisCacheConfiguration <span class="hljs-title">getRedisCacheConfigurationWithTtl</span><span class="hljs-params">(Integer seconds)</span> </span>&#123;        Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = <span class="hljs-keyword">new</span> Jackson2JsonRedisSerializer&lt;&gt;(Object<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        ObjectMapper om = <span class="hljs-keyword">new</span> ObjectMapper();        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);        jackson2JsonRedisSerializer.setObjectMapper(om);        RedisCacheConfiguration redisCacheConfiguration = RedisCacheConfiguration.defaultCacheConfig();        redisCacheConfiguration = redisCacheConfiguration.serializeValuesWith(                RedisSerializationContext                        .SerializationPair                        .fromSerializer(jackson2JsonRedisSerializer)        ).entryTtl(Duration.ofSeconds(seconds));        <span class="hljs-keyword">return</span> redisCacheConfiguration;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">// RedisAutoConfiguration</span><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableCaching</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"all"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory factory)</span> </span>&#123;        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> RedisTemplate&lt;String, Object&gt;();        template.setConnectionFactory(factory);        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="hljs-keyword">new</span> Jackson2JsonRedisSerializer(Object<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        ObjectMapper om = <span class="hljs-keyword">new</span> ObjectMapper();        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);        jackson2JsonRedisSerializer.setObjectMapper(om);        StringRedisSerializer stringRedisSerializer = <span class="hljs-keyword">new</span> StringRedisSerializer();        <span class="hljs-comment">// key采用String的序列化方式</span>        template.setKeySerializer(stringRedisSerializer);        <span class="hljs-comment">// hash的key也采用String的序列化方式</span>        template.setHashKeySerializer(stringRedisSerializer);        <span class="hljs-comment">// value序列化方式采用jackson</span>        template.setValueSerializer(jackson2JsonRedisSerializer);        <span class="hljs-comment">// hash的value序列化方式采用jackson</span>        template.setHashValueSerializer(jackson2JsonRedisSerializer);        template.afterPropertiesSet();        <span class="hljs-keyword">return</span> template;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">// 基础使用</span><span class="hljs-meta">@Resource</span>RedisTemplate&lt;String,Object&gt; redisTemplate;redisTemplate.opsForList().rightPush(<span class="hljs-string">"user:1:order"</span>, dataList.get(<span class="hljs-number">3</span>).get(<span class="hljs-string">"key"</span>).toString());<span class="hljs-comment">// 注解使用</span><span class="hljs-meta">@Cacheable</span>(value = <span class="hljs-string">"redisTest"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> TestBean <span class="hljs-title">testBeanAnnotation</span> <span class="hljs-params">()</span> </span>&#123;&#125;</code></pre><h2 id="Redis使用场景"><a href="#Redis使用场景" class="headerlink" title="Redis使用场景"></a>Redis使用场景</h2><p>| 类型   | 适用场景                                    |<br>|  | - |<br>| String | 缓存，限流，计数器，分布式锁，分布式session |<br>| Hash   | 存储用户信息，用户主页访问量，组合查询      |<br>| List   | 微博关注人时间轴列表，简单队列              |<br>| Set    | 赞，踩，标签，好友关系                      |<br>| Zset   | 排行榜                                      |</p><p>或者简单消息队列，发布订阅实施消息系统等等</p><h3 id="String-缓存"><a href="#String-缓存" class="headerlink" title="String - 缓存"></a>String - 缓存</h3><pre><code class="hljs java"><span class="hljs-comment">// 1.Cacheable 注解</span><span class="hljs-comment">// controller 调用 service 时自动判断有没有缓存，如果有就走redis缓存直接返回，如果没有则数据库然后自动放入redis中</span><span class="hljs-comment">// 可以设置过期时间，KEY生成规则 （KEY生成规则基于 参数的toString方法）</span><span class="hljs-meta">@Cacheable</span>(value = <span class="hljs-string">"yearScore"</span>, key = <span class="hljs-string">"#yearScore"</span>)<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;YearScore&gt; <span class="hljs-title">findBy</span> <span class="hljs-params">(YearScore yearScore)</span> </span>&#123;&#125;<span class="hljs-comment">// 2.手动用缓存</span><span class="hljs-keyword">if</span> (redis.hasKey(???) &#123;    <span class="hljs-keyword">return</span> ....&#125; redis.set(find from DB)...</code></pre><h3 id="String-限流-计数器"><a href="#String-限流-计数器" class="headerlink" title="String - 限流 | 计数器"></a>String - 限流 | 计数器</h3><pre><code class="hljs java"><span class="hljs-comment">// 注：这只是一个最简单的Demo 效率低，耗时旧，但核心就是这个意思</span><span class="hljs-comment">// 计数器也是利用单线程incr...等等</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/redisLimit"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testRedisLimit</span><span class="hljs-params">(String uuid)</span> </span>&#123;    <span class="hljs-keyword">if</span> (jedis.get(uuid) != <span class="hljs-keyword">null</span>) &#123;        Long incr = jedis.incr(uuid);        <span class="hljs-keyword">if</span> (incr &gt; MAX_LIMITTIME) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">"Failure Request"</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">"Success Request"</span>;        &#125;    &#125;    <span class="hljs-comment">// 设置Key 起始请求为1，10秒过期  -&gt;  实际写法肯定封装过,这里就是随便一写</span>    jedis.set(uuid, <span class="hljs-string">"1"</span>);    jedis.expire(uuid, <span class="hljs-number">10</span>);    <span class="hljs-keyword">return</span> <span class="hljs-string">"Success Request"</span>;&#125;</code></pre><h3 id="String-分布式锁-重点"><a href="#String-分布式锁-重点" class="headerlink" title="String - 分布式锁 (重点)"></a>String - 分布式锁 (重点)</h3><pre><code class="hljs java"><span class="hljs-comment">/***</span><span class="hljs-comment"> * 核心思路：</span><span class="hljs-comment"> *     分布式服务调用时setnx,返回1证明拿到，用完了删除，返回0就证明被锁，等...</span><span class="hljs-comment"> *     SET KEY value [EX seconds] [PX milliseconds] [NX|XX]</span><span class="hljs-comment"> *     EX second:设置键的过期时间为second秒</span><span class="hljs-comment"> *     PX millisecond:设置键的过期时间为millisecond毫秒</span><span class="hljs-comment"> *     NX：只在键不存在时，才对键进行设置操作</span><span class="hljs-comment"> *     XX:只在键已经存在时，才对键进行设置操作</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 1.设置锁</span><span class="hljs-comment"> *     A. 分布式业务统一Key</span><span class="hljs-comment"> *     B. 设置Key过期时间</span><span class="hljs-comment"> *     C. 设置随机value,利用ThreadLocal 线程私有存储随机value</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 2.业务处理</span><span class="hljs-comment"> *     ...</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 3.解锁</span><span class="hljs-comment"> *     A. 无论如何必须解锁 - finally (超时时间和finally 双保证)</span><span class="hljs-comment"> *     B. 要对比是否是本线程上的锁，所以要对比线程私有value和存储的value是否一致(避免把别人加锁的东西删除了)</span><span class="hljs-comment"> */</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/redisLock"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testRedisLock</span> <span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">for</span>(;;)&#123;            RedisContextHolder.clear();            String uuid = UUID.randomUUID().toString();            String set = jedis.set(KEY, uuid, <span class="hljs-string">"NX"</span>, <span class="hljs-string">"EX"</span>, <span class="hljs-number">1000</span>);            RedisContextHolder.setValue(uuid);            <span class="hljs-keyword">if</span> (!<span class="hljs-string">"OK"</span>.equals(set)) &#123;                <span class="hljs-comment">// 进入循环-可以短时间休眠</span>            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 获取锁成功 Do Somethings....</span>                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-comment">// 解锁 -&gt; 保证获取数据，判断一致以及删除数据三个操作是原子的， 因此如下写法是不符合的</span>        <span class="hljs-comment">/*if (RedisContextHolder.getValue() != null &amp;&amp; jedis.get(KEY) != null &amp;&amp; RedisContextHolder.getValue().equals(jedis.get(KEY))) &#123;</span><span class="hljs-comment">                jedis.del(KEY);</span><span class="hljs-comment">            &#125;*/</span>        <span class="hljs-comment">// 正确姿势 -&gt; 使用Lua脚本,保证原子性</span>        String luaScript = <span class="hljs-string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del',KEYS[1]) else return 0 end"</span>;        Object eval = jedis.eval(luaScript, Collections.singletonList(KEY), Collections.singletonList(RedisContextHolder.getValue()));    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-string">"锁创建成功-业务处理成功"</span>;&#125;</code></pre><h3 id="String-分布式Session（重点）"><a href="#String-分布式Session（重点）" class="headerlink" title="String - 分布式Session（重点）"></a>String - 分布式Session（重点）</h3><pre><code class="hljs armasm">// <span class="hljs-number">1</span>.首先明白为什么需要分布式session -&gt; nginx负载均衡 分发到不同的Tomcat，即使利用<span class="hljs-built_in">IP</span>分发，可以利用request获取session，但是其中一个挂了，怎么办？？ 所以需要分布式session注意理解其中的区别  A服务-用户校验服务  <span class="hljs-keyword">B服务-业务层</span><span class="hljs-keyword"></span><span class="hljs-keyword">情况A：</span><span class="hljs-keyword">A,B </span>服务单机部署：<span class="hljs-symbol">cookie</span>：登录成功后，存储信息到cookie，A服务自身通过request设置session，获取session，<span class="hljs-keyword">B服务通过唯一key或者userid </span>查询数据库获取用户信息<span class="hljs-symbol">cookie</span>+redis：登录成功后，存储信息到cookie，A服务自身通过request设置session，获取session，<span class="hljs-keyword">B服务通过唯一key或者userid </span>查询redis获取用户信息情况<span class="hljs-keyword">B：</span><span class="hljs-keyword">A服务多节点部署，B服务多节点部署</span><span class="hljs-keyword">B服务获取用户信息的方式其实是不重要的，必然要查，要么从数据库，要么从cookie</span><span class="hljs-keyword"></span><span class="hljs-keyword">A服务：登录成功后，存储唯一key到cookie， </span>与此同时，A服务需要把session（KEY-UserInfo）同步到redis中，不能存在单纯的request（否则nginx分发到另一个服务器就完犊子了）官方实现：<span class="hljs-symbol">spring</span>-session-<span class="hljs-meta">data</span>-redis有一个内置拦截器，拦截request，session通过redis交互，普通使用代码依然是request.getSession....  但是实际上这个session的值已经被该组件拦截，通过redis进行同步了</code></pre><h3 id="List-简单队列-栈"><a href="#List-简单队列-栈" class="headerlink" title="List 简单队列-栈"></a>List 简单队列-栈</h3><pre><code class="hljs java"><span class="hljs-comment">// 说白了利用redis - list数据结构 支持从左从右push，从左从右pop</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisStack</span> </span>&#123;    <span class="hljs-meta">@Resource</span>    Jedis jedis;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String KEY = <span class="hljs-string">"Stack"</span>;    <span class="hljs-comment">/** push **/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span> <span class="hljs-params">(String value)</span> </span>&#123;        jedis.lpush(KEY, value);    &#125;    <span class="hljs-comment">/** pop **/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">pop</span> <span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> jedis.lpop(KEY);    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisQueue</span> </span>&#123;    <span class="hljs-meta">@Resource</span>    JedisPool jedisPool;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String KEY = <span class="hljs-string">"Queue"</span>;    <span class="hljs-comment">/** push **/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span> <span class="hljs-params">(String value)</span> </span>&#123;        Jedis jedis = jedisPool.getResource();        jedis.lpush(KEY, value);    &#125;    <span class="hljs-comment">/** pop **/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">pop</span> <span class="hljs-params">()</span> </span>&#123;        Jedis jedis = jedisPool.getResource();        <span class="hljs-keyword">return</span> jedis.rpop(KEY);    &#125;&#125;</code></pre><h3 id="List-社交类APP-好友列表"><a href="#List-社交类APP-好友列表" class="headerlink" title="List 社交类APP - 好友列表"></a>List 社交类APP - 好友列表</h3><pre><code class="hljs jboss-cli">根据时间显示好友，多个好友列表，求交集，并集  显示共同好友等等<span class="hljs-string">...</span>疑问：难道大厂真的用redis存这些数据吗？？？多大的量啊<span class="hljs-string">...</span> 我个人认为实际是数据库存用户id，然后用算法去处理，更省空间</code></pre><h3 id="Set-抽奖-好友关系（合，并，交集）"><a href="#Set-抽奖-好友关系（合，并，交集）" class="headerlink" title="Set 抽奖 | 好友关系（合，并，交集）"></a>Set 抽奖 | 好友关系（合，并，交集）</h3><pre><code class="hljs angelscript"><span class="hljs-comment">// 插入key 及用户id</span>sadd cat:<span class="hljs-number">1</span> <span class="hljs-number">001</span> <span class="hljs-number">002</span> <span class="hljs-number">003</span> <span class="hljs-number">004</span> <span class="hljs-number">005</span> <span class="hljs-number">006</span><span class="hljs-comment">// 返回抽奖参与人数</span>scard cat:<span class="hljs-number">1</span><span class="hljs-comment">// 随机抽取一个</span>srandmember cat:<span class="hljs-number">1</span><span class="hljs-comment">// 随机抽取一人，并移除</span>spop cat:<span class="hljs-number">1</span></code></pre><h3 id="Zset-排行榜"><a href="#Zset-排行榜" class="headerlink" title="Zset 排行榜"></a>Zset 排行榜</h3><pre><code class="hljs crmsh">根据分数实现有序列表微博热搜：每点击一次 分数+<span class="hljs-number">1</span> 即可--- 不用数据库目的是因为避免<span class="hljs-keyword">order</span> <span class="hljs-title">by</span> 进行全表扫描</code></pre><h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><h3 id="Q1-为什么Redis能这么快"><a href="#Q1-为什么Redis能这么快" class="headerlink" title="Q1:为什么Redis能这么快"></a>Q1:为什么Redis能这么快</h3><pre><code class="hljs tex">1.Redis完全基于内存，绝大部分请求是纯粹的内存操作，执行效率高。2.Redis使用单进程单线程模型的(K,V)数据库，将数据存储在内存中，存取均不会受到硬盘IO的限制，因此其执行速度极快，另外单线程也能处理高并发请求，还可以避免频繁上下文切换和锁的竞争，同时由于单线程操作，也可以避免各种锁的使用，进一步提高效率3.数据结构简单，对数据操作也简单，Redis不使用表，不会强制用户对各个关系进行关联，不会有复杂的关系限制，其存储结构就是键值对，类似于HashMap，HashMap最大的优点就是存取的时间复杂度为O(1)5.C语言编写，效率更高6.Redis使用多路I/O复用模型，为非阻塞IO7.有专门设计的RESP协议</code></pre><blockquote><p>针对第四点进行说明 -&gt; </p><p>常见的IO模型有四种：</p><ul><li><p>同步阻塞IO（Blocking IO）：即传统的IO模型。</p></li><li><p>同步非阻塞IO（Non-blocking IO）：默认创建的socket都是阻塞的，非阻塞IO要求socket被设置为NONBLOCK。注意这里所说的NIO并非Java的NIO（New IO）库。</p></li><li><p>IO多路复用（IO Multiplexing）：即经典的Reactor设计模式，有时也称为异步阻塞IO，Java中的Selector和Linux中的epoll都是这种模型。</p></li><li><p>异步IO（Asynchronous IO）：即经典的Proactor设计模式，也称为异步非阻塞IO</p></li></ul><p>同步异步，阻塞非阻塞的概念：</p><p><img src="/2023/09/12/Redis%E7%AF%87/Redis%E7%AF%87%5Cu=3153840595,3774439005&fm=173&app=49&f=JPEG.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="/2023/09/12/Redis%E7%AF%87/Redis%E7%AF%87%5Cu=3983759926,858503315&fm=173&app=49&f=JPEG.jpg" srcset="/img/loading.gif" alt="img"></p><p>假设Redis采用同步阻塞IO：</p><p>Redis主程序（服务端 单线程）-&gt; 多个客户端连接（真实情况是如开发人员连接redis，程序 redispool连接redis），这每一个都对应着一个客户端，假设为100个客户端，其中一个进行交互时候，如果采用同步阻塞式，那么剩下的99个都需要原地等待，这势必是不科学的。</p><p>IO多路复用</p><p>Redis 采用  I/O 多路复用模型</p><p>I/O 多路复用模型中，最重要的函数调用就是 <code>select</code>，该方法的能够同时监控多个文件描述符的可读可写情况，当其中的某些文件描述符可读或者可写时，<code>select</code> 方法就会返回可读以及可写的文件描述符个数</p><pre><code class="hljs 注：redis默认使用的是更加优化的算法：epoll```">|            | select                                   | poll                                     | epoll                                                        || ---- | ---- | ---- |  || 操作方式   | 遍历                                     | 遍历                                     | 回调                                                         || 底层实现   | 数组                                     | 链表                                     | 哈希表                                                       || IO效率     | 每次调用都进行线性遍历，时间复杂度为O(n) | 每次调用都进行线性遍历，时间复杂度为O(n) | 事件通知方式，每当fd就绪，系统注册的回调函数就会被调用，将就绪fd放到readyList里面，时间复杂度O(1) || 最大连接数 | 1024（x86）或2048（x64）                 | 无上限                                   | 无上限                                                       |所以我们可以说Redis是这样的：服务端单线程毫无疑问，多客户端连接时候，如果客户端没有发起任何动作，则服务端会把其视为不活跃的IO流，将其挂起，当有真正的动作时，会通过回调的方式执行相应的事件### Q2:从海量Key里查询出某一个固定前缀的KeyA. 笨办法：KEYS [pattern]  注意key很多的话，这样做肯定会出问题，造成redis崩溃B. SCAN cursor [MATCH pattern] [COUNT count] 游标方式查找### Q3:如何通过Redis实现分布式锁 </code></pre><p>见上文</p></blockquote><pre><code class="hljs">### Q4:如何实现异步队列</code></pre><p>上文说到利用 redis-list 实现队列<br>假设场景:A服务生产数据 - B服务消费数据，即可利用此种模型构造-生产消费者模型</p><ol><li>使用Redis中的List作为队列</li><li>使用BLPOP key [key…] timeout  -&gt; LPOP key [key …] timeout:阻塞直到队列有消息或者超时<br>（方案二：解决方案一中，拿数据的时，生产者尚未生产的情况）</li></ol><p>3.pub/sub：主题订阅者模式<br>基于reds的终极方案，上文有介绍，基于发布/订阅模式<br>缺点:消息的发布是无状态的，无法保证可达。对于发布者来说，消息是“即发即失”的，此时如果某个消费者在生产者发布消息时下线，重新上线之后，是无法接收该消息的，要解决该问题需要使用专业的消息队列</p><pre><code class="hljs">### Q5:Redis支持的数据类型？</code></pre><p>见上文</p><pre><code class="hljs">### Q6:什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？&gt; 持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。&gt;&gt; Redis 提供了两种持久化方式:RDB（默认） 和AOF &gt;&gt; **RDB：**&gt;&gt; rdb是Redis DataBase缩写&gt;&gt; 功能核心函数rdbSave(生成RDB文件)和rdbLoad（从文件加载内存）两个函数&gt;&gt; ![img](Redis篇/1481291-20180925141429889-1694430603.png)&gt;&gt; &gt;&gt; RDB:  把当前进程数据生成快照文件保存到硬盘的过程。分为手动触发和自动触发&gt;&gt; 手动触发 -&gt;  save (不推荐，阻塞严重)  bgsave -&gt; （save的优化版，微秒级阻塞）&gt;&gt; ```shutdowm 关闭服务时，如果没有配置AOF，则会使用bgsave持久化数据</code></pre><blockquote><p><strong>bgsave - 工作原理</strong></p><p>会从当前父进程fork一个子进程，然后生成rdb文件</p><p>缺点：频率低，无法做到实时持久化</p><p><strong>AOF:</strong></p><p>Aof是Append-only file缩写，AOF文件存储的也是RESP协议</p><p><img src="/2023/09/12/Redis%E7%AF%87/1481291-20180925141527592-2105439510.png" srcset="/img/loading.gif" alt="img"></p><p>每当执行服务器(定时)任务或者函数时flushAppendOnlyFile 函数都会被调用， 这个函数执行以下两个工作</p><p>aof写入保存：</p><p>WRITE：根据条件，将 aof_buf 中的缓存写入到 AOF 文件</p><p>SAVE：根据条件，调用 fsync 或 fdatasync 函数，将 AOF 文件保存到磁盘中。</p><p><strong>存储结构:</strong></p><p>内容是redis通讯协议(RESP )格式的命令文本存储</p><p><strong>原理：</strong></p><p>相当于存储了redis的执行命令(类似mysql的sql语句日志)，数据的完整性和一致性更高</p><p><strong>比较</strong>：</p><p>1、aof文件比rdb更新频率高</p><p>2、aof比rdb更安全</p><p>3、rdb性能更好</p><p>PS：正确停止redis服务 应该基于连接命令 加再上 shutdown -&gt; 否则数据持久化会出现问题</p></blockquote><h3 id="Q7-redis通讯协议-RESP"><a href="#Q7-redis通讯协议-RESP" class="headerlink" title="Q7:redis通讯协议(RESP)"></a>Q7:redis通讯协议(RESP)</h3><blockquote><p>Redis 即 REmote Dictionary Server (远程字典服务)；</p><p>而Redis的协议规范是 Redis Serialization Protocol (Redis序列化协议)</p><p>RESP 是redis客户端和服务端之前使用的一种通讯协议；</p><p>RESP 的特点：实现简单、快速解析、可读性好</p><p>协议如下：</p><p>客户端以规定格式的形式发送命令给服务器</p><pre><code class="hljs lsl">set <span class="hljs-type">key</span> value 协议翻译如下：* <span class="hljs-number">3</span>    -&gt;  表示以下有几组命令$ <span class="hljs-number">3</span>    -&gt;  表示命令长度是<span class="hljs-number">3</span>SET$<span class="hljs-number">6</span>     -&gt;  表示长度是<span class="hljs-number">6</span>keykey$<span class="hljs-number">5</span>     -&gt;  表示长度是<span class="hljs-number">5</span>value完整即：* <span class="hljs-number">3</span>$ <span class="hljs-number">3</span>SET$<span class="hljs-number">6</span>keykey$<span class="hljs-number">5</span> value</code></pre><p>​       </p><p>服务器在执行最后一条命令后，返回结果，返回格式如下：</p><p>For Simple Strings the first byte of the reply is “+” 回复</p><p>For Errors the first byte of the reply is “-“ 错误</p><p>For Integers the first byte of the reply is “:” 整数</p><p>For Bulk Strings the first byte of the reply is “$” 字符串</p><p>For Arrays the first byte of the reply is “*” 数组</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">// 伪造6379 redis-服务端，监听  jedis发送的协议内容</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SocketApp</span> </span>&#123;        <span class="hljs-comment">/***</span><span class="hljs-comment">     * 监听 6379 传输的数据</span><span class="hljs-comment">     * JVM端口需要进行设置</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>  </span>&#123;        <span class="hljs-keyword">try</span> &#123;            ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6379</span>);            Socket redis = serverSocket.accept();            <span class="hljs-keyword">byte</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">2048</span>];            redis.getInputStream().read(result);            System.out.println(<span class="hljs-keyword">new</span> String(result));        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span class="hljs-comment">// jedis连接-发送命令</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">"127.0.0.1"</span>);        jedis.set(<span class="hljs-string">"key"</span>, <span class="hljs-string">"This is value."</span>);        jedis.close();    &#125;&#125;<span class="hljs-comment">// 监听命令内容如下：</span>*<span class="hljs-number">3</span>$<span class="hljs-number">3</span>SET$<span class="hljs-number">3</span>key$<span class="hljs-number">14</span></code></pre><h3 id="Q8-redis架构有哪些"><a href="#Q8-redis架构有哪些" class="headerlink" title="Q8:redis架构有哪些"></a>Q8:redis架构有哪些</h3><h4 id="单节点"><a href="#单节点" class="headerlink" title="单节点"></a>单节点</h4><h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><pre><code class="hljs crmsh"><span class="hljs-literal">Master</span>-<span class="hljs-literal">slave</span>  主从赋值，此种结构可以考虑关闭<span class="hljs-literal">master</span>的持久化，只让从数据库进行持久化，另外可以通过读写分离，缓解主服务器压力</code></pre><h4 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h4><pre><code class="hljs angelscript">Redis sentinel 是一个分布式系统中监控 redis 主从服务器，并在主服务器下线时自动进行故障转移。其中三个特性：监控（Monitoring）：    Sentinel  会不断地检查你的主服务器和从服务器是否运作正常。提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作。特点：<span class="hljs-number">1</span>、保证高可用<span class="hljs-number">2</span>、监控各个节点<span class="hljs-number">3</span>、自动故障迁移缺点：主从模式，切换需要时间丢数据没有解决 master 写的压力</code></pre><h4 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h4><blockquote><p><img src="/2023/09/12/Redis%E7%AF%87/1481291-20180925142304757-1498788186.png" srcset="/img/loading.gif" alt="img"></p><p>从redis 3.0之后版本支持redis-cluster集群，Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。</p><p>特点：</p><p>1、无中心架构（不存在哪个节点影响性能瓶颈），少了 proxy 层。</p><p>2、数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布。</p><p>3、可扩展性，可线性扩展到 1000 个节点，节点可动态添加或删除。</p><p>4、高可用性，部分节点不可用时，集群仍可用。通过增加 Slave 做备份数据副本</p><p>5、实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave到 Master 的角色提升。</p><p>缺点：</p><p>1、资源隔离性较差，容易出现相互影响的情况。</p><p>2、数据通过异步复制,不保证数据的强一致性</p></blockquote><h3 id="Q9-Redis集群-如何从海量数据里快速找到所需？"><a href="#Q9-Redis集群-如何从海量数据里快速找到所需？" class="headerlink" title="Q9:Redis集群-如何从海量数据里快速找到所需？"></a>Q9:Redis集群-如何从海量数据里快速找到所需？</h3><ul><li><h4 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h4><p>按照某种规则去划分数据，分散存储在多个节点上。通过将数据分到多个Redis服务器上，来减轻单个Redis服务器的压力。</p></li><li><h4 id="一致性Hash算法"><a href="#一致性Hash算法" class="headerlink" title="一致性Hash算法"></a>一致性Hash算法</h4><p>既然要将数据进行分片，那么通常的做法就是获取节点的Hash值，然后根据节点数求模，但这样的方法有明显的弊端，当Redis节点数需要动态增加或减少的时候，会造成大量的Key无法被命中。所以Redis中引入了<strong>一致性Hash算法</strong>。该算法<strong>对2^32 取模，将Hash值空间组成虚拟的圆环</strong>，整个圆环按<strong>顺时针</strong>方向组织，每个节点依次为0、1、2…2^32-1，之后将每个服务器进行Hash运算，确定服务器在这个Hash环上的地址，确定了服务器地址后，对数据使用同样的Hash算法，将数据定位到特定的Redis服务器上。如果定位到的地方没有Redis服务器实例，则继续顺时针寻找，找到的第一台服务器即该数据最终的服务器位置。 </p><p><img src="https://user-gold-cdn.xitu.io/2019/9/17/16d3e62113addc43?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" srcset="/img/loading.gif" alt="一致性Hash算法"></p></li></ul><h4 id="Hash环的数据倾斜问题"><a href="#Hash环的数据倾斜问题" class="headerlink" title="Hash环的数据倾斜问题"></a>Hash环的数据倾斜问题</h4><p>Hash环在服务器节点很少的时候，容易遇到服务器节点不均匀的问题，这会造成<strong>数据倾斜</strong>，数据倾斜指的是被缓存的对象大部分集中在Redis集群的其中一台或几台服务器上。 </p><p><img src="/2023/09/12/Redis%E7%AF%87/16d3e6243490f5e0" srcset="/img/loading.gif" alt="数据倾斜"></p><p> 如上图，一致性Hash算法运算后的数据大部分被存放在A节点上，而B节点只存放了少量的数据，久而久之A节点将被撑爆。<br><strong>引入虚拟节点</strong></p><p><img src="/2023/09/12/Redis%E7%AF%87/16d3e627518a678e" srcset="/img/loading.gif" alt="虚拟节点"></p><p> 例如上图：将NodeA和NodeB两个节点分为Node A#1-A#3 NodeB#1-B#3。</p><h3 id="Q10-什么是缓存穿透？如何避免？什么是缓存雪崩？如何避免？什么是缓存击穿？如何避免？"><a href="#Q10-什么是缓存穿透？如何避免？什么是缓存雪崩？如何避免？什么是缓存击穿？如何避免？" class="headerlink" title="Q10:什么是缓存穿透？如何避免？什么是缓存雪崩？如何避免？什么是缓存击穿？如何避免？"></a>Q10:什么是缓存穿透？如何避免？什么是缓存雪崩？如何避免？什么是缓存击穿？如何避免？</h3><blockquote><p>缓存穿透</p><p>一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。一些恶意的请求会故意查询不存在的key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。</p><p>如何避免？</p><p>1：对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。</p><p>2：对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤。</p><p>3：由于请求参数是不合法的（每次都请求不存在的参数），于是我们可以使用布隆过滤器（Bloomfilter）或压缩filter提前进行拦截，不合法就不让这个请求进入到数据库层</p><p>缓存雪崩</p><p>当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。</p><p>如何避免？</p><p>1：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p><p>2：做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期</p><p>3：不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p><p>4：启用限流策略，尽量避免数据库被干掉</p><p>缓存击穿</p><p>概念<br>一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。</p><p>解决方案<br>A. 在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key</p><p>B. 服务层处理 - 方法加锁 + 双重校验：</p><pre><code class="hljs java"><span class="hljs-comment">// 锁-实例</span><span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getProductImgUrlById</span><span class="hljs-params">(String id)</span></span>&#123;    <span class="hljs-comment">// 获取缓存</span>    String product = jedisClient.get(PRODUCT_KEY + id);    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == product) &#123;        <span class="hljs-comment">// 如果没有获取锁等待3秒，SECONDS代表：秒</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (lock.tryLock(<span class="hljs-number">3</span>, TimeUnit.SECONDS)) &#123;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-comment">// 获取锁后再查一次，查到了直接返回结果</span>                    product = jedisClient.get(PRODUCT_KEY + id);                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == product) &#123;                        <span class="hljs-comment">// ....</span>                    &#125;                    <span class="hljs-keyword">return</span> product;                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                    product = jedisClient.get(PRODUCT_KEY + id);                &#125; <span class="hljs-keyword">finally</span> &#123;                    <span class="hljs-comment">// 释放锁（成功、失败都必须释放，如果是lock.tryLock()方法会一直阻塞在这）</span>                    lock.unlock();                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                product = jedisClient.get(PRODUCT_KEY + id);            &#125;        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            product = jedisClient.get(PRODUCT_KEY + id);        &#125;    &#125;    <span class="hljs-keyword">return</span> product;&#125;</code></pre></blockquote><table><thead><tr><th></th><th>解释</th><th>基础解决方案</th></tr></thead><tbody><tr><td>缓存穿透</td><td>访问一个不存在的key，缓存不起作用，请求会穿透到DB，流量大时DB会挂掉</td><td>1.采用布隆过滤器，使用一个足够大的bitmap，用于存储可能访问的key，不存在的key直接被过滤； 2.访问key未在DB查询到值，也将空值写进缓存，但可以设置较短过期时间</td></tr><tr><td>缓存雪崩</td><td>大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩</td><td>可以给缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效</td></tr><tr><td>缓存击穿</td><td>一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增</td><td>在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key</td></tr></tbody></table><h3 id="Q11-缓存与数据库双写一致"><a href="#Q11-缓存与数据库双写一致" class="headerlink" title="Q11:缓存与数据库双写一致"></a>Q11:缓存与数据库双写一致</h3><blockquote><p>如果仅仅是读数据，没有此类问题</p><p>如果是新增数据，也没有此类问题</p><p>当数据需要更新时，如何保证缓存与数据库的双写一致性？</p><p>三种更新策略：</p><ol><li>先更新数据库，再更新缓存  -&gt;  </li><li>先删除缓存，再更新数据库</li><li>先更新数据库，再删除缓存</li></ol><p>方案一：并发的时候，执行顺序无法保证，可能A先更新数据库，但B后更新数据库但先更新缓存</p><p>​                加锁的话，确实可以避免，但这样吞吐量会下降，可以根据业务场景考虑</p><p>方案二：该方案会导致不一致的原因是。同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:<br>（1）请求A进行写操作，删除缓存<br>（2）请求B查询发现缓存不存在<br>（3）请求B去数据库查询得到旧值<br>（4）请求B将旧值写入缓存<br>（5）请求A将新值写入数据库</p><p>因此采用：<strong>采用延时双删策略</strong>   即进入逻辑就删除Key，执行完操作，延时再删除key</p><p>方案三：更新数据库 - 删除缓存  可能出现问题的场景：</p><p>（1）缓存刚好失效<br>（2）请求A查询数据库，得一个旧值<br>（3）请求B将新值写入数据库<br>（4）请求B删除缓存<br>（5）请求A将查到的旧值写入缓存</p><p>先天条件要求：请求第二步的读取操作耗时要大于更新操作，条件较为苛刻</p><p>但如果真的发生怎么处理？</p><p>A. 给键设置合理的过期时间</p><p>B. 异步延时删除key</p></blockquote><h3 id="Q12-何保证Redis中的数据都是热点数据"><a href="#Q12-何保证Redis中的数据都是热点数据" class="headerlink" title="Q12:何保证Redis中的数据都是热点数据"></a>Q12:何保证Redis中的数据都是热点数据</h3><blockquote><p>A. 可以通过手工或者主动方式，去加载热点数据</p><p>B. Redis有其自己的数据淘汰策略：</p><p>redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略（回收策略）。redis 提供 6种数据淘汰策略：</p><ol><li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</li><li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li>no-enviction（驱逐）：禁止驱逐数据</li></ol></blockquote><h3 id="Q13-Redis的并发竞争问题如何解决"><a href="#Q13-Redis的并发竞争问题如何解决" class="headerlink" title="Q13:Redis的并发竞争问题如何解决?"></a>Q13:Redis的并发竞争问题如何解决?</h3><pre><code class="hljs routeros">即多线程同时操作统一Key的解决办法：Redis为单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，但是在Jedis客户端对Redis进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成对此有多种解决方法：A：条件允许的情况下，请使用redis自带的incr命令,decr命令B：乐观锁方式watch price<span class="hljs-builtin-name">get</span> price <span class="hljs-variable">$price</span><span class="hljs-variable">$price</span> = <span class="hljs-variable">$price</span> + 10multi<span class="hljs-builtin-name">set</span> price <span class="hljs-variable">$price</span>execC：针对客户端，操作同一个key的时候，进行加锁处理D：场景允许的话，使用setnx 实现</code></pre><h3 id="Q14-Redis回收进程如何工作的-Redis回收使用的是什么算法"><a href="#Q14-Redis回收进程如何工作的-Redis回收使用的是什么算法" class="headerlink" title="Q14:Redis回收进程如何工作的? Redis回收使用的是什么算法?"></a>Q14:Redis回收进程如何工作的? Redis回收使用的是什么算法?</h3><blockquote><p>Q12 中提到过，当所需内存超过配置的最大内存时，redis会启用数据淘汰规则</p><p>默认规则是：# maxmemory-policy noeviction</p><p>即只允许读，无法继续添加key</p><p>因此常需要配置淘汰策略，比如LRU算法</p><p><img src="/2023/09/12/Redis%E7%AF%87/251954349742220-1569134965865.png" srcset="/img/loading.gif" alt="img"></p><pre><code class="hljs LRU算法最为精典的实现，就是HashMap+Double">### Q15:Redis大批量增加数据参考文章：https:&#x2F;&#x2F;www.cnblogs.com&#x2F;PatrickLiu&#x2F;p&#x2F;8548580.html使用管道模式，运行的命令如下所示：</code></pre><p>cat data.txt | redis-cli –pipe</p><pre><code class="hljs routeros">data.txt文本：```java<span class="hljs-builtin-name">SET</span> Key0 Value0<span class="hljs-builtin-name">SET</span> Key1 Value1<span class="hljs-built_in">..</span>.<span class="hljs-builtin-name">SET</span> KeyN ValueN<span class="hljs-comment"># 或者是 RESP协议内容 - 注意文件编码！！！</span><span class="hljs-number">*8</span><span class="hljs-variable">$5</span>HMSET<span class="hljs-variable">$8</span>person:1<span class="hljs-variable">$2</span>id<span class="hljs-variable">$1</span>1</code></pre><p>这将产生类似于这样的输出：</p><pre><code class="hljs yaml"><span class="hljs-string">All</span> <span class="hljs-string">data</span> <span class="hljs-string">transferred.</span> <span class="hljs-string">Waiting</span> <span class="hljs-string">for</span> <span class="hljs-string">the</span> <span class="hljs-string">last</span> <span class="hljs-string">reply...</span><span class="hljs-string">Last</span> <span class="hljs-string">reply</span> <span class="hljs-string">received</span> <span class="hljs-string">from</span> <span class="hljs-string">server.</span><span class="hljs-attr">errors:</span> <span class="hljs-number">0</span><span class="hljs-string">,</span> <span class="hljs-attr">replies:</span> <span class="hljs-number">1000000</span></code></pre><p>redis-cli实用程序还将确保只将从Redis实例收到的错误重定向到标准输出</p><p>演示：</p><pre><code class="hljs angelscript">cat redis_commands.txt | redis-cli -h <span class="hljs-number">192.168</span><span class="hljs-number">.127</span><span class="hljs-number">.130</span> -p <span class="hljs-number">6379</span> [-a <span class="hljs-string">"password"</span>] -n <span class="hljs-number">0</span> --pipeAll data transferred.Waiting <span class="hljs-keyword">for</span> the last reply...Last reply received <span class="hljs-keyword">from</span> server.errors:<span class="hljs-number">0</span>，replies：<span class="hljs-number">10000000</span></code></pre><pre><code class="hljs mysql数据快速导入到redis">博文：https:&#x2F;&#x2F;www.cnblogs.com&#x2F;tommy-huang&#x2F;p&#x2F;4703514.html&#96;&#96;&#96;sql# 1.准备一个tablecreate database  if not exists &#96;test&#96;;use &#96;test&#96;;CREATE TABLE &#96;person&#96; (  &#96;id&#96; int(10) unsigned NOT NULL AUTO_INCREMENT,  &#96;name&#96; varchar(200) NOT NULL,  &#96;age&#96; varchar(200) NOT NULL,  PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;MyISAM AUTO_INCREMENT&#x3D;1 DEFAULT CHARSET&#x3D;utf8;# 2.插入七八万条数据# 3.SQL查询，将其转化为 RESP协议命令   Linux 版本： -&gt; 不要在windows环境试，没啥意义SELECT CONCAT(   &quot;*8\r\n&quot;,   &#39;$&#39;,LENGTH(redis_cmd),&#39;\r\n&#39;,redis_cmd,&#39;\r\n&#39;,   &#39;$&#39;,LENGTH(redis_key),&#39;\r\n&#39;,redis_key,&#39;\r\n&#39;,   &#39;$&#39;,LENGTH(hkey1),&#39;\r\n&#39;,hkey1,&#39;\r\n&#39;,&#39;$&#39;,LENGTH(hval1),&#39;\r\n&#39;,hval1,&#39;\r\n&#39;,   &#39;$&#39;,LENGTH(hkey2),&#39;\r\n&#39;,hkey2,&#39;\r\n&#39;,&#39;$&#39;,LENGTH(hval2),&#39;\r\n&#39;,hval2,&#39;\r\n&#39;,   &#39;$&#39;,LENGTH(hkey3),&#39;\r\n&#39;,hkey3,&#39;\r\n&#39;,&#39;$&#39;,LENGTH(hval3),&#39;\r\n&#39;,hval3,&#39;\r&#39;)FROM(   SELECT &#39;HMSET&#39; AS redis_cmd,   concat_ws(&#39;:&#39;,&#39;person&#39;, id) AS redis_key,   &#39;id&#39; AS hkey1, id AS hval1,   &#39;name&#39; AS hkey2, name AS hval2,   &#39;age&#39; AS hkey3, age AS hval3   From person)AS t# 4.如果用的就是线上数据库+线上Linux -&gt; 把sql存到 order.sql，进行执行mysql -uroot -p123456 test --default-character-set&#x3D;utf8 --skip-column-names --raw &lt; order.sql  |redis-cli -h 127.0.0.1 -p 6379 -a 123456 --pipe# 5.本地数据库+线上redis利用Navicat导出数据 -&gt; data.txt，清理格式（导出来的数据里面各种 &quot; 符号），全局替换即可cat data.txt | redis-cli -h 127.0.0.1 -p 6379 -a 123456  --pipe81921条数据 一瞬间导入完成注意事项： RESP协议要求，不要有莫名其妙的字符，注意文件类型是Unix编码类型</code></pre></blockquote><h3 id="Q16：延申：布隆过滤器"><a href="#Q16：延申：布隆过滤器" class="headerlink" title="Q16：延申：布隆过滤器"></a>Q16：延申：布隆过滤器</h3><blockquote><p>数据结构及算法篇 / 布隆过滤器</p><p>Redis 实现</p><p>redis 4.X 以上 提供 布隆过滤器插件</p><p>centos中安装redis插件bloom-filter：<a href="https://blog.csdn.net/u013030276/article/details/88350641" target="_blank" rel="noopener">https://blog.csdn.net/u013030276/article/details/88350641</a></p><p>语法：<em>[bf.add  key  options]</em></p><p>语法：[bf.exists  key  options]</p><p>注意: <code>redis 布隆过滤器提供的是 最大内存512M，2亿数据，万分之一的误差率</code></p></blockquote><h3 id="Q17：Lua脚本相关"><a href="#Q17：Lua脚本相关" class="headerlink" title="Q17：Lua脚本相关"></a>Q17：Lua脚本相关</h3><p>使用Lua脚本的好处：</p><ul><li>减少网络开销。可以将多个请求通过脚本的形式一次发送，减少网络时延</li><li>原子操作，redis会将整个脚本作为一个整体执行，中间不会被其他命令插入。因此在编写脚本的过程中无需担心会出现竞态条件，无需使用事务</li><li>复用，客户端发送的脚本会永久存在redis中，这样，其他客户端可以复用这一脚本而不需要使用代码完成相同的逻辑</li></ul><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/testLua"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testLua</span> <span class="hljs-params">()</span> </span>&#123;    String key   = <span class="hljs-string">"mylock"</span>;    String value = <span class="hljs-string">"xxxxxxxxxxxxxxx"</span>;    <span class="hljs-comment">//        if redis.call('get', KEYS[1]) == ARGV[1]</span>    <span class="hljs-comment">//            then</span>    <span class="hljs-comment">//                return redis.call('del', KEYS[1])</span>    <span class="hljs-comment">//        else</span>    <span class="hljs-comment">//            return 0</span>    <span class="hljs-comment">//        end</span>    <span class="hljs-comment">// lua脚本，用来释放分布式锁 - 如果使用的较多，可以封装到文件中, 再进行调用</span>    String luaScript = <span class="hljs-string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del',KEYS[1]) else return 0 end"</span>;    Object eval = jedis.eval(luaScript, Collections.singletonList(key), Collections.singletonList(value));    <span class="hljs-keyword">return</span> eval.toString();&#125;</code></pre><h3 id="Q18：性能相关-Redis慢查询分析"><a href="#Q18：性能相关-Redis慢查询分析" class="headerlink" title="Q18：性能相关 - Redis慢查询分析"></a>Q18：性能相关 - Redis慢查询分析</h3><blockquote><p>redis 命令会放在redis内置队列中，然后主线程一个个执行，因此 其中一个 命令执行时间过长，会造成成批量的阻塞</p><pre><code class="hljs 命令：```slowlog">     slowlog len 获取慢查询记录量(慢查询队列是先进先出的，因此新的值在满载的时候，旧的会出去)Redis 慢查询 -&gt; 执行阶段耗时过长 &#96;&#96;&#96;conf文件设置： </code></pre><p>slowlog-low-slower-than 10000 -&gt; 10000微秒,10毫秒 (默认)<br>                            0 -&gt; 记录所有命令<br>                           -1 -&gt; 不记录命令<br>slow-max-len 存放的最大条数</p><pre><code class="hljs 慢查询导致原因:">数据分段（更细颗粒度存放数据） ### Q19：如何提高Redis处理效率? 基于Jedis 的批量操作 Pipelined&#96;&#96;&#96;javaJedis jedis &#x3D; new Jedis(&quot;127.0.0.1&quot;, 6379);Pipeline pipelined &#x3D; jedis.pipelined();for (String key : keys) &#123;   pipelined.del(key);&#125;pipelined.sync();jedis.close();&#x2F;&#x2F; pipelined 实际是封装过一层的指令集 -&gt;  实际应用的还是单条指令，但是节省了网络传输开销（服务端到Redis环境的网络开销） </code></pre></blockquote>]]></content>
    
    
    <categories>
      
      <category>中间件篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring-xsd</title>
    <link href="/2023/09/12/Spring-xsd/"/>
    <url>/2023/09/12/Spring-xsd/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-XSD篇"><a href="#Spring-XSD篇" class="headerlink" title="Spring XSD篇"></a>Spring XSD篇</h1><h2 id="错误描述"><a href="#错误描述" class="headerlink" title="错误描述"></a>错误描述</h2><p>有时候你会发现过去一直启动正常的系统，某天启动时会报出形如下面的错误： </p><pre><code class="hljs xquery">org.xml.sax.SAXParseException: schema_reference.<span class="hljs-number">4</span>: Failed <span class="hljs-keyword">to</span> read <span class="hljs-keyword">schema</span><span class="hljs-built_in"> document</span> <span class="hljs-string">'http://www.springframework.org/schema/beans/spring-beans-2.0.xsd'</span>, because <span class="hljs-number">1</span>) could<span class="hljs-built_in"> not</span> find the<span class="hljs-built_in"> document</span>; <span class="hljs-number">2</span>) the<span class="hljs-built_in"> document</span> could<span class="hljs-built_in"> not</span> be read; <span class="hljs-number">3</span>) the<span class="hljs-built_in"> root</span> <span class="hljs-keyword">element</span> of the <span class="hljs-keyword">document</span> is not &lt;xsd:schema&gt;.</code></pre><p> 很显然，spring xml配置文件中指定的xsd文件读取不到了，原因多是因为断网或spring的官网暂时无法连接导致的。 你可以通过在浏览器输入xsd文件的URL，如：<a href="http://www.springframework.org/schema/beans/spring-beans-2.0.xsd" target="_blank" rel="noopener">http://www.springframework.org/schema/beans/spring-beans-2.0.xsd</a> 进行确认 </p><h2 id="XSD文件的作用"><a href="#XSD文件的作用" class="headerlink" title="XSD文件的作用"></a>XSD文件的作用</h2><p>xml文档要有格式，为了Spring的配置文件增加的节点(比如&lt;tx:advice)能符合要求、合法，必须通过引入校验该xml格式的文件，也就是xsd文件，Spring通过配置可以联网引入xsd文件，也可以在断网下使用本地xsd文件校验xml文件</p><p> xsi:schemaLocation 属性提供一种方法来查找在 XML 实例文档中定义的命名空间的 XML 架构定义。它的值是用空白分隔的统一资源标识符 (URI) 对的列表，其中的每一对 URI 都依次包含一个命名空间以及该命名空间的 XML 架构定义（通常为 .xsd 文件）的位置 </p><pre><code class="hljs Spring在启动时默认要加载xsd文件来验证XML文件的">![image-20191209135859502](Spring-xsd&#x2F;image-20191209135859502.png)## XSD引起的错误&gt; 前文讲到：XSD文件在Spring启动时起作用&gt;&gt; - 项目正式启动时&gt;&gt; - test测试时&gt;&gt; - Maven打包不跳过test测试（不跳过test测试即会启动项目）&gt;&gt;   &gt;&gt; Spring会默认从本地Jar中读取XSD文件，如果本地读取不到则会通过定义的url地址从网上进行下载示例：![image-20191209140226954](Spring-xsd&#x2F;image-20191209140226954.png)Spring中：![image-20191209140357800](Spring-xsd&#x2F;image-20191209140357800.png)上述的版本无法对应，因此就会从网络读取，如果恰好服务器断网或没有外网，则项目启动后会在几秒钟之后停止，报关于解析xml文件错误&#96;&#96;&#96;javajava.lang.Throwable: org.springframework.beans.factory.xml.XmlBeanDefinitionStoreException: Line 1 in XML document from cn.testin.common.spring.pojo.DynamicResource@957e06 is invalid; nested exception is org.xml.sax.SAXParseException; lineNumber: 1; columnNumber: 1297; cvc-complex-type.2.4.c: The matching wildcard is strict, but no declaration can be found for element &#39;mongo:mongo-client&#39;.</code></pre><h2 id="XSD引用解决方案"><a href="#XSD引用解决方案" class="headerlink" title="XSD引用解决方案"></a>XSD引用解决方案</h2> <pre><code class="hljs 不要在Spring的配置文件中配置XSD的版本号```，因为没配置版本号时，默认取当前jar里的XSD文件，减少了各种风险">例子：&#96;&#96;&#96;xml&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;       xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd&quot;&gt;&lt;&#x2F;beans&gt;</code></pre><p>其他方法：</p><p>思路一致，既然需要解决断网情况下无法启动的问题，则保证配置的能够生效即可</p><ul><li>将tx的某个版本的xsd文件拷贝到工程的source folder下，然后xml的配置改成如下形式： </li></ul><pre><code class="hljs xml">xsi:schemaLocation="http://www.springframework.org/schema/beans         classpath:beans/spring-beans-4.1.xsd         http://www.springframework.org/schema/mvc         classpath:mvc/spring-mvc-4.1.xsd         http://www.springframework.org/schema/context         classpath:context/spring-context-4.1.xsd         http://www.springframework.org/schema/aop         classpath:aop/spring-aop-4.1.xsd         http://www.springframework.org/schema/tx           classpath:tx/spring-tx-4.1.xsd "&gt;</code></pre><ul><li><strong>根据使用的Spring的相应jar包版本更改对应的版本</strong> </li></ul>]]></content>
    
    
    <categories>
      
      <category>Tips篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring-xsd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HelloGithub</title>
    <link href="/2023/09/12/HelloGithub/"/>
    <url>/2023/09/12/HelloGithub/</url>
    
    <content type="html"><![CDATA[<h1 id="Hello-GitHub"><a href="#Hello-GitHub" class="headerlink" title="Hello GitHub"></a>Hello GitHub</h1><blockquote><p>优秀的GitHub项目大全</p></blockquote><h2 id="new-pac（科学上网）"><a href="#new-pac（科学上网）" class="headerlink" title="new-pac（科学上网）"></a>new-pac（科学上网）</h2><p> <a href="https://github.com/Alvin9999/new-pac" target="_blank" rel="noopener">GitHub</a> </p><p><img src="/2023/09/12/HelloGithub/image-20200411165909545.png" srcset="/img/loading.gif" alt="image-20200411165909545"></p><h2 id="Vue-Form-Making（Vue拖拽生成器）"><a href="#Vue-Form-Making（Vue拖拽生成器）" class="headerlink" title="Vue-Form-Making（Vue拖拽生成器）"></a>Vue-Form-Making（Vue拖拽生成器）</h2><p> 基于Vue的可视化表单设计器，让表单开发简单而高效。 </p><p><a href="https://github.com/GavinZhuLei/vue-form-making" target="_blank" rel="noopener">GitHub链接</a></p><p><a href="https://gitee.com/gavinzhulei/vue-form-making/" target="_blank" rel="noopener">码云链接</a></p><p><a href="http://form.xiaoyaoji.cn/#/zh-CN/" target="_blank" rel="noopener">直接体验网站</a></p><p>效果图：</p><p><img src="/2023/09/12/HelloGithub/image-20200404214851372.png" srcset="/img/loading.gif" alt="image-20200404214851372"></p><h2 id="VeryNginx（Nginx增强版工具）"><a href="#VeryNginx（Nginx增强版工具）" class="headerlink" title="VeryNginx（Nginx增强版工具）"></a>VeryNginx（Nginx增强版工具）</h2><p> VeryNginx 是一个功能强大而对人类友好的 Nginx 扩展程序. </p><p><a href="https://github.com/alexazhou/VeryNginx/blob/master/readme_zh.md" target="_blank" rel="noopener">GitHub链接</a></p><p>涉及功能：</p><ul><li>Nginx 运行状态分析</li><li>自定义行为</li><li>访问统计</li></ul><p><img src="/2023/09/12/HelloGithub/image-20200406233855399.png" srcset="/img/loading.gif" alt="image-20200406233855399"></p><h2 id="hutool-Hutool工具包"><a href="#hutool-Hutool工具包" class="headerlink" title="hutool(Hutool工具包)"></a>hutool(Hutool工具包)</h2><p>国人发布的小而精的第三方类库，功能完备，中文注释，非常值得学习和使用</p><p><a href="https://github.com/looly/hutool/" target="_blank" rel="noopener">GitHub链接</a></p><p><a href="https://gitee.com/loolly/hutool/" target="_blank" rel="noopener">码云链接</a></p><p><a href="https://www.hutool.cn/" target="_blank" rel="noopener">官网</a></p><p><img src="/2023/09/12/HelloGithub/image-20200407000720821.png" srcset="/img/loading.gif" alt="image-20200407000720821">    </p><h2 id="Java-design-patterns（设计模式）"><a href="#Java-design-patterns（设计模式）" class="headerlink" title="Java-design-patterns（设计模式）"></a>Java-design-patterns（设计模式）</h2><p>Design patterns implemented in Java <a href="https://java-design-patterns.com/" target="_blank" rel="noopener">https://java-design-patterns.com</a> </p><p>设计模式的集大成者，真正的世界级GitHub项目，但是都是英文，阅读起来比较困难</p><p><a href="https://github.com/iluwatar/java-design-patterns" target="_blank" rel="noopener">GitHub</a></p><p><img src="/2023/09/12/HelloGithub/image-20200407001051245.png" srcset="/img/loading.gif" alt="image-20200407001051245"></p><h2 id="fuck-login-Python爬虫破解登录"><a href="#fuck-login-Python爬虫破解登录" class="headerlink" title="fuck-login(Python爬虫破解登录)"></a>fuck-login(Python爬虫破解登录)</h2><p> 模拟登录一些知名的网站，为了方便爬取需要登录的网站 </p><p><a href="https://github.com/xchaoinfo/fuck-login" target="_blank" rel="noopener">GitHub</a></p><p><img src="/2023/09/12/HelloGithub/image-20200410002641787.png" srcset="/img/loading.gif" alt="image-20200410002641787"></p><h2 id="walle-web-瓦力"><a href="#walle-web-瓦力" class="headerlink" title="walle-web( 瓦力 )"></a>walle-web( 瓦力 )</h2><p> walle - 瓦力 Devops开源项目代码部署平台 <a href="https://walle-web.io/" target="_blank" rel="noopener">https://walle-web.io</a> </p><p><a href="https://github.com/meolu/walle-web" target="_blank" rel="noopener">GitHub</a></p><p><img src="/2023/09/12/HelloGithub/image-20200410002753465.png" srcset="/img/loading.gif" alt="image-20200410002753465"></p><h2 id="editor-md-MarkDown"><a href="#editor-md-MarkDown" class="headerlink" title="editor.md(MarkDown)"></a>editor.md(MarkDown)</h2><p><a href="https://github.com/pandao/editor.md" target="_blank" rel="noopener">GitHub</a></p><p>MarkDown类型编辑器</p><p><img src="/2023/09/12/HelloGithub/image-20200410002854868.png" srcset="/img/loading.gif" alt="image-20200410002854868"></p><h2 id="qrcode-彩色二维码"><a href="#qrcode-彩色二维码" class="headerlink" title="qrcode( 彩色二维码 )"></a>qrcode( 彩色二维码 )</h2><p> Python 写的生成动态、彩色、各式各样的二维码，详细的<a href="https://github.com/sylnsfar/qrcode/blob/master/README-cn.md" target="_blank" rel="noopener">中文文档</a>，通过 <code>qrcode</code> 生成的二维码样式如下：<br><img src="/2023/09/12/HelloGithub/qrcode-show-min.png" srcset="/img/loading.gif" alt="qrcode"> </p><p><a href="https://github.com/sylnsfar/qrcode" target="_blank" rel="noopener">GitHub</a></p><h2 id="atrament-js（JavaScript画板）"><a href="#atrament-js（JavaScript画板）" class="headerlink" title="atrament.js（JavaScript画板）"></a>atrament.js（JavaScript画板）</h2><p><a href="https://github.com/jakubfiala/atrament.js" target="_blank" rel="noopener">GitHub</a></p><p><a href="http://fiala.uk/atrament.js/demo/" target="_blank" rel="noopener">在线演示</a></p><p><img src="/2023/09/12/HelloGithub/image-20200412180002526.png" srcset="/img/loading.gif" alt="image-20200412180002526"></p><h2 id="nodeclub-开源社区"><a href="#nodeclub-开源社区" class="headerlink" title="nodeclub(开源社区)"></a>nodeclub(开源社区)</h2><p><a href="https://github.com/cnodejs/nodeclub" target="_blank" rel="noopener">GitHub</a></p><p><a href="https://cnodejs.org/" target="_blank" rel="noopener">在线演示</a></p><p><img src="/2023/09/12/HelloGithub/image-20200412180528524.png" srcset="/img/loading.gif" alt="image-20200412180528524"></p><h2 id="jstraining-全栈工程师培训材料"><a href="#jstraining-全栈工程师培训材料" class="headerlink" title="jstraining(全栈工程师培训材料)"></a>jstraining(全栈工程师培训材料)</h2><p><a href="https://github.com/ruanyf/jstraining" target="_blank" rel="noopener">jstraining</a></p><p><img src="/2023/09/12/HelloGithub/image-20200412180943461.png" srcset="/img/loading.gif" alt="image-20200412180943461"></p><h2 id="How-To-Ask-Questions-The-Smart-Way-提问的智慧"><a href="#How-To-Ask-Questions-The-Smart-Way-提问的智慧" class="headerlink" title="How-To-Ask-Questions-The-Smart-Way(提问的智慧)"></a>How-To-Ask-Questions-The-Smart-Way(提问的智慧)</h2><p><a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way" target="_blank" rel="noopener">How-To-Ask-Questions-The-Smart-Way</a></p><p><img src="/2023/09/12/HelloGithub/image-20200412181036533.png" srcset="/img/loading.gif" alt="image-20200412181036533"></p><h2 id="glances-系统情况工具"><a href="#glances-系统情况工具" class="headerlink" title="glances 系统情况工具"></a>glances 系统情况工具</h2><p> <a href="https://github.com/nicolargo/glances" target="_blank" rel="noopener">glances</a> </p><p>安装： pip install glances </p><p><img src="/2023/09/12/HelloGithub/image-20200413110024289.png" srcset="/img/loading.gif" alt="image-20200413110024289"></p><h2 id="FeHelper（谷歌插件-前端助手）"><a href="#FeHelper（谷歌插件-前端助手）" class="headerlink" title="FeHelper（谷歌插件-前端助手）"></a>FeHelper（谷歌插件-前端助手）</h2><p> <a href="https://github.com/zxlie/FeHelper" target="_blank" rel="noopener">FeHelper</a> </p><p>Google插件开源项目</p><p><img src="/2023/09/12/HelloGithub/image-20200413114231663.png" srcset="/img/loading.gif" alt="image-20200413114231663"></p><h2 id="Rocketmq"><a href="#Rocketmq" class="headerlink" title="Rocketmq"></a>Rocketmq</h2><p> <a href="https://github.com/apache/rocketmq" target="_blank" rel="noopener">rocketmq</a> </p><p> Mirror of Apache RocketMQ ，啥都不多说了，消息中间件之一</p><h2 id="RAP（接口文档管理工具）"><a href="#RAP（接口文档管理工具）" class="headerlink" title="RAP（接口文档管理工具）"></a>RAP（接口文档管理工具）</h2><p> <a href="https://github.com/thx/RAP" target="_blank" rel="noopener">RAP</a> </p><p> Web接口管理工具，开源免费，接口自动化，MOCK数据自动生成，自动化测试，企业级管理。阿里妈妈MUX团队出品！阿里巴巴都在用！1000+公司的选择！RAP2已发布请移步至<a href="https://github.com/thx/rap2-delos" target="_blank" rel="noopener">https://github.com/thx/rap2-delos</a> <a href="http://rap2.taobao.org/" target="_blank" rel="noopener">http://rap2.taobao.org</a> </p><p><a href="http://rap2.taobao.org/account/login" target="_blank" rel="noopener">网站演示</a></p><p><img src="/2023/09/12/HelloGithub/image-20200414105038407.png" srcset="/img/loading.gif" alt="image-20200414105038407"></p><h2 id="500LineorLess-CN（500行Python代码能做什么）"><a href="#500LineorLess-CN（500行Python代码能做什么）" class="headerlink" title="500LineorLess_CN（500行Python代码能做什么）"></a>500LineorLess_CN（500行Python代码能做什么）</h2><p><a href="https://github.com/HT524/500LineorLess_CN" target="_blank" rel="noopener">500LineorLess_CN</a> </p><p>500 line or less 中文翻译计划。</p><p><img src="/2023/09/12/HelloGithub/image-20200414105546892.png" srcset="/img/loading.gif" alt="image-20200414105546892"></p><h2 id="nginx-book-Nginx书籍"><a href="#nginx-book-Nginx书籍" class="headerlink" title="nginx-book(Nginx书籍)"></a>nginx-book(Nginx书籍)</h2><p> <a href="https://github.com/taobao/nginx-book" target="_blank" rel="noopener">nginx-book</a> </p><p><img src="/2023/09/12/HelloGithub/image-20200415104300497.png" srcset="/img/loading.gif" alt="image-20200415104300497"></p><h2 id="chinese-programmer-wrong-pronunciation（单词发音）"><a href="#chinese-programmer-wrong-pronunciation（单词发音）" class="headerlink" title="chinese-programmer-wrong-pronunciation（单词发音）"></a>chinese-programmer-wrong-pronunciation（单词发音）</h2><p> <a href="https://github.com/shimohq/chinese-programmer-wrong-pronunciation" target="_blank" rel="noopener">chinese-programmer-wrong-pronunciation</a> </p><p><img src="/2023/09/12/HelloGithub/image-20200415104356658.png" srcset="/img/loading.gif" alt="image-20200415104356658"></p><h2 id="linux-command（Linux命令大全）"><a href="#linux-command（Linux命令大全）" class="headerlink" title="linux-command（Linux命令大全）"></a>linux-command（Linux命令大全）</h2><p> <a href="https://github.com/jaywcjlove/linux-command" target="_blank" rel="noopener">linux-command</a> </p><p><a href="https://wangchujiang.com/linux-command/" target="_blank" rel="noopener">演示网址</a></p><p><img src="/2023/09/12/HelloGithub/image-20200415104536532.png" srcset="/img/loading.gif" alt="image-20200415104536532"></p><h2 id="octotree（GitHub-GitLab目录结构化）"><a href="#octotree（GitHub-GitLab目录结构化）" class="headerlink" title="octotree（GitHub|GitLab目录结构化）"></a>octotree（GitHub|GitLab目录结构化）</h2><p> <a href="https://github.com/ovity/octotree" target="_blank" rel="noopener">octotree</a> </p><p> 为 GitHub 和 GitLab 网站，提供直观地显示项目目录结构的浏览器插件，效果如下： </p><p><img src="/2023/09/12/HelloGithub/image-20200416091429035.png" srcset="/img/loading.gif" alt="image-20200416091429035"></p><h2 id="bitbar（MacOS状态栏脚本）"><a href="#bitbar（MacOS状态栏脚本）" class="headerlink" title="bitbar（MacOS状态栏脚本）"></a>bitbar（MacOS状态栏脚本）</h2><p><a href="https://github.com/matryer/bitbar" target="_blank" rel="noopener">GitHub地址</a></p><p>Bitbar 是可以将任何（自己或别人写好的）脚本的<strong>输出</strong>到 Mac OS 的状态栏上。同时，支持自定义更新频率。例如：定时获取比特币的价格、HelloGitHub 项目的 star 数量，使用步骤如下：</p><ol><li>运行该程序，选择脚本所在目录</li><li>确保脚本的有执行权限，赋予执行权限的命令：<code>chmod +x script.sh</code></li><li>选择 <code>Refresh all</code>，刷新使之生效</li></ol><p><img src="/2023/09/12/HelloGithub/image-20200416091827444.png" srcset="/img/loading.gif" alt="image-20200416091827444"></p><h2 id="jumpserver（-专业运维安全审计系统-）"><a href="#jumpserver（-专业运维安全审计系统-）" class="headerlink" title="jumpserver（ 专业运维安全审计系统 ）"></a>jumpserver（ 专业运维安全审计系统 ）</h2><p> <a href="https://github.com/jumpserver/jumpserver" target="_blank" rel="noopener">jumpserver</a> </p><p><a href="http://www.jumpserver.org" target="_blank" rel="noopener">演示地址</a></p><p> JumpServer 是全球首款开源的堡垒机，是符合 4A 的专业运维安全审计系统。 <a href="http://www.jumpserver.org/" target="_blank" rel="noopener">http://www.jumpserver.org</a> </p><h2 id="locust（压测工具）"><a href="#locust（压测工具）" class="headerlink" title="locust（压测工具）"></a>locust（压测工具）</h2><p> <a href="https://github.com/locustio/locust" target="_blank" rel="noopener">locust</a> </p><p>Scalable user load testing tool written in Python <a href="http://locust.io/" target="_blank" rel="noopener">http://locust.io</a></p><p>基于Python语言编写脚本，基于协程单机并发性较高</p><p><a href="https://locust.io/" target="_blank" rel="noopener">官网地址</a></p><h2 id="cmder（Windows控制台）"><a href="#cmder（Windows控制台）" class="headerlink" title="cmder（Windows控制台）"></a>cmder（Windows控制台）</h2><p> <a href="https://github.com/cmderdev/cmder" target="_blank" rel="noopener">cmder</a> </p><p><a href="https://cmder.net/" target="_blank" rel="noopener">官方地址</a></p><p> Windows 控制台模拟器，运行效果如下： </p><p><img src="/2023/09/12/HelloGithub/image-20200417092129337.png" srcset="/img/loading.gif" alt="image-20200417092129337"></p><h2 id="PPRows-Mac代码行数统计"><a href="#PPRows-Mac代码行数统计" class="headerlink" title="PPRows(Mac代码行数统计)"></a>PPRows(Mac代码行数统计)</h2><p> <a href="https://github.com/jkpang/PPRows" target="_blank" rel="noopener">PPRows</a> </p><p> It Can Calculate how many lines of code you write on Mac ; 在Mac上计算你写了多少行代码 </p><h2 id="SwitchHosts-Windows切换Host工具"><a href="#SwitchHosts-Windows切换Host工具" class="headerlink" title="SwitchHosts(Windows切换Host工具)"></a>SwitchHosts(Windows切换Host工具)</h2><p> <a href="https://github.com/oldj/SwitchHosts" target="_blank" rel="noopener">SwitchHosts</a> </p><p><img src="/2023/09/12/HelloGithub/image-20200417092506878.png" srcset="/img/loading.gif" alt="image-20200417092506878"></p><h2 id="be-a-professional-programmer-大触之路的点点滴滴"><a href="#be-a-professional-programmer-大触之路的点点滴滴" class="headerlink" title="be-a-professional-programmer(大触之路的点点滴滴)"></a>be-a-professional-programmer(大触之路的点点滴滴)</h2><p> <a href="https://github.com/stanzhai/be-a-professional-programmer" target="_blank" rel="noopener">be-a-professional-programmer</a> </p><p> 成为专业程序员路上用到的各种优秀资料、神器及框架 <a href="http://tools.stanzhai.site/" target="_blank" rel="noopener">http://tools.stanzhai.site</a> </p><h2 id="Awesome（Windows平台的生产力工具）"><a href="#Awesome（Windows平台的生产力工具）" class="headerlink" title="Awesome（Windows平台的生产力工具）"></a>Awesome（Windows平台的生产力工具）</h2><p> 一个 Windows 上优质和精选的最佳应用程序及工具列表。 </p><p> <a href="https://github.com/Awesome-Windows/Awesome" target="_blank" rel="noopener">Awesome</a> </p><p><img src="/2023/09/12/HelloGithub/image-20200417092930459.png" srcset="/img/loading.gif" alt="image-20200417092930459"></p><h2 id="easy-service（Windows程序转为为服务工具）"><a href="#easy-service（Windows程序转为为服务工具）" class="headerlink" title="easy-service（Windows程序转为为服务工具）"></a>easy-service（Windows程序转为为服务工具）</h2><p> <a href="https://github.com/pandolia/easy-service" target="_blank" rel="noopener">easy-service</a> </p><p><strong>介绍</strong></p><p>如果你的 Windows 程序需要在后台长期运行，而且你希望它在开机后用户登录之前就自动运行、且在用户注销之后也不停止，那么你需要将程序注册为一个系统服务。</p><p>然而，在 Windows 下编写一个可注册为系统服务的程序并不是一件简单的事情。首先，程序必须是二进制的可执行程序，这就排除了脚本语言和虚拟机语言；其次，程序必须按系统服务的格式编写，过程繁琐，编写示例可见：<a href="https://code.msdn.microsoft.com/windowsapps/CppWindowsService-cacf4948" target="_blank" rel="noopener">MS 官方文档</a> 。</p><h2 id="jeecg-boot（-基于代码生成器的JAVA快速开发平台-）"><a href="#jeecg-boot（-基于代码生成器的JAVA快速开发平台-）" class="headerlink" title="jeecg-boot（ 基于代码生成器的JAVA快速开发平台 ）"></a>jeecg-boot（ 基于代码生成器的JAVA快速开发平台 ）</h2><p> <a href="https://github.com/zhangdaiscott/jeecg-boot" target="_blank" rel="noopener">jeecg-boot</a> </p><p> 一款基于代码生成器的JAVA快速开发平台，开源界“小普元”超越传统商业企业级开发平台！采用前后端分离架构：SpringBoot 2.x，Ant Design&amp;Vue，Mybatis-plus，Shiro，JWT。强大的代码生成器让前后端代码一键生成，无需写任何代码! 引领新的开发模式(OnlineCoding模式-&gt; 代码生成器模式-&gt; 手工MERGE智能开发)，帮助Java项目解决70%的重复工作，让开发更多关注业务逻辑。既能快速提高开发效率，帮助公司节省成本，同时又不失灵活性。JeecgBoot还独创在线开发模式（No代码）：在线表单配置（表单设计器）、移动配置能力、在线工作流配置（流程设计器）、在线报表配置、在线图表配置、插件能力（可插拔）等等 </p><p><a href="http://www.jeecg.com/" target="_blank" rel="noopener">官方演示地址</a> </p><h2 id="SQLAdvisor（SQL索引优化建议）"><a href="#SQLAdvisor（SQL索引优化建议）" class="headerlink" title="SQLAdvisor（SQL索引优化建议）"></a>SQLAdvisor（SQL索引优化建议）</h2><p><a href="https://github.com/Meituan-Dianping/SQLAdvisor" target="_blank" rel="noopener">SQLAdvisor</a></p><p>输入SQL，输出索引优化建议</p><p>SQLAdvisor是由美团点评公司技术工程部DBA团队（北京）开发维护的一个分析SQL给出索引优化建议的工具。它基于MySQL原生态词法解析，结合分析SQL中的where条件、聚合条件、多表Join关系 给出索引优化建议。<strong>目前SQLAdvisor在美团点评内部广泛应用，公司内部对SQLAdvisor的开发全面转到github上，开源和内部使用保持一致</strong>。</p><p><strong>主要功能：输出SQL索引优化建议</strong></p><h2 id="fsql（像写SQL一样搜索文件）"><a href="#fsql（像写SQL一样搜索文件）" class="headerlink" title="fsql（像写SQL一样搜索文件）"></a>fsql（像写SQL一样搜索文件）</h2><p><a href="https://github.com/kashav/fsql" target="_blank" rel="noopener">fsql</a></p><p><img src="/2023/09/12/HelloGithub/image-20200828095555596.png" srcset="/img/loading.gif" alt="image-20200828095555596"></p><h2 id="symphony（Java开源论坛项目）"><a href="#symphony（Java开源论坛项目）" class="headerlink" title="symphony（Java开源论坛项目）"></a>symphony（Java开源论坛项目）</h2><p><a href="https://github.com/88250/symphony" target="_blank" rel="noopener">symphony</a></p><p><a href="https://hacpai.com/" target="_blank" rel="noopener">官方演示地址</a></p><p><img src="/2023/09/12/HelloGithub/image-20200418201535012.png" srcset="/img/loading.gif" alt="image-20200418201535012"></p><h2 id="druid-阿里数据库连接池"><a href="#druid-阿里数据库连接池" class="headerlink" title="druid(阿里数据库连接池)"></a>druid(阿里数据库连接池)</h2><p><a href="https://github.com/alibaba/druid" target="_blank" rel="noopener">druid</a></p><p>阿里巴巴数据库事业部出品，为监控而生的数据库连接池 <a href="https://github.com/alibaba/druid/wiki" target="_blank" rel="noopener">https://github.com/alibaba/druid/wiki</a></p><h2 id="BrowserQuest（JavaScript多人在线游戏）"><a href="#BrowserQuest（JavaScript多人在线游戏）" class="headerlink" title="BrowserQuest（JavaScript多人在线游戏）"></a>BrowserQuest（JavaScript多人在线游戏）</h2><p><a href="https://github.com/mozilla/BrowserQuest" target="_blank" rel="noopener">BrowserQuest</a></p><p><img src="/2023/09/12/HelloGithub/image-20200418202724561.png" srcset="/img/loading.gif" alt="image-20200418202724561"></p><h2 id="chinese-copywriting-guidelines（中文排版指南）"><a href="#chinese-copywriting-guidelines（中文排版指南）" class="headerlink" title="chinese-copywriting-guidelines（中文排版指南）"></a>chinese-copywriting-guidelines（中文排版指南）</h2><p><a href="https://github.com/sparanoid/chinese-copywriting-guidelines" target="_blank" rel="noopener">chinese-copywriting-guidelines</a></p><p>中文文案排版指南</p><h2 id="ResumeSample（程序员简历模板）"><a href="#ResumeSample（程序员简历模板）" class="headerlink" title="ResumeSample（程序员简历模板）"></a>ResumeSample（程序员简历模板）</h2><p><a href="https://github.com/geekcompany/ResumeSample" target="_blank" rel="noopener">ResumeSample</a></p><p>Resume template for Chinese programmers . 程序员简历模板系列。包括PHP程序员简历模板、iOS程序员简历模板、Android程序员简历模板、Web前端程序员简历模板、Java程序员简历模板、C/C++程序员简历模板、NodeJS程序员简历模板、架构师简历模板以及通用程序员简历模板 <a href="http://get.jobdeer.com/744.get" target="_blank" rel="noopener">http://get.jobdeer.com/744.get</a></p><h2 id="ohmyzsh（终极-Shell）"><a href="#ohmyzsh（终极-Shell）" class="headerlink" title="ohmyzsh（终极 Shell）"></a>ohmyzsh（终极 Shell）</h2><p><a href="https://github.com/ohmyzsh/ohmyzsh" target="_blank" rel="noopener">ohmyzsh</a></p><p>一个能够让你快速上手，史称 “终极 Shell” zsh 的工具，让你感觉终端前所未有的好用。详细介绍 —— <a href="http://macshuo.com/?p=676" target="_blank" rel="noopener">MacTalk 之终极 Shell</a></p><h2 id="certbot（自动启用和部署-HTTPS-的工具）"><a href="#certbot（自动启用和部署-HTTPS-的工具）" class="headerlink" title="certbot（自动启用和部署 HTTPS 的工具）"></a>certbot（自动启用和部署 HTTPS 的工具）</h2><p><a href="https://github.com/certbot/certbot" target="_blank" rel="noopener">certbot</a></p><p>免费的自动启用和部署 HTTPS 的工具，让你的网站开启 HTTPS 变得简单快捷。在部署教程页面选择服务器的操作系统和 Web 服务器，之后根据给出的步骤一步步的执行命令就行了，<a href="https://certbot.eff.org/" target="_blank" rel="noopener">部署教程</a><br><img src="/2023/09/12/HelloGithub/cerbot-show-min.png" srcset="/img/loading.gif" alt="certbot"></p><h2 id="server（开源云存储平台）"><a href="#server（开源云存储平台）" class="headerlink" title="server（开源云存储平台）"></a>server（开源云存储平台）</h2><p><a href="https://github.com/nextcloud/server" target="_blank" rel="noopener">server</a></p><p>开源云存储平台，功能齐全，可以用于搭建公司内部的云存储平台</p><h2 id="Rental（58同城租房信息爬虫）"><a href="#Rental（58同城租房信息爬虫）" class="headerlink" title="Rental（58同城租房信息爬虫）"></a>Rental（58同城租房信息爬虫）</h2><p><a href="https://github.com/answershuto/Rental" target="_blank" rel="noopener">Rental</a></p><p>一款租房 APP，基于 Node.js 爬虫，爬取 58 同城租房信息，并用地图进行可视化展示，方便用户获取周围租房</p><h2 id="ForestBlog（SSM个人博客）"><a href="#ForestBlog（SSM个人博客）" class="headerlink" title="ForestBlog（SSM个人博客）"></a>ForestBlog（SSM个人博客）</h2><p>一个简单漂亮的SSM(Spring+SpringMVC+Mybatis)博客系统，功能齐全，拓展性以及复用性很好，适合二次开发，值得学习，同时有文件系统支撑以及富文本编辑器的模块</p><p><a href="https://github.com/saysky/ForestBlog" target="_blank" rel="noopener">ForestBlog</a></p><h2 id="owncloud-core（私有云服务，搭建本地云盘）"><a href="#owncloud-core（私有云服务，搭建本地云盘）" class="headerlink" title="owncloud/core（私有云服务，搭建本地云盘）"></a>owncloud/core（私有云服务，搭建本地云盘）</h2><p><a href="https://github.com/owncloud" target="_blank" rel="noopener">owncloud</a>/<strong><a href="https://github.com/owncloud/core" target="_blank" rel="noopener">core</a></strong></p><p><img src="/2023/09/12/HelloGithub/image-20200420185507454.png" srcset="/img/loading.gif" alt="image-20200420185507454"></p><h2 id="VerificationCode（滑动验证码Demo）"><a href="#VerificationCode（滑动验证码Demo）" class="headerlink" title="VerificationCode（滑动验证码Demo）"></a>VerificationCode（滑动验证码Demo）</h2><p> <a href="https://github.com/eatage/VerificationCode" target="_blank" rel="noopener">VerificationCode</a> </p><p><img src="/2023/09/12/HelloGithub/image-20200420091623861.png" srcset="/img/loading.gif" alt="image-20200420091623861"></p><h2 id="mvvm（MVVM框架教程）"><a href="#mvvm（MVVM框架教程）" class="headerlink" title="mvvm（MVVM框架教程）"></a>mvvm（MVVM框架教程）</h2><p> <a href="https://github.com/DMQ/mvvm" target="_blank" rel="noopener">mvvm</a> </p><p> 剖析vue实现原理，自己动手实现mvvm </p><h2 id="useful-scripts（实用的脚本-）"><a href="#useful-scripts（实用的脚本-）" class="headerlink" title="useful-scripts（实用的脚本 ）"></a>useful-scripts（实用的脚本 ）</h2><p> <a href="https://github.com/oldratlee/useful-scripts" target="_blank" rel="noopener">useful-scripts</a> </p><p> 👉 把平时有用的手动操作做成脚本，这样可以便捷的使用。 ✨ </p><p><img src="/2023/09/12/HelloGithub/image-20200420092455718.png" srcset="/img/loading.gif" alt="image-20200420092455718"></p><h2 id="feather（Simple图标库）"><a href="#feather（Simple图标库）" class="headerlink" title="feather（Simple图标库）"></a>feather（Simple图标库）</h2><p> <a href="https://github.com/feathericons/feather" target="_blank" rel="noopener">feather</a> </p><p><a href="https://feathericons.com/" target="_blank" rel="noopener">官方演示地址</a></p><p><img src="/2023/09/12/HelloGithub/image-20200420092836840.png" srcset="/img/loading.gif" alt="image-20200420092836840"></p><h2 id="lx-music-desktop（全网音乐播放器）"><a href="#lx-music-desktop（全网音乐播放器）" class="headerlink" title="lx-music-desktop（全网音乐播放器）"></a>lx-music-desktop（全网音乐播放器）</h2><p> <a href="https://github.com/lyswhut/lx-music-desktop" target="_blank" rel="noopener">lx-music-desktop</a> </p><p><img src="/2023/09/12/HelloGithub/image-20200421095532511.png" srcset="/img/loading.gif" alt="image-20200421095532511"></p><h2 id="fontawesome（矢量Icon库）"><a href="#fontawesome（矢量Icon库）" class="headerlink" title="fontawesome（矢量Icon库）"></a>fontawesome（矢量Icon库）</h2><p><a href="http://www.fontawesome.com.cn/" target="_blank" rel="noopener">官方中文访问地址</a></p><p><img src="/2023/09/12/HelloGithub/image-20200421115524145.png" srcset="/img/loading.gif" alt="image-20200421115524145"></p><h2 id="elasticsearch-sql-用SQL操作ES"><a href="#elasticsearch-sql-用SQL操作ES" class="headerlink" title="elasticsearch-sql(用SQL操作ES)"></a>elasticsearch-sql(用SQL操作ES)</h2><p> <a href="https://github.com/NLPchina/elasticsearch-sql" target="_blank" rel="noopener">elasticsearch-sql</a> </p><p><a href="http://essql.nlpcn.org/" target="_blank" rel="noopener">官方地址</a></p><p><img src="/2023/09/12/HelloGithub/image-20200421133737012.png" srcset="/img/loading.gif" alt="image-20200421133737012"></p><h2 id="pyecharts-Python-amp-Echarts"><a href="#pyecharts-Python-amp-Echarts" class="headerlink" title="pyecharts(Python &amp; Echarts)"></a>pyecharts(Python &amp; Echarts)</h2><p> <a href="https://github.com/pyecharts/pyecharts" target="_blank" rel="noopener">pyecharts</a> </p><p> <a href="https://pyecharts.org/" target="_blank" rel="noopener">官方演示地址</a> </p><p><img src="/2023/09/12/HelloGithub/image-20200421134129020.png" srcset="/img/loading.gif" alt="image-20200421134129020"></p><h2 id="weibospider-Python-微博爬虫"><a href="#weibospider-Python-微博爬虫" class="headerlink" title="weibospider(Python 微博爬虫)"></a>weibospider(Python 微博爬虫)</h2><p> <a href="https://github.com/SpiderClub/weibospider" target="_blank" rel="noopener">weibospider</a> </p><p>项目亮点 ⭐</p><ul><li><p>功能全面：包括了<strong>用户信息抓取</strong>、<strong>指定关键字搜索结果增量抓取</strong>、<strong>指定用户主页所有原创微博抓取</strong>、<strong>评论抓取</strong>和<strong>转发关系抓取</strong>等</p></li><li><p>数据全面：<strong>PC端展现的数据量比移动端更加丰富</strong>。并且相比于<em>其它同类项目</em>对微博的简单分析，本项目做了大量细致的工作， 比如不同<code>domain</code>不同用户的解析策略、不同<code>domain</code>不同用户的主页分析策略等</p></li><li><p>复用性和扩展性好。项目很多地方都有详细的代码注释，方便阅读。即使本项目不能完全满足你对微博数据采集和分析的需求，你完全可以在该项目的基础上 做二次开发，项目已经在微博数据采集和模版解析上做了大量工作。</p></li><li><p>该项目会长期更新，目前已经迭代一年有余了。</p></li></ul><h2 id="newspaper（Web内容提取器）"><a href="#newspaper（Web内容提取器）" class="headerlink" title="newspaper（Web内容提取器）"></a>newspaper（Web内容提取器）</h2><p> 强大的提取 Web 的内容、文章的库，支持多种语言，安装命令 <code>pip3 install newspaper3k</code> </p><p> <a href="https://github.com/codelucas/newspaper" target="_blank" rel="noopener">newspaper</a> </p><h2 id="faker（-生成假数据的库-）"><a href="#faker（-生成假数据的库-）" class="headerlink" title="faker（ 生成假数据的库 ）"></a>faker（ 生成假数据的库 ）</h2><p> <a href="https://github.com/joke2k/faker" target="_blank" rel="noopener">faker</a> </p><pre><code class="hljs python">fake.address()<span class="hljs-comment"># '辽宁省雪市静安廉街b座 998259'</span>fake.street_address()<span class="hljs-comment"># '巢湖街U座'</span>fake.building_number()<span class="hljs-comment"># 'x座'</span></code></pre><h2 id="china-area-mysql-中国-5-级行政区域MySQL-库"><a href="#china-area-mysql-中国-5-级行政区域MySQL-库" class="headerlink" title="china_area_mysql( 中国 5 级行政区域MySQL 库 )"></a>china_area_mysql( 中国 5 级行政区域MySQL 库 )</h2><p><a href="https://github.com/kakuilan/china_area_mysql" target="_blank" rel="noopener">china_area_mysql</a> </p><p><strong>中国5级行政区域mysql库</strong></p><p>爬取国家统计局官网的行政区域数据,包括省市县镇村5个层级;</p><p>港澳地区的数据只有3级;台湾地区4级;</p><p>包含大陆地区的邮政编码和经纬度信息.</p><h2 id="open-source-team-中国顶尖团队开源库汇总"><a href="#open-source-team-中国顶尖团队开源库汇总" class="headerlink" title="open_source_team(中国顶尖团队开源库汇总)"></a>open_source_team(中国顶尖团队开源库汇总)</h2><p><a href="https://github.com/niezhiyang/open_source_team" target="_blank" rel="noopener">open_source_team</a> </p><p><img src="/2023/09/12/HelloGithub/image-20200422095016798.png" srcset="/img/loading.gif" alt="image-20200422095016798"></p><h2 id="ctop（Docker容器-监控）"><a href="#ctop（Docker容器-监控）" class="headerlink" title="ctop（Docker容器 监控）"></a>ctop（Docker容器 监控）</h2><p><a href="https://github.com/bcicen/ctop" target="_blank" rel="noopener">ctop</a></p><p><img src="/2023/09/12/HelloGithub/image-20200424001200085.png" srcset="/img/loading.gif" alt="image-20200424001200085"></p><h2 id="HanLP（NLP-工具包）"><a href="#HanLP（NLP-工具包）" class="headerlink" title="HanLP（NLP 工具包）"></a>HanLP（NLP 工具包）</h2><p><a href="https://github.com/hankcs/HanLP" target="_blank" rel="noopener">HanLP</a></p><p>一系列模型与算法组成的 NLP 工具包，目标是普及自然语言处理在生产环境中的应用。具备功能完善、性能高效、架构清晰、语料时新、可自定义的特点，功能包括：中文分词、词性标注、命名实体识别、关键词提取等。示例代码：</p><pre><code class="hljs java">String[] testCase = <span class="hljs-keyword">new</span> String[]&#123;    <span class="hljs-string">"北川景子参演了林诣彬导演的《速度与激情3》"</span>,    <span class="hljs-string">"林志玲亮相网友:确定不是波多野结衣？"</span>,&#125;;Segment segment = HanLP.newSegment().enableJapaneseNameRecognize(<span class="hljs-keyword">true</span>);<span class="hljs-keyword">for</span> (String sentence : testCase)&#123;    List termList = segment.seg(sentence);    System.out.println(termList);&#125;</code></pre><h2 id="wxapp-market（小程序营销组件）"><a href="#wxapp-market（小程序营销组件）" class="headerlink" title="wxapp-market（小程序营销组件）"></a>wxapp-market（小程序营销组件）</h2><p><a href="https://github.com/o2team/wxapp-market" target="_blank" rel="noopener">wxapp-market</a></p><p>小程序营销组件，使用简单、方式齐全。包含示例代码，玩法多样</p><ul><li>大转盘</li><li>刮刮乐</li><li>老虎机</li><li>水果机</li><li>…</li></ul><p><img src="/2023/09/12/HelloGithub/image-20200828095642344.png" srcset="/img/loading.gif" alt="image-20200828095642344"></p><h2 id="❤️emoji-MarkDown表情库"><a href="#❤️emoji-MarkDown表情库" class="headerlink" title="❤️emoji(MarkDown表情库)"></a>❤️emoji(MarkDown表情库)</h2><p><a href="https://emoji.svend.cc/" target="_blank" rel="noopener">官方演示地址</a></p><p><a href="https://github.com/gee1k/emoji" target="_blank" rel="noopener">emoji</a></p><p>Demo：💚💚💚💚💚💚💚💚💚💚💚💚💚</p><p><img src="/2023/09/12/HelloGithub/image-20200424001525467.png" srcset="/img/loading.gif" alt="image-20200424001525467"></p><h2 id="binlog2sql（从-MySQL-binlog-解析出你要的-SQL）"><a href="#binlog2sql（从-MySQL-binlog-解析出你要的-SQL）" class="headerlink" title="binlog2sql（从 MySQL binlog 解析出你要的 SQL）"></a>binlog2sql（从 MySQL binlog 解析出你要的 SQL）</h2><p><a href="https://github.com/danfengcao/binlog2sql" target="_blank" rel="noopener">binlog2sql</a></p><p>从 MySQL binlog 解析出你要的 SQL。根据不同选项，提供如下功能</p><ul><li>数据快速回滚，<a href="https://github.com/danfengcao/binlog2sql/blob/master/example/mysql-flashback-priciple-and-practice.md" target="_blank" rel="noopener">闪回原理与实践</a></li><li>主从切换后新 master 丢数据的修复</li><li>从 binlog 生成标准SQL，带来的衍生功能</li></ul><h2 id="ItChat（Python调用微信）"><a href="#ItChat（Python调用微信）" class="headerlink" title="ItChat（Python调用微信）"></a>ItChat（Python调用微信）</h2><p><a href="https://github.com/littlecodersh/ItChat" target="_blank" rel="noopener">ItChat</a></p><p>开源的微信个人号SDK，提供了丰富的功能。从而使得 Python 调用微信、发送消息、传输文件等操作只需要编写极少的代码，示例代码如下：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> itchatitchat.auto_login()itchat.send(<span class="hljs-string">'Hello, filehelper'</span>, toUserName=<span class="hljs-string">'filehelper'</span>)</code></pre><h2 id="Amazing-Windows-Apps-Windows软件推荐集合"><a href="#Amazing-Windows-Apps-Windows软件推荐集合" class="headerlink" title="Amazing-Windows-Apps(Windows软件推荐集合)"></a>Amazing-Windows-Apps(Windows软件推荐集合)</h2><p><a href="https://github.com/AmazingApps/Amazing-Windows-Apps" target="_blank" rel="noopener">Amazing-Windows-Apps</a></p><p>注意切换至master分支</p><p>该项目收录了众多 Windows 绝妙的项目、工具。这些软件都是经过测试，安全、免费、好用，<a href="https://github.com/AmazingApps/Amazing-Windows-Apps/tree/master/zh-CN" target="_blank" rel="noopener">在线阅读</a></p><h2 id="chinese-poetry（中国古典数据集）"><a href="#chinese-poetry（中国古典数据集）" class="headerlink" title="chinese-poetry（中国古典数据集）"></a>chinese-poetry（中国古典数据集）</h2><p><a href="https://github.com/chinese-poetry/chinese-poetry" target="_blank" rel="noopener">chinese-poetry</a></p><p>The most comprehensive database of Chinese poetry 🧶最全中华古诗词数据库, 唐宋两朝近一万四千古诗人, 接近5.5万首唐诗加26万宋诗. 两宋时期1564位词人，21050首词。 <a href="http://shici.store/" target="_blank" rel="noopener">中华诗歌</a></p><h2 id="awesome-java-leetcode（-各大-IT-公司的算法笔试面试题-）"><a href="#awesome-java-leetcode（-各大-IT-公司的算法笔试面试题-）" class="headerlink" title="awesome-java-leetcode（ 各大 IT 公司的算法笔试面试题 ）"></a>awesome-java-leetcode（ 各大 IT 公司的算法笔试面试题 ）</h2><p> <a href="https://github.com/Blankj/awesome-java-leetcode" target="_blank" rel="noopener">awesome-java-leetcode</a> </p><p> 👑 LeetCode of algorithms with java solution(updating). </p><h2 id="handsontable（-HTML5-表格处理工具-）"><a href="#handsontable（-HTML5-表格处理工具-）" class="headerlink" title="handsontable（ HTML5 表格处理工具 ）"></a>handsontable（ HTML5 表格处理工具 ）</h2><p> <a href="https://github.com/handsontable/handsontable" target="_blank" rel="noopener">handsontable</a> </p><p> 强大的开源 HTML5 表格处理工具，适用于中后台的很多业务场景。API 方便、扩展性好、可操作性强，与Execl 等表格处理程序兼容好。并支持非常丰富的操作，如数据绑定、验证、排序及强大的上下文菜单。 </p><h2 id="EasyCode（IDEA代码生成器插件）"><a href="#EasyCode（IDEA代码生成器插件）" class="headerlink" title="EasyCode（IDEA代码生成器插件）"></a>EasyCode（IDEA代码生成器插件）</h2><p><a href="https://gitee.com/makejava/EasyCode" target="_blank" rel="noopener">gitee-EasyCode</a></p><p>EasyCode是基于IntelliJ IDEA开发的代码生成插件，支持自定义任意模板（Java，html，js，xml）。只要是与数据库相关的代码都可以通过自定义模板来生成。支持数据库类型与java类型映射关系配置。支持同时生成生成多张表的代码。每张表有独立的配置信息。完全的个性化定义，规则由你设置。</p><h2 id="wiki（-知识分享平台）"><a href="#wiki（-知识分享平台）" class="headerlink" title="wiki（ 知识分享平台）"></a>wiki（ 知识分享平台）</h2><p> <a href="https://github.com/Requarks/wiki" target="_blank" rel="noopener">wiki</a> </p><p><a href="https://docs.requarks.io/" target="_blank" rel="noopener">演示地址</a></p><p> NodeJS+Git+Markdown 实现轻松搭建 wiki。对于团队内部的知识分享是一个不错的选择。<a href="https://docs.requarks.io/wiki" target="_blank" rel="noopener">在线预览</a> </p><h2 id="toapi（数据爬取-构建成Api）"><a href="#toapi（数据爬取-构建成Api）" class="headerlink" title="toapi（数据爬取+构建成Api）"></a>toapi（数据爬取+构建成Api）</h2><p> <a href="https://github.com/gaojiuli/toapi" target="_blank" rel="noopener">toapi</a> </p><p> 该项目做的事儿是通过简单的配置把目标网页的内容爬下来，缓存结果后提供成 API 的一条龙服务。 </p><p><img src="/2023/09/12/HelloGithub/image-20200428092902021.png" srcset="/img/loading.gif" alt="image-20200428092902021"></p><h2 id="redash（-据可视化-Web-项目-）"><a href="#redash（-据可视化-Web-项目-）" class="headerlink" title="redash（ 据可视化 Web 项目 ）"></a>redash（ 据可视化 Web 项目 ）</h2><p><a href="https://github.com/getredash/redash" target="_blank" rel="noopener">redash</a> </p><p>开源的数据可视化 Web 项目，提供了数据库查询和数据可视化功能。只提供的数据可视化最要的功能，使得简单易用且容易上手。可以直观地将一个 SQL 查询的结果可视化出来。同时提供 SQL 代码片段存储，减少重复编写 SQL 的问题 </p><p><img src="/2023/09/12/HelloGithub/image-20200828095719234.png" srcset="/img/loading.gif" alt="image-20200828095719234"></p><h2 id="reading-code-of-nginx-1-9-2（Nginx源码阅读）"><a href="#reading-code-of-nginx-1-9-2（Nginx源码阅读）" class="headerlink" title="reading-code-of-nginx-1.9.2（Nginx源码阅读）"></a>reading-code-of-nginx-1.9.2（Nginx源码阅读）</h2><p>nginx-1.9.2 源码通读分析注释，带详尽函数中文分析注释以及相关函数流程调用注释</p><p> <a href="https://github.com/y123456yz/reading-code-of-nginx-1.9.2" target="_blank" rel="noopener">reading-code-of-nginx-1.9.2</a> </p><h2 id="chrome-music-lab（-Chrome-音乐实验室-）"><a href="#chrome-music-lab（-Chrome-音乐实验室-）" class="headerlink" title="chrome-music-lab（ Chrome 音乐实验室 ）"></a>chrome-music-lab（ Chrome 音乐实验室 ）</h2><p> Chrome 音乐实验室是一个网站，让学习音乐变得更加简单、好玩。完全基于Web端，国内可直接访问、老少皆宜、支持多种乐器，圆你一个音乐梦 </p><p><a href="http://musiclab.chromeexperiments.com/" target="_blank" rel="noopener">演示地址</a></p><p> <a href="https://github.com/googlecreativelab/chrome-music-lab" target="_blank" rel="noopener">chrome-music-lab</a> </p><p><img src="/2023/09/12/HelloGithub/image-20200429154632043.png" srcset="/img/loading.gif" alt="image-20200429154632043"></p><h2 id="mpvue（基于Vue的微信小程序框架）"><a href="#mpvue（基于Vue的微信小程序框架）" class="headerlink" title="mpvue（基于Vue的微信小程序框架）"></a>mpvue（基于Vue的微信小程序框架）</h2><p> <a href="http://mpvue.com/" target="_blank" rel="noopener">演示地址</a> </p><p> <a href="https://github.com/Meituan-Dianping/mpvue" target="_blank" rel="noopener">mpvue</a> </p><p>小程序的前端框架。框架基于 Vue.js 核心，修改了 Vue.js 的 runtime 和 compiler 实现。使其可以运行在小程序环境中，为小程序开发引入了整套 Vue.js 开发体验。<a href="http://mpvue.com/mpvue/quickstart/" target="_blank" rel="noopener">5 分钟上手视频</a></p><ul><li>彻底的组件化开发能力：提高代码复用性</li><li>完整的 Vue.js 开发体验</li><li>方便的 Vuex 数据管理方案：方便构建复杂应用</li><li>快捷的 webpack 构建机制：自定义构建策略、开发阶段 hotReload</li><li>支持使用 npm 外部依赖</li><li>使用 Vue.js 命令行工具 vue-cli 快速初始化项目</li><li>H5 代码转换编译成小程序目标代码的能力</li></ul><h2 id="30-seconds-of-code（30s代码理解）"><a href="#30-seconds-of-code（30s代码理解）" class="headerlink" title="30-seconds-of-code（30s代码理解）"></a>30-seconds-of-code（30s代码理解）</h2><p> <a href="https://github.com/30-seconds/30-seconds-of-code" target="_blank" rel="noopener">30-seconds-of-code</a> </p><p> 精选可以在 30秒 或更短的时间内理解的实用 JavaScript 代码片段集合<br><img src="/2023/09/12/HelloGithub/30-seconds-show-min.png" srcset="/img/loading.gif" alt="30-seconds-of-code"> </p><h2 id="blog（-蚂蚁数据体验技术团队的博客-）"><a href="#blog（-蚂蚁数据体验技术团队的博客-）" class="headerlink" title="blog（ 蚂蚁数据体验技术团队的博客 ）"></a>blog（ 蚂蚁数据体验技术团队的博客 ）</h2><p> <a href="https://github.com/ProtoTeam/blog" target="_blank" rel="noopener">blog</a> </p><p> 蚂蚁数据体验技术团队的博客 </p><h2 id="tabler（-Bootstrap-4-免费开源的-Dashboard-模版-）"><a href="#tabler（-Bootstrap-4-免费开源的-Dashboard-模版-）" class="headerlink" title="tabler（ Bootstrap 4 免费开源的 Dashboard 模版 ）"></a>tabler（ Bootstrap 4 免费开源的 Dashboard 模版 ）</h2><p> <a href="https://github.com/tabler/tabler" target="_blank" rel="noopener">tabler</a> </p><p> 一套基于 Bootstrap 4 免费开源的 Dashboard 模版</p><p> <img src="/2023/09/12/HelloGithub/tabler-show-min.png" srcset="/img/loading.gif" alt="tabler"> </p><h2 id="❤️vuepress（-Vue-官方出品的静态网站生成器-）"><a href="#❤️vuepress（-Vue-官方出品的静态网站生成器-）" class="headerlink" title="❤️vuepress（  Vue 官方出品的静态网站生成器  ）"></a>❤️vuepress（  Vue 官方出品的静态网站生成器  ）</h2><p> <a href="https://github.com/vuejs/vuepress" target="_blank" rel="noopener">vuepress</a> </p><p><a href="https://vuepress.vuejs.org/" target="_blank" rel="noopener">演示地址</a></p><p> Vue 官方出品的静态网站生成器。大家的个人博客是不是要折腾一番了？<a href="https://vuepress.vuejs.org/zh/guide/" target="_blank" rel="noopener">官方中文文档</a> </p><h2 id="❤️simpread（简悦-谷歌插件）"><a href="#❤️simpread（简悦-谷歌插件）" class="headerlink" title="❤️simpread（简悦 谷歌插件）"></a>❤️simpread（简悦 谷歌插件）</h2><p><a href="https://github.com/Kenshin/simpread" target="_blank" rel="noopener">simpread</a></p><p>简悦 ( SimpRead ) - 让你瞬间进入沉浸式阅读的扩展 <a href="http://ksria.com/simpread" target="_blank" rel="noopener">http://ksria.com/simpread</a></p><p>谷歌插件好评度：5星<br>安装人数10W+</p><p><img src="/2023/09/12/HelloGithub/image-20200504101925998.png" srcset="/img/loading.gif" alt="image-20200504101925998"></p><h2 id="vjtools（唯品会的-Java-技术干货分享）"><a href="#vjtools（唯品会的-Java-技术干货分享）" class="headerlink" title="vjtools（唯品会的 Java 技术干货分享）"></a>vjtools（唯品会的 Java 技术干货分享）</h2><p><a href="https://github.com/vipshop/vjtools" target="_blank" rel="noopener">vjtools</a></p><p>主力于Java的唯品会，关于Java的一些小家底。</p><p>各位看官看着是好的，烦请“Star”。</p><p><a href="https://github.com/vipshop/vjtools/releases/tag/v.1.0.8" target="_blank" rel="noopener">1.0.8版</a> - 2018.9.24</p><h2 id="Auto-js（安卓自动化工具）"><a href="#Auto-js（安卓自动化工具）" class="headerlink" title="Auto.js（安卓自动化工具）"></a>Auto.js（安卓自动化工具）</h2><p><a href="https://github.com/hyb1996/Auto.js" target="_blank" rel="noopener">Auto.js</a></p><p>不需要 ROOT 权限的类似按键精灵的自动操作软件，可以实现自动点击、滑动、输入文字、打开应用等。Auto.js 的大部分用户用它来点赞、签到、刷游戏</p><h2 id="DesktopNaotu（百度桌面版思维导图）"><a href="#DesktopNaotu（百度桌面版思维导图）" class="headerlink" title="DesktopNaotu（百度桌面版思维导图）"></a>DesktopNaotu（百度桌面版思维导图）</h2><p><a href="https://github.com/NaoTu/DesktopNaotu" target="_blank" rel="noopener">DesktopNaotu</a></p><p>桌面版脑图是基于百度脑图的本地化版本，帮助你在没有互联网环境的情况下，依然可以使用脑图工具。开箱即用，跨平台支持 Windows/Linux/Mac OS。桌面版思维工具，目前 Xmind 使用很多，但是需要收费，对于不常用，要求没有严格可以考虑此项目</p><h2 id="Best-App（苹果系统下各种推荐）"><a href="#Best-App（苹果系统下各种推荐）" class="headerlink" title="Best-App（苹果系统下各种推荐）"></a>Best-App（苹果系统下各种推荐）</h2><p><a href="https://github.com/hzlzh/Best-App" target="_blank" rel="noopener">Best-App</a></p><p>收集&amp;推荐优秀的 Apps/硬件/技巧/周边等</p><p><strong>总目录</strong></p><p>欢迎大家推荐好的 App/产品 加入，请<code>Star</code>、<code>Pull Request</code>或在 <a href="https://github.com/hzlzh/Best-App/issues" target="_blank" rel="noopener">收集&amp;提交页</a> 中提交 :)</p><ol><li><a href="https://github.com/hzlzh/Best-App/blob/master/README.md" target="_blank" rel="noopener">付费 Apps 推荐列表(macOS)</a></li><li><a href="https://github.com/hzlzh/Best-App/blob/master/Best-App-iOS.md" target="_blank" rel="noopener">付费 Apps 推荐列表(iOS &amp; Cydia)</a></li><li><a href="https://github.com/hzlzh/Best-App/blob/master/Best-App-Mac-Free.md" target="_blank" rel="noopener">免费 Apps 推荐(macOS)</a> - 整理中…</li><li><a href="https://github.com/hzlzh/Best-App/blob/master/Best-App-iOS-Free.md" target="_blank" rel="noopener">免费 Apps 推荐列表(iOS &amp; Cydia)</a> - 整理中…</li><li><a href="https://github.com/hzlzh/Best-App/blob/master/Best-Accessories-Apple.md" target="_blank" rel="noopener">苹果设备 周边&amp;配件 推荐列表</a></li><li><a href="https://github.com/hzlzh/Best-App/blob/master/Best-App-Android.md" target="_blank" rel="noopener">付费 Apps 推荐列表(Android)</a> - 整理中…</li><li><a href="https://github.com/hzlzh/Best-App/blob/master/Best-Life-Products.md" target="_blank" rel="noopener">改善生活+提升幸福度物品 推荐列表</a> - 整理中…</li></ol><h2 id="❤️awescnb（博客园自定义皮肤）"><a href="#❤️awescnb（博客园自定义皮肤）" class="headerlink" title="❤️awescnb（博客园自定义皮肤）"></a>❤️awescnb（博客园自定义皮肤）</h2><p><a href="https://gitee.com/guangzan/awescnb" target="_blank" rel="noopener">码云地址</a></p><p><a href="[https://guangzan.gitee.io/awescnb-docs/guide/use/options.html#theme%EF%BC%88%E5%85%A8%E5%B1%80%E4%B8%BB%E9%A2%98%EF%BC%89](https://guangzan.gitee.io/awescnb-docs/guide/use/options.html#theme（全局主题）)">文档地址</a></p><p>可快速构建博客园皮肤样式</p><p>效果图：</p><p><img src="/2023/09/12/HelloGithub/image-20200505164102620.png" srcset="/img/loading.gif" alt="image-20200505164102620"></p><h2 id="❤️system-design-primer（架构级教程）"><a href="#❤️system-design-primer（架构级教程）" class="headerlink" title="❤️system-design-primer（架构级教程）"></a>❤️system-design-primer（架构级教程）</h2><p><a href="https://github.com/donnemartin/system-design-primer" target="_blank" rel="noopener">system-design-primer</a></p><p>学习如何设计可扩展的系统将帮助你成为一个更好的工程师。这个仓库就是整理、收集系统设计方面的资源。<a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md" target="_blank" rel="noopener">中文版</a></p><p><img src="/2023/09/12/HelloGithub/image-20200506142834984.png" srcset="/img/loading.gif" alt="image-20200506142834984"></p><h2 id="skill-map（技能知识图谱）"><a href="#skill-map（技能知识图谱）" class="headerlink" title="skill-map（技能知识图谱）"></a>skill-map（技能知识图谱）</h2><p><a href="https://github.com/TeamStuQ/skill-map" target="_blank" rel="noopener">skill-map</a></p><p>程序员技能图谱是由极客邦科技发起的一个技术社区开源项目。汇集、整理、共建泛 IT 技术领域（人工智能，前端开发，移动开发、后端开发等）、互联网产品、运营等领域学习技能图谱，帮助程序员梳理知识框架结构。并尝试提供路径指导和精华资源，方便大家学习成长</p><h2 id="redis-3-0-annotated（redis-源码注释C语言）"><a href="#redis-3-0-annotated（redis-源码注释C语言）" class="headerlink" title="redis-3.0-annotated（redis 源码注释C语言）"></a>redis-3.0-annotated（redis 源码注释C语言）</h2><p><a href="https://github.com/huangz1990/redis-3.0-annotated" target="_blank" rel="noopener">redis-3.0-annotated</a></p><p>带有详细注释的 Redis 3.0 代码（annotated Redis 3.0 source code）。</p><h2 id="git-bug（Git中的BUG管理工具）"><a href="#git-bug（Git中的BUG管理工具）" class="headerlink" title="git-bug（Git中的BUG管理工具）"></a>git-bug（Git中的BUG管理工具）</h2><p><a href="https://github.com/MichaelMure/git-bug" target="_blank" rel="noopener">git-bug</a></p><p>嵌入在 Git 中的分布式 bug 追踪、管理系统。用来管理 git 项目的 bug，这些信息会被存在 <code>.git</code> 文件夹里，所以其他人克隆也能看到 bug，不需要而外的存储系统。</p><h2 id="snibox（代码片段记录工具）"><a href="#snibox（代码片段记录工具）" class="headerlink" title="snibox（代码片段记录工具）"></a>snibox（代码片段记录工具）</h2><p><a href="https://github.com/snibox/snibox" target="_blank" rel="noopener">snibox</a></p><p>代码片段管理器。支持各种编程语言的代码片段、Markdown、纯文本</p><p><img src="/2023/09/12/HelloGithub/image-20200506143637120.png" srcset="/img/loading.gif" alt="image-20200506143637120"></p><h2 id="❤️hotkeys-JavaScript-键盘监听工具"><a href="#❤️hotkeys-JavaScript-键盘监听工具" class="headerlink" title="❤️hotkeys(JavaScript 键盘监听工具)"></a>❤️hotkeys(JavaScript 键盘监听工具)</h2><p><a href="https://github.com/jaywcjlove/hotkeys" target="_blank" rel="noopener">hotkeys</a></p><p>一个强健的 Javascript 库用于捕获键盘输入和输入的组合键。它没有依赖，压缩只有 3kb 左右。<a href="https://wangchujiang.com/hotkeys/" target="_blank" rel="noopener">在线展示</a></p><h2 id="octicons（GitHub-官方开源的-GitHub-网站上用的图标库）"><a href="#octicons（GitHub-官方开源的-GitHub-网站上用的图标库）" class="headerlink" title="octicons（GitHub 官方开源的 GitHub 网站上用的图标库）"></a>octicons（GitHub 官方开源的 GitHub 网站上用的图标库）</h2><p><a href="https://github.com/primer/octicons" target="_blank" rel="noopener">octicons</a></p><p><a href="https://primer.style/octicons/" target="_blank" rel="noopener">演示地址</a></p><p><img src="/2023/09/12/HelloGithub/image-20200507092051440.png" srcset="/img/loading.gif" alt="image-20200507092051440"></p><h2 id="HowToBeAProgrammer（大佬的人生感悟，如何成为一名真正的工程师）"><a href="#HowToBeAProgrammer（大佬的人生感悟，如何成为一名真正的工程师）" class="headerlink" title="HowToBeAProgrammer（大佬的人生感悟，如何成为一名真正的工程师）"></a>HowToBeAProgrammer（大佬的人生感悟，如何成为一名真正的工程师）</h2><p><a href="https://github.com/braydie/HowToBeAProgrammer" target="_blank" rel="noopener">HowToBeAProgrammer</a></p><p><a href="[https://github.com/braydie/HowToBeAProgrammer/blob/master/zh/README.md#%E7%9B%AE%E5%BD%95](https://github.com/braydie/HowToBeAProgrammer/blob/master/zh/README.md#目录)">中文版本</a></p><p>成为一名好的程序员是困难的，将一个想法变为现实，最困难的地方在于与你的同事和顾客相处。编程能力很重要，但在好的程序员看来。相比构建一个让各种各样客户都满意的软件系统，纯粹的编程真的只是小孩子的玩意。在这篇文章里，我尝试尽可能简洁地总结那些当我 21 岁时，希望别人告诉我的事。</p><h2 id="33-js-concepts（JavaScript-33个概念）"><a href="#33-js-concepts（JavaScript-33个概念）" class="headerlink" title="33-js-concepts（JavaScript 33个概念）"></a>33-js-concepts（JavaScript 33个概念）</h2><p><a href="https://github.com/stephentian/33-js-concepts" target="_blank" rel="noopener">33-js-concepts</a>    </p><p>📜 每个 JavaScript 工程师都应懂的33个概念 <a href="https://github.com/leonardomso" target="_blank" rel="noopener">@leonardomso</a></p><h2 id="❤️chrome-plugin-demo（Google插件开发说明）"><a href="#❤️chrome-plugin-demo（Google插件开发说明）" class="headerlink" title="❤️chrome-plugin-demo（Google插件开发说明）"></a>❤️chrome-plugin-demo（Google插件开发说明）</h2><p><a href="https://github.com/sxei/chrome-plugin-demo" target="_blank" rel="noopener">chrome-plugin-demo</a></p><p>《Chrome插件开发全攻略》配套完整Demo，欢迎clone体验 <a href="http://blog.haoji.me/chrome-plugin-develop.html" target="_blank" rel="noopener">http://blog.haoji.me/chrome-plugin-de…</a></p><h2 id="❤️soar（SQL-自动优化和改写的工具）"><a href="#❤️soar（SQL-自动优化和改写的工具）" class="headerlink" title="❤️soar（SQL 自动优化和改写的工具）"></a>❤️soar（SQL 自动优化和改写的工具）</h2><p><a href="https://github.com/XiaoMi/soar" target="_blank" rel="noopener">soar</a></p><p>SQL 自动优化和改写的工具。可以自动优化 MySQL 语法族，并且给出为什么要这样优化的理由。功能特点：</p><ul><li>跨平台支持</li><li>目前只支持 MySQL 语法族协议的 SQL 优化</li><li>支持基于启发式算法的语句优化</li><li>支持复杂查询的多列索引优化（UPDATE、INSERT、DELETE、SELECT）</li><li>等等</li></ul><h2 id="gridea（JavaScript静态客户端写作工具）"><a href="#gridea（JavaScript静态客户端写作工具）" class="headerlink" title="gridea（JavaScript静态客户端写作工具）"></a>gridea（JavaScript静态客户端写作工具）</h2><p><a href="https://github.com/getgridea/gridea" target="_blank" rel="noopener">gridea</a></p><p><a href="https://github.com/getgridea/gridea/blob/master/README-zh_CN.md" target="_blank" rel="noopener">中文地址介绍</a></p><p>静态博客写作客户端，你可以用它来记录你的生活、心情、知识、笔记、创意。使用了 electron 技术，对于学习 Javascript 桌面端开发是一个很好的项目</p><p><img src="/2023/09/12/HelloGithub/image-20200511174004731.png" srcset="/img/loading.gif" alt="image-20200511174004731"></p><h2 id="❤️makegirlsmoe-web（二次元捏脸）"><a href="#❤️makegirlsmoe-web（二次元捏脸）" class="headerlink" title="❤️makegirlsmoe_web（二次元捏脸）"></a>❤️makegirlsmoe_web（二次元捏脸）</h2><p><a href="https://github.com/makegirlsmoe/makegirlsmoe_web" target="_blank" rel="noopener">makegirlsmoe_web</a></p><p>动漫角色图片生成工具。支持：选择发色、发型、眼睛、皮肤、微笑、风格等等特征生成二次元图片。自定义生成可爱的二次元头像，二次元界福音。<a href="https://make.girls.moe/#/" target="_blank" rel="noopener">在线尝试</a><br><img src="/2023/09/12/HelloGithub/makegirlsmoe_web.png" srcset="/img/loading.gif" alt="makegirlsmoe_web"></p><h2 id="❤️learn-go-with-tests（通过单元测试学Go）"><a href="#❤️learn-go-with-tests（通过单元测试学Go）" class="headerlink" title="❤️learn-go-with-tests（通过单元测试学Go）"></a>❤️learn-go-with-tests（通过单元测试学Go）</h2><p><a href="https://github.com/quii/learn-go-with-tests" target="_blank" rel="noopener">learn-go-with-tests</a></p><p>通过单元测试学习 Go 语言。下载仓库源码后，进入对应目录。每一个小文件夹就是一个对应的 Go 项目，在里面<code>go test</code>即可运行单元测试。由于是测试驱动开发，所以需要在你改动代码之后跑通单元测试才算学会通过。每一个对应的文件夹都有相应 Markdown 文字教程，比较浅显易懂。而且还有<a href="https://studygolang.gitbook.io/learn-go-with-tests" target="_blank" rel="noopener">中文版</a></p><h2 id="auxpi（基于-API-的简单图床应用）"><a href="#auxpi（基于-API-的简单图床应用）" class="headerlink" title="auxpi（基于 API 的简单图床应用）"></a>auxpi（基于 API 的简单图床应用）</h2><p><a href="https://github.com/0xDkd/auxpi" target="_blank" rel="noopener">auxpi</a></p><p>基于 API 的简单图床应用。整合了主流图床的 API，并且做了一个 GUI 用来管理，<a href="https://github.com/aimerforreimu/AUXPI/wiki/一键安装脚本" target="_blank" rel="noopener">安装</a>简单<br><img src="/2023/09/12/HelloGithub/AUXPI.jpeg" srcset="/img/loading.gif" alt="auxpi"></p><h2 id="vscode-leetcode（LeeCode刷题神器）"><a href="#vscode-leetcode（LeeCode刷题神器）" class="headerlink" title="vscode-leetcode（LeeCode刷题神器）"></a>vscode-leetcode（LeeCode刷题神器）</h2><p>这是一个可以让用户在 VS Code 编辑器中，练习 LeetCode 习题的插件。支持：查看高票解答、提交答案、测试答案等。提高了刷题效率，助你在校招、社招中杀出重围。上班摸鱼刷题利器</p><h2 id="掘金文章及点赞爬虫"><a href="#掘金文章及点赞爬虫" class="headerlink" title="掘金文章及点赞爬虫"></a>掘金文章及点赞爬虫</h2><p>GitHub地址：<a href="https://github.com/6fedcom/juejin-ariticle-liked-helper" target="_blank" rel="noopener">https://github.com/6fedcom/juejin-ariticle-liked-helper</a></p><p>演示地址：<a href="https://juejin.58fe.com/" target="_blank" rel="noopener">https://juejin.58fe.com</a></p><p>把自己掘金网站上点赞过的文章爬出来，然后可以根据标题，作者检索，可以按照发布时间，点赞数，阅读数排序，从而更高效的管理自己点赞过的文章，杜绝“收藏吃灰”</p><p><img src="/2023/09/12/HelloGithub/image-20200519155002551.png" srcset="/img/loading.gif" alt="image-20200519155002551"></p><h2 id="RemixIcon（图标库）"><a href="#RemixIcon（图标库）" class="headerlink" title="RemixIcon（图标库）"></a>RemixIcon（图标库）</h2><p><a href="https://github.com/Remix-Design/RemixIcon" target="_blank" rel="noopener">RemixIcon</a></p><p>在线尝试：<a href="https://github.com/Remix-Design/RemixIcon" target="_blank" rel="noopener">https://github.com/Remix-Design/RemixIcon</a></p><p>一套免费、可商用、设计精美、细致的图标库。看到它第一眼后，我感觉自己之前用的图标简直就是枯草🙈。这个项目可以让开发者、设计师在一个图标库中快速找到适合的图标，用于自己的网站或 APP 开发。不同于混搭收集的图标库，RemixIcon 的每一枚图标都是由设计师精心设计而成，并且每一枚图标都包含填充和描边两种风格，便于切换使用<br><img src="/2023/09/12/HelloGithub/RemixIcon.png" srcset="/img/loading.gif" alt="RemixIcon"></p><h2 id="❤️fe-interview（每天四道前端面试题）"><a href="#❤️fe-interview（每天四道前端面试题）" class="headerlink" title="❤️fe-interview（每天四道前端面试题）"></a>❤️fe-interview（每天四道前端面试题）</h2><p><a href="https://github.com/haizlin/fe-interview" target="_blank" rel="noopener">fe-interview</a></p><p>万人Star</p><p>每天早上 4 个基础前端面试题，助你在前端面试中‘所向披靡’，无人能挡</p><h2 id="❤️AutoPiano（HTML5自由钢琴）"><a href="#❤️AutoPiano（HTML5自由钢琴）" class="headerlink" title="❤️AutoPiano（HTML5自由钢琴）"></a>❤️AutoPiano（HTML5自由钢琴）</h2><p>GitHub地址：<a href="https://github.com/WarpPrism/AutoPiano" target="_blank" rel="noopener">https://github.com/WarpPrism/AutoPiano</a></p><p>演示地址：<a href="http://www.autopiano.cn/" target="_blank" rel="noopener">http://www.autopiano.cn/</a></p><p>自由钢琴（AutoPiano）是利用 HTML5 技术开发的在线钢琴应用。在学习工作之余可以享受钢琴、音乐的美好，支持钢琴曲的自动播放功能、按键提示。让学习钢琴变得简单，谁都可以练成‘钢琴手’，<a href="http://www.autopiano.cn/" target="_blank" rel="noopener">在线体验</a></p><p><img src="/2023/09/12/HelloGithub/image-20200519232434521.png" srcset="/img/loading.gif" alt="image-20200519232434521"></p><h2 id="you-get（Python视频下载工具）"><a href="#you-get（Python视频下载工具）" class="headerlink" title="you-get（Python视频下载工具）"></a>you-get（Python视频下载工具）</h2><p><a href="https://github.com/soimort/you-get" target="_blank" rel="noopener">you-get</a></p><p>一个 Python 写的视频下载工具，下载工具千万个但我仅仅推荐了这个工具。是因为正常情况下载不了视频的网站，用它你就可以方便地下载下来。剩下的要自己去看介绍，不能再多说了🙊</p><pre><code class="hljs angelscript">(env) ➜  ~ you-<span class="hljs-keyword">get</span> <span class="hljs-string">'https://v.ifeng.com/c/7msWmwppMPC'</span>Site:       ifeng.comTitle:      完整版第五期：陈晓卿 中国有俩行当门槛极低——美食圈和摄影圈Type:       MPEG<span class="hljs-number">-4</span> video (video/mp4)Size:       <span class="hljs-number">0.01</span> MiB (<span class="hljs-number">8578</span> Bytes)Downloading 完整版第五期：陈晓卿 中国有俩行当门槛极低——美食圈和摄影圈.mp4 <span class="hljs-number">100</span>% (  <span class="hljs-number">0.0</span>/  <span class="hljs-number">0.0</span>MB) ├████████████████████┤[<span class="hljs-number">1</span>/<span class="hljs-number">1</span>]   <span class="hljs-number">71</span> kB/s</code></pre><h2 id="nps（GO语言-内网穿透工具）"><a href="#nps（GO语言-内网穿透工具）" class="headerlink" title="nps（GO语言 内网穿透工具）"></a>nps（GO语言 内网穿透工具）</h2><p><a href="https://github.com/ehang-io/nps" target="_blank" rel="noopener">nps</a> </p><p>一款功能强大、轻量级的内网穿透代理服务器。支持 TCP 和 UDP 流量转发、支持内网 HTTP 代理、内网 socks5 代理、snappy 压缩、站点保护、加密传输、多路复用等功能。拥有 web 图形化管理，集成多用户模式。可以自搭建内网穿透代理服务，用来替代付费的内网穿透服务。又不像其他类似项目依赖命令行，它有图形页面。安装：</p><pre><code class="hljs vim"><span class="hljs-keyword">go</span> <span class="hljs-built_in">get</span> -<span class="hljs-keyword">u</span> github.<span class="hljs-keyword">com</span>/cnlh/nps<span class="hljs-keyword">go</span> build cmd/nps/nps.<span class="hljs-keyword">go</span> # 服务端程序<span class="hljs-keyword">go</span> build cmd/nps/npc.<span class="hljs-keyword">go</span> # 客户端程序</code></pre><h2 id="pan-light（百度云盘快速下载工具）"><a href="#pan-light（百度云盘快速下载工具）" class="headerlink" title="pan-light（百度云盘快速下载工具）"></a>pan-light（百度云盘快速下载工具）</h2><p><a href="https://github.com/peterq/pan-light" target="_blank" rel="noopener">pan-light</a></p><p>基于 Golang + Qt5 的百度网盘不限速客户端。对比之前命令行版本的百度盘客户端，该项目拥有图形界面，更加友好、方便、易于使用，到 <a href="https://github.com/peterq/pan-light/releases" target="_blank" rel="noopener">release 页面</a>下载运行即可使用<br><img src="/2023/09/12/HelloGithub/pan-light.png" srcset="/img/loading.gif" alt="pan-light"></p><h2 id="QuestionAnsweringSystem（人机问答系统）"><a href="#QuestionAnsweringSystem（人机问答系统）" class="headerlink" title="QuestionAnsweringSystem（人机问答系统）"></a>QuestionAnsweringSystem（人机问答系统）</h2><p><a href="https://github.com/ysc/QuestionAnsweringSystem" target="_blank" rel="noopener">QuestionAnsweringSystem</a></p><p>一个 Java 实现的人机问答系统，能够自动分析问题并给出候选答案。在 2011 年的美国热门电视智力问答节目《Jeopardy》中，由 IBM 开发的 AI 问答系统 Watson 战胜了人类选手，而 QuestionAnsweringSystem 则是 Watson 的 Java 实现。从今天的眼光去看，它可能已经不够那么智能，不过由于它的简便性和易于部署运行，因此非常适合新手把玩，赶紧去你的应用中集成一个炫酷的智能问答系统吧</p><h2 id="arthas（Java-诊断工具）"><a href="#arthas（Java-诊断工具）" class="headerlink" title="arthas（Java 诊断工具）"></a>arthas（Java 诊断工具）</h2><p><a href="https://github.com/alibaba/arthas" target="_blank" rel="noopener">arthas</a></p><p>阿里开源的 Java 诊断工具。当线上出现了奇怪的异常时，无需发版就能截获运行时的数据，包括参数、返回值、异常、耗时等等。上手简单、文档完备、无代码侵入式的可以对正在运行的 jvm 进程进行监控，简单易用的命令行工具。线上出 bug 了，有了 arthas 先喝口咖啡压压惊，问题分分钟定位不是梦<br><img src="/2023/09/12/HelloGithub/arthas.png" srcset="/img/loading.gif" alt="arthas"></p><h2 id="wormhole（API-管理平台）"><a href="#wormhole（API-管理平台）" class="headerlink" title="wormhole（API 管理平台）"></a>wormhole（API 管理平台）</h2><p>一个简单、易用的 API 管理平台。目的是为了降低后端服务开发与前端调用的耦合性，通过该框架使整个项目的开发、协作更加完善。客户端开发人员从管理平台查找需要的接口信息进行调用，服务端开发人员定义好接口后同步到管理平台中，管理平台可以统一对接口的访问设置等。一个让前端和后端能够成为“好朋友”的框架✌️<br><img src="/2023/09/12/HelloGithub/wormhole.jpg" srcset="/img/loading.gif" alt="wormhole"></p><h2 id="from-coder-to-expert（大厂内部分享资料）"><a href="#from-coder-to-expert（大厂内部分享资料）" class="headerlink" title="from_coder_to_expert（大厂内部分享资料）"></a>from_coder_to_expert（大厂内部分享资料）</h2><p><a href="https://github.com/0voice/from_coder_to_expert" target="_blank" rel="noopener">from_coder_to_expert</a></p><p>2019 年各互联网大厂最新内部技术分享的文档、PDF、PPT 集合。从程序员到 CTO，从专业走向卓越</p><p><img src="/2023/09/12/HelloGithub/image-20200521153856235.png" srcset="/img/loading.gif" alt="image-20200521153856235"></p><h2 id="overcommit（代码提交配置工具）"><a href="#overcommit（代码提交配置工具）" class="headerlink" title="overcommit（代码提交配置工具）"></a>overcommit（代码提交配置工具）</h2><p> <a href="https://github.com/sds/overcommit" target="_blank" rel="noopener">overcommit</a></p><p>一款可配置的 git hook 管理工具。git hook 是 git 的强大功能，当触发某一个 git 的事件，例如：add、commit、push 等操作时，会触发执行对应事件的附加操作（hook）。可以用来检测代码质量、commit 描述风格、控制代码质量等。overcommit 就是能让你不写一行代码（配置不算代码），来自定义 hook 要执行的操作。它使用简单、文档详尽、例子众多、社区活跃，值得一试<br><img src="/2023/09/12/HelloGithub/overcommit.png" srcset="/img/loading.gif" alt="overcommit"></p><h2 id="SoloPi（安卓精灵类）"><a href="#SoloPi（安卓精灵类）" class="headerlink" title="SoloPi（安卓精灵类）"></a>SoloPi（安卓精灵类）</h2><p><a href="https://github.com/alipay/SoloPi" target="_blank" rel="noopener">SoloPi</a> </p><p>一个不需要连接电脑、非侵入式的 Android 自动化工具。公测版拥有录制回放、性能测试、一机多控三项主要功能，能为测试开发人员节省宝贵时间。安卓版本多、终端型号多，一个成熟安卓应用的上线需要进行大量测试，而很多测试都是属于重复操作，通过此工具可以极大简化测试人员的工作量<br><img src="/2023/09/12/HelloGithub/image-20200828095852860.png" srcset="/img/loading.gif" alt="image-20200828095852860"></p><h2 id="❤️chart-xkcd（手绘图表）"><a href="#❤️chart-xkcd（手绘图表）" class="headerlink" title="❤️chart.xkcd（手绘图表）"></a>❤️chart.xkcd（手绘图表）</h2><p> <a href="https://github.com/timqian/chart.xkcd" target="_blank" rel="noopener">chart.xkcd</a></p><p><strong><em>Star 6.3k\</em> *Watch 76* *Fork 151*</strong><br>手绘风格的 JS 图表库。手绘风格的设计给人一种很可爱的感觉，看了这些图表你会发现数据也可以以萌萌哒的形式展示<br><img src="/2023/09/12/HelloGithub/image-20200828095908367.png" srcset="/img/loading.gif" alt="image-20200828095908367"></p><h2 id="❤️PicGo（图床工具）"><a href="#❤️PicGo（图床工具）" class="headerlink" title="❤️PicGo（图床工具）"></a>❤️PicGo（图床工具）</h2><p><a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a></p><p>基于 electron-vue 实现的桌面图床工具。该工具可以帮助你高效、非常方便地上传图片到网络图床，包括了微博图床、七牛图床、腾讯云 COS、又拍云、GitHub、SM.MS、阿里云OSS、Imgur 等。只要使用快捷键或拖动就可以上传，而且上传成功的图片链接会自动复制到你的剪贴板里，支持 macOS、Windows、Linux 三大系统</p><h2 id="Valine（无后端JS评论插件）"><a href="#Valine（无后端JS评论插件）" class="headerlink" title="Valine（无后端JS评论插件）"></a>Valine（无后端JS评论插件）</h2><p><a href="https://github.com/xCss/Valine" target="_blank" rel="noopener">Valine</a></p><p>一款快速、简洁且高效的无后端的 JS 评论插件。该库使用 LeanCloud API 存储数据，且设计美观、体积小、支持 Markdown 和 Emoji。对于使用 Hexo、Hugo 等静态网页博客主来说，它简直就是福音。通过简单的几步就可以快速的给自己的博客增加评论功能，你还不快来试试<br><img src="/2023/09/12/HelloGithub/Valine.png" srcset="/img/loading.gif" alt="Valine"></p><h2 id="tablesaw（Java数据可视化项目）"><a href="#tablesaw（Java数据可视化项目）" class="headerlink" title="tablesaw（Java数据可视化项目）"></a>tablesaw（Java数据可视化项目）</h2><p><a href="https://github.com/jtablesaw/tablesaw" target="_blank" rel="noopener">tablesaw</a></p><p>一款包括数据框和可视化库，可用于加载、转换、过滤和汇总数据的 Java 实用程序。用 Tablesaw 处理数据会节省您的时间和精力，它还支持描述性统计，并且能够与 Smile 机器学习库完美集成。最近两年数据分析师职业大火，做好数据分析，就离不开数据可视化框架。Java 工程师掌握一种数据可视化库势在必行，示例代码：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BoxExample</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    Table table = Table.read().csv(<span class="hljs-string">"../data/tornadoes_1950-2014.csv"</span>);    Layout layout = Layout.builder().title(<span class="hljs-string">"Tornado Injuries by Scale"</span>).build();    BoxTrace trace =        BoxTrace.builder(table.categoricalColumn(<span class="hljs-string">"scale"</span>), table.nCol(<span class="hljs-string">"injuries"</span>)).build();    Plot.show(<span class="hljs-keyword">new</span> Figure(layout, trace));  &#125;&#125;</code></pre><p><img src="/2023/09/12/HelloGithub/tablesaw.png" srcset="/img/loading.gif" alt="tablesaw"></p><h2 id="marktext（MarkDown编辑器）"><a href="#marktext（MarkDown编辑器）" class="headerlink" title="marktext（MarkDown编辑器）"></a>marktext（MarkDown编辑器）</h2><p><a href="https://github.com/marktext/marktext" target="_blank" rel="noopener">marktext</a></p><p>一个简单且优雅的开源 Markdown 编辑器，支持 Linux、macOS 和 Windows <a href="https://github.com/marktext/marktext#download-and-install" target="_blank" rel="noopener">下载地址</a>。功能：</p><ul><li>实时预览（所见即所得）和简洁明了的界面</li><li>Markdown 扩展，例如数学表达式和 emoji 表情</li><li>输出 HTML 和 PDF 文件</li><li>各种编辑模式：源代码模式、打字机模式、专注模式</li><li>等等</li></ul><p><img src="/2023/09/12/HelloGithub/marktext.png" srcset="/img/loading.gif" alt="marktext"></p><h2 id="reverse-interview-zh（反向面试）"><a href="#reverse-interview-zh（反向面试）" class="headerlink" title="reverse-interview-zh（反向面试）"></a>reverse-interview-zh（反向面试）</h2><p><a href="https://github.com/yifeikong/reverse-interview-zh" target="_blank" rel="noopener">reverse-interview-zh</a></p><p>中文地址：<a href="https://github.com/yifeikong/reverse-interview-zh" target="_blank" rel="noopener">https://github.com/yifeikong/reverse-interview-zh</a></p><p>如果当面试官问“你还有什么要问我的吗？”的时候你毫无头绪，那这个项目正是你所需要的。<a href="https://github.com/yifeikong/reverse-interview-zh" target="_blank" rel="noopener">中文</a></p><h2 id="❤️chinese-colors（中国风色号）"><a href="#❤️chinese-colors（中国风色号）" class="headerlink" title="❤️chinese-colors（中国风色号）"></a>❤️chinese-colors（中国风色号）</h2><p><a href="https://github.com/zerosoul/chinese-colors" target="_blank" rel="noopener">chinese-colors</a></p><p>演示地址：<a href="https://colors.ichuantong.cn/" target="_blank" rel="noopener">https://colors.ichuantong.cn/</a></p><p><img src="/2023/09/12/HelloGithub/image-20200523113715127.png" srcset="/img/loading.gif" alt="image-20200523113715127"></p><h2 id="spring-analysis（Spring源码阅读）"><a href="#spring-analysis（Spring源码阅读）" class="headerlink" title="spring-analysis（Spring源码阅读）"></a>spring-analysis（Spring源码阅读）</h2><p><a href="https://github.com/seaswalker/spring-analysis" target="_blank" rel="noopener">spring-analysis</a></p><p>Spring 框架源码讲解。包括：spring-core、spring-aop、spring-context、spring-taskspring-mvc 等部分</p><h2 id="eladmin（一站式构建）"><a href="#eladmin（一站式构建）" class="headerlink" title="eladmin（一站式构建）"></a>eladmin（一站式构建）</h2><p><a href="https://github.com/elunez/eladmin" target="_blank" rel="noopener">eladmin</a></p><p>基于 Spring Boot 2.1.0、Vue 的前后端分离的后台管理系统，支持数据字典与数据权限管理、一键生成前后端代码、前端菜单动态路由等。基于 Spring Boot2.1.0 框架，涉及的技术栈：非关系数据库 redis、接口测试工具 swagger、druid 数据源驱动、邮件依赖（javax.mail）、三方支付和云存储 SDK、页面模板引擎 freemarker。技术栈丰富，初学者可以作为实战项目学习和使用<br><img src="/2023/09/12/HelloGithub/eladmin.png" srcset="/img/loading.gif" alt="eladmin"></p><h2 id="fiora（支持多端聊天室）"><a href="#fiora（支持多端聊天室）" class="headerlink" title="fiora（支持多端聊天室）"></a>fiora（支持多端聊天室）</h2><p><a href="https://github.com/yinxin630/fiora" target="_blank" rel="noopener">fiora</a></p><p>演示地址：<a href="https://fiora.suisuijiang.com/" target="_blank" rel="noopener">https://fiora.suisuijiang.com/</a></p><p>一个功能丰富、支持多端的在线聊天室。它界面小清新，支持基本的聊天功能的同时还有好玩的消息朗读功能。项目上基于 TypeScript + React 16.9 代码逻辑清晰、注释较为完善，适合用来学习 node.js、 TypeScript、React 等技术<br><img src="/2023/09/12/HelloGithub/fiora.png" srcset="/img/loading.gif" alt="fiora"></p><h2 id="RPA-Python（Python-自动化操作的库）"><a href="#RPA-Python（Python-自动化操作的库）" class="headerlink" title="RPA-Python（Python 自动化操作的库）"></a>RPA-Python（Python 自动化操作的库）</h2><p><a href="https://github.com/tebelorg/RPA-Python" target="_blank" rel="noopener">RPA-Python</a></p><p>一个 Python 自动化操作的库。比如：自动打开网页并截图，示例代码：</p><pre><code class="hljs python">t.init()t.url(<span class="hljs-string">'https://www.google.com'</span>)t.type(<span class="hljs-string">'q'</span>, <span class="hljs-string">'decentralization[enter]'</span>)t.snap(<span class="hljs-string">'page'</span>, <span class="hljs-string">'results.png'</span>)t.close()</code></pre><h2 id="scrcpy（电脑显示并控制-Android-手机）"><a href="#scrcpy（电脑显示并控制-Android-手机）" class="headerlink" title="scrcpy（电脑显示并控制 Android 手机）"></a>scrcpy（电脑显示并控制 Android 手机）</h2><p><a href="https://github.com/Genymobile/scrcpy" target="_blank" rel="noopener">scrcpy</a></p><p>一款可以用电脑显示并控制 Android 手机的开源工具。连接方便使用方便，手机无需 root、无需安装任何应用。支持 USB、Wi-Fi 两种方式连接，支持 Windows、macOS、Linux 三种操作系统。注意电脑端需要安装 adb 工具<br><img src="/2023/09/12/HelloGithub/scrcpy.jpg" srcset="/img/loading.gif" alt="scrcpy"></p><h2 id="netdata（Linux-系统性能实时监控工具）"><a href="#netdata（Linux-系统性能实时监控工具）" class="headerlink" title="netdata（Linux 系统性能实时监控工具）"></a>netdata（Linux 系统性能实时监控工具）</h2><p><a href="https://github.com/netdata/netdata" target="_blank" rel="noopener">netdata</a></p><p>一款免费开源的 Linux 系统性能实时监控工具。它易于安装、占用资源少、功能强大，支持监控多种服务<br><img src="/2023/09/12/HelloGithub/image-20200828095955430.png" srcset="/img/loading.gif" alt="image-20200828095955430"></p><h2 id="mkcert（开发环境实现-HTTPS化）"><a href="#mkcert（开发环境实现-HTTPS化）" class="headerlink" title="mkcert（开发环境实现 HTTPS化）"></a>mkcert（开发环境实现 HTTPS化）</h2><p><a href="https://github.com/FiloSottile/mkcert" target="_blank" rel="noopener">mkcert</a></p><p>无需配置，执行一条命令让本地的开发环境实现 HTTPS 的工具。效果如下：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> mkcert -install</span>Created a new local CA at "/Users/filippo/Library/Application Support/mkcert" 💥The local CA is now installed in the system trust store! ⚡️The local CA is now installed in the Firefox trust store (requires browser restart)! 🦊<span class="hljs-meta">$</span><span class="bash"> mkcert example.com <span class="hljs-string">"*.example.com"</span> example.test localhost 127.0.0.1 ::1</span>Using the local CA at "/Users/filippo/Library/Application Support/mkcert" ✨Created a new certificate valid for the following names 📜 - "example.com" - "*.example.com" - "example.test" - "localhost" - "127.0.0.1" - "::1"The certificate is at "./example.com+5.pem" and the key at "./example.com+5-key.pem" ✅</code></pre><h2 id="❤️Sourcetrail（可视化源码探索项目）"><a href="#❤️Sourcetrail（可视化源码探索项目）" class="headerlink" title="❤️Sourcetrail（可视化源码探索项目）"></a>❤️Sourcetrail（可视化源码探索项目）</h2><p><a href="https://github.com/CoatiSoftware/Sourcetrail" target="_blank" rel="noopener">Sourcetrail</a></p><p>官方地址：<a href="https://www.sourcetrail.com/" target="_blank" rel="noopener">https://www.sourcetrail.com/</a></p><p>一个免费开源、跨平台的可视化源码探索项目。能够十分高效的帮助使用者探索、熟悉陌生的代码，支持 C、C++、Python 和 Java 语言，同时提供了相关 SDK 用于拓展支持其它语言，相信在未来会提供更多语言的支持。程序员在它的帮助下可以快速熟悉陌生项目、学习开源项目、框架等，此等利器赶快去试试吧<br><img src="/2023/09/12/HelloGithub/Sourcetrail.png" srcset="/img/loading.gif" alt="Sourcetrail"></p><h2 id="kiwi（国际化方案）"><a href="#kiwi（国际化方案）" class="headerlink" title="kiwi（国际化方案）"></a>kiwi（国际化方案）</h2><p><a href="https://github.com/alibaba/kiwi" target="_blank" rel="noopener">kiwi</a></p><p>🐤Kiwi-国际化全流程解决方案</p><p>还在为前端的全球化多语言而发愁吗？可以试试阿里开源的这项目<br><img src="/2023/09/12/HelloGithub/kiwi.png" srcset="/img/loading.gif" alt="kiwi"></p><h2 id="FileSaver-js（文件保存的-JavaScript-库）"><a href="#FileSaver-js（文件保存的-JavaScript-库）" class="headerlink" title="FileSaver.js（文件保存的 JavaScript 库）"></a>FileSaver.js（文件保存的 JavaScript 库）</h2><p><a href="https://github.com/eligrey/FileSaver.js" target="_blank" rel="noopener">FileSaver.js</a></p><p>文件保存的 JavaScript 库，支持多种常见的文件存储格式：xls、txt、png 等。它可以方便的把数据转成文件，然后供用户下载。示例代码：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 存储文本</span><span class="hljs-keyword">var</span> blob = <span class="hljs-keyword">new</span> Blob([<span class="hljs-string">"Hello, world!"</span>], &#123;<span class="hljs-attr">type</span>: <span class="hljs-string">"text/plain;charset=utf-8"</span>&#125;);FileSaver.saveAs(blob, <span class="hljs-string">"hello world.txt"</span>);</code></pre><h2 id="paint（在线画画）"><a href="#paint（在线画画）" class="headerlink" title="paint（在线画画）"></a>paint（在线画画）</h2><p><a href="https://github.com/dli/paint" target="_blank" rel="noopener">paint</a></p><p>演示地址：<a href="http://david.li/paint" target="_blank" rel="noopener">http://david.li/paint</a></p><p>在线体验下油画创作。呈上我的“杰作”：<br><img src="/2023/09/12/HelloGithub/paint.png" srcset="/img/loading.gif" alt="paint"></p><h2 id="git-quick-stats（Git统计工具）"><a href="#git-quick-stats（Git统计工具）" class="headerlink" title="git-quick-stats（Git统计工具）"></a>git-quick-stats（Git统计工具）</h2><p><a href="https://github.com/arzzen/git-quick-stats" target="_blank" rel="noopener">git-quick-stats</a></p><p>项目的 git 提交记录展示和统计的工具。支持：不同时间维度和用户名的统计、近期提交的概览等<br><img src="/2023/09/12/HelloGithub/git-quick-stats.png" srcset="/img/loading.gif" alt="git-quick-stats"></p><h2 id="rc-bullets（弹幕插件）"><a href="#rc-bullets（弹幕插件）" class="headerlink" title="rc-bullets（弹幕插件）"></a>rc-bullets（弹幕插件）</h2><p><a href="https://github.com/zerosoul/rc-bullets" target="_blank" rel="noopener">rc-bullets</a></p><p>🌈基于CSS3 Animation，使用React构建的弹幕组件 <a href="https://zerosoul.github.io/rc-bullets/" target="_blank" rel="noopener">https://zerosoul.github.io/rc-bullets/</a></p><p>基于 CSS3 Animation 使用 React 构建的弹幕组件。<a href="http://zerosoul.github.io/rc-bullets" target="_blank" rel="noopener">演示地址</a>，支持功能：</p><ul><li>管理弹幕：暂停、隐藏、清屏等</li><li>设置弹幕：速度、循环次数、延迟播放、自定义动画类型等</li></ul><h2 id="miaosha（秒杀方案集锦）"><a href="#miaosha（秒杀方案集锦）" class="headerlink" title="miaosha（秒杀方案集锦）"></a>miaosha（秒杀方案集锦）</h2><p><a href="https://github.com/qiurunze123/miaosha" target="_blank" rel="noopener">miaosha</a></p><p>一款秒杀系统设计与实现。高并发大流量的秒杀是面试常见问题，该项目不仅有具体问题的解决思路，还有具体代码实现和示例 demo，全部理解、学习后相信秒杀问题再也拦不住你啦<br><img src="/2023/09/12/HelloGithub/miaosha.png" srcset="/img/loading.gif" alt="miaosha"></p><h2 id="postwoman（API-调试工具）"><a href="#postwoman（API-调试工具）" class="headerlink" title="postwoman（API 调试工具）"></a>postwoman（API 调试工具）</h2><p><a href="https://github.com/liyasthomas/postwoman" target="_blank" rel="noopener">postwoman</a></p><p>一款基于 Node.js 的免费开源、便捷美观的 API 调试工具。它是调试接口的利器，能够尽快的发现问题提高开发效率。相信体会过 Postman 的同学，看到这个项目的名字就已经跃跃欲试了<br><img src="/2023/09/12/HelloGithub/postwoman.png" srcset="/img/loading.gif" alt="postwoman"></p><h2 id="SnowJena（基于令牌桶算法实现的分布式无锁限流框架）"><a href="#SnowJena（基于令牌桶算法实现的分布式无锁限流框架）" class="headerlink" title="SnowJena（基于令牌桶算法实现的分布式无锁限流框架）"></a>SnowJena（基于令牌桶算法实现的分布式无锁限流框架）</h2><p><a href="https://github.com/ystcode/SnowJena" target="_blank" rel="noopener">SnowJena</a></p><p>基于令牌桶算法实现的分布式无锁限流框架。简单易用的 API，开箱即用、支持熔断降级、动态配置规则、可视化监控等功能</p><p><img src="/2023/09/12/HelloGithub/SnowJena.jpeg" srcset="/img/loading.gif" alt="SnowJena"></p><h2 id="xournalpp（手写PDF笔记）"><a href="#xournalpp（手写PDF笔记）" class="headerlink" title="xournalpp（手写PDF笔记）"></a>xournalpp（手写PDF笔记）</h2><p><a href="https://github.com/xournalpp/xournalpp" target="_blank" rel="noopener">xournalpp</a></p><p>一款支持 PDF 手写注释的笔记软件，支持 Linux、Windows、macOS 平台。看书的时候喜欢标注、做笔记，那这款工具肯定适合你。<a href="https://github.com/xournalpp/xournalpp/releases" target="_blank" rel="noopener">下载地址</a><br><img src="/2023/09/12/HelloGithub/xournalpp.png" srcset="/img/loading.gif" alt="xournalpp"></p><h2 id="❤️showdoc（在线文档工具）"><a href="#❤️showdoc（在线文档工具）" class="headerlink" title="❤️showdoc（在线文档工具）"></a>❤️showdoc（在线文档工具）</h2><p><a href="https://github.com/star7th/showdoc" target="_blank" rel="noopener">showdoc</a></p><p>演示地址：<a href="https://www.showdoc.cc/" target="_blank" rel="noopener">https://www.showdoc.cc/</a></p><p>一款基于 JavaScript 实现的开源在线文档工具。支持：多端编辑查看、权限管理、文档导出、Markdown 语法等，功能虽不多但已足够用了。推荐自建自用、小团队内部使用<br><img src="/2023/09/12/HelloGithub/showdoc.png" srcset="/img/loading.gif" alt="showdoc"></p><h2 id="my-mac-os（macOS实用工具大全）"><a href="#my-mac-os（macOS实用工具大全）" class="headerlink" title="my-mac-os（macOS实用工具大全）"></a>my-mac-os（macOS实用工具大全）</h2><p><a href="https://github.com/nikitavoloboev/my-mac-os" target="_blank" rel="noopener">my-mac-os</a></p><p>该项目罗列了作者自用、收集的 macOS 上实用、炫酷的软件。我从中找到好几个炫酷、实用提高工作的工具，你也赶快来挑挑吧<br><img src="/2023/09/12/HelloGithub/my-mac-os.png" srcset="/img/loading.gif" alt="my-mac-os"></p><h2 id="G2（蚂蚁金服统计图表）"><a href="#G2（蚂蚁金服统计图表）" class="headerlink" title="G2（蚂蚁金服统计图表）"></a>G2（蚂蚁金服统计图表）</h2><p><a href="https://github.com/antvis/G2" target="_blank" rel="noopener">G2</a></p><p>演示地址：<a href="https://g2.antv.vision/" target="_blank" rel="noopener">https://g2.antv.vision</a></p><p>一套面向常规统计图表，以数据驱动的高交互可视化图形语法，具有高度的易用性和扩展性。使用 G2，你可以无需关注图表各种繁琐的实现细节，一条语句即可使用 Canvas 或 SVG 构建出各种各样的可交互的统计图表。G2 是整个蚂蚁金服 AntV 可视化解决方案中的一个环节，主要针对在高交互、高扩展的二维统计图表<br><img src="/2023/09/12/HelloGithub/image-20200828100034367.png" srcset="/img/loading.gif" alt="image-20200828100034367"></p><h2 id="incubator-dolphinscheduler（可视化工作流调度系统）"><a href="#incubator-dolphinscheduler（可视化工作流调度系统）" class="headerlink" title="incubator-dolphinscheduler（可视化工作流调度系统）"></a>incubator-dolphinscheduler（可视化工作流调度系统）</h2><p><a href="https://github.com/apache/incubator-dolphinscheduler" target="_blank" rel="noopener">incubator-dolphinscheduler</a></p><p>演示地址：<a href="https://dolphinscheduler.apache.org/" target="_blank" rel="noopener">https://dolphinscheduler.apache.org</a></p><p>分布式易扩展的可视化 DAG 工作流任务调度系统。致力于解决数据处理流程中错综复杂的依赖关系，使调度系统在数据处理流程中开箱即用<br><img src="/2023/09/12/HelloGithub/incubator-dolphinscheduler.jpg" srcset="/img/loading.gif" alt="incubator-dolphinscheduler"></p><h2 id="wtf（终端信息管家）"><a href="#wtf（终端信息管家）" class="headerlink" title="wtf（终端信息管家）"></a>wtf（终端信息管家）</h2><p><a href="https://github.com/wtfutil/wtf" target="_blank" rel="noopener">wtf</a></p><p>演示地址：<a href="http://wtfutil.com/" target="_blank" rel="noopener">http://wtfutil.com</a></p><p>瞥一眼你的“私人管家”，终端个人信息面板。安装简单，还可通过配置文件设置你想看到的信息。设置可能需要花一些时间，但最终效果还是很可以的<br><img src="/2023/09/12/HelloGithub/wtf.jpg" srcset="/img/loading.gif" alt="wtf"></p><h2 id="❤️honeyed-words-generator（土味情话生成器）"><a href="#❤️honeyed-words-generator（土味情话生成器）" class="headerlink" title="❤️honeyed-words-generator（土味情话生成器）"></a>❤️honeyed-words-generator（土味情话生成器）</h2><p><a href="https://github.com/zerosoul/honeyed-words-generator" target="_blank" rel="noopener">honeyed-words-generator</a></p><p>演示地址：<a href="https://works.yangerxiao.com/honeyed-words-generator/" target="_blank" rel="noopener">https://works.yangerxiao.com/honeyed-words-generator/</a></p><p>一个“土味情话”在线生成项目。支持生成图片、分享二维码，<a href="https://works.yangerxiao.com/honeyed-words-generator/" target="_blank" rel="noopener">在线访问</a>。你们先看，我看完被撩到了我先去静静<br><img src="/2023/09/12/HelloGithub/honeyed-words-generator.png" srcset="/img/loading.gif" alt="honeyed-words-generator"></p><h2 id="learnGitBranching（可视化Git学习）"><a href="#learnGitBranching（可视化Git学习）" class="headerlink" title="learnGitBranching（可视化Git学习）"></a>learnGitBranching（可视化Git学习）</h2><p><a href="https://github.com/pcottle/learnGitBranching" target="_blank" rel="noopener">learnGitBranching</a></p><p>演示地址：<a href="https://pcottle.github.com/learnGitBranching/?demo" target="_blank" rel="noopener">https://pcottle.github.com/learnGitBranching/?demo</a></p><p>一个 Git 命令可视化学习项目。能够生动形象的帮助开发人员理解、学习 Git 命令，通过一系列刺激的关卡挑战，逐步深入的学习 Git 的强大功能。<a href="https://learngitbranching.js.org/" target="_blank" rel="noopener">在线尝试</a><br><img src="/2023/09/12/HelloGithub/learnGitBranching.png" srcset="/img/loading.gif" alt="learnGitBranching"></p><h2 id="crawlab（Go语言分布式爬虫框架）"><a href="#crawlab（Go语言分布式爬虫框架）" class="headerlink" title="crawlab（Go语言分布式爬虫框架）"></a>crawlab（Go语言分布式爬虫框架）</h2><p><a href="https://github.com/crawlab-team/crawlab" target="_blank" rel="noopener">crawlab</a></p><p>在线尝试：<a href="https://crawlab.cn/" target="_blank" rel="noopener">https://crawlab.cn/</a></p><p>基于 Go 的分布式爬虫管理平台。支持 Python、Node.js、Go、Java、PHP 等多种编程语言以及多种爬虫框架<br><img src="/2023/09/12/HelloGithub/crawlab.png" srcset="/img/loading.gif" alt="crawlab"></p><h2 id="❤️concurrent（多线程开源书籍）"><a href="#❤️concurrent（多线程开源书籍）" class="headerlink" title="❤️concurrent（多线程开源书籍）"></a>❤️concurrent（多线程开源书籍）</h2><p><a href="https://github.com/RedSpider1/concurrent" target="_blank" rel="noopener">concurrent</a></p><p><img src="/2023/09/12/HelloGithub/image-20200603113527353.png" srcset="/img/loading.gif" alt="image-20200603113527353"></p><h2 id="istio-handbook（《Istio-服务网格进阶实战》）"><a href="#istio-handbook（《Istio-服务网格进阶实战》）" class="headerlink" title="istio-handbook（《Istio 服务网格进阶实战》）"></a>istio-handbook（《Istio 服务网格进阶实战》）</h2><p><a href="https://github.com/servicemesher/istio-handbook" target="_blank" rel="noopener">istio-handbook</a></p><p>在线阅读地址：<a href="https://www.servicemesher.com/istio-handbook/" target="_blank" rel="noopener">https://www.servicemesher.com/istio-handbook/</a></p><p><img src="/2023/09/12/HelloGithub/image-20200603113735547.png" srcset="/img/loading.gif" alt="image-20200603113735547"></p><h2 id="Yearning（G语言SQL审核平台）"><a href="#Yearning（G语言SQL审核平台）" class="headerlink" title="Yearning（G语言SQL审核平台）"></a>Yearning（G语言SQL审核平台）</h2><p><a href="https://github.com/cookieY/Yearning" target="_blank" rel="noopener">Yearning</a></p><p>演示地址：<a href="http://yearning.io/" target="_blank" rel="noopener">http://yearning.io/</a></p><p>Go 写的高颜值、开源 SQL 审核平台<br><img src="/2023/09/12/HelloGithub/Yearning.png" srcset="/img/loading.gif" alt="Yearning"></p><h2 id="jexcel（Excel操作工具）"><a href="#jexcel（Excel操作工具）" class="headerlink" title="jexcel（Excel操作工具）"></a>jexcel（Excel操作工具）</h2><p><a href="https://github.com/paulhodel/jexcel" target="_blank" rel="noopener">jexcel</a></p><p>在线地址：<a href="https://bossanova.uk/jexcel" target="_blank" rel="noopener">https://bossanova.uk/jexcel</a></p><p><img src="/2023/09/12/HelloGithub/image-20200828100110759.png" srcset="/img/loading.gif" alt="image-20200828100110759"></p><p>一个轻量级、功能强大的电子表格库。轻松实现复杂数据的表格管理，支持 JS 数组、JSON、CSV 等数据，并且可以实现 excel 文件的直接复制和粘贴。示例代码：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> data = [    [<span class="hljs-string">'Jazz'</span>, <span class="hljs-string">'Honda'</span>, <span class="hljs-string">'2019-02-12'</span>, <span class="hljs-string">''</span>, <span class="hljs-literal">true</span>, <span class="hljs-string">'$ 2.000,00'</span>, <span class="hljs-string">'#777700'</span>],    [<span class="hljs-string">'Civic'</span>, <span class="hljs-string">'Honda'</span>, <span class="hljs-string">'2018-07-11'</span>, <span class="hljs-string">''</span>, <span class="hljs-literal">true</span>, <span class="hljs-string">'$ 4.000,01'</span>, <span class="hljs-string">'#007777'</span>],];</code></pre><h2 id="❤️form-create（JSON表单构建工具）"><a href="#❤️form-create（JSON表单构建工具）" class="headerlink" title="❤️form-create（JSON表单构建工具）"></a>❤️form-create（JSON表单构建工具）</h2><p><a href="https://github.com/xaboy/form-create" target="_blank" rel="noopener">form-create</a></p><p>在线演示地址：<a href="http://www.form-create.com/v2/" target="_blank" rel="noopener">http://www.form-create.com/v2/</a></p><p>一个可以通过 JSON 自动生成具有动态渲染、数据收集、验证和提交功能的表单生成器。结合内置多种常用表单组件和自定义组件，轻松搞定复杂的表单，支持 iview、element-ui、and-design-vue<br><img src="/2023/09/12/HelloGithub/image-20200828100124897.png" srcset="/img/loading.gif" alt="image-20200828100124897"></p><h2 id="❤️MrDoc（在线文档管理工具）"><a href="#❤️MrDoc（在线文档管理工具）" class="headerlink" title="❤️MrDoc（在线文档管理工具）"></a>❤️MrDoc（在线文档管理工具）</h2><p><a href="https://github.com/zmister2016/MrDoc" target="_blank" rel="noopener">MrDoc</a></p><p>在线地址：<a href="http://mrdoc.zmister.com/" target="_blank" rel="noopener">http://mrdoc.zmister.com</a></p><p>一个基于 Python 开发的在线文档系统。支持 Markdown 语法、文集分类、科学公式、流程图、思维导图等内容。清爽的阅读界面，还可以把内容打包导出为 Markdown 文件、EPUB 文件、PDF 文件。适合作为个人和小型团队的私有文档服务<br><img src="/2023/09/12/HelloGithub/MrDoc.png" srcset="/img/loading.gif" alt="MrDoc"></p><h2 id="geek-crawler（Python脚本获取极客时间课程）"><a href="#geek-crawler（Python脚本获取极客时间课程）" class="headerlink" title="geek_crawler（Python脚本获取极客时间课程）"></a>geek_crawler（Python脚本获取极客时间课程）</h2><p><a href="https://github.com/zhengxiaotian/geek_crawler" target="_blank" rel="noopener">geek_crawler</a></p><p>极客时间课程（目前仅支持图文、音频）下载到本地的 Python 脚本。需输入账号密码后，才能将指定极客时间专栏课程保存到本地，方便随时随地学习<br><img src="/2023/09/12/HelloGithub/geek_crawler.jpeg" srcset="/img/loading.gif" alt="geek_crawler"></p><h2 id="winget-cli（Windows包管理工具）"><a href="#winget-cli（Windows包管理工具）" class="headerlink" title="winget-cli（Windows包管理工具）"></a>winget-cli（Windows包管理工具）</h2><p><a href="https://github.com/microsoft/winget-cli" target="_blank" rel="noopener">winget-cli</a></p><p>微软开源的 Windows 程序包管理器，帮助开发者快速的安装工具（预览版）。 目前有搜索、显示和安装软件包等功能，命令简单 <code>winget install</code><br><img src="/2023/09/12/HelloGithub/winget-cli.png" srcset="/img/loading.gif" alt="winget-cli"></p><h2 id="❤️tool-tips（IDEA骚操作）"><a href="#❤️tool-tips（IDEA骚操作）" class="headerlink" title="❤️tool-tips（IDEA骚操作）"></a>❤️tool-tips（IDEA骚操作）</h2><p><a href="https://github.com/xiaoxiunique/tool-tips" target="_blank" rel="noopener">tool-tips</a></p><p>文档地址：<a href="http://atips.cn/idea/" target="_blank" rel="noopener">http://atips.cn/idea/</a></p><p>玩转 IDE 加班远离你，IntelliJ IDEA 的技巧仓库</p><p><img src="/2023/09/12/HelloGithub/image-20200604183348756.png" srcset="/img/loading.gif" alt="image-20200604183348756"></p><h2 id="❤️GitHub520（Github-Host采集网站）"><a href="#❤️GitHub520（Github-Host采集网站）" class="headerlink" title="❤️GitHub520（Github Host采集网站）"></a>❤️GitHub520（Github Host采集网站）</h2><p><a href="https://github.com/521xueweihan/GitHub520" target="_blank" rel="noopener">GitHub520</a></p><p>通过修改 hosts 解决 GitHub 访问慢、图裂问题的项目。基于 GitHub Action 定时访问 ipaddress 自动获取、输出 GitHub 相关域名对应的最新 IP 保证长期有效，用户不需要安装和运行代码，直接复制项目首页的内容便可生效</p><h2 id="❤️Crash-Course-Computer-Science-Chinese（计算机科学速成课）"><a href="#❤️Crash-Course-Computer-Science-Chinese（计算机科学速成课）" class="headerlink" title="❤️Crash-Course-Computer-Science-Chinese（计算机科学速成课）"></a>❤️Crash-Course-Computer-Science-Chinese（计算机科学速成课）</h2><p>💻 计算机速成课 | Crash Course 字幕组 (全40集 2018-5-1 精校完成) <a href="https://www.bilibili.com/video/av21376839/" target="_blank" rel="noopener">https://www.bilibili.com/video/av2137…</a></p><p>计算机科学速成课 🔥 2018年5月1号 - 全40集完结撒花</p><p><strong><em>近期视频（其他题材）：</em></strong></p><p><a href="https://crashcourse.club/" target="_blank" rel="noopener">https://crashcourse.club/</a></p><p><strong><em>精校版：</em></strong></p><p><a href="https://www.bilibili.com/video/av21376839/" target="_blank" rel="noopener">https://www.bilibili.com/video/av21376839/</a></p><p><img src="/2023/09/12/HelloGithub/image-20200619091510262.png" srcset="/img/loading.gif" alt="image-20200619091510262"></p><h2 id="fate（起中文名工具）"><a href="#fate（起中文名工具）" class="headerlink" title="fate（起中文名工具）"></a>fate（起中文名工具）</h2><p><a href="https://github.com/godcong/fate" target="_blank" rel="noopener">fate</a></p><p>命运 起名 算命 宝宝起名 起名助手 宝宝取名</p><h2 id="JApiDocs（无需额外注解的文档生成工具）"><a href="#JApiDocs（无需额外注解的文档生成工具）" class="headerlink" title="JApiDocs（无需额外注解的文档生成工具）"></a>JApiDocs（无需额外注解的文档生成工具）</h2><p><a href="https://github.com/YeDaxia/JApiDocs" target="_blank" rel="noopener">JApiDocs</a></p><p>一个无需额外注解、开箱即用的 SpringBoot 接口文档生成工具。特性：</p><ul><li>代码即文档</li><li>支持导出 HTML</li><li>同步导出客户端 Model 代码</li><li>等等</li></ul><h2 id="react-trello（JavaScript-任务管理界面）"><a href="#react-trello（JavaScript-任务管理界面）" class="headerlink" title="react-trello（JavaScript 任务管理界面）"></a>react-trello（JavaScript 任务管理界面）</h2><p><a href="https://github.com/rcdexta/react-trello" target="_blank" rel="noopener">react-trello</a></p><p>任务状态管理面板组件。实现了拖拽方式管理任务状态，点击即可编辑任务内容<br><img src="/2023/09/12/HelloGithub/image-20200828100155309.png" srcset="/img/loading.gif" alt="image-20200828100155309"></p><h2 id="rich（花里胡哨的终端）"><a href="#rich（花里胡哨的终端）" class="headerlink" title="rich（花里胡哨的终端）"></a>rich（花里胡哨的终端）</h2><p><a href="https://github.com/willmcgugan/rich" target="_blank" rel="noopener">rich</a></p><p>一个让你的终端输出变得“花里胡哨”的三方库。我的一位前辈告诉我，不要整那些花里胡哨的主题和样式，这是在自寻烦恼。可是臣妾做不到啊，这么好看的终端输出，让我的心情都愉悦起来了。瞧那性感的语法高亮、整齐的表格、舒服的颜色、进度条等，一切都是值得的<br><img src="/2023/09/12/HelloGithub/rich.png" srcset="/img/loading.gif" alt="rich"></p><h2 id="Aerial（苹果屏保）"><a href="#Aerial（苹果屏保）" class="headerlink" title="Aerial（苹果屏保）"></a>Aerial（苹果屏保）</h2><p><a href="https://github.com/JohnCoates/Aerial" target="_blank" rel="noopener">Aerial</a></p><p>炫酷的苹果系统屏保项目。该屏保视频取材自苹果零售店 Apple TV 的专用屏保，航拍质量超棒，快换上试试吧。直接下载 <a href="https://github.com/JohnCoates/Aerial/releases" target="_blank" rel="noopener">Aerial.saver.zip 文件</a>，解压后双击文件“即可食用”<br><img src="/2023/09/12/HelloGithub/image-20200828100218026.png" srcset="/img/loading.gif" alt="image-20200828100218026"></p><h2 id="vscode-rainbow-fart（VS插件-彩虹屁）"><a href="#vscode-rainbow-fart（VS插件-彩虹屁）" class="headerlink" title="vscode-rainbow-fart（VS插件 彩虹屁）"></a>vscode-rainbow-fart（VS插件 彩虹屁）</h2><p><a href="https://github.com/SaekiRaku/vscode-rainbow-fart" target="_blank" rel="noopener">vscode-rainbow-fart</a></p><p>一款在你编程时花式夸你的 VSCode 扩展插件。可以根据代码关键字，播放贴近代码意义的真人语音，并且有一个醒目的项目名字“彩虹屁”</p><h2 id="❤️GitHub-Chinese-Top-Charts（GitHub总榜项目）"><a href="#❤️GitHub-Chinese-Top-Charts（GitHub总榜项目）" class="headerlink" title="❤️GitHub-Chinese-Top-Charts（GitHub总榜项目）"></a>❤️GitHub-Chinese-Top-Charts（GitHub总榜项目）</h2><p><a href="https://github.com/kon9chunkit/GitHub-Chinese-Top-Charts" target="_blank" rel="noopener">GitHub-Chinese-Top-Charts</a></p><p>每周更新一次的 GitHub 中文项目排行榜</p><h2 id="❤️apidoc（注释生成API-文档）"><a href="#❤️apidoc（注释生成API-文档）" class="headerlink" title="❤️apidoc（注释生成API 文档）"></a>❤️apidoc（注释生成API 文档）</h2><p><a href="https://github.com/apidoc/apidoc" target="_blank" rel="noopener">apidoc</a></p><p>根据代码中的注释生成 RESTful 风格的 API 文档。注释示例：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@api</span> &#123;get&#125; /user/:id Request User information</span><span class="hljs-comment"> * <span class="hljs-doctag">@apiName</span> GetUser</span><span class="hljs-comment"> * <span class="hljs-doctag">@apiGroup</span> User</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@apiParam</span> &#123;Number&#125; id User's unique ID.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@apiSuccess</span> &#123;String&#125; firstname Firstname of the User.</span><span class="hljs-comment"> * <span class="hljs-doctag">@apiSuccess</span> &#123;String&#125; lastname  Lastname of the User.</span><span class="hljs-comment"> */</span></code></pre><h2 id="papirus-icon-theme（Linux-系统的开源-SVG-图标）"><a href="#papirus-icon-theme（Linux-系统的开源-SVG-图标）" class="headerlink" title="papirus-icon-theme（Linux 系统的开源 SVG 图标）"></a>papirus-icon-theme（Linux 系统的开源 SVG 图标）</h2><p><a href="https://github.com/PapirusDevelopmentTeam/papirus-icon-theme" target="_blank" rel="noopener">papirus-icon-theme</a></p><p>适用于 Linux 系统的免费开源 SVG 图标主题<br><img src="/2023/09/12/HelloGithub/papirus-icon-theme.png" srcset="/img/loading.gif" alt="papirus-icon-theme"></p><h2 id="gotty（终端执行的命令展示到网页）"><a href="#gotty（终端执行的命令展示到网页）" class="headerlink" title="gotty（终端执行的命令展示到网页）"></a>gotty（终端执行的命令展示到网页）</h2><p><a href="https://github.com/yudai/gotty" target="_blank" rel="noopener">gotty</a></p><p>能够把终端执行的命令展示到网页上的工具。安装和运行命令如下：</p><pre><code class="hljs fsharp">安装：go get github.com/yudai/gotty运行：gotty [options] &lt;command&gt; <span class="hljs-meta">[&lt;arguments...&gt;]</span></code></pre><h2 id="logrus（Go-第三方日志库）"><a href="#logrus（Go-第三方日志库）" class="headerlink" title="logrus（Go 第三方日志库）"></a>logrus（Go 第三方日志库）</h2><p><a href="https://github.com/sirupsen/logrus" target="_blank" rel="noopener">logrus</a></p><p>可能是 Go 目前最受欢迎的第三方日志库。日志首先要能让人看懂，其次是程序易于处理日志包含的内容，logrus 也许能让你轻松快速实现上述两点<br><img src="/2023/09/12/HelloGithub/logrus.png" srcset="/img/loading.gif" alt="logrus"></p><h2 id="❤️metersphere（企业级持续测试平台）"><a href="#❤️metersphere（企业级持续测试平台）" class="headerlink" title="❤️metersphere（企业级持续测试平台）"></a>❤️metersphere（企业级持续测试平台）</h2><p><a href="https://github.com/metersphere/metersphere" target="_blank" rel="noopener">metersphere</a></p><p>一站式的开源企业级持续测试平台。适应场景包括：测试跟踪、接口测试、性能测试等，兼容 JMeter 等开源标准，能够帮助开发和测试团队充分利用云弹性进行高度可扩展的自动化测试。测试同学的福音<br><img src="/2023/09/12/HelloGithub/metersphere.png" srcset="/img/loading.gif" alt="metersphere"></p><h2 id="MyBookshelf（安卓小说阅读软件）"><a href="#MyBookshelf（安卓小说阅读软件）" class="headerlink" title="MyBookshelf（安卓小说阅读软件）"></a>MyBookshelf（安卓小说阅读软件）</h2><p><a href="https://github.com/gedoor/MyBookshelf" target="_blank" rel="noopener">MyBookshelf</a></p><p>免费开源的安卓小说阅读软件，能够自定义订阅小说数据源。支持：</p><ul><li>全局状态栏沉浸</li><li>自定义多线程搜索、缓存</li><li>支持一键缓存</li><li>点击章节名跳转小说目录</li><li>自定义字体、阅读背景、文字颜色、背景颜色</li><li>等等</li></ul><h2 id="❤️all-contributors-cli（给贡献者一个惊喜）"><a href="#❤️all-contributors-cli（给贡献者一个惊喜）" class="headerlink" title="❤️all-contributors-cli（给贡献者一个惊喜）"></a>❤️all-contributors-cli（给贡献者一个惊喜）</h2><p><a href="https://github.com/all-contributors/all-contributors-cli" target="_blank" rel="noopener">all-contributors-cli</a></p><p>这是一个用于认可开源项目贡献者的规范，不仅仅是代码，它感谢每一个贡献。</p><p>基本想法是：</p><blockquote><p>使用项目README (或者项目中其他重要的公开文档页) 来认可项目社区成员的贡献</p><p>同时提供一定的CSS自定义功能，可以丰富界面</p></blockquote><pre><code class="hljs bash"><span class="hljs-comment"># 使用说明，操作文档：https://allcontributors.org/docs/zh-cn/cli/usage</span><span class="hljs-comment"># Tips 非 node.js 构建的项目可以拉取本项目，修改配置生成目标文件，然后复制即可，不一定要在自己的项目中直接运行命令</span><span class="hljs-comment"># 预先安装</span>npm install -g create-react-app yarn<span class="hljs-comment">#  初始化</span>yarn all-contributors init<span class="hljs-comment"># 增加用户</span>yarn all-contributors add jfmengels code,doc<span class="hljs-comment"># 重构界面</span>yarn all-contributors （选第二个）</code></pre><p><img src="/2023/09/12/HelloGithub/image-20200819093041276.png" srcset="/img/loading.gif" alt="image-20200819093041276"></p><h2 id="❤️starcharts（Star走势图）"><a href="#❤️starcharts（Star走势图）" class="headerlink" title="❤️starcharts（Star走势图）"></a>❤️starcharts（Star走势图）</h2><p><a href="https://github.com/caarlos0/starcharts" target="_blank" rel="noopener">starcharts</a></p><p>在线预览：</p><p>更改所有人和仓库名即可：<a href="https://starchart.cc/juejin-im/open-source.svg" target="_blank" rel="noopener">https://starchart.cc/juejin-im/open-source.svg</a></p><p>&lt; 复制地址至浏览器中查看 &gt;</p><p><img src="/2023/09/12/HelloGithub/image-20200819093327340.png" srcset="/img/loading.gif" alt="image-20200819093327340"></p><h2 id="❤️Logo-Generator（Pornhub风格Logo生成器）"><a href="#❤️Logo-Generator（Pornhub风格Logo生成器）" class="headerlink" title="❤️Logo Generator（Pornhub风格Logo生成器）"></a>❤️Logo Generator（Pornhub风格Logo生成器）</h2><p><a href="https://github.com/bestony/logoly" target="_blank" rel="noopener">logoly</a></p><p>在线演示地址：<a href="https://www.logoly.pro/" target="_blank" rel="noopener">www.logoly.pro/</a></p><p>A Pornhub Flavour Logo Generator，「西秦公子」的开源项目</p><p><img src="/2023/09/12/HelloGithub/image-20200819170925233.png" srcset="/img/loading.gif" alt="image-20200819170925233"></p><h2 id="❤️github-cards（Github-项目卡片）"><a href="#❤️github-cards（Github-项目卡片）" class="headerlink" title="❤️github-cards（Github 项目卡片）"></a>❤️github-cards（Github 项目卡片）</h2><p>GitHub地址：<a href="https://github.com/lepture/github-cards" target="_blank" rel="noopener">github-cards</a></p><p>Card for your GitHub profile, card for your GitHub repositories.</p><p><img src="/2023/09/12/HelloGithub/image-20200823125212747.png" srcset="/img/loading.gif" alt="image-20200823125212747"></p><h2 id="husky（前端代码检查工具）"><a href="#husky（前端代码检查工具）" class="headerlink" title="husky（前端代码检查工具）"></a>husky（前端代码检查工具）</h2><p><a href="https://github.com/typicode/husky" target="_blank" rel="noopener">husky</a></p><p><code>husky</code> 会根据 package.json 里的配置，在 <code>.git/hooks</code> 目录生成 <a href="https://git-scm.com/docs/githooks" target="_blank" rel="noopener">所有</a> 的 <code>hook</code> 脚本，配合其他一些工具，它可以严格为我们把控代码质量和提交记录，让我们的工作流更加规范、更加完善</p><h2 id="LeetCode-Go（LeeCode-Go语言实战）"><a href="#LeetCode-Go（LeeCode-Go语言实战）" class="headerlink" title="LeetCode-Go（LeeCode Go语言实战）"></a>LeetCode-Go（LeeCode Go语言实战）</h2><p><a href="https://github.com/halfrost/LeetCode-Go" target="_blank" rel="noopener">LeetCode-Go</a></p><p>《LeetCode Cookbook》是帮助开发者在 LeetCode 上做题，提供解题思路和代码的项目。目前已经收录了 500+ 道题的题解和代码，代码都是 runtime beats 100%，代码全部都是用 Go 语言实现。<a href="https://books.halfrost.com/leetcode" target="_blank" rel="noopener">在线阅读</a></p><h2 id="remote-browser-JavaScript控制浏览器"><a href="#remote-browser-JavaScript控制浏览器" class="headerlink" title="remote-browser(JavaScript控制浏览器)"></a>remote-browser(JavaScript控制浏览器)</h2><p><a href="https://github.com/intoli/remote-browser" target="_blank" rel="noopener">remote-browser</a></p><p>实现用 JavaScript 语言控制 Chrome 和 Firefox 浏览器的库。可轻松实现自动化测试、抓取数据等功能<br><img src="/2023/09/12/HelloGithub/image-20200828100256061.png" srcset="/img/loading.gif" alt="image-20200828100256061"></p><h2 id="❤️star-history（展示star历史的项目）"><a href="#❤️star-history（展示star历史的项目）" class="headerlink" title="❤️star-history（展示star历史的项目）"></a>❤️star-history（展示star历史的项目）</h2><p><a href="https://github.com/timqian/star-history" target="_blank" rel="noopener">star-history</a></p><p>展示 GitHub 项目 Star 历史的在线工具。支持多个项目展示在同一个图表上，效果如下图：<br><img src="/2023/09/12/HelloGithub/image-20200828100310478.png" srcset="/img/loading.gif" alt="image-20200828100310478"></p><h2 id="❤️handcalcs（python代码转公式）"><a href="#❤️handcalcs（python代码转公式）" class="headerlink" title="❤️handcalcs（python代码转公式）"></a>❤️handcalcs（python代码转公式）</h2><p>通过简单的 Python 代码，生成复杂公式的工具。还记得写论文推算算法的时候，被一行行公式支配的恐惧吗？该库可以将 Python 写的公式，展示为 LaTeX 格式，效果如下：<br><img src="/2023/09/12/HelloGithub/image-20200828100330724.png" srcset="/img/loading.gif" alt="image-20200828100330724"></p><h2 id="BuildYourOwnLisp（基于C构建自己的Lisp）"><a href="#BuildYourOwnLisp（基于C构建自己的Lisp）" class="headerlink" title="BuildYourOwnLisp（基于C构建自己的Lisp）"></a>BuildYourOwnLisp（基于C构建自己的Lisp）</h2><p><a href="https://github.com/orangeduck/BuildYourOwnLisp" target="_blank" rel="noopener">BuildYourOwnLisp</a></p><p>该书教你用 C 语言实现自己的 Lisp 语言。用 1000 多行实现一个小但功能齐全的 Lisp 语言，这里有份中文翻译版本，但是没有翻译完<a href="https://ksco.gitbooks.io/build-your-own-lisp/content/" target="_blank" rel="noopener">点击阅读</a></p><h2 id="Never-Blink（图像处理小游戏）"><a href="#Never-Blink（图像处理小游戏）" class="headerlink" title="Never-Blink（图像处理小游戏）"></a>Never-Blink（图像处理小游戏）</h2><p><a href="https://github.com/ByronHsu/Never-Blink" target="_blank" rel="noopener">Never-Blink</a></p><p>谁先眨眼谁就输了的游戏。使用 React + Flask + Dlib 技术实现的“眨眼就输了”在线游戏，虽然是个 demo 级别的项目，但是很有意思可以在本地运行起来找朋友一起玩一下<br><img src="/2023/09/12/HelloGithub/image-20200828100343513.png" srcset="/img/loading.gif" alt="image-20200828100343513"></p><h2 id="go-micro-（Go-微服务框架）"><a href="#go-micro-（Go-微服务框架）" class="headerlink" title="go-micro （Go 微服务框架）"></a>go-micro （Go 微服务框架）</h2><p><a href="[go-micro](https://github.com/micro/go-micro)">GitHub地址</a></p><p>一款 Go 插件化的基础框架。我只知道它是个 Go 微服务框架，基于它可以快速构建微服务。示例代码如图所示：<br><img src="/2023/09/12/HelloGithub/go-micro.png" srcset="/img/loading.gif" alt="go-micro"></p><h2 id="tesseract-js（文字识别的-JS-库）"><a href="#tesseract-js（文字识别的-JS-库）" class="headerlink" title="tesseract.js（文字识别的 JS 库）"></a>tesseract.js（文字识别的 JS 库）</h2><p><a href="https://github.com/naptha/tesseract.js" target="_blank" rel="noopener">tesseract.js</a></p><p>支持多种语言的文字识别的 JS 库，能够方便、准确的把图片中的文字解析提取出来（就能复制了）。基于 Tesseract OCR 引擎实现的 JS 版本，方便前端实现文字识别功能和在浏览器中直接使用。<a href="https://tesseract.projectnaptha.com/" target="_blank" rel="noopener">在线尝试</a><br><img src="/2023/09/12/HelloGithub/tesseract.png" srcset="/img/loading.gif" alt="tesseract.js"></p><h2 id="mind-elixir-core（思维导图库）"><a href="#mind-elixir-core（思维导图库）" class="headerlink" title="mind-elixir-core（思维导图库）"></a>mind-elixir-core（思维导图库）</h2><p><a href="https://github.com/ssshooter/mind-elixir-core" target="_blank" rel="noopener">mind-elixir-core</a></p><p>一款免费开源的思维导图 JS 库。<a href="https://mindelixir.ink/#/" target="_blank" rel="noopener">在线尝试</a><br><img src="/2023/09/12/HelloGithub/mind-elixir-core.jpg" srcset="/img/loading.gif" alt="mind-elixir-core"></p><h2 id="taichi（高性能图形学编程框架）"><a href="#taichi（高性能图形学编程框架）" class="headerlink" title="taichi（高性能图形学编程框架）"></a>taichi（高性能图形学编程框架）</h2><p><a href="https://github.com/taichi-dev/taichi" target="_blank" rel="noopener">taichi</a></p><p>一个高性能图形学编程框架。它可以将你编写的 Python 代码转换成高效的汇编代码，在多 CPU 和 GPU 上运行，相当于是在用 Python 的语法写着色器。Taichi 解决了图形学配环境难，代码移植性差等问题，只需 <code>pip install taichi</code> 即可安装，编写的程序在 Windows、Linux、OSX 上均可运行，降低了新手学习图形学的门槛。</p><p><img src="/2023/09/12/HelloGithub/taichi.gif" srcset="/img/loading.gif" alt="taichi"></p><h2 id="lite（超级轻量级的文本编辑器）"><a href="#lite（超级轻量级的文本编辑器）" class="headerlink" title="lite（超级轻量级的文本编辑器）"></a>lite（超级轻量级的文本编辑器）</h2><p><a href="https://github.com/rxi/lite" target="_blank" rel="noopener">lite</a></p><p>一款用 Lua 编写的超级轻量级的文本编辑器。在 Windows 下的 exe 文件虽然只有 300KB 左右，但颜值、功能和速度却一点都不差，甚至还支持使用自定义插件、配色主题等功能。小而美的文本编辑器<br><img src="/2023/09/12/HelloGithub/lite.png" srcset="/img/loading.gif" alt="lite"></p><h2 id="ali（实时展示分析的压力测试工具）"><a href="#ali（实时展示分析的压力测试工具）" class="headerlink" title="ali（实时展示分析的压力测试工具）"></a>ali（实时展示分析的压力测试工具）</h2><p><a href="https://github.com/nakabonne/ali" target="_blank" rel="noopener">ali</a></p><p>能够实时展示分析的压力测试工具。现在压测工具有很多，这款的亮点在于可以在终端实时展示压测过程的曲线。一条命令搞定启动：<code>ali 地址</code><br><img src="/2023/09/12/HelloGithub/ali.gif" srcset="/img/loading.gif" alt="ali"></p><h2 id="BilibiliTask（基于GitHub-Action的工具）"><a href="#BilibiliTask（基于GitHub-Action的工具）" class="headerlink" title="BilibiliTask（基于GitHub Action的工具）"></a>BilibiliTask（基于GitHub Action的工具）</h2><p><a href="https://github.com/srcrs/BilibiliTask" target="_blank" rel="noopener">地址</a></p><p>哔哩哔哩定时自动完成任务项目。该项目借助 GitHub Action 自动完成：每日任务、投币、直播签到等，还可以把运行结果推送到微信，是一个解决重复劳动的有趣项目。按照项目首页的教程，花点时间就能配置好，一劳永逸<br><img src="/2023/09/12/HelloGithub/BilibiliTask.png" srcset="/img/loading.gif" alt="BilibiliTask"></p><h2 id="wagtail（快速建站）"><a href="#wagtail（快速建站）" class="headerlink" title="wagtail（快速建站）"></a>wagtail（快速建站）</h2><p><a href="https://github.com/wagtail/wagtail" target="_blank" rel="noopener">地址</a></p><p>目前最强大的开源 Django CMS（内容管理系统）之一。我很少用“最”这个字眼，节省时间就聊聊它惊艳到我的点吧。首先该项目更新、迭代活跃，其次项目首页提到的功能都是免费的，没有付费解锁的骚操作。wagtail 专注于内容管理，不束缚前端实现。有趣的 StreamField 技术让你的内容变得灵活且不失结构，竟然还支持 A/B 测试，最后 Google、NASA 他们都在用这个项目<br><img src="/2023/09/12/HelloGithub/wagtail.png" srcset="/img/loading.gif" alt="wagtail"></p><h2 id="stats（MacOS-菜单监控）"><a href="#stats（MacOS-菜单监控）" class="headerlink" title="stats（MacOS 菜单监控）"></a>stats（MacOS 菜单监控）</h2><p><a href="https://github.com/exelban/stats" target="_blank" rel="noopener">地址</a></p><p>macOS 菜单栏上的监控工具。支持 CPU、GPU、内存、网络等监控和多语言<br><img src="/2023/09/12/HelloGithub/stats.png" srcset="/img/loading.gif" alt="stats"></p><h2 id="socialify（在线生成GitHub头图）"><a href="#socialify（在线生成GitHub头图）" class="headerlink" title="socialify（在线生成GitHub头图）"></a>socialify（在线生成GitHub头图）</h2><p><a href="https://github.com/wei/socialify" target="_blank" rel="noopener">地址</a></p><p><a href="https://socialify.git.ci/" target="_blank" rel="noopener">在线尝试</a></p><p>一键自动生成 GitHub 仓库头图。很多 GitHub 开源项目的作者不会用 PS，想要制作一张项目推广图就很困难，Socialify 就是帮你解决这个头疼的问题。<br><img src="/2023/09/12/HelloGithub/socialify.png" srcset="/img/loading.gif" alt="socialify"></p><h2 id="❤️BILIBILI-HELPER（基于Java的自动化工具）"><a href="#❤️BILIBILI-HELPER（基于Java的自动化工具）" class="headerlink" title="❤️BILIBILI-HELPER（基于Java的自动化工具）"></a>❤️BILIBILI-HELPER（基于Java的自动化工具）</h2><p><a href="https://github.com/kkzhilu/BILIBILI-HELPER" target="_blank" rel="noopener">BILIBILI-HELPER</a></p><p>利用GitHub Action定时任务实现B站，哔哩哔哩（Bilibili）自动签到每日自动投币，银瓜子兑换硬币，领取大会员福利，大会员月底给自己充电等。每天轻松获取65经验值。赶快和我一起成为Lv6吧！</p><p>创意，创意，创意</p><h2 id="fiction-house（Java-小说网站）"><a href="#fiction-house（Java-小说网站）" class="headerlink" title="fiction_house（Java 小说网站）"></a>fiction_house（Java 小说网站）</h2><p><a href="https://github.com/201206030/fiction_house" target="_blank" rel="noopener">fiction_house</a></p><p><a href="http://ruoshu.com/" target="_blank" rel="noopener">在线尝试</a></p><p>小说精品屋是一个多平台（web、安卓app、微信小程序）、功能完善的屏幕自适应小说漫画连载系统，包含精品小说专区、轻小说专区和漫画专区。包括小说/漫画分类、小说/漫画搜索、小说/漫画排行、完本小说/漫画、小说/漫画评分、小说/漫画在线阅读、小说/漫画书架、小说/漫画阅读记录、小说下载、小说弹幕、小说/漫画自动采集/更新/纠错、小说内容自动分享到微博、邮件自动推广、链接自动推送到百度搜索引擎等功能。</p><h2 id="syncthing-Go-文件同步工具"><a href="#syncthing-Go-文件同步工具" class="headerlink" title="syncthing (Go 文件同步工具)"></a>syncthing (Go 文件同步工具)</h2><p><a href="https://github.com/syncthing/syncthing" target="_blank" rel="noopener">syncthing</a></p><p>一个采用 Go 语言编写的免费、跨平台的文件同步工具。它不需要安装，只需要下载对应系统的压缩包解压后就可以直接运行和使用。拥有命令行、Web 和桌面程序多种操作模式，同时支持内网和互联网的文件同步，可以用来搭建私有网盘。又一个代替付费网盘的选择，如果考虑到昂贵的宽费用。可以把 syncthing 做为局域网下手机、电视和电脑共享文件的开源解决方案</p><h2 id="freenom（域名自动续约工具）"><a href="#freenom（域名自动续约工具）" class="headerlink" title="freenom（域名自动续约工具）"></a>freenom（域名自动续约工具）</h2><p><a href="https://github.com/luolongfei/freenom" target="_blank" rel="noopener">freenom</a></p><p>自动续期 Freenom 免费域名的工具。Freenom 是一个提供免费顶级域名的商家，不过申请的域名需要每年定时续期，否则会被回收。有了这个项目，白 piao 顶级域名就是那么简单</p><h2 id="upptime（基于GitHubAction的测速工具）"><a href="#upptime（基于GitHubAction的测速工具）" class="headerlink" title="upptime（基于GitHubAction的测速工具）"></a>upptime（基于GitHubAction的测速工具）</h2><p><strong><a href="https://github.com/upptime/upptime" target="_blank" rel="noopener">upptime</a></strong></p><p>一个免费开源的网站正常运行时间（uptime）监控服务。之所没有任何费用是因为实现方法都是完全基于 GitHub 提供的免费服务，比如：使用 GitHub 的 Action 每隔 5 分钟访问一次目标网站，获取网站最新的状态。然后通过 GitHub Issues 记录和报告异常，最后在 GitHub Pages 上可视化展示网站的运行状态。</p><p><img src="/2023/09/12/HelloGithub/image-20201202012712300.png" srcset="/img/loading.gif" alt="image-20201202012712300"></p><h2 id="eul（Mac-状态栏监控）"><a href="#eul（Mac-状态栏监控）" class="headerlink" title="eul（Mac 状态栏监控）"></a>eul（Mac 状态栏监控）</h2><p><a href="https://github.com/gao-sun/eul" target="_blank" rel="noopener">eul</a></p><p>一款极简免费的 macOS 状态监控工具</p><p><img src="/2023/09/12/HelloGithub/image-20201202012801026.png" srcset="/img/loading.gif" alt="image-20201202012801026"></p><h2 id="❤️screenity（Chrome-插件）"><a href="#❤️screenity（Chrome-插件）" class="headerlink" title="❤️screenity（Chrome 插件）"></a>❤️screenity（Chrome 插件）</h2><p><a href="https://github.com/alyssaxuu/screenity" target="_blank" rel="noopener">screenity</a></p><p>一个强大的屏幕录制和标注的 Chrome 插件，特性：</p><ul><li>🎥 可以录制任何应用的内容，包含“色相头”</li><li>✏️ 在屏幕上的任何地方，添加文本和箭头等注释</li><li>👀 突出你的点击操作、光标</li><li>💾 支持导出为 mp4、gif 等常用格式</li><li>✂️ 修剪或删除录像</li></ul><p><img src="/2023/09/12/HelloGithub/screenity.gif" srcset="/img/loading.gif" alt="screenity"></p><h2 id="❤️running-page（展示跑步的项目）"><a href="#❤️running-page（展示跑步的项目）" class="headerlink" title="❤️running_page（展示跑步的项目）"></a>❤️running_page（展示跑步的项目）</h2><p><a href="https://github.com/yihong0618/running_page" target="_blank" rel="noopener">running_page</a></p><p>一个展示个人跑步主页的 Python 项目。特性：</p><ul><li>GitHub Actions 管理自动同步跑步进程及自动生成新的页面</li><li>Gatsby 生成的静态网页，速度快</li><li>Mapbox 进行地图展示</li><li>支持 Nike、Runtastic、佳明、Keep 的数据</li><li>自动备份 gpx 数据，方便备份及上传到其它软件</li></ul><p><img src="/2023/09/12/HelloGithub/image-20201202013135766.png" srcset="/img/loading.gif" alt="image-20201202013135766"></p><h2 id="Ant-Forest（蚂蚁森林能量自动收获脚本）"><a href="#Ant-Forest（蚂蚁森林能量自动收获脚本）" class="headerlink" title="Ant-Forest（蚂蚁森林能量自动收获脚本）"></a>Ant-Forest（蚂蚁森林能量自动收获脚本）</h2><p><a href="https://github.com/SuperMonster003/Ant-Forest" target="_blank" rel="noopener">Ant-Forest</a></p><p>基于 Auto.js 的蚂蚁森林能量自动收获脚本：</p><ol><li>能量球识别无法使用控件信息（使用基于霍夫变换的图像识别）</li><li>脚本执行逻辑易被打断（使用事件监听及扩展模块增强鲁棒性）</li><li>每次只能运行一次（完善的复查及定时循环功能）</li><li>不同设备分辨率及屏幕比例不同（使用等比缩放/定宽缩放等进行适配）</li></ol><h2 id="JustAuth（多平台第三方登陆）"><a href="#JustAuth（多平台第三方登陆）" class="headerlink" title="JustAuth（多平台第三方登陆）"></a>JustAuth（多平台第三方登陆）</h2><p><a href="https://github.com/justauth/JustAuth" target="_blank" rel="noopener">JustAuth</a></p><p>帮你搞定第三方登陆的 Java 开源组件。使用简单、接入方便，帮你随心所欲地接入第三方登陆，让登陆变得简单。</p><h2 id="Multiavatar（生成人物头像的-JS-库）"><a href="#Multiavatar（生成人物头像的-JS-库）" class="headerlink" title="Multiavatar（生成人物头像的 JS 库）"></a>Multiavatar（生成人物头像的 JS 库）</h2><p><a href="https://github.com/multiavatar/Multiavatar" target="_blank" rel="noopener">Multiavatar</a></p><p>生成人物头像的 JS 库。支持随机生成一个好看、独特、多文化的头像</p><h2 id="awesome-seo（Google-SEO-和流量变现资料的项目）"><a href="#awesome-seo（Google-SEO-和流量变现资料的项目）" class="headerlink" title="awesome-seo（Google SEO 和流量变现资料的项目）"></a>awesome-seo（Google SEO 和流量变现资料的项目）</h2><p><a href="https://github.com/madawei2699/awesome-seo" target="_blank" rel="noopener">awesome-seo</a></p><p>有关 Google SEO 和流量变现资料的项目。该项目是作者学习 SEO 过程中整理的权威资料</p><h2 id="Anki-Android（Anki）"><a href="#Anki-Android（Anki）" class="headerlink" title="Anki-Android（Anki）"></a>Anki-Android（Anki）</h2><p><a href="https://github.com/ankidroid/Anki-Android" target="_blank" rel="noopener">Anki-Android</a></p><p>高效学习神器 Anki 安卓客户端。</p><h2 id="❤️WxJave（企业微信开源工具）"><a href="#❤️WxJave（企业微信开源工具）" class="headerlink" title="❤️WxJave（企业微信开源工具）"></a>❤️WxJave（企业微信开源工具）</h2><p><strong><a href="https://github.com/Wechat-Group/WxJava" target="_blank" rel="noopener">WxJava</a></strong></p><p>微信Java开发工具包，支持包括微信支付、开放平台、公众号、企业微信/企业号、小程序等微信功能模块的后端开发。</p><h2 id="JustAuth（鉴权工具包）"><a href="#JustAuth（鉴权工具包）" class="headerlink" title="JustAuth（鉴权工具包）"></a>JustAuth（鉴权工具包）</h2><p><a href="https://github.com/justauth/JustAuth" target="_blank" rel="noopener">JustAuth</a></p><p>帮你搞定第三方登陆的 Java 开源组件。使用简单、接入方便，帮你随心所欲地接入第三方登陆，让登陆变得简单。目前已经支持十多个平台</p><h2 id="blind-watermark（Python盲水印）"><a href="#blind-watermark（Python盲水印）" class="headerlink" title="blind_watermark（Python盲水印）"></a>blind_watermark（Python盲水印）</h2><p><strong><a href="https://github.com/guofei9987/blind_watermark" target="_blank" rel="noopener">blind_watermark</a></strong></p><p>给图片加盲水印的 Python 库。盲水印就是图片有水印但人眼看不出来，需要通过程序才能提取水印，相当于隐形“盖章”，可以用在数据泄露溯源、版权保护等场景。该库出自阿里巴巴安全团队，强大之处：</p><ul><li>解析水印图时无需原图</li><li>水印图剪裁、旋转都不会破坏图中的盲水印</li><li>支持密码加密</li></ul><h2 id="ChatUI（对话体JavaScript）"><a href="#ChatUI（对话体JavaScript）" class="headerlink" title="ChatUI（对话体JavaScript）"></a>ChatUI（对话体JavaScript）</h2><p><strong><a href="https://github.com/alibaba/ChatUI" target="_blank" rel="noopener">ChatUI</a></strong></p><p>专注于对话领域的 UI 开源项目。可以帮助用户快速搭建体验友好的机器人对话界面，特性：</p><ul><li>最佳实践：基于阿里小蜜业务积累和打磨的对话式交互最佳实践</li><li>TypeScript：使用 TypeScript 开发，提供完整的类型定义文件</li><li>响应式：响应式布局，在无线和 PC 端都可以友好展现</li><li>主题：支持灵活的样式定制，以满足业务和品牌上多样化的视觉需求</li><li>国际化：支持多语言和本土化特性</li></ul><h2 id="Fawkes（用Ai来保护隐私）"><a href="#Fawkes（用Ai来保护隐私）" class="headerlink" title="Fawkes（用Ai来保护隐私）"></a>Fawkes（用Ai来保护隐私）</h2><p><a href="https://github.com/Shawn-Shan/fawkes" target="_blank" rel="noopener">fawkes</a></p><p>通过 AI 技术保护个人照片隐私的开源项目。芝加哥大学 Sand Lab 团队发起的项目，通过 AI 技术对图片的像素进行一些微调，人眼很难看出修改前后的区别，但对于人脸识别系统来说微调前后是天壤之别的，从而达到保护你照片隐私的效果</p><h2 id="Nav（静态SEO模块化工具）"><a href="#Nav（静态SEO模块化工具）" class="headerlink" title="Nav（静态SEO模块化工具）"></a>Nav（静态SEO模块化工具）</h2><p><a href="https://github.com/xjh22222228/nav" target="_blank" rel="noopener">nav</a></p><p>一个支持 SEO 的静态导航网站。不依赖后端的纯前端项目开箱即用，简单清爽</p><img src="/2023/09/12/HelloGithub/kexianming1/Desktop/GitHub/super-kerwin/Best Coder/开源篇/HelloGithub/f8bZL6J5PsBEwq4.png" srcset="/img/loading.gif" alt="nav" style="zoom: 25%;"><h2 id="vardbg（算法图形化）"><a href="#vardbg（算法图形化）" class="headerlink" title="vardbg（算法图形化）"></a>vardbg（算法图形化）</h2><p><a href="https://github.com/CCExtractor/vardbg" target="_blank" rel="noopener">vardbg</a></p><p>一款能够把 Python 程序执行过程，导出成视频或动图的代码调试工具。可用于动画学算法、制作代码讲解视频等场景</p><img src="/2023/09/12/HelloGithub/kexianming1/Desktop/GitHub/super-kerwin/Best Coder/开源篇/HelloGithub/image-20230313200725510.png" srcset="/img/loading.gif" alt="image-20230313200725510" style="zoom:25%;"><h2 id="React-Resume-Site（在线简历生成）"><a href="#React-Resume-Site（在线简历生成）" class="headerlink" title="React-Resume-Site（在线简历生成）"></a>React-Resume-Site（在线简历生成）</h2><p><a href="https://github.com/hua1995116/react-resume-site" target="_blank" rel="noopener">react-resume-site</a></p><p>一款免费的简历在线制作工具。用写 Markdown 的方式制作出好看的简历，<a href="https://resume.mdedit.online/editor/#/" target="_blank" rel="noopener">在线尝试</a></p><h2 id="Nativefier（Web-页面变成本地应用）"><a href="#Nativefier（Web-页面变成本地应用）" class="headerlink" title="Nativefier（Web 页面变成本地应用）"></a>Nativefier（Web 页面变成本地应用）</h2><p><strong><a href="https://github.com/nativefier/nativefier" target="_blank" rel="noopener">nativefier</a></strong></p><p>能够把 Web 页面变成本地应用的命令行工具。通过 Electron+Chromium 把网站包装成本地 .app、.exe 等可执行文件，支持运行在 Windows、macOS 和 Linux 操作系统上</p><h2 id="❤️Blue-topaz-example（Obsidian插件合集及介绍）"><a href="#❤️Blue-topaz-example（Obsidian插件合集及介绍）" class="headerlink" title="❤️Blue-topaz-example（Obsidian插件合集及介绍）"></a>❤️Blue-topaz-example（Obsidian插件合集及介绍）</h2><p><strong><a href="https://github.com/PKM-er/Blue-topaz-example" target="_blank" rel="noopener">Blue-topaz-example</a></strong></p><p><img src="/2023/09/12/HelloGithub/image-20230529152931235.png" srcset="/img/loading.gif" alt="image-20230529152931235"></p><h2 id="❤️BingGPT（BingGPTApp）"><a href="#❤️BingGPT（BingGPTApp）" class="headerlink" title="❤️BingGPT（BingGPTApp）"></a>❤️BingGPT（BingGPTApp）</h2><p><strong><a href="https://github.com/dice2o/BingGPT" target="_blank" rel="noopener">BingGPT</a></strong></p><p>注意：issues中可以解决很多问题</p><h2 id="❤️-每日一句名言"><a href="#❤️-每日一句名言" class="headerlink" title="❤️ 每日一句名言"></a>❤️ 每日一句名言</h2><p>Api地址: <a href="https://v1.hitokoto.cn/" target="_blank" rel="noopener">https://v1.hitokoto.cn/</a></p><h2 id="待看：64期"><a href="#待看：64期" class="headerlink" title="待看：64期"></a>待看：64期</h2><h2 id="待看：榜单"><a href="#待看：榜单" class="headerlink" title="待看：榜单"></a>待看：<a href="https://github.com/Wechat-ggGitHub/Awesome-GitHub-Repo" target="_blank" rel="noopener">榜单</a></h2><h1 id="我的开源项目"><a href="#我的开源项目" class="headerlink" title="我的开源项目"></a>我的开源项目</h1><ul><li><a href="https://github.com/kkzhilu/Code-Generate" target="_blank" rel="noopener">Code-Generate</a>  代码生成器</li><li><a href="https://github.com/kkzhilu/Kerwin-DesignPattern" target="_blank" rel="noopener">Kerwin-DesignPattern</a>  Kerwin的Super设计模式篇~ （非产品）</li></ul><h1 id="朋友们的开源项目"><a href="#朋友们的开源项目" class="headerlink" title="朋友们的开源项目"></a>朋友们的开源项目</h1><h2 id="sql-convert（mybatis插件-将mysql查询语句转化为oracle）"><a href="#sql-convert（mybatis插件-将mysql查询语句转化为oracle）" class="headerlink" title="sql-convert（mybatis插件,将mysql查询语句转化为oracle）"></a>sql-convert（mybatis插件,将mysql查询语句转化为oracle）</h2><p><a href="https://gitee.com/kkzhilu/sql-convert" target="_blank" rel="noopener">gitee</a></p><p>mybatis插件,将mysql查询语句转化为oracle，作者：程顺鹏</p><h2 id="spring-boot-rocket-mq-consumer-starter"><a href="#spring-boot-rocket-mq-consumer-starter" class="headerlink" title="spring-boot-rocket-mq-consumer-starter"></a>spring-boot-rocket-mq-consumer-starter</h2><p><a href="https://github.com/chengsp-tinet/spring-boot-rocket-mq-consumer-starter" target="_blank" rel="noopener">spring-boot-rocket-mq-consumer-starter</a></p><p>SpringBoot Mq Starter consumer</p><h2 id="spring-boot-rocket-mq-producer-starter"><a href="#spring-boot-rocket-mq-producer-starter" class="headerlink" title="spring-boot-rocket-mq-producer-starter"></a>spring-boot-rocket-mq-producer-starter</h2><p><a href="https://github.com/chengsp-tinet/spring-boot-rocket-mq-producer-starter" target="_blank" rel="noopener">https://github.com/chengsp-tinet/spring-boot-rocket-mq-producer-starter</a></p><p>SpringBoot Mq Starter producer</p><h2 id="spring-boot-thread-pool-starter"><a href="#spring-boot-thread-pool-starter" class="headerlink" title="spring-boot-thread-pool-starter"></a>spring-boot-thread-pool-starter</h2><p><a href="https://github.com/chengsp-tinet/spring-boot-thread-pool-starter" target="_blank" rel="noopener">spring-boot-thread-pool-starter</a></p><p>SpringBoot 线程池 Starter</p><h2 id="hexo-theme-fluid"><a href="#hexo-theme-fluid" class="headerlink" title="hexo-theme-fluid"></a>hexo-theme-fluid</h2><p><a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="noopener">地址</a></p><p>Hexo 主题开源项目 | Fluid   </p><p>第一次提交代码的开源项目</p><h1 id="持续输出的开源项目及地址"><a href="#持续输出的开源项目及地址" class="headerlink" title="持续输出的开源项目及地址"></a>持续输出的开源项目及地址</h1><p><a href="https://github.com/ZhongFuCheng3y/3y" target="_blank" rel="noopener">Java 3Y 系列后端学习资料</a></p><p><a href="https://pan.baidu.com/s/1KJVwFU2wJLdH6hf4Tq0h4Q" target="_blank" rel="noopener">Java 3Y 原创思维导图+PDF电子书</a>  密码：so3g    </p><p><a href="https://github.com/crisxuan/bestJavaer" target="_blank" rel="noopener">bestJavaer持续项目</a>  作者：程序员cxuan</p><p>💖  <a href="https://github.com/AobingJava/JavaFamily" target="_blank" rel="noopener">敖丙面向面试系列文章 | 文章大全地址</a> 作者：敖丙</p><p><strong><em>公开薪资网站</em></strong> | <a href="http://offer.fyi/" target="_blank" rel="noopener">网内</a> | <a href="https://www.levels.fyi/" target="_blank" rel="noopener">国外</a></p><p><strong><em>职级对标 | 薪资网站</em></strong> <a href="https://duibiao.info/" target="_blank" rel="noopener">地址</a></p><h1 id="大牛博客"><a href="#大牛博客" class="headerlink" title="大牛博客"></a>大牛博客</h1><ul><li>JavaDoop  源码大佬：<a href="https://javadoop.com/post/spring-ioc" target="_blank" rel="noopener">https://javadoop.com/post/spring-ioc</a></li><li>GitBook大佬： <a href="https://zhousiwei.gitee.io/mybook/elk/es_cluster.html" target="_blank" rel="noopener">https://zhousiwei.gitee.io/mybook/elk/es_cluster.html</a></li><li>低调的小熊猫：<a href="http://ilovey.live/" target="_blank" rel="noopener">http://ilovey.live/</a></li><li>博客园系列文章：<a href="https://www.cnblogs.com/java-chen-hao/p/11187914.html" target="_blank" rel="noopener">https://www.cnblogs.com/java-chen-hao/p/11187914.html</a></li><li>集百家之长 -&gt;  系列类型文章：<a href="https://how2playlife.com/" target="_blank" rel="noopener">https://how2playlife.com/</a></li><li>23岁大佬的GitHub： <a href="https://github.com/AobingJava/JavaFamily" target="_blank" rel="noopener">https://github.com/AobingJava/JavaFamily</a> </li><li>【掘金】 吊打面试官系列文章： <a href="https://juejin.im/post/5dd09f5af265da0be72aacbd" target="_blank" rel="noopener">https://juejin.im/post/5dd09f5af265da0be72aacbd</a> </li><li>系统性学习： <a href="https://xintiaohuiyi.gitbook.io/jynotebook/" target="_blank" rel="noopener">https://xintiaohuiyi.gitbook.io/jynotebook/</a> </li><li>【Java3Y】<a href="https://github.com/ZhongFuCheng3y/3y" target="_blank" rel="noopener">https://github.com/ZhongFuCheng3y/3y</a> </li><li>【Java3Y】公众号历史文章： <a href="https://mp.weixin.qq.com/s/n_1LxAhC6eJYUzKEFQVLCg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/n_1LxAhC6eJYUzKEFQVLCg</a> </li><li>Java知其所以然   公众号， 后辈楷模</li><li>❤  YourBatman          CSDN：<a href="https://blog.csdn.net/f641385712" target="_blank" rel="noopener">https://blog.csdn.net/f641385712</a></li></ul><h1 id="可能接触的工具"><a href="#可能接触的工具" class="headerlink" title="可能接触的工具"></a>可能接触的工具</h1><p><strong>135</strong></p><p>135微信公众号编辑器</p><p><strong>MediaCreationTool</strong></p><p>windows自家的一键重装工具</p><p><strong>二十次幂</strong></p><p>公众号流量监控平台：<a href="https://www.ershicimi.com/" target="_blank" rel="noopener">https://www.ershicimi.com/</a></p><p><strong>在线短信接收网站：</strong><a href="https://www.materialtools.com/" target="_blank" rel="noopener">在线短信接收</a></p><p><strong>国内高匿代理IP</strong>：<a href="https://www.xicidaili.com/nn/" target="_blank" rel="noopener">https://www.xicidaili.com/nn/</a></p><h1 id="精妙无比的生活小点子"><a href="#精妙无比的生活小点子" class="headerlink" title="精妙无比的生活小点子"></a>精妙无比的生活小点子</h1><ul><li><p>MD-Nice  MD排版工具   解决 =》兼容不同平台的样式库</p></li><li><p>小程序 公众号留言       解决 =》公众号无法留言的问题，通过小程序的方式另类的进行留言</p></li><li><p>❤️（尚未发现） CODEX 代码中嵌入MarkDown流程图代码，选中后绘制最终结果</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>开源篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HelloGithub</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
